var documenterSearchIndex = {"docs":
[{"location":"zz_moment_kinetics_structs/#moment_kinetics_structs","page":"moment_kinetics_structs","title":"moment_kinetics_structs","text":"","category":"section"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs","text":"structs used within moment_kinetics that should be defined early to avoid dependency cycles when they are used by several other modules.\n\n\n\n\n\n","category":"module"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.coordinate","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.coordinate","text":"structure containing basic information related to coordinates\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.discretization_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.discretization_info","text":"discretization_info for one dimension\n\nAll the specific discretizations in moment_kinetics are subtypes of this type.\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.electron_pdf_substruct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.electron_pdf_substruct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.em_fields_struct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.em_fields_struct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.moments_electron_substruct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.moments_electron_substruct","text":"momentselectronsubstruct is a struct that contains moment information for electrons\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.moments_ion_substruct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.moments_ion_substruct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.moments_neutral_substruct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.moments_neutral_substruct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.moments_struct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.moments_struct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.null_spatial_dimension_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.null_spatial_dimension_info","text":"Type representing a spatial dimension with only one grid point\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.null_velocity_dimension_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.null_velocity_dimension_info","text":"Type representing a velocity space dimension with only one grid point\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.null_vperp_dimension_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.null_vperp_dimension_info","text":"Type representing a vperp dimension with only one grid point\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.pdf_struct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.pdf_struct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.pdf_substruct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.pdf_substruct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.scratch_electron_pdf","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.scratch_electron_pdf","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.scratch_pdf","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.scratch_pdf","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.weak_discretization_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.weak_discretization_info","text":"discretization_info for a discretization that supports 'weak form' methods, for one dimension\n\n\n\n\n\n","category":"type"},{"location":"shared_memory_debugging/#Shared-memory-debugging","page":"Shared memory debugging","title":"Shared memory debugging","text":"","category":"section"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"This debug_test directory contains scripts for running a set of short runs, intended to be used with the --debug flag to check for bugs (e.g. race conditions). The output is not checked - the intention is just to catch errors raised by the debugging checks.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The inputs only have 3 time-steps, and very few grid points, because the debug checks are very slow. The actual output is not important, so it does not matter that the runs are badly under-resolved.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"It may be necessary to use the --compiled-modules=no flag to Julia for changes to the --debug setting to be picked up correctly. This setting means that all precompilation is redone each time Julia is started, which can be slow. An alternative workaround is to hard-code the moment_kinetics.debugging._debug_level variable in debugging.jl to the desired value.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"To run the debug tests, call (from the top-level moment_kinetics directory) something like","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"julia --project --check-bounds=yes --compiled-modules=no debug_test/runtests.jl --debug 99","category":"page"},{"location":"shared_memory_debugging/#Collision-operator-and-'anysv'-region","page":"Shared memory debugging","title":"Collision operator and 'anysv' region","text":"","category":"section"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The collision operator uses a slightly hacky special set of functions for shared memory parallelism, to allow the outer loop over spatial dimensions to be parallelised, but also inner loops over s, vperp, vpa or combinations to be parallelised - changing the type of inner-loop parallelism within the outer loop. This happens within an 'anysv' region, which is started with the begin_r_z_anysv_region() function. The debug checks within an 'anysv' region only check for correctness on the sub-block communicator that parallelises over velocity space, so if there were errors due to incorrect species or spatial parallelism they would not (might not?) be detected. These errors should be unlikely as the collision operator only writes to a single species at a single spatial point.","category":"page"},{"location":"shared_memory_debugging/#Finding-race-conditions","page":"Shared memory debugging","title":"Finding race conditions","text":"","category":"section"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The code is parallelized using MPI with shared memory arrays. 'Race conditions' can occur if a shared array is accessed incorrectly. All the processes sharing an array can be synchronized, ensuring they pass through the following code block with a consistent state, by using the _block_synchronize() function (which calls MPI.Barrier() to synchronize the processes). Race conditions occur if between consecutive calls to _block_synchronize() any array is:","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"written by 2 or more processes at the same position\nwritten by one process at a certain position, and read by one or more other processes at the same position.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"If a race condition occurs, it can result in errors in the results. These are sometimes small, but often show inconsistent results between runs (because results erroneously depend on the execution order on different processes). They are undefined behaviour though, and so can also cause anything up to segfaults.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The provided debugging routines can help to pin down where either of these errors happen.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The @debug_shared_array macro (activated at --debug 2 or higher) counts all reads and writes to shared arrays by each process, and checks at each _block_synchronize() call whether either pattern has occurred since the previous _block_synchronize(). If they have and in addition @debug_track_array_allocate_location is active (--debug 3 or higher), then the array for which the error occured is identified by printing a stack-trace of the location where it was allocated, and the stack-trace for the exception shows the location of the _block_synchronize() call where the error occured.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"@debug_block_synchronize (activated at --debug 4)checks that all processes called _block_synchronize() from the same place - i.e. the same line in the code, checked by comparing stack traces.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"@debug_detect_redundant_block_synchronize (activated at --debug 5) aims to find any unnecessary calls to _block_synchronize(). These calls can be somewhat expensive (for large numbers of processes at least), so it is good to minimise the number. When this mode is active, at each _block_synchronize() a check is made whether there would be a race-condition error if the previous _block_synchronize() call was removed. If there would not be, then the previous call was unnecessary and could be removed. The tricky part is that whether it was necessary or not could depend on the options being used... Detecting redundant block_synchronize() calls requires that all dimensions that could be split over processes are actually split over processes, which demands a large number of processes are used. The @debug_detect_redundant_block_synchronize flag, when activated, modifies the splitting algorithm to force every dimension to be split if possible, and raise an error if not.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"Suggested debugging strategy for race conditions is:","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"Look at the loop types and ensure that there is an appropriate begin_*_region() call before each new loop type.\nRun debug_test/runtests.jl with @debug_shared_array activated, but not @debug_detect_redundant_block_synchronize. It will be faster to first run without @debug_track_array_allocate_location to find failing tests, then with @debug_track_array_allocate_location to help identify the cause of the failure. Usually a failure should indicate where there is a missing begin_*_region() call. There may be places though where synchronization is required even though the type of loop macros used does not change (for example when phi is calculated contributions from all ion species need to be summed, resulting in an unusual pattern of array accesses); in this case _block_synchronize() can be called directly.\nThe function debug_check_shared_memory() can be inserted between begin_*_region() calls when debugging to narrow down the location where the incorrect array access occured. It is defined when @debug_shared_array is active, and can be imported with using ..communication: debug_check_shared_memory(). The function runs the same error checks as are added by @debug_shared_array in _block_synchronize().\nThe tests in debug_test/ check for correctness by looping over the dimensions and forcing each to be split over separate processes in turn. This allows the correctness checks to be run using only 2 processes, which would not be possible if all dimensions had to be split at the same time.\n[This final level of checking only looks for minor optimizations rather than finding bugs, so it is much less important than the checks above.] Run debug_test/debug_redundant_synchronization/runtests.jl with @debug_detect_redundant_block_synchronize activated. This should show if any call to _block_synchronize() (including the ones inside begin_*_region() calls) was 'unnecessary' - i.e. there would be no incorrect array accesses if it was removed. This test needs to be run on a suitable combination of grid sizes and numbers of processes so that all dimensions are split across multiple processes to avoid false positives.  Any redundant calls which appear in all tests can be deleted.  Redundant calls that appear in only some tests (unless they are in some code block that is just not called in all the other tests) should preferably be moved inside a conditional block, so that they are called only when necessary, if a suitable one exists. If there is no conditional block that the call can be moved to, it may sometimes be necessary to just test one or more options before calling, e.g.\nmoments.evolve_upar && _block_synchronize()\nThe checks for redundant _block_synchronize() calls have been separated from the correctness checks so that the correctness checks can be run in the CI using only 2 processes, while the redundancy checks can be run manually on a machine with enough memory and cpu cores.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"You can find out what loop type is currently active by looking at loop_ranges[].parallel_dims. This variable is a Tuple containing Symbols for each dimension currently being parallelized.","category":"page"},{"location":"zz_analysis/#analysis","page":"analysis","title":"analysis","text":"","category":"section"},{"location":"zz_analysis/#moment_kinetics.analysis","page":"analysis","title":"moment_kinetics.analysis","text":"\n\n\n\n","category":"module"},{"location":"zz_analysis/#moment_kinetics.analysis.analyze_2D_instability-NTuple{7, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_2D_instability","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.analyze_fields_data-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_fields_data","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.analyze_moments_data-NTuple{8, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_moments_data","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.analyze_pdf_data-NTuple{7, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.check_Chodura_condition","page":"analysis","title":"moment_kinetics.analysis.check_Chodura_condition","text":"Check the (kinetic) Chodura condition\n\nChodura condition is: ∫d^3v F/vpa^2 ≤ mi ne/Te\n\nReturn a tuple (whose first entry is the result for the lower boundary and second for the upper) of the ratio which is 1 if the Chodura condition is satisfied (with equality): Te/(mi ne) * ∫d^3v F/vpa^2\n\nCurrently only evaluates condition for the first species: is=1\n\n2D2V\n\nIn normalised form (normalised variables suffixed with 'N'): vpa = cref vpaN vperp = cref vperpN ne = nref neN Te = Tref TeN F = FN nref / cref^3 cref = sqrt(Tref / mi)\n\ncref^3 ∫d^3vN FN nref / cref^3 cref^2 vpaN^2 ≤ mi nref neN / Tref TeN nref / (cref^2) * ∫d^3vN FN / vpaN^2 ≤ mi nref neN / Tref TeN mi nref / (2 Tref) * ∫d^3vN FN / vpaN^2 ≤ mi nref neN / Tref TeN 1 / 2 * ∫d^3vN FN / vpaN^2 ≤ neN / TeN 1 / 2 * ∫d^3vN FN / vpaN^2 ≤ neN / TeN TeN / (2 neN) * ∫d^3vN FN / vpaN^2 ≤ 1\n\n1D1V\n\nThe 1D1V code evolves the marginalised distribution function f = ∫d^2vperp F so the Chodura condition becomes ∫dvpa f/vpa^2 ≤ mi ne/Te\n\nIn normalised form (normalised variables suffixed with 'N'): vpa = cref vpaN ne = nref neN Te = Tref TeN f = fN nref / cref cref = sqrt(2 Tref / mi)\n\ncref ∫dvpaN fN nref / cref cref^2 vpaN^2 ≤ mi nref neN / Tref TeN nref / cref^2 * ∫dvpaN fN / vpaN^2 ≤ mi nref neN / Tref TeN mi nref / (2 Tref) * ∫dvpaN fN / vpaN^2 ≤ mi nref neN / Tref TeN 1 / 2 * ∫dvpaN fN / vpaN^2 ≤ neN / TeN 1 / 2 * ∫dvpaN fN / vpaN^2 ≤ neN / TeN TeN / (2 neN) * ∫dvpaN fN / vpaN^2 ≤ 1\n\nIf ir0 is passed, only load the data for as single r-point (to save memory).\n\nIf find_extra_offset=true is passed, calculates how many entries of f_lower/f_upper adjacent to v_=0 would need to be zero-ed out in order for the condition to be satisfied.\n\n\n\n\n\n","category":"function"},{"location":"zz_analysis/#moment_kinetics.analysis.field_line_average-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.field_line_average","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.fit_cosine","page":"analysis","title":"moment_kinetics.analysis.fit_cosine","text":"Fit a cosine to a 1d array\n\nFit function is Acos(2πn(z + δ)/L)\n\nThe domain z is taken to be periodic, with the first and last points identified, so L=z[end]-z[begin]\n\nArguments\n\nz : Array     1d array with positions of the grid points - should have the same length as data data : Array     1d array of the data to be fit amplitudeguess : Float     Initial guess for the amplitude (the value from the previous time point might be a     good choice) offsetguess : Float     Initial guess for the offset (the value from the previous time point might be a good     choice) n : Int, default 1     The periodicity used for the fit\n\nReturns\n\namplitude : Float     The amplitude A of the cosine fit offset : Float     The offset δ of the cosine fit error : Float     The RMS of the difference between data and the fit\n\n\n\n\n\n","category":"function"},{"location":"zz_analysis/#moment_kinetics.analysis.fit_delta_phi_mode-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.fit_delta_phi_mode","text":"Fit delta_phi to get the frequency and growth rate.\n\nNote, expect the input to be a standing wave (as simulations are initialised with just a density perturbation), so need to extract both frequency and growth rate from the time-variation of the amplitude.\n\nThe function assumes that if the amplitude does not cross zero, then the mode is non-oscillatory and so fits just an exponential, not exp*cos. The simulation used as input should be long enough to contain at least ~1 period of oscillation if the mode is oscillatory or the fit will not work.\n\nArguments\n\nz : Array{mkfloat, 1}     1d array of the grid point positions t : Array{mkfloat, 1}     1d array of the time points deltaphi : Array{mkfloat, 2}     2d array of the values of delta_phi(z, t)\n\nReturns\n\nphifitresult struct whose fields are:     growthrate : mkfloat         Fitted growth rate of the mode     amplitude0 : mkfloat         Fitted amplitude at t=0     frequency : mkfloat         Fitted frequency of the mode     offset0 : mkfloat         Fitted offset at t=0     amplitudefiterror : mkfloat         RMS error in fit to ln(amplitude) - i.e. ln(A)     offsetfiterror : mkfloat         RMS error in fit to offset - i.e. δ     cosinefiterror : mkfloat         Maximum of the RMS errors of the cosine fits at each time point     amplitude : Array{mkfloat, 1}         Values of amplitude from which growthrate fit was calculated     offset : Array{mk_float, 1}         Values of offset from which frequency fit was calculated\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_Fourier_modes_1D-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, moment_kinetics.moment_kinetics_structs.coordinate, Any, Any}} where T","page":"analysis","title":"moment_kinetics.analysis.get_Fourier_modes_1D","text":"Get 1D Fourier transform (in r) of nonuniformdata\n\nFirst interpolates to uniform grid, then uses FFT.\n\nIf zind is not given, find the zind where mode seems to be growing most strongly.\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_Fourier_modes_2D-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, moment_kinetics.moment_kinetics_structs.coordinate, Any, moment_kinetics.moment_kinetics_structs.coordinate, Any}} where T","page":"analysis","title":"moment_kinetics.analysis.get_Fourier_modes_2D","text":"Get 2D Fourier transform (in r and z) of nonuniformdata\n\nFirst interpolates to uniform grid, then uses FFT\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_growth_rate_of_box_mode_1D-Tuple{Any}","page":"analysis","title":"moment_kinetics.analysis.get_growth_rate_of_box_mode_1D","text":"Function for calculating the growth rate of a box size mode (can also be initialised with multiple modes, numberofpeaks decides how many of the largest peaks are tracked). Used by the ITG_1D tests.\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_r_perturbation-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T","page":"analysis","title":"moment_kinetics.analysis.get_r_perturbation","text":"Return (v - mean(v, dims=2))\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_unnormalised_f_coords_2d-NTuple{9, Any}","page":"analysis","title":"moment_kinetics.analysis.get_unnormalised_f_coords_2d","text":"Get the unnormalised distribution function and unnormalised ('lab space') coordinates.\n\nInputs should depend only on z and vpa.\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_unnormalised_f_dzdt_1d-NTuple{8, Any}","page":"analysis","title":"moment_kinetics.analysis.get_unnormalised_f_dzdt_1d","text":"Get the unnormalised distribution function and unnormalised ('lab space') dzdt coordinate at a point in space.\n\nInputs should depend only on vpa.\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.moving_average-Tuple{AbstractVector, Int64}","page":"analysis","title":"moment_kinetics.analysis.moving_average","text":"Calculate a moving average\n\nresult[i] = mean(v[i-n:i+n])\n\nExcept near the ends of the array where indices outside the range of v are skipped.\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.steady_state_residuals-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.steady_state_residuals","text":"steady_state_residuals(variable, variable_at_previous_time, dt;\n                       epsilon=0.0001, use_mpi=false,\n                       only_max_abs=false, ir=nothing, comm=nothing)\n\nCalculate how close a variable is to steady state.\n\nCalculates several quantities. Define the 'squared absolute residual' r_mathrmabs(t)^2 for a quantity a(tx) as\n\nr_mathrmabs(t)^2 = left( a(tx) - a(t - delta tx) right)\n\nand the 'squared relative residual' r_mathrmrel(t)^2\n\nr_mathrmrel(t)^2 = left( fraca(tx) - a(t - delta tx)delta t left a(tx) + epsilon max_x(a(tx)) right right)\n\nwhere x stands for any spatial and velocity coordinates, and the offset epsilon max_x(a(tx)) is used to avoid points where a(tx) happens to be very close to zero from dominating the result in the 'squared relative residual', with max_x being the maximum over the x coordinate(s). Returns an OrderedDict containing: the maximum 'absolute residual' max_xleft( sqrtr_mathrmabs(t)^2 right) (\"RMS absolute residual\"); the root-mean-square (RMS) 'absolute residual' left sqrtr_mathrmabs(t)^2 right_x (\"max absolute residual\"); the maximum 'relative residual' max_xleft( sqrtr_mathrmrel(t)^2 right) (\"RMS relative residual\"); the root-mean-square (RMS) 'relative residual' left sqrtr_mathrmrel(t)^2 right_x (\"max relative residual\").\n\nvariable gives the value of a(tx) at the current time, variable_at_previous_time the value a(t - delta t x) at a previous time and dt gives the difference in times delta t. All three can be arrays with a time dimension of the same length, or have no time dimension.\n\nBy default runs in serial, but if use_mpi=true is passed, assume MPI has been initialised, and that variable has r and z dimensions but no species dimension, and use @loop_* macros. In this case the result is returned only on global rank 0. When using distributed-memory MPI, this routine will double-count the points on block boundaries.\n\nIf only_max_abs=true is passed, then only calculate the 'maxium absolute residual'. In this case just returns the \"max absolute residual\", not an OrderedDict.\n\nTo calculate a residual only for a specific point in r, pass the r-index ir and appropriate communicators comm_local and comm_global. If ir is passed, it is assumed that this function is called inside a @begin_r_anyzv_region().\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.steady_state_square_residuals","page":"analysis","title":"moment_kinetics.analysis.steady_state_square_residuals","text":"steady_state_square_residuals(variable, variable_at_previous_time, dt,\n                              variable_max=nothing, use_mpi=false,\n                              only_max_abs=false, epsilon=0.0001,\n                              ir=nothing, comm_local=nothing, comm_global=nothing)\n\nUsed to calculate the mean square residual for steady_state_residuals.\n\nUseful to define this separately as it can be called on (equally-sized) chunks of the variable and then combined appropriately. If this is done, the global maximum of abs.(variable) should be passed to variable_max.\n\nSee steady_state_residuals for documenation of the other arguments. The return values of steady_state_residuals are the square-root of the return values of this function.\n\n\n\n\n\n","category":"function"},{"location":"zz_quadrature/#quadrature","page":"quadrature","title":"quadrature","text":"","category":"section"},{"location":"zz_quadrature/#moment_kinetics.quadrature","page":"quadrature","title":"moment_kinetics.quadrature","text":"\n\n\n\n","category":"module"},{"location":"zz_quadrature/#moment_kinetics.quadrature.composite_simpson_weights-Tuple{Any}","page":"quadrature","title":"moment_kinetics.quadrature.composite_simpson_weights","text":"compositesimpsonweights creates, computes, and returns an array for the 1D integration weights associated with each grid point using composite Simpson's rule\n\n\n\n\n\n","category":"method"},{"location":"zz_quadrature/#moment_kinetics.quadrature.trapezium_weights-Tuple{Any}","page":"quadrature","title":"moment_kinetics.quadrature.trapezium_weights","text":"trapezium_weights creates, computes, and returns an array for the 1D integration weights associated with each grid point using the trapezium rule.\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#input_structs","page":"input_structs","title":"input_structs","text":"","category":"section"},{"location":"zz_input_structs/#moment_kinetics.input_structs","page":"input_structs","title":"moment_kinetics.input_structs","text":"\n\n\n\n","category":"module"},{"location":"zz_input_structs/#moment_kinetics.input_structs.advance_info","page":"input_structs","title":"moment_kinetics.input_structs.advance_info","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.boundary_data_type","page":"input_structs","title":"moment_kinetics.input_structs.boundary_data_type","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.collisions_input","page":"input_structs","title":"moment_kinetics.input_structs.collisions_input","text":"Collisions input struct to contain all the different collisions substructs and overall  collision input parameters.\n\n\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.electron_physics_type","page":"input_structs","title":"moment_kinetics.input_structs.electron_physics_type","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.em_fields_input","page":"input_structs","title":"moment_kinetics.input_structs.em_fields_input","text":"Settings for electronmagenetic fields\n\n\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.geometry_input","page":"input_structs","title":"moment_kinetics.input_structs.geometry_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.ion_source_data","page":"input_structs","title":"moment_kinetics.input_structs.ion_source_data","text":"Source profile structs for ions and electrons which allows them to have any number  of different sources (from wall perhaps, superposition of core sources, etc.). These sources are then contained in a vector of structs.\n\nSince the ion source must be the same as the electron source in all respects (apart from possibly a different electron temperature or source strength), the electron vector of source profile structs will be a kind of mirror of the ion vector of structs. \n\n\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.ion_species_parameters","page":"input_structs","title":"moment_kinetics.input_structs.ion_species_parameters","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.kinetic_electron_solver_type","page":"input_structs","title":"moment_kinetics.input_structs.kinetic_electron_solver_type","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.kinetic_ion_solver_type","page":"input_structs","title":"moment_kinetics.input_structs.kinetic_ion_solver_type","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.neutral_species_parameters","page":"input_structs","title":"moment_kinetics.input_structs.neutral_species_parameters","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.pp_input","page":"input_structs","title":"moment_kinetics.input_structs.pp_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.spatial_initial_condition_input","page":"input_structs","title":"moment_kinetics.input_structs.spatial_initial_condition_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.species_composition","page":"input_structs","title":"moment_kinetics.input_structs.species_composition","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.time_info","page":"input_structs","title":"moment_kinetics.input_structs.time_info","text":"t_error_sum is included so that a type which might be mkfloat or Float128 can be set by an option but known at compile time when a `timeinfo` struct is passed as a function argument.\n\n\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.velocity_initial_condition_input","page":"input_structs","title":"moment_kinetics.input_structs.velocity_initial_condition_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#Base.get-Tuple{OrderedCollections.OrderedDict{String, Any}, Any, Enum}","page":"input_structs","title":"Base.get","text":"Utility method for converting a string to an Enum when getting from a Dict, based on the type of the default value\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#moment_kinetics.input_structs.Dict_to_NamedTuple-Tuple{OrderedCollections.OrderedDict}","page":"input_structs","title":"moment_kinetics.input_structs.Dict_to_NamedTuple","text":"Convert an OrderedDict whose keys are String or Symbol to a NamedTuple\n\nUseful as NamedTuple is immutable, so option values cannot be accidentally changed.\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#moment_kinetics.input_structs.check_sections!-Tuple{OrderedCollections.OrderedDict{String, Any}}","page":"input_structs","title":"moment_kinetics.input_structs.check_sections!","text":"check_sections!(options::OptionsDict)\n\nCheck that there are no unexpected sections in options. The 'expected sections' are the ones that were defined with set_defaults_and_check_section!.\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#moment_kinetics.input_structs.convert_to_sorted_nested_OptionsDict-Tuple{AbstractDict}","page":"input_structs","title":"moment_kinetics.input_structs.convert_to_sorted_nested_OptionsDict","text":"convert_to_sorted_nested_OptionsDict(d::AbstractDict)\n\nTo ensure consistency when writing options to an output file, the entries in the dictionary containing the options must be in a deterministic order. As TOML reads options into a nested Dict, the only way to guarantee this is to sort the options before storing them in an OptionsDict. OptionsDict is an alias for OrderedDict{String,Any} so it will preserve the order of entries as long as they were in a consistent order when it was created.\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#moment_kinetics.input_structs.options_to_TOML-Tuple","page":"input_structs","title":"moment_kinetics.input_structs.options_to_TOML","text":"options_to_toml(io::IO [=stdout], data::AbstractDict; sorted=false, by=identity)\n\nConvert moment_kinetics 'options' (in the form of an AbstractDict) to TOML format.\n\nThis function is defined so that we can handle some extra types, for example Enum.\n\nFor descriptions of the arguments, see TOML.print.\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#moment_kinetics.input_structs.set_defaults_and_check_section!","page":"input_structs","title":"moment_kinetics.input_structs.set_defaults_and_check_section!","text":"set_defaults_and_check_section!(options::OptionsDict, struct_type::Type,\n                                name::Union{String,Nothing}=nothing)\n\nAlternative form to be used when the options should be stored in a struct of type struct_type rather than a NamedTuple. struct_type must be defined using @kwdef.\n\nThe returned instance of struct_type is immutable, so if you need to modify the settings\n\ne.g. to apply some logic to set defaults depending on other settings/parameters - then\n\nyou should use the 'standard' version of set_defaults_and_check_section! that returns a OptionsDict that can be modified, and then use that OptionsDict to initialise the struct_type.\n\nThe name of the section in the options that will be read defaults to the name of struct_type, but can be set using the section_name argument.\n\nReturns an instance of struct_type.\n\n\n\n\n\n","category":"function"},{"location":"zz_input_structs/#moment_kinetics.input_structs.set_defaults_and_check_section!-Tuple{OrderedCollections.OrderedDict{String, Any}, String, Bool}","page":"input_structs","title":"moment_kinetics.input_structs.set_defaults_and_check_section!","text":"Set the defaults for options in a section, and check that there are not any unexpected options (i.e. options that have no default).\n\nModifies the options[section_name]::OptionsDict by adding defaults for any values that are not already present.\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#moment_kinetics.input_structs.set_defaults_and_check_top_level!-Tuple{OrderedCollections.OrderedDict{String, Any}, Bool}","page":"input_structs","title":"moment_kinetics.input_structs.set_defaults_and_check_top_level!","text":"Set the defaults for options in the top level of the input, and check that there are not any unexpected options (i.e. options that have no default).\n\nModifies the options[section_name]::OptionsDict by adding defaults for any values that are not already present.\n\nIgnores any sections, as these will be checked separately.\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#array_allocation","page":"array_allocation","title":"array_allocation","text":"","category":"section"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation","page":"array_allocation","title":"moment_kinetics.array_allocation","text":"\n\n\n\n","category":"module"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_bool-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_bool","text":"allocate array with dimensions given by dims and entries of type Bool\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_complex-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_complex","text":"allocate 1d array with dimensions given by dims and entries of type Complex{mk_float}\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_float-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_float","text":"allocate array with dimensions given by dims and entries of type mk_float\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_int-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_int","text":"allocate 1d array with dimensions given by dims and entries of type mk_int\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_shared_bool-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_bool","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_shared_complex-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_complex","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_shared_float-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_float","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_shared_int-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_int","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#vpa_advection","page":"vpa_advection","title":"vpa_advection","text":"","category":"section"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection","page":"vpa_advection","title":"moment_kinetics.vpa_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.implicit_vpa_advection!-NTuple{25, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.implicit_vpa_advection!","text":"\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_vpa!-NTuple{15, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_vpa!","text":"calculate the advection speed in the vpa-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_vpa_DK!-NTuple{12, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_vpa_DK!","text":"update the advection speed in the parallel velocity coordinate for the case where no moments are evolved independently from the pdf. vpa is unchanged.\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_vpa_n_evolution!-NTuple{11, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_vpa_n_evolution!","text":"update the advection speed in the parallel velocity coordinate for the case where density is evolved independently from the pdf; in this case, the parallel velocity coordinate is unchanged.\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_vpa_n_u_evolution!-NTuple{13, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_vpa_n_u_evolution!","text":"update the advection speed in the parallel velocity coordinate for the case where density and flow are evolved independently from the pdf; in this case, the parallel velocity coordinate is the peculiar velocity wpa = vpa-upar\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_vpa_n_u_p_evolution!-NTuple{13, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_vpa_n_u_p_evolution!","text":"update the advection speed in the parallel velocity coordinate for the case where density, flow and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized peculiar velocity wpa = (vpa - upar)/vth\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.vpa_advection!-NTuple{18, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.vpa_advection!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#interpolation","page":"interpolation","title":"interpolation","text":"","category":"section"},{"location":"zz_interpolation/#moment_kinetics.interpolation","page":"interpolation","title":"moment_kinetics.interpolation","text":"Interpolation routines intended for post-processing.\n\nNote these are not guaranteed to be highly optimized!\n\n\n\n\n\n","category":"module"},{"location":"zz_interpolation/#moment_kinetics.interpolation.fill_single_element_interpolation_matrix!","page":"interpolation","title":"moment_kinetics.interpolation.fill_single_element_interpolation_matrix!","text":"fill_single_element_interpolation_matrix!(\n    matrix_slice, newgrid, jelement, coord, spectral)\n\nSet matrix_slice equal to the interpolation matrix that interpolates values from the element jelement of the vector being multiplied onto the grid points given by newgrid (which must be contained within the physical space covered by element jelement).\n\ncoord is the coordinate object for the dimension in which the interpolation is done, and spectral the discretization object corresponding to jelement.\n\n\n\n\n\n","category":"function"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_symmetric!","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_symmetric!","text":"interpolate_symmetric!(result, newgrid, f, oldgrid, derivative=Val(0))\n\nInterpolate f from oldgrid to newgrid, imposing that f(x) is symmetric around x=0, so the interpolation is done by fitting a polynomial in x^2 to the values of f given on oldgrid, and evaluating on newgrid. Since interpolation is done in a polynomial of x^2, the signs of the points on newgrid and oldgrid do not matter, and are ignored.\n\nVal(n) can be passed as derivative to calculate the derivative of order n of the interpolating function (only a few values of n are supported).\n\n\n\n\n\n","category":"function"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_1d!","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_1d!","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nArguments\n\nresult : Array{mkfloat, 1}     Array to be overwritten with the result of the interpolation newgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies spectral : discretization_info     struct containing information for discretization, whose type determines which method     is used. derivative : Val(n)     The value of n the integer in the Val{n} indicates the order of the derivative to     be calculated of the interpolating function (only a few values of n are supported).     Defaults to Val(0), which means just calculating the interpolating function itself.\n\n\n\n\n\n","category":"function"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_1d-Tuple{Any, Vararg{Any}}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_1d","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nThis version allocates a new array for the result, which is returned.\n\nArguments\n\nnewgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies spectral : Bool or chebyshevinfo     struct containing information for discretization, whose type determines which method     is used. derivative : Val(n)     The value of n the integer in the Val{n} indicates the order of the derivative to     be calculated of the interpolating function (only a few values of n are supported).     Defaults to Val(0), which means just calculating the interpolating function itself.\n\nReturns\n\nresult : Array     Array with the values of f interpolated to the points in new_grid.\n\n\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa!-Tuple{AbstractVector{Float64}, Any, AbstractVector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa!-Tuple{Array{Float64, 3}, Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa-Tuple{Any, AbstractVector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa-Tuple{Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Array{Float64, 3}, Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Matrix{Float64}, Any, Matrix{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Vector{Float64}, Any, Vector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Matrix{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Vector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.single_element_interpolate!","page":"interpolation","title":"moment_kinetics.interpolation.single_element_interpolate!","text":"single_element_interpolate!(result, newgrid, f, imin, imax, coord, spectral)\n\nInterpolation within a single element.\n\nf is an array with the values of the input variable in the element to be interpolated. imin and imax give the start and end points of the element in the grid (used to calculate shift and scale factors to a normalised grid).\n\nnewgrid gives the points within the element where output is required. result is filled with the interpolated values at those points.\n\ncoord is the coordinate struct for the dimension along which interpolation is being done. spectral is the corresponding discretization_info.\n\n\n\n\n\n","category":"function"},{"location":"zz_initial_conditions/#initial_conditions","page":"initial_conditions","title":"initial_conditions","text":"","category":"section"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions","page":"initial_conditions","title":"moment_kinetics.initial_conditions","text":"\n\n\n\n","category":"module"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.allocate_pdf_and_moments-NTuple{13, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.allocate_pdf_and_moments","text":"Creates the structs for the pdf and the velocity-space moments\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.convert_full_f_ion_to_normalised!","page":"initial_conditions","title":"moment_kinetics.initial_conditions.convert_full_f_ion_to_normalised!","text":"Take the full ion distribution function, calculate the moments, then normalise and shift to the moment-kinetic grid.\n\nUses input value of f and modifies in place to the normalised distribution functions. Input density, upar, p, and vth are not used, the values are overwritten with the moments of f.\n\nInputs/outputs depend on z, vperp, and vpa (should be inside loops over species, r).\n\nThe velocity grid that the input f is defined on can be scaled by vgrid_scale_factor: f is given on a velocity grid vperp.grid .* vgrid_scale_factor and vpa.grid .* vgrid_scale_factor.\n\n\n\n\n\n","category":"function"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.convert_full_f_neutral_to_normalised!","page":"initial_conditions","title":"moment_kinetics.initial_conditions.convert_full_f_neutral_to_normalised!","text":"Take the full neutral-particle distribution function, calculate the moments, then normalise and shift to the moment-kinetic grid.\n\nUses input value of f and modifies in place to the normalised distribution functions. Input density, uz, p, and vth are not used, the values are overwritten with the moments of f.\n\nInputs/outputs depend on z, vzeta, vr and vz (should be inside loops over species, r).\n\nThe velocity grid that the input f is defined on can be scaled by vgrid_scale_factor: f is given on a velocity grid vzeta.grid .* vgrid_scale_factor, vr.grid .* vgrid_scale_factor, and vz.grid .* vgrid_scale_factor.\n\n\n\n\n\n","category":"function"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.create_pdf-NTuple{8, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.create_pdf","text":"Allocate arrays for pdfs\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_density!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_density!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_electron_density!-Tuple{Any, Any, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_electron_density!","text":"initialise the electron density\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_electron_pdf_over_density_and_boundary_phi!-NTuple{16, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_electron_pdf_over_density_and_boundary_phi!","text":"initelectronpdfoverdensityandboundaryphi initialises the normalised electron pdf = pdfe * vthe / dense and the boundary values of the electrostatic potential phi; care is taken to ensure that the parallel boundary condition is satisfied; NB: as the electron pdf is obtained via a time-independent equation, this 'initital' value for the electron will just be the first guess in an iterative solution\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_electron_upar!-NTuple{8, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_electron_upar!","text":"initialise the electron parallel flow density\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_electron_vth!-NTuple{4, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_electron_vth!","text":"initialise the electron thermal speed profile. For Boltzmann electrons returns vth0 = sqrt(2*Ts/Tref/meovermi) For Braginskii or kinetic electrons, sets Te=Ti, so returns vthi/sqrt(meovermi).\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_ion_pdf_over_density!-NTuple{17, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_ion_pdf_over_density!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_neutral_pdf_over_density!-NTuple{20, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_neutral_pdf_over_density!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_pdf_and_moments!-NTuple{29, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_pdf_and_moments!","text":"creates the normalised pdfs and the velocity-space moments and populates them with a self-consistent initial condition\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_upar!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_upar!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_uz!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_uz!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_vth!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_vth!","text":"for now the only initialisation option for the temperature is constant in z returns vth0 = sqrt(2Ts/ms) / sqrt(Tref/mref) = sqrt(2Ts/T_ref)\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.initialize_pdf!-NTuple{16, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.initialize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing","page":"makie_post_processing","title":"makie_post_processing","text":"","category":"section"},{"location":"zz_makie_post_processing/#makie_post_processing.makie_post_processing","page":"makie_post_processing","title":"makie_post_processing.makie_post_processing","text":"Post processing functions using Makie.jl\n\nOptions are read by default from a file post_processing_input.toml, if it exists.\n\nThe plots can be generated from the command line by running\n\njulia --project run_makie_post_processing.jl dir1 [dir2 [dir3 ...]]\n\n\n\n\n\n","category":"module"},{"location":"zz_makie_post_processing/#makie_post_processing.input_dict","page":"makie_post_processing","title":"makie_post_processing.input_dict","text":"Global dict containing settings for makiepostprocessing. Can be re-loaded at any time to change settings.\n\nIs an OrderedDict so the order of sections is nicer if input_dict is written out as a TOML file.\n\n\n\n\n\n","category":"constant"},{"location":"zz_makie_post_processing/#makie_post_processing.input_dict_dfns","page":"makie_post_processing","title":"makie_post_processing.input_dict_dfns","text":"Global dict containing settings for makiepostprocessing for files with distribution function output. Can be re-loaded at any time to change settings.\n\nIs an OrderedDict so the order of sections is nicer if input_dict_dfns is written out as a TOML file.\n\n\n\n\n\n","category":"constant"},{"location":"zz_makie_post_processing/#makie_post_processing.Chodura_condition_plots","page":"makie_post_processing","title":"makie_post_processing.Chodura_condition_plots","text":"Chodura_condition_plots(run_info::Vector{Any}; plot_prefix)\nChodura_condition_plots(run_info; plot_prefix=nothing, axes=nothing)\n\nPlot the criterion from the Chodura condition at the sheath boundaries.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Vector, comparison plots are made where line plots from the different runs are overlayed on the same axis, and heatmap plots are displayed in a horizontal row.\n\nSettings are read from the [Chodura_condition] section of the input.\n\nWhen run_info is a Vector, plot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf. When run_info is not a Vector, plot_prefix is optional - plots will be saved only if it is passed.\n\nWhen run_info is not a Vector, a Vector of Axis objects can be passed to axes, and each plot will be added to one of axes.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing._MMS_pdf_plots-NTuple{10, Any}","page":"makie_post_processing","title":"makie_post_processing._MMS_pdf_plots","text":"_MMS_pdf_plots(run_info, input, variable_name, plot_prefix, field_label,\n               field_sym_label, norm_label, plot_dims, animate_dims)\n\nUtility function for making plots to avoid duplicated code in compare_ion_pdf_symbolic_test and compare_neutral_pdf_symbolic_test.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\ninput is a NamedTuple of settings to use.\n\nvariable_name is the name of the variable being plotted.\n\nplot_prefix gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nfield_label is the label for the computed variable that will be used in plots/animations, field_sym_label is the label for the manufactured solution, and norm_label is the label for the error.\n\nplot_dims are the dimensions of the variable, and animate_dims are the same but omitting :t.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing._get_steady_state_residual_fig_axes-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing._get_steady_state_residual_fig_axes","text":" _get_steady_state_residual_fig_axes(n_runs)\n\nUtility method to avoid code duplication when creating the figaxes OrderedDict for calculatesteadystateresidual.\n\nn_runs sets the number of axes to create in each entry.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_1d-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.animate_1d","text":"animate_1d(xcoord, data; frame_index=nothing, ax=nothing, fig=nothing,\n           xlabel=nothing, ylabel=nothing, title=nothing, yscale=nothing,\n           transform=identity, outfile=nothing, ylims=nothing,\n           axis_args=Dict{Symbol,Any}(), kwargs...)\n\nMake a 1d animation of data vs xcoord.\n\nxlabel, ylabel and title can be passed to set axis labels and title for the (sub-)plot.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nIf ax is passed, the animation will be added to that existing Axis, otherwise a new Figure and Axis will be created. If ax is passed, you should also pass an Observable{mk_int} to frame_index so that the data for this animation can be updated when frame_index is changed.\n\nIf outfile is passed the animation will be saved to a file with that name. The suffix determines the file type. If ax is passed at the same time as outfile then the Figure containing ax must also be passed (to the fig argument) so that the animation can be saved.\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nOther kwargs are passed to Makie's lines!() function.\n\nIf ax is not passed, returns the Figure, otherwise returns the object returned by lines!().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_2d-Tuple{Any, Any, Any}","page":"makie_post_processing","title":"makie_post_processing.animate_2d","text":"animate_2d(xcoord, ycoord, data; frame_index=nothing, ax=nothing, fig=nothing,\n           colorbar_place=nothing, xlabel=nothing, ylabel=nothing, title=nothing,\n           outfile=nothing, colormap=\"reverse_deep\", colorscale=nothing,\n           transform=identity, axis_args=Dict{Symbol,Any}(), kwargs...)\n\nMake a 2d animation of data vs xcoord and ycoord.\n\nxlabel, ylabel and title can be passed to set axis labels and title for the (sub-)plot.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nIf ax is passed, the animation will be added to that existing Axis, otherwise a new Figure and Axis will be created. If ax is passed, you should also pass an Observable{mk_int} to frame_index so that the data for this animation can be updated when frame_index is changed.\n\nIf outfile is passed the animation will be saved to a file with that name. The suffix determines the file type. If ax is passed at the same time as outfile then the Figure containing ax must also be passed (to the fig argument) so that the animation can be saved.\n\ncolormap is included explicitly because we do some special handling so that extra Makie functionality can be specified by a prefix to the colormap string, rather than the standard Makie mechanism of creating a struct that modifies the colormap. For example Reverse(\"deep\") can be passed as \"reverse_deep\". This is useful so that these extra colormaps can be specified in an input file, but is not needed for interactive use.\n\nWhen xcoord and ycoord are both one-dimensional, uses Makie's heatmap!() function for the plot. If either or both of xcoord and ycoord are two-dimensional, instead uses irregular_heatmap!.\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nOther kwargs are passed to Makie's heatmap!() function.\n\nIf ax is not passed, returns the Figure, otherwise returns the object returned by heatmap!().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_f_unnorm_vs_vpa","page":"makie_post_processing","title":"makie_post_processing.animate_f_unnorm_vs_vpa","text":"animate_f_unnorm_vs_vpa(run_info; input=nothing, electron=false, neutral=false, is=1,\n                        iz=nothing, fig=nothing, ax=nothing, frame_index=nothing,\n                        outfile=nothing, yscale=identity, transform=identity,\n                        axis_args=Dict{Symbol,Any}(), kwargs...)\n\nPlot an unnormalized distribution function against v_parallel at a fixed z.\n\nThis function is only needed for moment-kinetic runs. These are currently only supported for the 1D1V case.\n\nThe information for the runs to animate is passed in run_info (as returned by get_run_info). If run_info is a Vector, comparison plots are made where plots from the different runs are overlayed on the same axis.\n\nBy default animates the ion distribution function. If electron=true is passed, animates the electron distribution function instead. If neutral=true is passed, animates the neutral distribution function instead.\n\nis selects which species to analyse.\n\nit and iz specify the indices of the time- and z-points to choose. By default they are taken from input.\n\nIf input is not passed, it is taken from input_dict_dfns[\"f\"].\n\nThe data needed will be loaded from file.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen run_info is not a Vector, an Axis can be passed to ax to have the plot added to ax. When ax is passed, if outfile is passed to save the plot, then the Figure containing ax must be passed to fig.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nAny extra kwargs are passed to lines!() (which is used to create the plot, as we have to handle time-varying coordinates so cannot use animate_1d).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_f_unnorm_vs_vpa_z","page":"makie_post_processing","title":"makie_post_processing.animate_f_unnorm_vs_vpa_z","text":"animate_f_unnorm_vs_vpa_z(run_info; input=nothing, electron=false, neutral=false,\n                          is=1, fig=nothing, ax=nothing, frame_index=nothing,\n                          outfile=nothing, yscale=identity, transform=identity,\n                          axis_args=Dict{Symbol,Any}(), kwargs...)\n\nAnimate an unnormalized distribution function against v_parallel and z.\n\nThis function is only needed for moment-kinetic runs. These are currently only supported for the 1D1V case.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Vector, comparison plots are made where plots from the different runs are displayed in a horizontal row.\n\nBy default animates the ion distribution function. If electron=true is passed, animates the electron distribution function instead. If neutral=true is passed, animates the neutral distribution function instead.\n\nis selects which species to analyse.\n\nIf input is not passed, it is taken from input_dict_dfns[\"f\"].\n\nThe data needed will be loaded from file.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen run_info is not a Vector, an Axis can be passed to ax to have the animation created in ax. When ax is passed, if outfile is passed to save the animation, then the Figure containing ax must be passed to fig.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nAny extra kwargs are passed to plot_2d (which is used to create the plot, as we have to handle time-varying coordinates so cannot use animate_2d).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_r","text":"animate_vs_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, yscale=nothing,\n             transform=identity, ylims=nothing,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n             ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n             ivz=nothing, kwargs...)\nanimate_vs_r(run_info, var_name; is=1, data=nothing,\n             input=nothing, frame_index=nothing, ax=nothing,\n             fig=nothing, outfile=nothing, yscale=nothing,\n             transform=identity, ylims=nothing, label=nothing,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n             ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n             ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r.\n\nIf a Vector of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vpa","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vpa","text":"animate_vs_vpa(run_info::Vector{Any}, var_name; is=1, data=nothing,\n               input=nothing, outfile=nothing, yscale=nothing,\n               transform=identity, ylims=nothing,\n               axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n               ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n               ivz=nothing, kwargs...)\nanimate_vs_vpa(run_info, var_name; is=1, data=nothing,\n               input=nothing, frame_index=nothing, ax=nothing,\n               fig=nothing, outfile=nothing, yscale=nothing,\n               transform=identity, ylims=nothing, label=nothing,\n               axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n               ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n               ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vpa.\n\nIf a Vector of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vpa_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vpa_r","text":"animate_vs_vpa_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\nanimate_vs_vpa_r(run_info, var_name; is=1, data=nothing,\n                 input=nothing, frame_index=nothing, ax=nothing,\n                 fig=nothing, colorbar_place=colorbar_place,\n                 title=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vpa.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vpa_vperp","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vpa_vperp","text":"animate_vs_vpa_vperp(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                     input=nothing, outfile=nothing, colorscale=identity,\n                     transform=identity, axis_args=Dict{Symbol,Any}(),\n                     it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                     ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                     kwargs...)\nanimate_vs_vpa_vperp(run_info, var_name; is=1, data=nothing,\n                     input=nothing, frame_index=nothing, ax=nothing,\n                     fig=nothing, colorbar_place=colorbar_place,\n                     title=nothing, outfile=nothing, colorscale=identity,\n                     transform=identity, axis_args=Dict{Symbol,Any}(),\n                     it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                     ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                     kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vperp and vpa.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vpa_z","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vpa_z","text":"animate_vs_vpa_z(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\nanimate_vs_vpa_z(run_info, var_name; is=1, data=nothing,\n                 input=nothing, frame_index=nothing, ax=nothing,\n                 fig=nothing, colorbar_place=colorbar_place,\n                 title=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vpa.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vperp","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vperp","text":"animate_vs_vperp(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, yscale=nothing,\n                 transform=identity, ylims=nothing,\n                 axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n                 ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n                 ivz=nothing, kwargs...)\nanimate_vs_vperp(run_info, var_name; is=1, data=nothing,\n                 input=nothing, frame_index=nothing, ax=nothing,\n                 fig=nothing, outfile=nothing, yscale=nothing,\n                 transform=identity, ylims=nothing, label=nothing,\n                 axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n                 ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n                 ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vperp.\n\nIf a Vector of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vperp_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vperp_r","text":"animate_vs_vperp_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                   input=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\nanimate_vs_vperp_r(run_info, var_name; is=1, data=nothing,\n                   input=nothing, frame_index=nothing, ax=nothing,\n                   fig=nothing, colorbar_place=colorbar_place,\n                   title=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vperp.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vperp_z","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vperp_z","text":"animate_vs_vperp_z(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                   input=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\nanimate_vs_vperp_z(run_info, var_name; is=1, data=nothing,\n                   input=nothing, frame_index=nothing, ax=nothing,\n                   fig=nothing, colorbar_place=colorbar_place,\n                   title=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vperp.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vr","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vr","text":"animate_vs_vr(run_info::Vector{Any}, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, yscale=nothing,\n              transform=identity, ylims=nothing,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n              ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n              ivz=nothing, kwargs...)\nanimate_vs_vr(run_info, var_name; is=1, data=nothing,\n              input=nothing, frame_index=nothing, ax=nothing,\n              fig=nothing, outfile=nothing, yscale=nothing,\n              transform=identity, ylims=nothing, label=nothing,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n              ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n              ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vr.\n\nIf a Vector of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vr_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vr_r","text":"animate_vs_vr_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nanimate_vs_vr_r(run_info, var_name; is=1, data=nothing,\n                input=nothing, frame_index=nothing, ax=nothing,\n                fig=nothing, colorbar_place=colorbar_place,\n                title=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vr.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vr_vzeta","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vr_vzeta","text":"animate_vs_vr_vzeta(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                    input=nothing, outfile=nothing, colorscale=identity,\n                    transform=identity, axis_args=Dict{Symbol,Any}(),\n                    it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                    ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                    kwargs...)\nanimate_vs_vr_vzeta(run_info, var_name; is=1, data=nothing,\n                    input=nothing, frame_index=nothing, ax=nothing,\n                    fig=nothing, colorbar_place=colorbar_place,\n                    title=nothing, outfile=nothing, colorscale=identity,\n                    transform=identity, axis_args=Dict{Symbol,Any}(),\n                    it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                    ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                    kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta and vr.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vr_z","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vr_z","text":"animate_vs_vr_z(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nanimate_vs_vr_z(run_info, var_name; is=1, data=nothing,\n                input=nothing, frame_index=nothing, ax=nothing,\n                fig=nothing, colorbar_place=colorbar_place,\n                title=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vr.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vz","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vz","text":"animate_vs_vz(run_info::Vector{Any}, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, yscale=nothing,\n              transform=identity, ylims=nothing,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n              ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n              ivz=nothing, kwargs...)\nanimate_vs_vz(run_info, var_name; is=1, data=nothing,\n              input=nothing, frame_index=nothing, ax=nothing,\n              fig=nothing, outfile=nothing, yscale=nothing,\n              transform=identity, ylims=nothing, label=nothing,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n              ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n              ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vz.\n\nIf a Vector of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vz_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vz_r","text":"animate_vs_vz_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nanimate_vs_vz_r(run_info, var_name; is=1, data=nothing,\n                input=nothing, frame_index=nothing, ax=nothing,\n                fig=nothing, colorbar_place=colorbar_place,\n                title=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vz.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vz_vr","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vz_vr","text":"animate_vs_vz_vr(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\nanimate_vs_vz_vr(run_info, var_name; is=1, data=nothing,\n                 input=nothing, frame_index=nothing, ax=nothing,\n                 fig=nothing, colorbar_place=colorbar_place,\n                 title=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vr and vz.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vz_vzeta","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vz_vzeta","text":"animate_vs_vz_vzeta(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                    input=nothing, outfile=nothing, colorscale=identity,\n                    transform=identity, axis_args=Dict{Symbol,Any}(),\n                    it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                    ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                    kwargs...)\nanimate_vs_vz_vzeta(run_info, var_name; is=1, data=nothing,\n                    input=nothing, frame_index=nothing, ax=nothing,\n                    fig=nothing, colorbar_place=colorbar_place,\n                    title=nothing, outfile=nothing, colorscale=identity,\n                    transform=identity, axis_args=Dict{Symbol,Any}(),\n                    it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                    ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                    kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta and vz.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vz_z","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vz_z","text":"animate_vs_vz_z(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nanimate_vs_vz_z(run_info, var_name; is=1, data=nothing,\n                input=nothing, frame_index=nothing, ax=nothing,\n                fig=nothing, colorbar_place=colorbar_place,\n                title=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vz.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vzeta","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vzeta","text":"animate_vs_vzeta(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, yscale=nothing,\n                 transform=identity, ylims=nothing,\n                 axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n                 ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n                 ivz=nothing, kwargs...)\nanimate_vs_vzeta(run_info, var_name; is=1, data=nothing,\n                 input=nothing, frame_index=nothing, ax=nothing,\n                 fig=nothing, outfile=nothing, yscale=nothing,\n                 transform=identity, ylims=nothing, label=nothing,\n                 axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n                 ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n                 ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta.\n\nIf a Vector of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vzeta_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vzeta_r","text":"animate_vs_vzeta_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                   input=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\nanimate_vs_vzeta_r(run_info, var_name; is=1, data=nothing,\n                   input=nothing, frame_index=nothing, ax=nothing,\n                   fig=nothing, colorbar_place=colorbar_place,\n                   title=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vzeta.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vzeta_z","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vzeta_z","text":"animate_vs_vzeta_z(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                   input=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\nanimate_vs_vzeta_z(run_info, var_name; is=1, data=nothing,\n                   input=nothing, frame_index=nothing, ax=nothing,\n                   fig=nothing, colorbar_place=colorbar_place,\n                   title=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vzeta.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_z","page":"makie_post_processing","title":"makie_post_processing.animate_vs_z","text":"animate_vs_z(run_info::Vector{Any}, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, yscale=nothing,\n             transform=identity, ylims=nothing,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n             ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n             ivz=nothing, kwargs...)\nanimate_vs_z(run_info, var_name; is=1, data=nothing,\n             input=nothing, frame_index=nothing, ax=nothing,\n             fig=nothing, outfile=nothing, yscale=nothing,\n             transform=identity, ylims=nothing, label=nothing,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n             ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n             ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z.\n\nIf a Vector of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_z_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_z_r","text":"animate_vs_z_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n               input=nothing, outfile=nothing, colorscale=identity,\n               transform=identity, axis_args=Dict{Symbol,Any}(),\n               it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n               ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n               kwargs...)\nanimate_vs_z_r(run_info, var_name; is=1, data=nothing,\n               input=nothing, frame_index=nothing, ax=nothing,\n               fig=nothing, colorbar_place=colorbar_place,\n               title=nothing, outfile=nothing, colorscale=identity,\n               transform=identity, axis_args=Dict{Symbol,Any}(),\n               it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n               ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n               kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and z.\n\nIf a Vector of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.calculate_steady_state_residual","page":"makie_post_processing","title":"makie_post_processing.calculate_steady_state_residual","text":"calculatesteadystateresidual(runinfo, variablename; is=1, data=nothing,                                 plotprefix=nothing, figaxes=nothing, irun=1)\n\nCalculate and plot the 'residuals' for variable_name.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Vector, comparison plots are made where plots from the different runs are displayed in a horizontal row.\n\nIf the variable has a species dimension, is selects which species to analyse.\n\nBy default the variable will be loaded from file. If the data has already been loaded, it can be passed to data instead. data should be a Vector of the same length as run_info if run_info is a Vector.\n\nIf plot_prefix is passed, it gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf.\n\nfig_axes can be passed an OrderedDict of Tuples as returned by _get_steady_state_residual_fig_axes - each tuple contains the Figure fig and Axis or Vector{Axis} ax to which to add the plot corresponding to its key. If run_info is a Vector, ax for each entry must be a Vector of the same length.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.check_moment_constraints","page":"makie_post_processing","title":"makie_post_processing.check_moment_constraints","text":"check_moment_constraints(run_info, is_neutral; input, plot_prefix)\n\nPlots to check moment constraints. Comparison plots not currently supported.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.clear_Dict!-Tuple{AbstractDict}","page":"makie_post_processing","title":"makie_post_processing.clear_Dict!","text":"clear_Dict!(d::AbstractDict)\n\nRemove all entries from an AbstractDict, leaving it empty\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.collisionality_plots","page":"makie_post_processing","title":"makie_post_processing.collisionality_plots","text":"A function to plot collisionalities. The mean free path is plotted (or animated)  along with the lengthscales of the gradients of density, parallel flow and temperature.\n\nThere are also functions to check the calculations of the mean free path and the  comparison of temperature, LT and dTdz. They would only be for making sure lengthscales and mean free path calculations are sensible.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.compare_ion_pdf_symbolic_test-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.compare_ion_pdf_symbolic_test","text":"compare_ion_pdf_symbolic_test(run_info, plot_prefix; io=nothing,\n                                  input=nothing)\n\nCompare the computed and manufactured solutions for the ion distribution function.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nIf io is passed then error norms will be written to that file.\n\ninput is a NamedTuple of settings to use. If not given it will be read from the [manufactured_solns] section of [input_dict_dfns][@ref].\n\nNote: when calculating error norms, data is loaded only for 1 time point and for an r-z chunk that is the same size as computed by 1 block of the simulation at run time. This should prevent excessive memory requirements for this function.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.compare_moment_symbolic_test-NTuple{6, Any}","page":"makie_post_processing","title":"makie_post_processing.compare_moment_symbolic_test","text":"compare_moment_symbolic_test(run_info, plot_prefix, field_label, field_sym_label,\n                             norm_label, variable_name; io=nothing)\n\nCompare the computed and manufactured solutions for a field or moment variable variable_name.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nfield_label is the label that will be used for the name of the computed variable in plots, field_sym_label is the label for the manufactured solution, and norm_label is the label for the error (the difference between the computed and manufactured solutions).\n\nIf io is passed then error norms will be written to that file.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.compare_neutral_pdf_symbolic_test-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.compare_neutral_pdf_symbolic_test","text":"compare_neutral_pdf_symbolic_test(run_info, plot_prefix; io=nothing,\n                                  input=nothing)\n\nCompare the computed and manufactured solutions for the neutral distribution function.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nIf io is passed then error norms will be written to that file.\n\ninput is a NamedTuple of settings to use. If not given it will be read from the [manufactured_solns] section of [input_dict_dfns][@ref].\n\nNote: when calculating error norms, data is loaded only for 1 time point and for an r-z chunk that is the same size as computed by 1 block of the simulation at run time. This should prevent excessive memory requirements for this function.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.compare_runs","page":"makie_post_processing","title":"makie_post_processing.compare_runs","text":"compare_runs(run_info)\n\nPlot/animate the differences between several runs, comparing each run to the first one in run_info. Where different grids are used for (some of) the runs, all results will be interpolated onto the grid of the first run.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.constraints_plots-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.constraints_plots","text":"constraints_plots(run_info; plot_prefix=plot_prefix)\n\nPlot and/or animate the coefficients used to correct the normalised distribution function(s) (aka shape functions) to obey the moment constraints.\n\nIf there were no discretisation errors, we would have A=1, B=0, C=0. The plots/animations show (A-1) so that all three coefficients can be shown nicely on the same axes.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.convert_to_OrderedDicts!-Tuple{AbstractDict}","page":"makie_post_processing","title":"makie_post_processing.convert_to_OrderedDicts!","text":"convert_to_OrderedDicts!(d::AbstractDict)\n\nRecursively convert an AbstractDict to OrderedDict.\n\nAny nested AbstractDicts are also converted to OrderedDict.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.curvilinear_grid_mesh-NTuple{4, Any}","page":"makie_post_processing","title":"makie_post_processing.curvilinear_grid_mesh","text":"curvilinear_grid_mesh(xs, ys, zs, colors)\n\nTesselates the grid defined by xs and ys in order to form a mesh with per-face coloring given by colors.\n\nThe grid defined by xs and ys must have dimensions (nx, ny) == size(colors) .+ 1, as is the case for heatmap/image.\n\nCode from: https://github.com/MakieOrg/Makie.jl/issues/742#issuecomment-1415809653\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.generate_example_input_Dict-Tuple{}","page":"makie_post_processing","title":"makie_post_processing.generate_example_input_Dict","text":"generate_example_input_Dict()\n\nCreate a Dict containing all the makie-post-processing options with default values\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.generate_example_input_file","page":"makie_post_processing","title":"makie_post_processing.generate_example_input_file","text":"generate_example_input_file(filename::String=post_processing_input.toml;\n                            overwrite::Bool=false)\n\nCreate an example makie-post-processing input file.\n\nEvery option is commented out, but filled with the default value.\n\nPass filename to choose the name of the example file (defaults to the default input file name used by makie_post_process()).\n\nPass overwrite=true to overwrite any existing file at filename.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.generate_maximal_input_file","page":"makie_post_processing","title":"makie_post_processing.generate_maximal_input_file","text":"generate_maximal_input_file(filename::String=default_input_file_name;\n                            overwrite::Bool=false)\n\nGenerate an input file with all Bool options set to true, and no other options present. Intended mostly for setting up tests to check that makie_post_process runs without errors.\n\nhandle_errors is set to false (although it is a Bool) so that any errors are not caught, and so will register as a test failure.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.get_1d_ax","page":"makie_post_processing","title":"makie_post_processing.get_1d_ax","text":"get_1d_ax(n=nothing; title=nothing, subtitles=nothing, yscale=nothing,\n          get_legend_place=nothing, size=nothing, kwargs...)\n\nCreate a new Figure fig and Axis ax intended for 1d plots.\n\ntitle gives an overall title to the Figure.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10.\n\nBy default creates a single Axis, and returns (fig, ax). If a number of axes n is passed, then ax is a Vector{Axis} of length n (even if n is 1). The axes are created in a horizontal row, and the width of the figure is increased in proportion to n.\n\nget_legend_place can be set to one of (:left, :right, :above, :below) to create a GridPosition for a legend in the corresponding place relative to each Axis. If get_legend_place is set, (fig, ax, legend_place) is returned where legend_place is a GridPosition (if n=nothing) or a Tuple of n GridPositions.\n\nWhen n is passed, subtitles can be passed a Tuple of length n which will be used to set a subtitle for each Axis in ax.\n\nsize is passed through to the Figure constructor. Its default value is (600, 400) if n is not passed, or (600*n, 400) if n is passed.\n\nExtra kwargs are passed to the Axis() constructor.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.get_2d_ax","page":"makie_post_processing","title":"makie_post_processing.get_2d_ax","text":"get_2d_ax(n=nothing; title=nothing, subtitles=nothing, size=nothing, kwargs...)\n\nCreate a new Figure fig and Axis ax intended for 2d plots.\n\ntitle gives an overall title to the Figure.\n\nBy default creates a single Axis, and returns (fig, ax, colorbar_place), where colorbar_place is a location in the grid layout that can be passed to Colorbar() located immediately to the right of ax. If a number of axes n is passed, then ax is a Vector{Axis} and colorbar_place is a Vector{GridPosition} of length n (even if n is 1). The axes are created in a horizontal row, and the width of the figure is increased in proportion to n.\n\nWhen n is passed, subtitles can be passed a Tuple of length n which will be used to set a subtitle for each Axis in ax.\n\nsize is passed through to the Figure constructor. Its default value is (600, 400) if n is not passed, or (600*n, 400) if n is passed.\n\nExtra kwargs are passed to the Axis() constructor.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.get_dimension_slice_indices-Tuple","page":"makie_post_processing","title":"makie_post_processing.get_dimension_slice_indices","text":"getdimensionsliceindices(keepdims...; input, it=nothing, is=nothing,                             ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,                             ivzeta=nothing, ivr=nothing, ivz=nothing)\n\nGet indices for dimensions to slice\n\nThe indices are taken from input, unless they are passed as keyword arguments\n\nThe dimensions in keep_dims are not given a slice (those are the dimensions we want in the variable after slicing).\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.get_run_info-Tuple","page":"makie_post_processing","title":"makie_post_processing.get_run_info","text":"get_run_info(run_dir...; itime_min=1, itime_max=0,\n             itime_skip=1, dfns=false, initial_electron=false, electron_debug=false,\n             do_setup=true, setup_input_file=nothing)\nget_run_info((run_dir, restart_index)...; itime_min=1, itime_max=0,\n             itime_skip=1, dfns=false, initial_electron=false, electron_debug=false,\n             do_setup=true, setup_input_file=nothing)\n\nGet file handles and other info for a single run\n\nrun_dir is either the directory to read output from (whose name should be the run_name), or a momentkinetics binary output file. If a file is passed, it is only used to infer the directory and `runname, so it is possible for example to pass a.moments.h5output file and alsodfns=trueand the.dfns.h5` file will be the one actually opened (as long as it exists).\n\nrestart_index can be given by passing a Tuple, e.g. (\"runs/example\", 42) as the positional argument. It specifies which restart to read if there are multiple restarts. If no restart_index is given or if nothing is passed, read all restarts and concatenate them. An integer value reads the restart with that index - -1 indicates the latest restart (which does not have an index).\n\nSeveral runs can be loaded at the same time by passing multiple positional arguments. Each argument can be a String run_dir giving a directory to read output from or a Tuple (run_dir, restart_index) giving both a directory and a restart index (it is allowed to mix Strings and Tuples in a call).\n\nBy default load data from moments files, pass dfns=true to load from distribution functions files, or initial_electron=true and dfns=true to load from initial electron state files, or electron_debug=true and dfns=true to load from electron debug files.\n\nThe itime_min, itime_max and itime_skip options can be used to select only a slice of time points when loading data. In makie_post_process these options are read from the input (if they are set) before get_run_info() is called, so that the run_info returned can be passed to setup_makie_post_processing_input!, to be used for defaults for the remaining options. If either itime_min or itime_max are ≤0, their values are used as offsets from the final time index of the run.\n\nsetup_makie_post_processing_input!() is called at the end of get_run_info(), for convenience when working interactively. Use moment_kinetics.load_data.get_run_info_no_setup if you do not want this. A post-processing input file can be passed to setup_input_file that will be passed to setup_makie_post_processing_input!() if you do not want to use the default input file.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.get_variable_symbol-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.get_variable_symbol","text":"get_variable_symbol(variable_name)\n\nGet a symbol corresponding to a variable_name\n\nFor example get_variable_symbol(\"phi\") returns \"ϕ\".\n\nIf the symbol has not been defined, just return variable_name.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.grid_points_to_faces","page":"makie_post_processing","title":"makie_post_processing.grid_points_to_faces","text":"grid_points_to_faces(coord::AbstractVector)\ngrid_points_to_faces(coord::Observable{T} where T <: AbstractVector)\ngrid_points_to_faces(coord::AbstractMatrix)\ngrid_points_to_faces(coord::Observable{T} where T <: AbstractMatrix)\n\nTurn grid points in coord into 'cell faces'.\n\nReturns faces, which has a length one greater than coord. The first and last values of faces are the first and last values of coord. The intermediate values are the mid points between grid points.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.instability2D_plots","page":"makie_post_processing","title":"makie_post_processing.instability2D_plots","text":"instability2D_plots(run_info::Vector{Any}, variable_name; plot_prefix, zind=nothing)\ninstability2D_plots(run_info, variable_name; plot_prefix, zind=nothing,\n                    axes_and_observables=nothing)\n\nMake plots of variable_name for analysis of 2D instability.\n\nThe information for the runs to analyse and plot is passed in run_info (as returned by get_run_info). If run_info is a Vector, make plots comparing the runs, shown in a horizontal row..\n\nSettings are read from the [instability2D] section of the input.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nWhen run_info is not a Vector, axes_and_observables can be passed to add plots and animations to existing figures, although this is not very convenient - see the use of this argument when called from the run_info::Vector{Any} method.\n\nIf zind is not passed, it is calculated as the z-index where the mode seems to have the maximum growth rate for this variable. Returns zind.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.irregular_heatmap!-NTuple{4, Any}","page":"makie_post_processing","title":"makie_post_processing.irregular_heatmap!","text":"irregular_heatmap!(ax, xs, ys, zs; kwargs...)\n\nPlot a heatmap onto the Axis ax where xs and ys are allowed to define irregularly spaced, 2d grids.  zs gives the value in each cell of the grid.\n\nThe grid defined by xs and ys must have dimensions (nx, ny) == size(zs) .+ 1, as is the case for heatmap/image.\n\nxs be an array of size (nx,ny) or a vector of size (nx).\n\nys be an array of size (nx,ny) or a vector of size (ny).\n\nkwargs are passed to Makie's mesh() function.\n\nCode adapted from: https://github.com/MakieOrg/Makie.jl/issues/742#issuecomment-1415809653\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.irregular_heatmap-Tuple{Any, Any, Any}","page":"makie_post_processing","title":"makie_post_processing.irregular_heatmap","text":"irregular_heatmap(xs, ys, zs; kwargs...)\n\nPlot a heatmap where xs and ys are allowed to define irregularly spaced, 2d grids. zs gives the value in each cell of the grid.\n\nThe grid defined by xs and ys must have dimensions (nx, ny) == size(zs) .+ 1, as is the case for heatmap/image.\n\nxs be an array of size (nx,ny) or a vector of size (nx).\n\nys be an array of size (nx,ny) or a vector of size (ny).\n\nkwargs are passed to Makie's mesh() function.\n\nCode adapted from: https://github.com/MakieOrg/Makie.jl/issues/742#issuecomment-1415809653\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.makie_post_process-Tuple","page":"makie_post_processing","title":"makie_post_processing.makie_post_process","text":"makie_post_process(run_dir...;\n                   input_file::String=default_input_file_name,\n                   restart_index::Union{Nothing,mk_int,AbstractVector}=nothing,\n                   plot_prefix::Union{Nothing,AbstractString}=nothing)\n\nRun post processing with input read from a TOML file\n\nrun_dir... is the path to the directory to plot from. If more than one run_dir is given, plots comparing the runs in run_dir... are made. A momentkinetics binary output file can also be passed as `rundir, in which case the filename is only used to infer the directory andrun_name, so it is possible for example to pass a.moments.h5output file and still make distribution function plots (as long as the corresponding.dfns.h5` file exists).\n\nrestart_index specifies which restart to read if there are multiple restarts. The default (nothing) reads all restarts and concatenates them. An integer value reads the restart with that index - -1 indicates the latest restart (which does not have an index). A Vector with the same length as run_dir can also be passed to give a different restart_index for each run.\n\nplot_prefix can be specified to give the prefix (directory and first part of file name) to use when saving plots/animations. By default the run directory and run name are used if there is only one run, and \"comparisonplots/compare\" is used if there are multiple runs.\n\nIf input_file does not exist, prints warning and uses default options.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.makie_post_process-Tuple{Union{String, Vector{String}}, AbstractDict{String, Any}}","page":"makie_post_processing","title":"makie_post_processing.makie_post_process","text":"makie_post_process(run_dir::Union{String,Vector{String}},\n                   new_input_dict::Dict{String,Any};\n                   restart_index::Union{Nothing,mk_int,AbstractVector}=nothing,\n                   plot_prefix::Union{Nothing,AbstractString}=nothing)\n\nRun post prossing, with (non-default) input given in a Dict\n\nrun_dir is the path to the directory to plot from. If run_dir is a Vector{String}, plots comparing the runs in run_dir are made. A momentkinetics binary output file can also be passed as `rundir, in which case the filename is only used to infer the directory andrun_name, so it is possible for example to pass a.moments.h5output file and still make distribution function plots (as long as the corresponding.dfns.h5` file exists).\n\ninput_dict is a dictionary containing settings for the post-processing.\n\nrestart_index specifies which restart to read if there are multiple restarts. The default (nothing) reads all restarts and concatenates them. An integer value reads the restart with that index - -1 indicates the latest restart (which does not have an index). A Vector with the same length as run_dir can also be passed to give a different restart_index for each run.\n\nplot_prefix can be specified to give the prefix (directory and first part of file name) to use when saving plots/animations. By default the run directory and run name are used if there is only one run, and \"comparisonplots/compare\" is used if there are multiple runs.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.manufactured_solutions_analysis","page":"makie_post_processing","title":"makie_post_processing.manufactured_solutions_analysis","text":"manufactured_solutions_analysis(run_info; plot_prefix)\nmanufactured_solutions_analysis(run_info::Vector{Any}; plot_prefix)\n\nCompare computed and manufactured solutions for field and moment variables for a 'method of manufactured solutions' (MMS) test.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nSettings are read from the [manufactured_solns] section of the input.\n\nWhile a Vector of run_info can be passed for compatibility with makie_post_process(), at present comparison of multiple runs is not supported - passing a Vector of length greater than one will result in an error.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.manufactured_solutions_analysis_dfns","page":"makie_post_processing","title":"makie_post_processing.manufactured_solutions_analysis_dfns","text":"manufactured_solutions_analysis_dfns(run_info; plot_prefix)\nmanufactured_solutions_analysis_dfns(run_info::Vector{Any}; plot_prefix)\n\nCompare computed and manufactured solutions for distribution function variables for a 'method of manufactured solutions' (MMS) test.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nSettings are read from the [manufactured_solns] section of the input.\n\nWhile a Vector of run_info can be passed for compatibility with makie_post_process(), at present comparison of multiple runs is not supported - passing a Vector of length greater than one will result in an error.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.manufactured_solutions_get_field_and_field_sym-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.manufactured_solutions_get_field_and_field_sym","text":" manufactured_solutions_get_field_and_field_sym(run_info, variable_name;\n     it=nothing, ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n     ivr=nothing, ivz=nothing)\n\nGet the data variable for variable_name from the output, and calculate the manufactured solution variable_sym.\n\nThe information for the runs to analyse and plot is passed in run_info (as returned by get_run_info).\n\nit, ir, iz, ivperp, ivpa, ivzeta, ivr, ivz can be used to select a subset of the grid by passing an integer or range for any dimension.\n\nReturns variable, variable_sym.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.parse_colormap-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.parse_colormap","text":"parse_colormap(colormap)\n\nParse a colormap option\n\nAllows us to have a string option which can be set in the input file and still use Reverse, etc. conveniently.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_1d-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.plot_1d","text":"plot_1d(xcoord, data; ax=nothing, xlabel=nothing, ylabel=nothing, title=nothing,\n        yscale=nothing, transform=identity, axis_args=Dict{Symbol,Any}(),\n        kwargs...)\n\nMake a 1d plot of data vs xcoord.\n\nxlabel, ylabel and title can be passed to set axis labels and title for the (sub-)plot.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nIf ax is passed, the plot will be added to that existing Axis, otherwise a new Figure and Axis will be created.\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nOther kwargs are passed to Makie's lines!() function.\n\nIf ax is not passed, returns the Figure, otherwise returns the object returned by lines!().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_2d-Tuple{Any, Any, Any}","page":"makie_post_processing","title":"makie_post_processing.plot_2d","text":"plot_2d(xcoord, ycoord, data; ax=nothing, colorbar_place=nothing, xlabel=nothing,\n        ylabel=nothing, title=nothing, colormap=\"reverse_deep\",\n        colorscale=nothing, transform=identity, axis_args=Dict{Symbol,Any}(),\n        kwargs...)\n\nMake a 2d plot of data vs xcoord and ycoord.\n\nxlabel, ylabel and title can be passed to set axis labels and title for the (sub-)plot.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nIf ax is passed, the plot will be added to that existing Axis, otherwise a new Figure and Axis will be created.\n\ncolormap is included explicitly because we do some special handling so that extra Makie functionality can be specified by a prefix to the colormap string, rather than the standard Makie mechanism of creating a struct that modifies the colormap. For example Reverse(\"deep\") can be passed as \"reverse_deep\". This is useful so that these extra colormaps can be specified in an input file, but is not needed for interactive use.\n\nWhen xcoord and ycoord are both one-dimensional, uses Makie's heatmap!() function for the plot. If either or both of xcoord and ycoord are two-dimensional, instead uses irregular_heatmap!.\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nOther kwargs are passed to Makie's heatmap!() function.\n\nIf ax is not passed, returns the Figure, otherwise returns the object returned by heatmap!().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_charged_pdf_2D_at_wall-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.plot_charged_pdf_2D_at_wall","text":"plot_charged_pdf_2D_at_wall(run_info; plot_prefix, electron=false)\n\nMake plots/animations of the ion distribution function at wall boundaries.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Vector, comparison plots are made where line plots/animations from the different runs are overlayed on the same axis, and heatmap plots/animations are displayed in a horizontal row.\n\nSettings are read from the [wall_pdf] section of the input.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf. When run_info is not a Vector, plot_prefix is optional - plots/animations will be saved only if it is passed.\n\nIf electron=true is passed, plot electron distribution function instead of ion distribution function.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_f_unnorm_vs_vpa","page":"makie_post_processing","title":"makie_post_processing.plot_f_unnorm_vs_vpa","text":"plot_f_unnorm_vs_vpa(run_info; input=nothing, electron=false, neutral=false,\n                     it=nothing, is=1, iz=nothing, fig=nothing, ax=nothing,\n                     outfile=nothing, yscale=identity, transform=identity,\n                     axis_args=Dict{Symbol,Any}(), kwargs...)\n\nPlot an unnormalized distribution function against v_parallel at a fixed z.\n\nThis function is only needed for moment-kinetic runs. These are currently only supported for the 1D1V case.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Vector, comparison plots are made where plots from the different runs are overlayed on the same axis.\n\nBy default plots the ion distribution function. If electron=true is passed, plots the electron distribution function instead. If neutral=true is passed, plots the neutral distribution function instead.\n\nis selects which species to analyse.\n\nit and iz specify the indices of the time- and z-points to choose. By default they are taken from input.\n\nIf input is not passed, it is taken from input_dict_dfns[\"f\"].\n\nThe data needed will be loaded from file.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nWhen run_info is not a Vector, an Axis can be passed to ax to have the plot added to ax. When ax is passed, if outfile is passed to save the plot, then the Figure containing ax must be passed to fig.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nAny extra kwargs are passed to plot_1d.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_f_unnorm_vs_vpa_z","page":"makie_post_processing","title":"makie_post_processing.plot_f_unnorm_vs_vpa_z","text":"plot_f_unnorm_vs_vpa_z(run_info; input=nothing, electron=false, neutral=false,\n                       it=nothing, is=1, fig=nothing, ax=nothing, outfile=nothing,\n                       yscale=identity, transform=identity, rasterize=true,\n                       subtitles=nothing, axis_args=Dict{Symbol,Any}(), kwargs...)\n\nPlot unnormalized distribution function against v_parallel and z.\n\nThis function is only needed for moment-kinetic runs. These are currently only supported for the 1D1V case.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Vector, comparison plots are made where plots from the different runs are displayed in a horizontal row.\n\nBy default plots the ion distribution function. If electron=true is passed, plots the electron distribution function instead. If neutral=true is passed, plots the neutral distribution function instead.\n\nis selects which species to analyse.\n\nit specifies the time-index to choose. By default it is taken from input.\n\nIf input is not passed, it is taken from input_dict_dfns[\"f\"].\n\nThe data needed will be loaded from file.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nWhen run_info is not a Vector, an Axis can be passed to ax to have the plot created in ax. When ax is passed, if outfile is passed to save the plot, then the Figure containing ax must be passed to fig.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nrasterize is passed through to Makie's mesh!() function. The default is to rasterize plots as vectorized plots from mesh!() have a very large file size. Pass false to keep plots vectorized. Pass a number to increase the resolution of the rasterized plot by that factor.\n\nWhen run_info is a Vector, subtitles can be passed a Vector (with the same length as run_info) to set the subtitle for each subplot.\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nAny extra kwargs are passed to plot_2d.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_neutral_pdf_2D_at_wall-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.plot_neutral_pdf_2D_at_wall","text":"plot_neutral_pdf_2D_at_wall(run_info; plot_prefix)\n\nMake plots/animations of the neutral particle distribution function at wall boundaries.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Vector, comparison plots are made where line plots/animations from the different runs are overlayed on the same axis, and heatmap plots/animations are displayed in a horizontal row.\n\nSettings are read from the [wall_pdf_neutral] section of the input.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf. When run_info is not a Vector, plot_prefix is optional - plots/animations will be saved only if it is passed.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_r","text":"plot_vs_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n          input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n          ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n          ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_r(run_info, var_name; is=1, data=nothing,\n          input=nothing, ax=nothing, label=nothing,\n          outfile=nothing, yscale=nothing, transform=identity,\n          axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n          iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n          ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs r.\n\nIf a Vector of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_r_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_r_t","text":"plot_vs_r_t(run_info::Vector{Any}, var_name; is=1, data=nothing,\n            input=nothing, outfile=nothing, colorscale=identity,\n            transform=identity, axis_args=Dict{Symbol,Any}(),\n            it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n            ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n            kwargs...)\nplot_vs_r_t(run_info, var_name; is=1, data=nothing,\n            input=nothing, ax=nothing,\n            colorbar_place=nothing, title=nothing,\n            outfile=nothing, colorscale=identity, transform=identity,\n            axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n            iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n            ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and r.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_t","text":"plot_vs_t(run_info::Vector{Any}, var_name; is=1, data=nothing,\n          input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n          ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n          ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_t(run_info, var_name; is=1, data=nothing,\n          input=nothing, ax=nothing, label=nothing,\n          outfile=nothing, yscale=nothing, transform=identity,\n          axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n          iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n          ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs t.\n\nIf a Vector of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vpa","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vpa","text":"plot_vs_vpa(run_info::Vector{Any}, var_name; is=1, data=nothing,\n            input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n            ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n            ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_vpa(run_info, var_name; is=1, data=nothing,\n            input=nothing, ax=nothing, label=nothing,\n            outfile=nothing, yscale=nothing, transform=identity,\n            axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n            iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n            ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vpa.\n\nIf a Vector of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vpa_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vpa_r","text":"plot_vs_vpa_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, colorscale=identity,\n              transform=identity, axis_args=Dict{Symbol,Any}(),\n              it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n              ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n              kwargs...)\nplot_vs_vpa_r(run_info, var_name; is=1, data=nothing,\n              input=nothing, ax=nothing,\n              colorbar_place=nothing, title=nothing,\n              outfile=nothing, colorscale=identity, transform=identity,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n              iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n              ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vpa.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vpa_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vpa_t","text":"plot_vs_vpa_t(run_info::Vector{Any}, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, colorscale=identity,\n              transform=identity, axis_args=Dict{Symbol,Any}(),\n              it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n              ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n              kwargs...)\nplot_vs_vpa_t(run_info, var_name; is=1, data=nothing,\n              input=nothing, ax=nothing,\n              colorbar_place=nothing, title=nothing,\n              outfile=nothing, colorscale=identity, transform=identity,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n              iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n              ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vpa.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vpa_vperp","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vpa_vperp","text":"plot_vs_vpa_vperp(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                  input=nothing, outfile=nothing, colorscale=identity,\n                  transform=identity, axis_args=Dict{Symbol,Any}(),\n                  it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                  ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                  kwargs...)\nplot_vs_vpa_vperp(run_info, var_name; is=1, data=nothing,\n                  input=nothing, ax=nothing,\n                  colorbar_place=nothing, title=nothing,\n                  outfile=nothing, colorscale=identity, transform=identity,\n                  axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                  iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                  ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs vperp and vpa.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vpa_z","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vpa_z","text":"plot_vs_vpa_z(run_info::Vector{Any}, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, colorscale=identity,\n              transform=identity, axis_args=Dict{Symbol,Any}(),\n              it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n              ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n              kwargs...)\nplot_vs_vpa_z(run_info, var_name; is=1, data=nothing,\n              input=nothing, ax=nothing,\n              colorbar_place=nothing, title=nothing,\n              outfile=nothing, colorscale=identity, transform=identity,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n              iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n              ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vpa.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vperp","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vperp","text":"plot_vs_vperp(run_info::Vector{Any}, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n              ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n              ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_vperp(run_info, var_name; is=1, data=nothing,\n              input=nothing, ax=nothing, label=nothing,\n              outfile=nothing, yscale=nothing, transform=identity,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n              iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n              ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vperp.\n\nIf a Vector of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vperp_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vperp_r","text":"plot_vs_vperp_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nplot_vs_vperp_r(run_info, var_name; is=1, data=nothing,\n                input=nothing, ax=nothing,\n                colorbar_place=nothing, title=nothing,\n                outfile=nothing, colorscale=identity, transform=identity,\n                axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vperp.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vperp_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vperp_t","text":"plot_vs_vperp_t(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nplot_vs_vperp_t(run_info, var_name; is=1, data=nothing,\n                input=nothing, ax=nothing,\n                colorbar_place=nothing, title=nothing,\n                outfile=nothing, colorscale=identity, transform=identity,\n                axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vperp.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vperp_z","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vperp_z","text":"plot_vs_vperp_z(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nplot_vs_vperp_z(run_info, var_name; is=1, data=nothing,\n                input=nothing, ax=nothing,\n                colorbar_place=nothing, title=nothing,\n                outfile=nothing, colorscale=identity, transform=identity,\n                axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vperp.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vr","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vr","text":"plot_vs_vr(run_info::Vector{Any}, var_name; is=1, data=nothing,\n           input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n           ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n           ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_vr(run_info, var_name; is=1, data=nothing,\n           input=nothing, ax=nothing, label=nothing,\n           outfile=nothing, yscale=nothing, transform=identity,\n           axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n           iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n           ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vr.\n\nIf a Vector of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vr_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vr_r","text":"plot_vs_vr_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, colorscale=identity,\n             transform=identity, axis_args=Dict{Symbol,Any}(),\n             it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n             ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n             kwargs...)\nplot_vs_vr_r(run_info, var_name; is=1, data=nothing,\n             input=nothing, ax=nothing,\n             colorbar_place=nothing, title=nothing,\n             outfile=nothing, colorscale=identity, transform=identity,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n             iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n             ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vr.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vr_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vr_t","text":"plot_vs_vr_t(run_info::Vector{Any}, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, colorscale=identity,\n             transform=identity, axis_args=Dict{Symbol,Any}(),\n             it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n             ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n             kwargs...)\nplot_vs_vr_t(run_info, var_name; is=1, data=nothing,\n             input=nothing, ax=nothing,\n             colorbar_place=nothing, title=nothing,\n             outfile=nothing, colorscale=identity, transform=identity,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n             iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n             ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vr.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vr_vzeta","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vr_vzeta","text":"plot_vs_vr_vzeta(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\nplot_vs_vr_vzeta(run_info, var_name; is=1, data=nothing,\n                 input=nothing, ax=nothing,\n                 colorbar_place=nothing, title=nothing,\n                 outfile=nothing, colorscale=identity, transform=identity,\n                 axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                 iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                 ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta and vr.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vr_z","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vr_z","text":"plot_vs_vr_z(run_info::Vector{Any}, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, colorscale=identity,\n             transform=identity, axis_args=Dict{Symbol,Any}(),\n             it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n             ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n             kwargs...)\nplot_vs_vr_z(run_info, var_name; is=1, data=nothing,\n             input=nothing, ax=nothing,\n             colorbar_place=nothing, title=nothing,\n             outfile=nothing, colorscale=identity, transform=identity,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n             iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n             ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vr.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vz","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vz","text":"plot_vs_vz(run_info::Vector{Any}, var_name; is=1, data=nothing,\n           input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n           ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n           ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_vz(run_info, var_name; is=1, data=nothing,\n           input=nothing, ax=nothing, label=nothing,\n           outfile=nothing, yscale=nothing, transform=identity,\n           axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n           iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n           ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vz.\n\nIf a Vector of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vz_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vz_r","text":"plot_vs_vz_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, colorscale=identity,\n             transform=identity, axis_args=Dict{Symbol,Any}(),\n             it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n             ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n             kwargs...)\nplot_vs_vz_r(run_info, var_name; is=1, data=nothing,\n             input=nothing, ax=nothing,\n             colorbar_place=nothing, title=nothing,\n             outfile=nothing, colorscale=identity, transform=identity,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n             iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n             ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vz.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vz_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vz_t","text":"plot_vs_vz_t(run_info::Vector{Any}, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, colorscale=identity,\n             transform=identity, axis_args=Dict{Symbol,Any}(),\n             it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n             ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n             kwargs...)\nplot_vs_vz_t(run_info, var_name; is=1, data=nothing,\n             input=nothing, ax=nothing,\n             colorbar_place=nothing, title=nothing,\n             outfile=nothing, colorscale=identity, transform=identity,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n             iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n             ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vz.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vz_vr","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vz_vr","text":"plot_vs_vz_vr(run_info::Vector{Any}, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, colorscale=identity,\n              transform=identity, axis_args=Dict{Symbol,Any}(),\n              it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n              ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n              kwargs...)\nplot_vs_vz_vr(run_info, var_name; is=1, data=nothing,\n              input=nothing, ax=nothing,\n              colorbar_place=nothing, title=nothing,\n              outfile=nothing, colorscale=identity, transform=identity,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n              iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n              ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs vr and vz.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vz_vzeta","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vz_vzeta","text":"plot_vs_vz_vzeta(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\nplot_vs_vz_vzeta(run_info, var_name; is=1, data=nothing,\n                 input=nothing, ax=nothing,\n                 colorbar_place=nothing, title=nothing,\n                 outfile=nothing, colorscale=identity, transform=identity,\n                 axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                 iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                 ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta and vz.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vz_z","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vz_z","text":"plot_vs_vz_z(run_info::Vector{Any}, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, colorscale=identity,\n             transform=identity, axis_args=Dict{Symbol,Any}(),\n             it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n             ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n             kwargs...)\nplot_vs_vz_z(run_info, var_name; is=1, data=nothing,\n             input=nothing, ax=nothing,\n             colorbar_place=nothing, title=nothing,\n             outfile=nothing, colorscale=identity, transform=identity,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n             iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n             ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vz.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vzeta","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vzeta","text":"plot_vs_vzeta(run_info::Vector{Any}, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n              ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n              ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_vzeta(run_info, var_name; is=1, data=nothing,\n              input=nothing, ax=nothing, label=nothing,\n              outfile=nothing, yscale=nothing, transform=identity,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n              iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n              ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vzeta.\n\nIf a Vector of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vzeta_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vzeta_r","text":"plot_vs_vzeta_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nplot_vs_vzeta_r(run_info, var_name; is=1, data=nothing,\n                input=nothing, ax=nothing,\n                colorbar_place=nothing, title=nothing,\n                outfile=nothing, colorscale=identity, transform=identity,\n                axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vzeta.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vzeta_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vzeta_t","text":"plot_vs_vzeta_t(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nplot_vs_vzeta_t(run_info, var_name; is=1, data=nothing,\n                input=nothing, ax=nothing,\n                colorbar_place=nothing, title=nothing,\n                outfile=nothing, colorscale=identity, transform=identity,\n                axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vzeta.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vzeta_z","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vzeta_z","text":"plot_vs_vzeta_z(run_info::Vector{Any}, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nplot_vs_vzeta_z(run_info, var_name; is=1, data=nothing,\n                input=nothing, ax=nothing,\n                colorbar_place=nothing, title=nothing,\n                outfile=nothing, colorscale=identity, transform=identity,\n                axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vzeta.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_z","page":"makie_post_processing","title":"makie_post_processing.plot_vs_z","text":"plot_vs_z(run_info::Vector{Any}, var_name; is=1, data=nothing,\n          input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n          ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n          ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_z(run_info, var_name; is=1, data=nothing,\n          input=nothing, ax=nothing, label=nothing,\n          outfile=nothing, yscale=nothing, transform=identity,\n          axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n          iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n          ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs z.\n\nIf a Vector of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_z_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_z_r","text":"plot_vs_z_r(run_info::Vector{Any}, var_name; is=1, data=nothing,\n            input=nothing, outfile=nothing, colorscale=identity,\n            transform=identity, axis_args=Dict{Symbol,Any}(),\n            it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n            ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n            kwargs...)\nplot_vs_z_r(run_info, var_name; is=1, data=nothing,\n            input=nothing, ax=nothing,\n            colorbar_place=nothing, title=nothing,\n            outfile=nothing, colorscale=identity, transform=identity,\n            axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n            iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n            ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and z.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_z_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_z_t","text":"plot_vs_z_t(run_info::Vector{Any}, var_name; is=1, data=nothing,\n            input=nothing, outfile=nothing, colorscale=identity,\n            transform=identity, axis_args=Dict{Symbol,Any}(),\n            it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n            ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n            kwargs...)\nplot_vs_z_t(run_info, var_name; is=1, data=nothing,\n            input=nothing, ax=nothing,\n            colorbar_place=nothing, title=nothing,\n            outfile=nothing, colorscale=identity, transform=identity,\n            axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n            iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n            ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and z.\n\nIf a Vector of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plots_for_dfn_variable-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.plots_for_dfn_variable","text":"plots_for_dfn_variable(run_info, variable_name; plot_prefix, has_rdim=true,\n                       has_zdim=true, is_1V=false, kwargs...)\n\nMake plots for the distribution function variable variable_name.\n\nWhich plots to make are determined by the settings in the section of the input whose heading is the variable name.\n\nrun_info is the information returned by get_run_info(). The dfns=true keyword argument must have been passed to get_run_info() so that output files containing the distribution functions are being read.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nhas_rdim, has_zdim and/or is_1V can be passed to allow the function to skip some plots that do not make sense for 0D/1D or 1V simulations (regardless of the settings).\n\nkwargs... are passed through to plot_vs_*(), plot_*_unnorm_vs_*(), animate_vs_*(), and animate_*_unnorm_vs_*().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.plots_for_variable-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.plots_for_variable","text":"plots_for_variable(run_info, variable_name; plot_prefix, has_rdim=true,\n                   has_zdim=true, is_1V=false,\n                   steady_state_residual_fig_axes=nothing, kwargs...)\n\nMake plots for the EM field or moment variable variable_name.\n\nWhich plots to make are determined by the settings in the section of the input whose heading is the variable name.\n\nrun_info is the information returned by get_run_info.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nhas_rdim, has_zdim and/or is_1V can be passed to allow the function to skip some plots that do not make sense for 0D/1D or 1V simulations (regardless of the settings).\n\nsteady_state_residual_fig_axes contains the figure, axes and legend places for steady state residual plots.\n\nkwargs... are passed through to plot_vs_*() and animate_vs_*().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.positive_or_nan-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.positive_or_nan","text":"positive_or_nan(x; epsilon=0)\n\nIf the argument x is zero or negative, replace it with NaN, otherwise return x.\n\nepsilon can be passed if the number should be forced to be above some value (typically we would assume epsilon is small and positive, but nothing about this function forces it to be).\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.println_to_stdout_and_file-Tuple{Any, Vararg{Any}}","page":"makie_post_processing","title":"makie_post_processing.println_to_stdout_and_file","text":"println_to_stdout_and_file(io, stuff...)\n\nPrint stuff both to stdout and to a file io.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.put_legend_above-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.put_legend_above","text":"putlegendabove(fig, ax; kwargs...)\n\nAdd a legend corresponding to the plot in ax to fig on the left of a new row at the top of the figure layout.\n\nAdditional kwargs are passed to the Legend() constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.put_legend_below-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.put_legend_below","text":"putlegendbelow(fig, ax; kwargs...)\n\nAdd a legend corresponding to the plot in ax to fig on the left of a new row at the bottom of the figure layout.\n\nAdditional kwargs are passed to the Legend() constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.put_legend_left-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.put_legend_left","text":"putlegendleft(fig, ax; kwargs...)\n\nAdd a legend corresponding to the plot in ax to fig on the bottom of a new column at the left of the figure layout.\n\nAdditional kwargs are passed to the Legend() constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.put_legend_right-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.put_legend_right","text":"putlegendright(fig, ax; kwargs...)\n\nAdd a legend corresponding to the plot in ax to fig on the bottom of a new column at the right of the figure layout.\n\nAdditional kwargs are passed to the Legend() constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.save_animation-NTuple{4, Any}","page":"makie_post_processing","title":"makie_post_processing.save_animation","text":"save_animation(fig, frame_index, nt, outfile)\n\nAnimate fig and save the result in outfile.\n\nframe_index is the Observable{mk_int} that updates the data used to make fig to a new time point. nt is the total number of time points to create.\n\nThe suffix of outfile determines the file type.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.select_slice","page":"makie_post_processing","title":"makie_post_processing.select_slice","text":"select_slice(variable::AbstractArray, dims::Symbol...; input=nothing, it=nothing,\n             is=1, ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n             ivzeta=nothing, ivr=nothing, ivz=nothing)\n\nReturns a slice of variable that includes only the dimensions given in dims..., e.g.\n\nselect_slice(variable, :t, :r)\n\nto get a two dimensional slice with t- and r-dimensions.\n\nAny other dimensions present in variable have a single point selected. By default this point is set by the options in input (which must be a NamedTuple) (or the final point for time or the size of the dimension divided by 3 if input is not given). These defaults can be overridden using the keyword arguments it, is, ir, iz, ivperp, ivpa, ivzeta, ivr, ivz. Ranges can also be passed to these keyword arguments for the 'kept dimensions' in dims to select a subset of those dimensions.\n\nThis function only recognises what the dimensions of variable are by the number of dimensions in the array. It assumes that either the variable has already been sliced to the correct dimensions (if ndims(variable) == length(dims) it just returns variable) or that variable has the full number of dimensions it could have (i.e. 'field' variables have 3 dimensions, 'moment' variables 4, 'ion distribution function' variables 6 and 'neutral distribution function' variables 7).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.select_time_slice-Tuple{AbstractVector, Any}","page":"makie_post_processing","title":"makie_post_processing.select_time_slice","text":"select_time_slice(time::AbstractVector, range)\n\nVariant of select_slice() to be used on 'time' arrays, which are always 1D.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.setup_makie_post_processing_input!","page":"makie_post_processing","title":"makie_post_processing.setup_makie_post_processing_input!","text":"setup_makie_post_processing_input!(input_file::Union{AbstractString,Nothing}=nothing;\n                                   run_info_moments=nothing, run_info_dfns=nothing,\n                                   allow_missing_input_file=false)\nsetup_makie_post_processing_input!(new_input_dict::AbstractDict{String,Any};\n                                   run_info_moments=nothing,\n                                   run_info_dfns=nothing)\n\nPass input_file to read the input from an input file other than post_processing_input.toml. You can also pass a Dict{String,Any} of options.\n\nSet up input, storing in the global input_dict and input_dict_dfns to be used in the various plotting and analysis functions.\n\nThe run_info that you are using (as returned by get_run_info) should be passed to run_info_moments (if it contains only the moments), or run_info_dfns (if it also contains the distributions functions), or both (if you have loaded both sets of output).  This allows default values to be set based on the grid sizes and number of time points read from the output files. Note that setup_makie_post_processing_input!() is called by default at the end of get_run_info(), for conveinence in interactive use.\n\nBy default an error is raised if input_file does not exist. To continue anyway, using default options, pass allow_missing_input_file=true.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.sound_wave_plots","page":"makie_post_processing","title":"makie_post_processing.sound_wave_plots","text":"sound_wave_plots(run_info::Vector{Any}; plot_prefix)\nsound_wave_plots(run_info; outfile=nothing, ax=nothing, phi=nothing)\n\nCalculate decay rate and frequency for the damped 'sound wave' in a 1D1V simulation in a periodic box. Plot the mode amplitude vs. time along with the fitted decay rate.\n\nThe information for the runs to analyse and plot is passed in run_info (as returned by get_run_info). If run_info is a Vector, comparison plots are made where line plots from the different runs are overlayed on the same axis.\n\nSettings are read from the [sound_wave] section of the input.\n\nWhen run_info is a Vector, plot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf. When run_info is not a Vector, outfile can be passed, to save the plot to outfile.\n\nWhen run_info is not a Vector, ax can be passed to add the plot to an existing Axis.\n\nWhen run_info is not a Vector, the array containing data for phi can be passed to phi - by default this data is loaded from the output file.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.timestep_diagnostics-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.timestep_diagnostics","text":"timestep_diagnostics(run_info, run_info_dfns; plot_prefix=nothing, it=nothing)\n\nPlot a time-trace of some adaptive-timestep diagnostics: steps per output, timestep failures per output, how many times per output each variable caused a timestep failure, and which factor limited the length of successful timesteps (CFL, accuracy, max_timestep).\n\nIf plot_prefix is passed, it gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix_timestep_diagnostics.pdf.\n\nit can be used to select a subset of the time points by passing a range.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.timing_data-Tuple{Vector{Any}}","page":"makie_post_processing","title":"makie_post_processing.timing_data","text":"timing_data(run_info; plot_prefix=nothing, threshold=nothing,\n            include_patterns=nothing, exclude_patterns=nothing, ranks=nothing,\n            figsize=nothing, include_legend=true)\n\nPlot timings from different parts of the moment_kinetics code. Only timings from function calls during the time evolution loop are included, not from the setup, because we plot versus time.\n\nTo reduce clutter, timings whose total time (at the final time point) is less than threshold times the overall run time will be excluded. By default, threshold is 1.0e-3.\n\nWhen there is more than one MPI rank present, the timings for each rank will be plotted separately. The lines will be labelled with the MPI rank, with the position of the labels moving along the lines one point at a time, to try to avoid overlapping many labels. If the curves all overlap, this will look like one curve labelled by many MPI ranks.\n\nThere are many timers, so it can be useful to filter them to see only the most relevant ones. By default all timers will be plotted. If include_patterns is passed, and exclude_patterns is not, then only the total time and any timers that match include_patterns (matches checked using occursin()) will be included in the plots. If exclude_patterns is passed, then any timers that match (matches checked using occursin()) exclude_patterns will be omitted, unless they match include_patterns in which case they will still be included. If ranks is passed, then only the MPI ranks with indices found in ranks will be included.\n\nfigsize can be passed to customize the size of the figures that plots are made on. This can be useful because the legends may become very large when many timers are plotted, in which case a larger figure might be needed.\n\nthreshold, exclude_patterns, include_patterns, ranks, and figsize can also be set in this_input_dict. When this function is called as part of makie_post_process, input_dict is passed as this_input_dict so that the settings are read from the post processing input file (by default post_processing_input.toml). The function arguments take precedence, if they are given.\n\nIf you load GLMakie by doing using GLMakie before running this function, but after calling using makie_post_processing (because CairoMakie is loaded when the module is loaded and would take over if you load GLMakie before makie_post_processing), the figures will be displayed in interactive windows. When you hover over a line some useful information will be displayed.\n\nPass include_legend=false to remove legends from the figures. This is mostly useful for interactive figures where hovering over the lines can show what they are, so that the legend is not needed.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.shared_utils.calculate_and_write_frequencies-NTuple{9, Any}","page":"makie_post_processing","title":"makie_post_processing.shared_utils.calculate_and_write_frequencies","text":"\n\n\n\n","category":"method"},{"location":"zz_z_advection/#z_advection","page":"z_advection","title":"z_advection","text":"","category":"section"},{"location":"zz_z_advection/#moment_kinetics.z_advection","page":"z_advection","title":"moment_kinetics.z_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_z_advection/#moment_kinetics.z_advection.update_speed_z!-NTuple{13, Any}","page":"z_advection","title":"moment_kinetics.z_advection.update_speed_z!","text":"calculate the advection speed in the z-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_z_advection/#moment_kinetics.z_advection.z_advection!-NTuple{15, Any}","page":"z_advection","title":"moment_kinetics.z_advection.z_advection!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"zz_MKJacobianUtils/#MKJacobianUtils","page":"MKJacobianUtils","title":"MKJacobianUtils","text":"","category":"section"},{"location":"zz_MKJacobianUtils/#Main.MKJacobianUtils.get_electron_Jacobian_matrix-Tuple{Any}","page":"MKJacobianUtils","title":"Main.MKJacobianUtils.get_electron_Jacobian_matrix","text":"get_electron_Jacobian_matrix(run_directory; restart_time_index=1,\n                             restart_index=nothing,\n                             include_z_advection=true,\n                             include_vpa_advection=true,\n                             include_electron_pdf_term=true,\n                             include_dissipation=true,\n                             include_krook=true,\n                             include_external_source=true,\n                             include_constraint_forcing=true,\n                             include_energy_equation=true,\n                             include_ion_dt_forcing=true)\n\nCalculate and return a Jacobian matrix for the kinetic electron solve.\n\nTo use this function, first include the script containing it\n\ninclude(\"util/MKJacobianUtils.jl\")\n\nthen you can call the function.\n\nTo avoid extreme behaviour due to an arbitrary initial condition, this script expects to 'restart' from an existing simulation. By default it returns the Jacobian matrix that would be used at the start of the first ion timestep (after the initialisation stage where electrons are relaxed towards steady state treating the ions as a fixed background).\n\nrun_directory is the path to the directory where the run to 'restart' from is stored.\n\nrestart_time_index can be passed an integer value if you want the Jacobian for an output step other than the initial one. restart_time_index=-1 would give the final time point of the simulation in run_directory.\n\nIf there were multiple restarts of the simulation in run_directory, restart_index can be used to select which restart to read from. Reads from the latest one by default. Numerical values can only be used for restarts before the latest one - e.g. if the run was not restarted, restart_index=1 is not valid, only the default restart_index=nothing can be used.\n\nThe include_* arguments can be used to select which particular terms to include in the Jacobian. By default all terms are included.\n\n\n\n\n\n","category":"method"},{"location":"zz_species_input/#species_input","page":"species_input","title":"species_input","text":"","category":"section"},{"location":"zz_species_input/#moment_kinetics.species_input","page":"species_input","title":"moment_kinetics.species_input","text":"Module for handling i/o for species specific input parameters which are hosted in the composition and species structs for passing to functions\n\n\n\n\n\n","category":"module"},{"location":"zz_gyroaverages/#gyroaverages","page":"gyroaverages","title":"gyroaverages","text":"","category":"section"},{"location":"zz_gyroaverages/#moment_kinetics.gyroaverages","page":"gyroaverages","title":"moment_kinetics.gyroaverages","text":"module for supporting gyroaverages at  fixed guiding centre R and fixed position r\n\n\n\n\n\n","category":"module"},{"location":"zz_gyroaverages/#moment_kinetics.gyroaverages.elementlist!-NTuple{4, Any}","page":"gyroaverages","title":"moment_kinetics.gyroaverages.elementlist!","text":"for a given list of coordinate values, determine in which elements they are found -1 indicates that the required element would be outside of the existing grid\n\n– assume here that the coordinates are fully local in memory\n\n\n\n\n\n","category":"method"},{"location":"zz_gyroaverages/#moment_kinetics.gyroaverages.gyroaverage_field!-NTuple{7, Any}","page":"gyroaverages","title":"moment_kinetics.gyroaverages.gyroaverage_field!","text":"function for gyroaveraging a field of shape (z,r) and filling the result into an array of shape (vperp,z,r,s)\n\n\n\n\n\n","category":"method"},{"location":"zz_gyroaverages/#moment_kinetics.gyroaverages.gyroaverage_pdf!-NTuple{8, Any}","page":"gyroaverages","title":"moment_kinetics.gyroaverages.gyroaverage_pdf!","text":"function for gyroaveraging a charge particle pdf of shape (vpa,vperp,z,r,s) and filling the result into an of the same shape\n\n\n\n\n\n","category":"method"},{"location":"zz_derivatives/#derivatives","page":"derivatives","title":"derivatives","text":"","category":"section"},{"location":"zz_derivatives/#moment_kinetics.derivatives","page":"derivatives","title":"moment_kinetics.derivatives","text":"This module contains all the necessary derivatives needed to carry out distributed memory differential operations on the arrays in moment kinetics. We provide separate derivative functions for each (i) distributed dimension and (ii) array shape. We do not need to provide derivatives for non-distributed dimensions as these can by handled by the derivative! function from calculus.jl\n\n\n\n\n\n","category":"module"},{"location":"zz_calculus/#calculus","page":"calculus","title":"calculus","text":"","category":"section"},{"location":"zz_calculus/#moment_kinetics.calculus","page":"calculus","title":"moment_kinetics.calculus","text":"\n\n\n\n","category":"module"},{"location":"zz_calculus/#moment_kinetics.calculus.derivative!-NTuple{4, Any}","page":"calculus","title":"moment_kinetics.calculus.derivative!","text":"derivative!(df, f, coord, spectral)\n\nNon-upwinding derivative.\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.derivative!-Tuple{Any, Any, Any, Any, moment_kinetics.moment_kinetics_structs.discretization_info}","page":"calculus","title":"moment_kinetics.calculus.derivative!","text":"derivative!(df, f, coord, adv_fac, spectral)\n\nUpwinding derivative.\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.derivative_elements_to_full_grid!-Tuple{Any, Any, Any, AbstractVector{Float64}}","page":"calculus","title":"moment_kinetics.calculus.derivative_elements_to_full_grid!","text":"\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.derivative_elements_to_full_grid!-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.derivative_elements_to_full_grid!","text":"\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.elements_to_full_grid_interior_pts!-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.elements_to_full_grid_interior_pts!","text":"maps the derivative at points away from element boundaries from the grid/element representation to the full grid representation\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.elementwise_derivative!","page":"calculus","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, adv_fac, spectral)\nelementwise_derivative!(coord, f, spectral)\n\nGeneric function for element-by-element derivatives\n\nFirst signature, with adv_fac, calculates an upwind derivative, the second signature calculates a derivative without upwinding information.\n\nResult is stored in coord.scratch_2d.\n\n\n\n\n\n","category":"function"},{"location":"zz_calculus/#moment_kinetics.calculus.elementwise_indefinite_integration!","page":"calculus","title":"moment_kinetics.calculus.elementwise_indefinite_integration!","text":"\n\n\n\n","category":"function"},{"location":"zz_calculus/#moment_kinetics.calculus.elementwise_indefinite_integration!-Tuple{Any, Any, moment_kinetics.moment_kinetics_structs.discretization_info}","page":"calculus","title":"moment_kinetics.calculus.elementwise_indefinite_integration!","text":"A function that takes the indefinite integral in each element of coord.grid, leaving the result (element-wise) in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.indefinite_integral!-Tuple{Any, Any, Any, moment_kinetics.moment_kinetics_structs.discretization_info}","page":"calculus","title":"moment_kinetics.calculus.indefinite_integral!","text":"indefinite_integral!(pf, f, coord, spectral)\n\nIndefinite line integral. \n\nThis function is designed to work on local-in-memory data only, with distributed-memory MPI not implemented here. A function which integrates along a line which is distributed in memory exists in moment_kinetics.em_fields as  calculate_phi_from_Epar!(). The distributed-memory functionality could be ported to a generic function, similiar to how the derivative! functions are generalised in moment_kinetics.derivatives.\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.indefinite_integral_elements_to_full_grid!-Tuple{Any, Any}","page":"calculus","title":"moment_kinetics.calculus.indefinite_integral_elements_to_full_grid!","text":"\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-NTuple{10, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the 3D integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-NTuple{4, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand multiplied by v^n, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-NTuple{7, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the 2D integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand multiplied by v, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-Tuple{Any, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-Tuple{Function, Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Compute the 2D integral ∫d^2vperp.dvpa prefactor(vperp,vpa)*integrand\n\nIn this variant vperp and vpa should be coordinate objects.\n\nNote that vperp_wgts contains the extra factor of vperp required for the Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-Tuple{Function, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Compute the 1D integral ∫dv prefactor(v)*integrand\n\nIn this variant v should be a coordinate object.\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-Tuple{Function, Vararg{Any, 4}}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Compute the 3D integral ∫dvzeta.dvr.dvz prefactor(vzeta,vr,vz)*integrand\n\nIn this variant vzeta, vr, and vz should be coordinate objects.\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.mass_matrix_solve!","page":"calculus","title":"moment_kinetics.calculus.mass_matrix_solve!","text":"mass_matrix_solve!(f, b, spectral::weak_discretization_info)\n\nSolve\n\nMf = b\n\nfor a, where M is the mass matrix of a weak-form finite element method and b is an input.\n\n\n\n\n\n","category":"function"},{"location":"zz_calculus/#moment_kinetics.calculus.reconcile_element_boundaries_upwind!-Tuple{Any, Any, Any, AbstractVector{Float64}}","page":"calculus","title":"moment_kinetics.calculus.reconcile_element_boundaries_upwind!","text":"if at the boundary point within the element, must carefully choose which value of df to use; this is because df is multi-valued at the overlapping point at the boundary between neighboring elements. here we choose to use the value of df from the upwind element.\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_vpa_advection/#electron_vpa_advection","page":"electron_vpa_advection","title":"electron_vpa_advection","text":"","category":"section"},{"location":"zz_electron_vpa_advection/#moment_kinetics.electron_vpa_advection","page":"electron_vpa_advection","title":"moment_kinetics.electron_vpa_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_electron_vpa_advection/#moment_kinetics.electron_vpa_advection.electron_vpa_advection!-NTuple{14, Any}","page":"electron_vpa_advection","title":"moment_kinetics.electron_vpa_advection.electron_vpa_advection!","text":"calculate the wpa-advection term for the electron kinetic equation  = (vthe / 2 pe * dpe/dz + wpa / 3 pe * dqpare/dz - wpa^2 * dvthe/dz) * df/dwpa\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_vpa_advection/#moment_kinetics.electron_vpa_advection.update_electron_speed_vpa!-NTuple{9, Any}","page":"electron_vpa_advection","title":"moment_kinetics.electron_vpa_advection.update_electron_speed_vpa!","text":"calculate the electron advection speed in the wpa-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#numerical_dissipation","page":"numerical_dissipation","title":"numerical_dissipation","text":"","category":"section"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation","text":"\n\n\n\n","category":"module"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.force_minimum_pdf_value!-Tuple{Any, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.force_minimum_pdf_value!","text":"force_minimum_pdf_value!(f, minval)\n\nSet a minimum value for the pdf-sized array f. Any points less than the minimum are set to the minimum. By default, no minimum is applied. The minimum value can be set by\n\n[ion_numerical_dissipation]\nforce_minimum_pdf_value = 0.0\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.force_minimum_pdf_value_neutral!-Tuple{Any, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.force_minimum_pdf_value_neutral!","text":"force_minimum_pdf_value_neutral!(f, minval)\n\nSet a minimum value for the neutral-pdf-sized array f. Any points less than the minimum are set to the minimum. By default, no minimum is applied. The minimum value can be set by\n\n[neutral_numerical_dissipation]\nforce_minimum_pdf_value = 0.0\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.r_dissipation!-NTuple{7, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.r_dissipation!","text":"Add diffusion in the r direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[ion_numerical_dissipation]\nr_dissipation_coefficient = 0.1\n\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.r_dissipation_neutral!-NTuple{7, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.r_dissipation_neutral!","text":"Add diffusion in the r direction to suppress oscillations for neutrals\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[neutral_numerical_dissipation]\nr_dissipation_coefficient = 0.1\n\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.setup_numerical_dissipation-Tuple{Any, Bool}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.setup_numerical_dissipation","text":"Define the dissipation parameters for each species, which means there need to be three sections in each input file that specify the parameters required of each species, as follows:\n\n[ion_numerical_dissipation]\nvpa_dissipation_coefficient\n...\n\n[electron_numerical_dissipation]\nvpa_dissipation_coefficient\n...\n\n[neutral_numerical_dissipation]\nvz_dissipation_coefficient\n...\n\nThere will still be the -1.0 default parameters.\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_boundary_buffer_decay!-NTuple{6, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_boundary_buffer_decay!","text":"Suppress the distribution function by damping towards a Maxwellian in the last element before the vpa boundaries, to avoid numerical instabilities there.\n\nDisabled by default.\n\nThe damping rate is set in the input TOML file by the parameter\n\n[ion_numerical_dissipation]\nvpa_boundary_buffer_damping_rate = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_boundary_buffer_diffusion!-NTuple{6, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_boundary_buffer_diffusion!","text":"Suppress the distribution function by applying diffusion in the last element before the vpa boundaries, to avoid numerical instabilities there.\n\nDisabled by default.\n\nThe maximum diffusion rate in the buffer is set in the input TOML file by the parameter\n\n[ion_numerical_dissipation]\nvpa_boundary_buffer_diffusion_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_boundary_force_decreasing!-Tuple{Any, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_boundary_force_decreasing!","text":"Try to suppress oscillations near the boundary by ensuring that every point in the final element is ≤ the innermost value. The distribution function should be decreasing near the boundaries, so this should be an OK thing to force.\n\nNote: not currently used.\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_dissipation!-NTuple{6, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_dissipation!","text":"Add diffusion in the vpa direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[ion_numerical_dissipation]\nvpa_dissipation_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vperp_dissipation!-NTuple{6, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vperp_dissipation!","text":"Add diffusion in the vperp direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[ion_numerical_dissipation]\nvperp_dissipation_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vz_dissipation_neutral!-NTuple{6, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vz_dissipation_neutral!","text":"Add diffusion in the vz direction to suppress oscillations for neutrals\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[neutral_numerical_dissipation]\nvz_dissipation_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.z_dissipation!-NTuple{8, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.z_dissipation!","text":"Add diffusion in the z direction to suppress oscillations, with derivatives of  degree n.\n\nDisabled by default.\n\nThe diffusion coefficient and degree are set in the input TOML file by the parameter\n\n[ion_numerical_dissipation]\nz_dissipation_coefficient = 0.1\nz_dissipation_degree = 2\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.z_dissipation_neutral!-NTuple{7, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.z_dissipation_neutral!","text":"Add diffusion in the z direction to suppress oscillations for neutrals\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[neutral_numerical_dissipation]\nz_dissipation_coefficient = 0.1\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"input_options/#Input-Options","page":"Input Options","title":"Input Options","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"This page describes the input options that can be specified in .toml input files.  The input variable name is given first, followed by its default value and a brief description.","category":"page"},{"location":"input_options/#File-I/O","page":"Input Options","title":"File I/O","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"Option name Default value Description\nrun_name name of the input .toml file with the .toml suffix removed prefix for all output files associated with this run\nbase_directory \"runs\" directory where the simulation data will be stored","category":"page"},{"location":"input_options/#Model-Options","page":"Input Options","title":"Model Options","text":"","category":"section"},{"location":"input_options/#Timestepping-Options","page":"Input Options","title":"Timestepping Options","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"See timestepping-input-parameters.","category":"page"},{"location":"input_options/#Special-cases","page":"Input Options","title":"Special cases","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"Some options apply only for certain types of run, etc. These special cases are described in the following subsections.","category":"page"},{"location":"fokker_planck_notes/#Fokker-Planck-collision-operator","page":"Fokker Planck collision operator","title":"Fokker Planck collision operator","text":"","category":"section"},{"location":"fokker_planck_notes/","page":"Fokker Planck collision operator","title":"Fokker Planck collision operator","text":"We implement the nonlinear Fokker-Planck collision operator for self collisions  using the weak-form finite-element method. This is documented in the  ExCALIBUR/NEPTUNE report 2070839-TN-07. A publication based on this report is in progress. Full online documentation will follow.","category":"page"},{"location":"fokker_planck_notes/#Input-parameters","page":"Fokker Planck collision operator","title":"Input parameters","text":"","category":"section"},{"location":"fokker_planck_notes/","page":"Fokker Planck collision operator","title":"Fokker Planck collision operator","text":"A series of 0D2V Fokker-Planck input files can be found in","category":"page"},{"location":"fokker_planck_notes/","page":"Fokker Planck collision operator","title":"Fokker Planck collision operator","text":"examples/fokker-planck/","category":"page"},{"location":"fokker_planck_notes/","page":"Fokker Planck collision operator","title":"Fokker Planck collision operator","text":"and examples of 1D2V pre-sheath simulations with the Fokker-Planck collision operator can be found in","category":"page"},{"location":"fokker_planck_notes/","page":"Fokker Planck collision operator","title":"Fokker Planck collision operator","text":"examples/fokker-planck-1D2V/","category":"page"},{"location":"fokker_planck_notes/","page":"Fokker Planck collision operator","title":"Fokker Planck collision operator","text":"noting that the timestepping or resolution parameters may require modification to find a converged simulation.","category":"page"},{"location":"fokker_planck_notes/","page":"Fokker Planck collision operator","title":"Fokker Planck collision operator","text":"The basic input namelist is structured as follows","category":"page"},{"location":"fokker_planck_notes/","page":"Fokker Planck collision operator","title":"Fokker Planck collision operator","text":"[fokker_planck_collisions]\nuse_fokker_planck = true\n# nuii sets the normalised input C[F,F] Fokker-Planck collision frequency\n# for frequency_option = \"manual\"\nnuii = 1.0\nfrequency_option = \"manual\"","category":"page"},{"location":"fokker_planck_notes/","page":"Fokker Planck collision operator","title":"Fokker Planck collision operator","text":"Set use_fokker_planck=false to turn off Fokker-Planck collisions  without commenting out the namelist. The default option for frequency_option = \"reference_parameters\", where nuii is set by the reference parameter inputs. Further specialised input parameters can be seen in the source at  setup_fkpl_collisions_input() in moment_kinetics/src/fokker_planck.jl.","category":"page"},{"location":"zz_gauss_legendre/#gauss_legendre","page":"gauss_legendre","title":"gauss_legendre","text":"","category":"section"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre","text":"module for Gauss-Legendre-Lobatto and Gauss-Legendre-Radau spectral element grids\n\n\n\n\n\n","category":"module"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.gausslegendre_base_info","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.gausslegendre_base_info","text":"A struct for passing around elemental matrices on Gauss-Legendre points in 1D\n\n\n\n\n\n","category":"type"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.gausslegendre_info","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.gausslegendre_info","text":"A struct for Gauss-Legendre arrays needed for global operations in 1D, contains the struct of elemental matrices for Lobatto and Radau points, as well as some assembled 1D global matrices.\n\n\n\n\n\n","category":"type"},{"location":"zz_gauss_legendre/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_info}","page":"gauss_legendre","title":"moment_kinetics.calculus.elementwise_derivative!","text":"A function that takes the first derivative in each element of coord.grid, leaving the result (element-wise) in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.calculus.mass_matrix_solve!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_info}","page":"gauss_legendre","title":"moment_kinetics.calculus.mass_matrix_solve!","text":"Function to carry out a 1D (global) mass matrix solve.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.GaussLegendre_derivative_vector!-NTuple{5, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.GaussLegendre_derivative_vector!","text":"Gauss-Legendre derivative at arbitrary x values, for boundary condition on Radau points.     D0 – the vector     xj – the x location where the derivative is evaluated      ngrid – number of points in x     x – the grid from -1, 1 Note that D0 is not scaled to the physical grid with a scaling factor.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.GaussLegendre_weak_product_matrix!-Tuple{Array{Float64, 3}, Vararg{Any, 4}}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.GaussLegendre_weak_product_matrix!","text":"Assign abitrary weak (nonlinear) inner product matrix Q on a 1D line with Jacobian equal to 1. matrix Q acts on two vectors x1 and x2 such that the quadratic form  y = x1 * Q * x2 is also a vector. See documentation of corresponding function for linear inner product matrices.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.GaussLegendre_weak_product_matrix!-Tuple{Matrix{Float64}, Vararg{Any, 4}}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.GaussLegendre_weak_product_matrix!","text":"Assign abitrary weak inner product matrix Q on a 1D line with Jacobian equal to 1 matrix Q acts on a single vector x such that y = Q * x is also a vector.\n\nWe use a projection onto Gauss-Legendre polynomials to carry out the calculation in two steps (see, e.g, S. A. Teukolsky, Short note on the mass matrix for Gauss–Lobatto grid points, J. Comput. Phys. 283 (2015) 408–413. https://doi.org/10.1016/j.jcp.2014.12.012). First, we write the desired matrix elements in terms of Legendre polynomials\n\n   l_i(x) = sum_j fracP_j(x)P_j(x_i)w_igamma_j\n\nwith w_i the weights from an integration on the Gauss-Legendre-Lobatto (or Radau) points x_i, i.e., \n\n int^1_-1 f(x) d x = sum_i f(x_i)w_i\n\nand gamma_j = sum_k w_k P_j(x_k)P_j(x_k) the numerical inner-product. Then, a matrix element can be expressed in integrals over Legendre polynomials rather than Lagrange polynomials, i.e.,\n\n   M_ij = int^1_-1 l_i(x)l_j(x) d x = sum_mn fracw_m P_m(x_i) w_n P_n(x_j)gamma_mgamma_n int^1_-1 P_m(x)P_n(x) d x \n\nDefining \n\n  A_mn = int^1_-1 P_m(x)P_n(x) d x \n\nwe can thus write\n\n   M_ij = sum_mn fracw_m P_m(x_i) w_n P_n(x_j)gamma_mgamma_n A_mn \n\nWe can use a quadrature which yields exact results (to machine precision) to evaluate A_mn using fast library functions for the Legendre polynomials, and then carry out the sum sum_mn to obtain exact results (to machine-precision). Here we use a Gauss-Legendre integration quadrature with exact results up to  polynomials with order k_max = 4N +1, with N=ngrid and the highest order polynomial product that we integrate is P_N-1(x)P_N-1(x)x^2, which has order k=2N  k_max.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.Legendre_h_n-Tuple{Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.Legendre_h_n","text":"Result of the inner product of Legendre polynomials of order k.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.gausslobattolegendre_differentiation_matrix!-Tuple{Matrix{Float64}, Vector{Float64}, Int64}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.gausslobattolegendre_differentiation_matrix!","text":"Formula for Gauss-Legendre-Lobatto differentiation matrix taken from p196 of Chpt The Spectral Elemtent Method' ofComputational Seismology'. Heiner Igel First Edition. Published in 2017 by Oxford University Press. Or https://doc.nektar.info/tutorials/latest/fundamentals/differentiation/fundamentals-differentiationch2.html\n\nD -- differentiation matrix \nx -- Gauss-Legendre-Lobatto points in [-1,1]\nngrid -- number of points per element (incl. boundary points)\n\nNote that D has does not include a scaling factor\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.gaussradaulegendre_differentiation_matrix!-Tuple{Matrix{Float64}, Vector{Float64}, Int64}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.gaussradaulegendre_differentiation_matrix!","text":"Formula for Gauss-Legendre-Radau differentiation matrix taken from https://doc.nektar.info/tutorials/latest/fundamentals/differentiation/fundamentals-differentiationch2.html\n\nD -- differentiation matrix \nx -- Gauss-Legendre-Radau points in [-1,1)\nngrid -- number of points per element (incl. boundary points)\n\nNote that D has does not include a scaling factor\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_KJ_local!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_KJ_local!","text":"If called for coord.name = vperp elemental matrix KJ on the i^th element is\n\n (KJ)_jk = -int^v_perp^U_v_perp^L fracpartialvarphi_j(v_perp)partial v_perpfracpartialvarphi_k(v_perp)partial v_perp v_perp^2 d v_perp\n = -int^1_-1 (c_i + x s_i)^2l_j^prime(x)l_k^prime(x) d x s_i\n\nwith c_i and s_i the appropriate shift and scale factors, respectively.  Otherwise, if called for any other coordinate elemental matrix KJ is the same as LL (see get_LL_local()!).\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_KK_local!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_KK_local!","text":"If called for coord.name = vperp elemental matrix KK on the i^th element is\n\n K_jk = -int^v_perp^U_v_perp^L left(v_perp fracpartialvarphi_j(v_perp)partial v_perp + varphi_j(v_perp) right)\n fracpartialvarphi_k(v_perp)partial v_perp d v_perp\n = -int^1_-1 ((c_i + x s_i)l_j^prime(x) + l_j(x))l_k^prime(x) d x s_i\n\nwith c_i and s_i the appropriate shift and scale factors, respectively.  Otherwise, if called for any other coordinate elemental matrix KK is the same as LL (see get_LL_local!()). IfexplicitBCterms = true`, boundary terms arising from integration by parts are included at the extreme boundary points.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_LL_local!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_LL_local!","text":"If called for coord.name = vperp elemental matrix LL on the i^th element is\n\n L_jk = -int^v_perp^U_v_perp^L fracpartialvarphi_j(v_perp)partial v_perpfracpartialvarphi_k(v_perp)partial v_perp v_perp d v_perp\n = -int^1_-1 (c_i + x s_i)l_j^prime(x)l_k^prime(x) d x s_i\n\nwith c_i and s_i the appropriate shift and scale factors, respectively.  Otherwise, if called for any other coordinate elemental matrix LL is \n\n L_jk = -int^v_^U_v_^L  fracpartialvarphi_j(v_)partial v_fracpartialvarphi_k(v_)partial v_ d v_ =\n -int^1_-1 l_j^prime(x)l_k^prime(x) d x s_i\n\nIf explicit_BC_terms = true, boundary terms arising from integration by parts are included at the extreme boundary points.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_MM_local!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_MM_local!","text":"If called for coord.name = vperp elemental matrix MM on the i^th element is\n\n M_jk = int^v_perp^U_v_perp^L  varphi_j(v_perp)varphi_k(v_perp) v_perp d v_perp = int^1_-1 (c_i + x s_i)l_j(x)l_k(x) s_i d x \n\nwith c_i and s_i the appropriate shift and scale factors, respectively.  Otherwise, if called for any other coordinate elemental matrix MM is \n\n M_jk = int^v_^U_v_^L  varphi_j(v_)varphi_k(v_) d v_ = int^1_-1 l_j(x)l_k(x) s_i d x\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_MN_local!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_MN_local!","text":"If called for coord.name = vperp elemental matrix MN on the i^th element is\n\n (MN)_jk = int^v_perp^U_v_perp^L  varphi_j(v_perp)varphi_k(v_perp) d v_perp = int^1_-1 l_j(x)l_k(x) s_i d x \n\nwith c_i and s_i the appropriate shift and scale factors, respectively.  Otherwise, if called for any other coordinate elemental matrix MN is the same as MM (see get_MM_local!()).\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_MR_local!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_MR_local!","text":"If called for coord.name = vperp elemental matrix MR on the i^th element is\n\n (MR)_jk = int^v_perp^U_v_perp^L  varphi_j(v_perp)varphi_k(v_perp) v_perp^2 d v_perp = int^1_-1 (c_i + s_i x)^2 l_j(x)l_k(x) s_i d x \n\nwith c_i and s_i the appropriate shift and scale factors, respectively.  Otherwise, if called for any other coordinate elemental matrix MR is the same as MM (see get_MM_local!()).\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_PP_local!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_PP_local!","text":"If called for coord.name = vperp elemental matrix PP on the i^th element is\n\n P_jk = int^v_perp^U_v_perp^L  varphi_j(v_perp)fracpartialvarphi_k(v_perp)partial v_perp v_perp d v_perp\n = int^1_-1 (c_i + x s_i)l_j(x)l_k^prime(x) d x \n\nwith c_i and s_i the appropriate shift and scale factors, respectively.  Otherwise, if called for any other coordinate elemental matrix PP is \n\n P_jk = int^v_^U_v_^L  varphi_j(v_)fracpartialvarphi_k(v_)partial v_ d v_ = int^1_-1 l_j(x)l_k^prime(x) d x\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_PU_local!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_PU_local!","text":"If called for coord.name = vperp elemental matrix PP on the i^th element is\n\n (PU)_jk = int^v_perp^U_v_perp^L  varphi_j(v_perp)fracpartialvarphi_k(v_perp)partial v_perp v_perp^2 d v_perp\n = int^1_-1 (c_i + x s_i)^2l_j(x)l_k^prime(x) d x \n\nwith c_i and s_i the appropriate shift and scale factors, respectively.  Otherwise, if called for any other coordinate elemental matrix PU is the same as PP see get_PP_local!().\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_QQ_local!-Tuple{AbstractArray{Float64, 3}, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_QQ_local!","text":"Construction function for nonlinear diffusion matrices, only used in the assembly of the collision operator\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_QQ_local!-Tuple{AbstractMatrix{Float64}, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_QQ_local!","text":"Construction function to provide the appropriate elemental  matrix Q to the global matrix assembly functions.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_YY0_local!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_YY0_local!","text":"If called for coord.name = vperp elemental matrix YY0 on the i^th element is\n\n (YY0)_jkm = int^v_perp^U_v_perp^L  varphi_j(v_perp)varphi_k(v_perp)varphi_m(v_perp) v_perp d v_perp\n = int^1_-1 (c_i + x s_i)l_j(x)l_k(x)l_m(x) s_i d x \n\nwith c_i and s_i the appropriate shift and scale factors, respectively.  Otherwise, if called for any other coordinate elemental matrix YY0 is \n\n (YY0)_jkm = int^v_^U_v_^L  varphi_j(v_)varphi_k(v_)varphi_m(v_) d v_\n = int^1_-1 l_j(x)l_k(x)l_m(x) s_i d x\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_YY1_local!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_YY1_local!","text":"If called for coord.name = vperp elemental matrix YY1 on the i^th element is\n\n (YY1)_jkm = int^v_perp^U_v_perp^L  varphi_j(v_perp)varphi_k(v_perp)fracpartialvarphi_m(v_perp)partial v_perp v_perp d v_perp\n = int^1_-1 (c_i + x s_i)l_j(x)l_k(x)l_m^prime(x) d x \n\nwith c_i and s_i the appropriate shift and scale factors, respectively.  Otherwise, if called for any other coordinate elemental matrix YY1 is \n\n (YY1)_jkm = int^v_^U_v_^L  varphi_j(v_)varphi_k(v_)fracpartialvarphi_m(v_)partial v_ d v_\n = int^1_-1 l_j(x)l_k(x)l_m^prime(x) d x\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_YY2_local!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_YY2_local!","text":"If called for coord.name = vperp elemental matrix YY2 on the i^th element is\n\n (YY2)_jkm = int^v_perp^U_v_perp^L  varphi_j(v_perp)fracpartialvarphi_k(v_)partial v_fracpartialvarphi_m(v_perp)partial v_perp v_perp d v_perp\n = int^1_-1 (c_i + x s_i)l_j(x)l_k^prime(x)l_m^prime(x) d xs_i \n\nwith c_i and s_i the appropriate shift and scale factors, respectively.  Otherwise, if called for any other coordinate elemental matrix YY2 is \n\n (YY2)_jkm = int^v_^U_v_^L  varphi_j(v_)fracpartialvarphi_k(v_)partial v_fracpartialvarphi_m(v_)partial v_ d v_\n = int^1_-1 l_j(x)l_k^prime(x)l_m^prime(x) d x s_i\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.get_YY3_local!-Tuple{Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.get_YY3_local!","text":"If called for coord.name = vperp elemental matrix YY3 on the i^th element is\n\n (YY3)_jkm = int^v_perp^U_v_perp^L  varphi_j(v_perp)fracpartialvarphi_k(v_)partial v_varphi_m(v_perp) v_perp d v_perp\n = int^1_-1 (c_i + x s_i)l_j(x)l_k^prime(x)l_m(x) d x \n\nwith c_i and s_i the appropriate shift and scale factors, respectively.  Otherwise, if called for any other coordinate elemental matrix YY3 is \n\n (YY3)_jkm = int^v_^U_v_^L  varphi_j(v_)fracpartialvarphi_k(v_)partial v_varphi_m(v_) d v_\n = int^1_-1 l_j(x)l_k^prime(x)l_m(x) d x\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.identity_matrix!-Tuple{Any, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.identity_matrix!","text":"Function that fills and n x n array with the values of the identity matrix I.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.ielement_global_func-Tuple{Any, Any, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.ielement_global_func","text":"Function for finding the elemental index in the global distributed-memory grid. Distributed-memory for global finite-element operators is not yet supported.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.integration_matrix!-Tuple{Matrix{Float64}, Vector{Float64}, Int64}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.integration_matrix!","text":"Function to calculate the elemental anti-differentiation (integration) matrix. This function forms the primitive\n\nF(x) = int^x_x_rm min f(x^prime) d x^prime\n\nof the function \n\nf(x) = sum_j f_j l_j(x)\n\nwhere l_j(x) is the j^rm th Lagrange polynomial on the element and f_j = f(x_j), with x_j j^rm th collocation point on the element. We find F(x) at the collocation points on the element, giving a series of integrals to evaluate:\n\nF(x_i) = int^x_i_-1 f(x^prime) d x^prime = sum_j f_j int^x_i_-1 l_j(x^prime) d x^prime\n\nwhere we have used that x_rm min = -1 on the elemental grid. Changing to a normalised coordinate y suitable for Gaussian quadrature \n\nx^prime = fracx_i + 12 y + fracx_i - 12\n\nwe can write the operation in matrix form:\n\nF(x_i) = sum_jA_ijf_j\n\nwith the matrix A_ij defined by\n\nA_ij = left(fracx_i + 12right) int^1_-1 l_j left( frac(x_i + 1)y + x_i - 12 right) dy\n\nor in discretised form\n\nA_ij = left(fracx_i + 12right) sum_k l_j left( frac(x_i + 1)y_k + x_i - 12 right) w_k\n\nwith y_k and w_k Gauss-quadrature points and weights, respectively.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.scale_factor_func-Tuple{Any, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.scale_factor_func","text":"Function for computing the scale factor on a grid with uniformed spaced element boundaries. Unused.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.scaled_gauss_legendre_lobatto_grid-NTuple{7, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.scaled_gauss_legendre_lobatto_grid","text":"Function for setting up the full Gauss-Legendre-Lobatto grid and collocation point weights.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.scaled_gauss_legendre_radau_grid-NTuple{8, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.scaled_gauss_legendre_radau_grid","text":"Function for setting up the full Gauss-Legendre-Radau grid and collocation point weights.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.setup_gausslegendre_pseudospectral-Tuple{Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.setup_gausslegendre_pseudospectral","text":"Function to create gausslegendre_info struct.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.setup_gausslegendre_pseudospectral_lobatto-Tuple{Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.setup_gausslegendre_pseudospectral_lobatto","text":"Function that creates the gausslegendre_base_info struct for Lobatto points. If collision_operator_dim = true, assign the elemental matrices used to implement the Fokker-Planck collision operator.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.setup_gausslegendre_pseudospectral_radau-Tuple{Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.setup_gausslegendre_pseudospectral_radau","text":"Function that creates the gausslegendre_base_info struct for Lobatto points. If collision_operator_dim = true, assign the elemental matrices used to implement the Fokker-Planck collision operator.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.setup_global_strong_form_matrix!-Tuple{Matrix{Float64}, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.setup_global_strong_form_matrix!","text":"A function that assigns the local matrices to a global array QQ_global for later evaluating strong form of required 1D equation.\n\nThe 'option' variable is a flag for choosing the type of matrix to be constructed. Currently the function is set up to assemble the elemental matrices without imposing boundary conditions on the first and final rows of the matrix. This means that the operators constructed from this function can only be used for differentiation, and not solving 1D ODEs. The shared points in the element assembly are averaged (instead of simply added) to be consistent with the derivative_elements_to_full_grid!() function in calculus.jl.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.setup_global_weak_form_matrix!-Tuple{Matrix{Float64}, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.setup_global_weak_form_matrix!","text":"A function that assigns the local weak-form matrices to  a global array QQ_global for later solving weak form of required 1D equation.\n\nThe 'option' variable is a flag for  choosing the type of matrix to be constructed.  Currently the function is set up to assemble the  elemental matrices without imposing boundary conditions on the  first and final rows of the matrix by default. This means that  the operators constructed from this function can only be used for differentiation, and not solving 1D ODEs. This assembly function assumes that the  coordinate is not distributed. To extend this function to support distributed-memory MPI, addition of off-memory matrix elements to the exterior points would be required.\n\nThe typical use of this function is to assemble matrixes M and K in\n\nM * d2f = K * f \n\nwhere M is the mass matrix and K is the stiffness matrix, and we wish to solve for d2f given f. To solve 1D ODEs\n\nK * f = b = M * d2f \n\nfor f given boundary data on f with periodic or dirichlet boundary conditions, set \n\nperiodic_bc = true, b[end] = 0\n\nor \n\ndirichlet_bc = true, b[1] = f[1] (except for cylindrical coordinates), b[end] = f[end]\n\nin the function call, and create new matrices for this purpose in the gausslegendre_info struct. Currently the Laplacian matrix is supported with boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.shift_factor_func-NTuple{5, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.shift_factor_func","text":"Function for computing the shift factor on a grid with uniformed spaced element boundaries. Unused.\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.interpolation.single_element_interpolate!-Tuple{Any, Any, Any, Any, Any, Any, Any, moment_kinetics.gauss_legendre.gausslegendre_base_info, Val{0}}","page":"gauss_legendre","title":"moment_kinetics.interpolation.single_element_interpolate!","text":"Function to perform interpolation on a single element.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#fokker_planck_calculus","page":"fokker_planck_calculus","title":"fokker_planck_calculus","text":"","category":"section"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus","text":"Module for functions used in calculating the integrals and doing the numerical differentiation for the implementation of the the full-F Fokker-Planck collision operator moment_kinetics.fokker_planck.\n\nParallelisation of the collision operator uses a special 'anysv' region type, see Collision operator and anysv region.\n\n\n\n\n\n","category":"module"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.YY_collision_operator_arrays","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.YY_collision_operator_arrays","text":"Struct to store the elemental nonlinear stiffness matrices used to express the finite-element weak form of the collision operator. The arrays are indexed so that the contraction in the assembly step is carried out over the fastest accessed indices, i.e., for YY0perp[i,j,k,iel], we contract over i and j to give data for the field position index k, all for the 1D element indexed by iel.\n\n\n\n\n\n","category":"type"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.boundary_integration_weights_struct","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.boundary_integration_weights_struct","text":"Struct to contain the integration weights for the boundary points in the (vpa,vperp) domain.\n\n\n\n\n\n","category":"type"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.fokkerplanck_arrays_direct_integration_struct","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.fokkerplanck_arrays_direct_integration_struct","text":"Struct of dummy arrays and precalculated coefficients for the Fokker-Planck collision operator when the Rosenbluth potentials are computed everywhere in (vpa,vperp) by direct integration. Used for testing.\n\n\n\n\n\n","category":"type"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.fokkerplanck_boundary_data_arrays_struct","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.fokkerplanck_boundary_data_arrays_struct","text":"Struct used for storing the integration weights for the boundary of the velocity space domain in (vpa,vperp) coordinates.\n\n\n\n\n\n","category":"type"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.fokkerplanck_weakform_arrays_struct","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.fokkerplanck_weakform_arrays_struct","text":"Struct of dummy arrays and precalculated coefficients for the finite-element weak-form Fokker-Planck collision operator.\n\n\n\n\n\n","category":"type"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.rosenbluth_potential_boundary_data","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.rosenbluth_potential_boundary_data","text":"Struct to store the boundary data for all of the Rosenbluth potentials required for the calculation.\n\n\n\n\n\n","category":"type"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.sparse_matrix_constructor","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.sparse_matrix_constructor","text":"Struct to contain data needed to create a sparse matrix.\n\n\n\n\n\n","category":"type"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data","text":"Struct to store the (vpa,vperp) boundary data for an individual Rosenbluth potential.\n\n\n\n\n\n","category":"type"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.algebraic_solve!-Tuple{Any, Any, Any, moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, Vararg{Any, 6}}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.algebraic_solve!","text":"Same as elliptic_solve!() above but no Dirichlet boundary conditions are imposed, because the function is only used where the lu_object_lhs is derived from a mass matrix. The source is made of two different terms with different weak matrices because of the form of the only algebraic equation that we consider.\n\nNote: algebraic_solve!() run only in serial. They do not handle shared-memory parallelism themselves. The calling site must ensure that algebraic_solve!() is only called by one process in a shared-memory block.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.allocate_boundary_data-Tuple{Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.allocate_boundary_data","text":"Function to allocate an instance of vpa_vperp_boundary_data.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.allocate_boundary_integration_weight-Tuple{Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.allocate_boundary_integration_weight","text":"Function to allocate a boundary_integration_weights_struct.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.allocate_boundary_integration_weights-Tuple{Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.allocate_boundary_integration_weights","text":"Function to allocate at fokkerplanck_boundary_data_arrays_struct.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.allocate_rosenbluth_potential_boundary_data-Tuple{Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.allocate_rosenbluth_potential_boundary_data","text":"Function to allocate an instance of rosenbluth_potential_boundary_data.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.allocate_sparse_matrix_constructor-Tuple{Int64}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.allocate_sparse_matrix_constructor","text":"Function to allocate an instance of sparse_matrix_constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.assemble_constructor_data!-Tuple{moment_kinetics.fokker_planck_calculus.sparse_matrix_constructor, Int64, Int64, Int64, Float64}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.assemble_constructor_data!","text":"Function to assemble data in an instance of sparse_matrix_constructor. Instead of writing data.SS[icsc] = ss, as in assign_constructor_data!() we write data.SS[icsc] += ss.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.assemble_explicit_collision_operator_rhs_parallel!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, moment_kinetics.fokker_planck_calculus.YY_collision_operator_arrays}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.assemble_explicit_collision_operator_rhs_parallel!","text":"Function to assemble the RHS of the kinetic equation due to the collision operator, in weak form. Once the array rhsvpavperp contains the assembled weak-form collision operator, a mass matrix solve still must be carried out to find the time derivative of the distribution function due to collisions. This function uses a purely parallel algorithm and may be tested by comparing to assemble_explicit_collision_operator_rhs_serial!(). The inner-most loop of the function is in assemble_explicit_collision_operator_rhs_parallel_inner_loop().\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.assemble_explicit_collision_operator_rhs_parallel_analytical_inputs!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, moment_kinetics.fokker_planck_calculus.YY_collision_operator_arrays}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.assemble_explicit_collision_operator_rhs_parallel_analytical_inputs!","text":"Function to assemble the RHS of the kinetic equation due to the collision operator, in weak form, when the distribution function appearing the derivatives is known analytically. The inner-most loop of the function is in assemble_explicit_collision_operator_rhs_parallel_analytical_inputs_inner_loop().\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.assemble_explicit_collision_operator_rhs_parallel_inner_loop-NTuple{21, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.assemble_explicit_collision_operator_rhs_parallel_inner_loop","text":"The inner-most loop of the parallel collision operator assembly. Called in assemble_explicit_collision_operator_rhs_parallel!().\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.assemble_explicit_collision_operator_rhs_serial!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, moment_kinetics.fokker_planck_calculus.YY_collision_operator_arrays}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.assemble_explicit_collision_operator_rhs_serial!","text":"Function to assemble the RHS of the kinetic equation due to the collision operator, in weak form. Once the array rhsvpavperp contains the assembled weak-form collision operator, a mass matrix solve still must be carried out to find the time derivative of the distribution function due to collisions. This function uses a purely serial algorithm for testing purposes.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.assemble_matrix_operators_dirichlet_bc-NTuple{4, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.assemble_matrix_operators_dirichlet_bc","text":"Function to contruct the global sparse matrices used to solve the elliptic PDEs for the Rosenbluth potentials. Uses a dense matrix construction method. The matrices are 2D in the compound index ic which indexes the velocity space labelled by ivpa,ivperp. Dirichlet boundary conditions are imposed in the appropriate stiffness matrices by setting the boundary row to be the Kronecker delta (0 except where ivpa = ivpap and ivperp = ivperpp). Used for testing.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.assemble_matrix_operators_dirichlet_bc_sparse-NTuple{4, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.assemble_matrix_operators_dirichlet_bc_sparse","text":"Function to contruct the global sparse matrices used to solve the elliptic PDEs for the Rosenbluth potentials. Uses a sparse matrix construction method. The matrices are 2D in the compound index ic which indexes the velocity space labelled by ivpa,ivperp. Dirichlet boundary conditions are imposed in the appropriate stiffness matrices by setting the boundary row to be the Kronecker delta (0 except where ivpa = ivpap and ivperp = ivperpp). See also assemble_matrix_operators_dirichlet_bc().\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.assign_constructor_data!-Tuple{moment_kinetics.fokker_planck_calculus.sparse_matrix_constructor, Int64, Int64, Int64, Float64}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.assign_constructor_data!","text":"Function to assign data to an instance of sparse_matrix_constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.assign_exact_boundary_data!-Tuple{moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.assign_exact_boundary_data!","text":"Function to assign precomputed (exact) data to an instance of vpa_vperp_boundary_data. Used in testing.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_YY_arrays-NTuple{4, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_YY_arrays","text":"Function to allocated an instance of YY_collision_operator_arrays. Calls get_QQ_local!() from gauss_legendre. Definitions of these nonlinear stiffness matrices can be found in the docs for get_QQ_local!().\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_boundary_data!-Tuple{moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, Array{Float64, 4}, Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_boundary_data!","text":"Function to carry out the direct integration of a formal definition of one of the Rosenbluth potentials, on the boundaries of the (vpa,vperp) domain, using the precomputed integration weights with dimension 4. The result is stored in an instance of vpa_vperp_boundary_data. Used in testing.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_boundary_data!-Tuple{moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, moment_kinetics.fokker_planck_calculus.boundary_integration_weights_struct, Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_boundary_data!","text":"Function to carry out the direct integration of a formal definition of one of the Rosenbluth potentials, on the boundaries of the (vpa,vperp) domain, using the precomputed integration weights with dimension 3. The result is stored in an instance of vpa_vperp_boundary_data.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_G!-Tuple{moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_G!","text":"\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_H!-Tuple{moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_H!","text":"\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_d2Gdvpa2!-Tuple{moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_d2Gdvpa2!","text":"\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_d2Gdvperp2!-Tuple{moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_d2Gdvperp2!","text":"\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_d2Gdvperpdvpa!-Tuple{moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_d2Gdvperpdvpa!","text":"\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_dGdvperp!-Tuple{moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_dGdvperp!","text":"\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_dHdvpa!-Tuple{moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_dHdvpa!","text":"\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_dHdvperp!-Tuple{moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_boundary_data_multipole_dHdvperp!","text":"\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_integrals!-NTuple{20, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_integrals!","text":"Function to carry out the integration of the revelant distribution functions to form the required coefficients for the full-F operator. We assume that the weights are precalculated. The function takes as arguments the arrays of coefficients (which we fill), the required distributions, the precomputed weights, the indicies of the `field' velocities, and the sizes of the primed vpa and vperp coordinates arrays.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_potential_boundary_data!-Tuple{moment_kinetics.fokker_planck_calculus.rosenbluth_potential_boundary_data, Union{moment_kinetics.fokker_planck_calculus.fokkerplanck_arrays_direct_integration_struct, moment_kinetics.fokker_planck_calculus.fokkerplanck_boundary_data_arrays_struct}, Vararg{Any, 5}}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_potential_boundary_data!","text":"Function to call direct integration function calculate_boundary_data!() and assign data to an instance of rosenbluth_potential_boundary_data, in place, without allocation.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_potential_boundary_data_delta_f_multipole!-Tuple{moment_kinetics.fokker_planck_calculus.rosenbluth_potential_boundary_data, Vararg{Any, 6}}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_potential_boundary_data_delta_f_multipole!","text":"Function to use the multipole expansion of the Rosenbluth potentials to calculate and assign boundary data to an instance of rosenbluth_potential_boundary_data, in place, without allocation. Use the exact results for the part of F that can be described with a Maxwellian, and the multipole expansion for the remainder.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_potential_boundary_data_exact!-Tuple{moment_kinetics.fokker_planck_calculus.rosenbluth_potential_boundary_data, Vararg{Any, 10}}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_potential_boundary_data_exact!","text":"Function to assign data to an instance of rosenbluth_potential_boundary_data, in place, without allocation. Used in testing.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_potential_boundary_data_multipole!-Tuple{moment_kinetics.fokker_planck_calculus.rosenbluth_potential_boundary_data, Vararg{Any, 5}}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_potential_boundary_data_multipole!","text":"Function to use the multipole expansion of the Rosenbluth potentials to calculate and assign boundary data to an instance of rosenbluth_potential_boundary_data, in place, without allocation.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_potentials_via_analytical_Maxwellian!-NTuple{12, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_potentials_via_analytical_Maxwellian!","text":"Function to calculate Rosenbluth potentials for shifted Maxwellians using an analytical specification\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_potentials_via_elliptic_solve!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, moment_kinetics.fokker_planck_calculus.fokkerplanck_weakform_arrays_struct}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_potentials_via_elliptic_solve!","text":"Function to solve the appropriate elliptic PDEs to find the Rosenbluth potentials. First, we calculate the Rosenbluth potentials at the boundary with the direct integration method. Then, we use this data to solve the elliptic PDEs with the boundary data providing an accurate Dirichlet boundary condition on the maximum vpa and vperp of the domain. We use the sparse LU decomposition from the LinearAlgebra package to solve the PDE matrix equations.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.create_sparse_matrix-Tuple{moment_kinetics.fokker_planck_calculus.sparse_matrix_constructor}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.create_sparse_matrix","text":"Wrapper function to create a sparse matrix with an instance of sparse_matrix_constructor and sparse().\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.elliptic_solve!-Tuple{Any, Any, moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data, Vararg{Any, 5}}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.elliptic_solve!","text":"Elliptic solve function.\n\nfield: the solution\nsource: the source function on the RHS\nboundary data: the known values of field at infinity\nlu_object_lhs: the object for the differential operator that defines field\nmatrix_rhs: the weak matrix acting on the source vector\nvpa, vperp: coordinate structs\n\nNote: all variants of elliptic_solve!() run only in serial. They do not handle shared-memory parallelism themselves. The calling site must ensure that elliptic_solve!() is only called by one process in a shared-memory block.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.enforce_dirichlet_bc!-NTuple{4, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.enforce_dirichlet_bc!","text":"Sets f(vpa,vperp) to a specied value f_bc at the boundaries in (vpa,vperp). f_bc is a 2D array of (vpa,vperp) where only boundary data is used. Used for testing.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.enforce_dirichlet_bc!-Tuple{Any, Any, Any, moment_kinetics.fokker_planck_calculus.vpa_vperp_boundary_data}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.enforce_dirichlet_bc!","text":"Sets f(vpa,vperp) to a specied value f_bc at the boundaries in (vpa,vperp). f_bc is an instance of vpa_vperp_boundary_data.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.enforce_vpavperp_BCs!-NTuple{5, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.enforce_vpavperp_BCs!","text":"Function to enforce boundary conditions on the collision operator result to be consistent with the boundary conditions imposed on the distribution function.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.enforce_zero_bc!-Tuple{Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.enforce_zero_bc!","text":"Unused function. Sets f(vpa,vperp) to zero at the boundaries in (vpa,vperp).\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.get_element_limit_indices-NTuple{4, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.get_element_limit_indices","text":"Function for getting the indices used to choose the integration quadrature.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.get_global_compound_index-NTuple{6, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.get_global_compound_index","text":"get_global_compound_index(vpa,vperp,ielement_vpa,ielement_vperp,ivpa_local,ivperp_local)\n\nFor local (within the single element specified by ielement_vpa and ielement_vperp) indices ivpa_local and ivperp_local, get the global index in the 'linear-indexed' 2d space of size (vperp.n, vpa.n) (as returned by ic_func).\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.get_scaled_x_w_no_divergences!-NTuple{6, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.get_scaled_x_w_no_divergences!","text":"Function to get the local grid and integration weights assuming no divergences of the function on the 1D element. Gauss-Legendre quadrature is used for the entire element.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.get_scaled_x_w_with_divergences!-NTuple{11, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.get_scaled_x_w_with_divergences!","text":"Function to get the local integration grid and quadrature weights to integrate a 1D element in the 2D representation of the velocity space distribution functions. This function assumes that there is a divergence at the point coord_val, and splits the grid and integration weights appropriately, using Gauss-Laguerre points near the divergence and Gauss-Legendre points away from the divergence.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.ic_func-Tuple{Int64, Int64, Int64}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.ic_func","text":"ic_func(ivpa::mk_int,ivperp::mk_int,nvpa::mk_int)\n\nGet the 'linear index' corresponding to ivpa and ivperp. Defined so that the linear index corresponds to the underlying layout in memory of a 2d array indexed by [ivpa,ivperp], i.e. for a 2d array f2d:\n\nsize(f2d) == (vpa.n, vperp.n)\nFor a reference to f2d that is reshaped to a vector (a 1d array) f1d = vec(f2d) than for any ivpa and ivperp it is true that f1d[ic_func(ivpa,ivperp)] == f2d[ivpa,ivperp].\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.icsc_func-NTuple{10, Int64}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.icsc_func","text":"Function that returns the sparse matrix index used to directly construct the nonzero entries of a 2D assembled sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.ielement_loopup-Tuple{Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.ielement_loopup","text":"Function to find the element in which x sits.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.init_Rosenbluth_potential_boundary_integration_weights!-NTuple{8, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.init_Rosenbluth_potential_boundary_integration_weights!","text":"Function that precomputes the required integration weights only along the velocity space boundaries. Used as the default option as part of the strategy to compute the Rosenbluth potentials at the boundaries with direct integration and in the rest of (vpa,vperp) by solving elliptic PDEs.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.init_Rosenbluth_potential_integration_weights!-NTuple{8, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.init_Rosenbluth_potential_integration_weights!","text":"Function that precomputes the required integration weights in the whole of (vpa,vperp) for the direct integration method of computing the Rosenbluth potentials.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.interpolate_2D_vspace!-NTuple{5, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.interpolate_2D_vspace!","text":"Function to interpolate f(vpa,vperp) from one velocity grid to another, assuming that both grids are represented by (vpa,vperp) in normalised units, but have different normalisation factors defining the meaning of these grids in physical units. E.g.,\n\n vpai, vperpi = ci * vpa, ci * vperp\n vpae, vperpe = ce * vpa, ce * vperp\n\nwith ci = sqrt(Ti/mi), ce = sqrt(Te/mi)\n\nscalefac = ci / ce is the ratio of the two reference speeds.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.ivpa_func-Tuple{Int64, Int64}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.ivpa_func","text":"ivpa_func(ic::mk_int,nvpa::mk_int)\n\nGet the vpa index ivpa that corresponds to a 'linear index' ic that spans a 2d velocity space.\n\nDefined so that ivpa_func(inc_func(ivpa,ivperp,nvpa), nvpa) == ivpa.\n\nSee also ic_func, ivperp_func.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.ivperp_func-Tuple{Int64, Int64}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.ivperp_func","text":"ivperp_func(ic::mk_int,nvpa::mk_int)\n\nGet the vperp index ivperp that corresponds to a 'linear index' ic that spans a 2d velocity space.\n\nDefined so that ivperp_func(inc_func(ivpa,ivperp,nvpa), nvpa) == ivperp.\n\nSee also ic_func, ivpa_func.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.local_element_integration!-NTuple{18, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.local_element_integration!","text":"Base level function for computing the integration kernals for the Rosenbluth potential integration. Note the definitions of ellipe(m) (E(m)) and ellipk(m) (K(m)). https://specialfunctions.juliamath.org/stable/functions_list/#SpecialFunctions.ellipe https://specialfunctions.juliamath.org/stable/functions_list/#SpecialFunctions.ellipk\n\nE(m) = int^pi2_0 sqrt 1 - m sin^2(theta) d theta\n\nK(m) = int^pi2_0 frac1sqrt 1 - m sin^2(theta) d theta\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.loop_over_vpa_elements!-NTuple{23, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.loop_over_vpa_elements!","text":"Function for computing the quadratures and carrying out the loop over the primed vpa coordinate in doing the numerical integration. Splits the integrand into three pieces – two which use Gauss-Legendre quadrature assuming no divergences in the integrand, and one which assumes a logarithmic divergence and uses a Gauss-Laguerre quadrature with an (exponential) change of variables to mitigate this divergence.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.loop_over_vpa_elements_no_divergences!-NTuple{21, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.loop_over_vpa_elements_no_divergences!","text":"Function for computing the quadratures and carrying out the loop over the primed vpa coordinate in doing the numerical integration. Uses a Gauss-Legendre quadrature assuming no divergences in the integrand.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.loop_over_vperp_vpa_elements!-NTuple{24, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.loop_over_vperp_vpa_elements!","text":"Function for computing the quadratures and carrying out the loop over the primed vperp coordinate in doing the numerical integration. Splits the integrand into three pieces – two which use Gauss-Legendre quadrature assuming no divergences in the integrand, and one which assumes a logarithmic divergence and uses a Gauss-Laguerre quadrature with an (exponential) change of variables to mitigate this divergence. This function calls loop_over_vpa_elements_no_divergences!() and loop_over_vpa_elements!() to carry out the primed vpa loop within the primed vperp loop.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.loop_over_vperp_vpa_elements_no_divergences!-NTuple{22, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.loop_over_vperp_vpa_elements_no_divergences!","text":"The function loop_over_vperp_vpa_elements_no_divergences!() was used for debugging. By changing the source where loop_over_vperp_vpa_elements!() is called to instead call this function we can verify that the Gauss-Legendre quadrature is adequate for integrating a divergence-free integrand. This function should be kept until we understand the problems preventing machine-precision accurary in the pure integration method of computing the Rosenbluth potentials.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.nel_hi-Tuple{Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.nel_hi","text":"Function returns 1 for nelement > ielement >= 1, 0 for ielement = nelement.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.nel_low-Tuple{Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.nel_low","text":"Function returns 1 for nelement >= ielement > 1, 0 for ielement = 1.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.ng_hi-Tuple{Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.ng_hi","text":"Function returns 1 if igrid = ngrid or 0 if 1 =< igrid < ngrid.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.ng_low-Tuple{Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.ng_low","text":"Function returns 1 if igrid = 1 or 0 if 1 < igrid <= ngrid.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.setup_basic_quadratures-Tuple{Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.setup_basic_quadratures","text":"Function for getting the basic quadratures used for the numerical integration of the Lagrange polynomials and the integration kernals.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.test_boundary_data-NTuple{9, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.test_boundary_data","text":"Function to compute the maximum error rm MAXf_rm numerical-f_rm exact for instances of vpa_vperp_boundary_data.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.test_rosenbluth_potential_boundary_data-Tuple{moment_kinetics.fokker_planck_calculus.rosenbluth_potential_boundary_data, moment_kinetics.fokker_planck_calculus.rosenbluth_potential_boundary_data, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.test_rosenbluth_potential_boundary_data","text":"Function to compare two instances of rosenbluth_potential_boundary_data – one assumed to contain exact results, and the other numerically computed results – and compute the maximum value of the error. Calls test_boundary_data().\n\n\n\n\n\n","category":"method"},{"location":"zz_jacobian_matrices/#jacobian_matrices","page":"jacobian_matrices","title":"jacobian_matrices","text":"","category":"section"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices","text":"Generic utilities to simplify calculation of (contributions to) Jacobian matrices\n\n\n\n\n\n","category":"module"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices.EquationTerm","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices.EquationTerm","text":"Represents a term in an evolution equation, which can be composed of multiple sub-terms. The whole right hand side of an evolution equation can be represented as an EquationTerm, as the sum of all the RHS terms.\n\nIf the EquationTerm is not a sum, product, or constant then it is a leaf node of the EquationTerm tree that gives a contribution to the Jacobian matrix.\n\nSome slightly clusmy handling of array data (only storing a flattened view of the arrays) is done to ensure that EquationTerm has no type parameters so that the sub_terms::Vector{EquationTerm} has a concrete type.\n\nNote that not all fields can be used for every kind, but all are included (rather than, for example, having multiple subtypes of an abstract EquationTerm type) so that we can make a type-stable tree of EquationTerm objects.\n\n\n\n\n\n","category":"type"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices.EquationTerm-Tuple{Symbol, Union{Nothing, AbstractArray{Float64}}}","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices.EquationTerm","text":"EquationTerm(state_variable::Symbol, array::AbstractArray{mk_float};\n             derivatives::Vector{Symbol}=Symbol[],\n             upwind_speeds::Vector{T} where T <: Union{Nothing,AbstractArray{mk_float}}=Nothing[],\n             second_derivatives::Vector{Symbol}=Symbol[],\n             integrand_coordinates::Union{Vector{Tc},Nothing} where Tc <: coordinate=nothing,\n             integrand_prefactor::EquationTerm=unit_term,\n             dims_coords...)\n\nConstruct an EquationTerm object, used to fill Jacobian matrices.\n\nstate_variable is the name of the variable in the jacobian_info that this term represents.\n\narray gives the values of this term. nothing may be passed for array, but this is only intended for internal use.\n\nderivatives is a list of any derivatives of state_variable included in this term, which are (optionally) upwinded by upwind_speeds.\n\nsecond_derivatives is a list of any second derivatives of state_variable included in this term.\n\nintegrand_coordinates is a list of coordinates corresponding to dimensions that state_variable is integrated over in this term. May be combined with derivatives. The prefactor of state_variable in the integral is integrand_prefactor.\n\ndims_coords... are name=c::coordinate keyword arguments giving the coordinates corresponding to the dimensions of state_variable.\n\n\n\n\n\n","category":"method"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices.jacobian_info","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices.jacobian_info","text":"Jacobian matrix and some associated information.\n\nmatrix is a (non-sparse) array containing the Jacobian matrix.\n\nstate_vector_entries are Symbols giving the names of the variables in the state vector.\n\nstate_vector_numbers is a NamedTuple providing a lookup table for the position of each name in state_vector_entries from the name.\n\nstate_vector_dims is a Tuple of Tuples (one for each state vector variable) giving the dimensions of that variable.\n\nstate_vector_coords are the mini_coordinate objects corresponding to state_vector_dims.\n\nstate_vector_sizes are the total number of points in each state vector variable.\n\nstate_vector_dim_sizes are the total numbers of points in each dimension in state_vector_dims.\n\nstate_vector_sizes are the total lengths of each variable in the state vector.\n\nstate_vector_dim_steps gives the step needed in the flattened state vector to move one point in each dimension in state_vector_dims.\n\nstate_vector_offsets gives the offset from indices in the corresponding variable to indices in the full state vector. The first entry of state_vector_offsets is 0. state_vector_offsets has a length one greater than state_vector_entries - the final element is the total size of the state vector. \n\nstate_vector_local_ranges gives the index range in each dimension of state_vector_dims that is locally owned by this process - used for parallelised loops over rows (or columns) when dealing with a single variable at a time from the state vector.\n\nrow_local_ranges gives an index range of locally owned rows of matrix - used for parallelised loops over rows (or columns) of the full matrix when it is not necessary to know which variable a row corresponds to.\n\ncoords is a NamedTuple containing mini_coordinate objects for all the dimensions involved in the jacobian_info.\n\nspectral is a NamedTuple containing mini_discretization_info objects for all the dimensions involved in the jacobian_info.\n\nboundary_skip_funcs is a NamedTuple that gives functions (for each variable in state_vector_entries) that indicate when a grid point should be skipped in the Jacobian because it is set by boundary conditions.\n\nsynchronize is the function to be called to synchronize all processes in the shared-memory group that is working with this jacobian_info object.\n\n\n\n\n\n","category":"type"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices.CompoundTerm-Tuple{moment_kinetics.jacobian_matrices.EquationTerm, AbstractArray{Float64}}","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices.CompoundTerm","text":"CompoundTerm(compound_term_expanded::EquationTerm,\n             array::AbstractArray{mk_float}; dims_coords...)\n\nCreate a 'compound' EquationTerm. Useful when the discrete version of the term is not exactly equal to the combination of its parts, for example a derivative of a product partial(ab) = apartial b + b partial a where the numerical derivative of ab is not exactly equal to the expanded form. The expanded form, passed in as compound_term_expanded, is needed to calculate the functional derivatives (terminology?) that give the Jacobian. The numerical values of this term are passed as array, with the coordinates corresponding to the dimensions of array being the keyword arguments dims_coords....\n\n\n\n\n\n","category":"method"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices.ConstantTerm-Tuple{AbstractArray}","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices.ConstantTerm","text":"ConstantTerm(array::AbstractArray; dims_coords...)\n\nCreate a constant EquationTerm, which does not depend on any of the state variables. The values of this term are passed as array, with the coordinates corresponding to the dimensions of array being the keyword arguments dims_coords....\n\n\n\n\n\n","category":"method"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices.NullTerm-Tuple{}","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices.NullTerm","text":"NullTerm()\n\nCreate a null EquationTerm, to use for example when a term is switched off by some option. Null terms are dropped when summed with non-null terms, or make the whole result null when multiplied by other terms.\n\n\n\n\n\n","category":"method"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices.add_term_to_Jacobian!","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices.add_term_to_Jacobian!","text":"add_term_to_Jacobian!(jacobian::jacobian_info, rows_variable::Symbol,\n                      prefactor::mk_float, terms::EquationTerm,\n                      boundary_speed=nothing)\n\nAdd the contribution of terms to jacobian. The terms should be all or part of the evolution equation for rows_variable.\n\nprefactor multiplies all the terms. Usually it will be the timestep.\n\nboundary_speed is the speed needed by jacobian.boundary_skip_funcs to determine whether a grid point is set by the boundary conditions. This will usually be the speed in the z-direction.\n\n\n\n\n\n","category":"function"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices.add_term_to_Jacobian_row!-Tuple{moment_kinetics.jacobian_matrices.jacobian_info, AbstractVector{Float64}, Symbol, Float64, moment_kinetics.jacobian_matrices.EquationTerm, Tuple, Any}","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices.add_term_to_Jacobian_row!","text":"add_term_to_Jacobian_row!(jacobian::jacobian_info,\n                          jacobian_row::AbstractVector{mk_float},\n                          rows_variable::Symbol, prefactor::mk_float,\n                          terms::EquationTerm, indices::Tuple,\n                          boundary_speed)\n\nTraverse the tree of EquationTerms, accumulating the prefactors until reaching a leaf term (kind = ETsimple) that represents a state vector variable, which makes a contribution to the Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices.create_jacobian_info-Tuple{NamedTuple, NamedTuple}","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices.create_jacobian_info","text":"create_jacobian_info(coords::NamedTuple, spectral::NamedTuple; comm=comm_block[],\n                     synchronize::Union{Function,Nothing}=_block_synchronize,\n                     boundary_skip_funcs=nothing, kwargs...)\n\nCreate a jacobian_info struct.\n\nkwargs describes the state vector. The keys are the variable names, and the arguments are 2 element Tuples whose first element is the 'region type' for parallel loops over that variable (or nothing if comm = nothing for serial operation) and whose second element Vector or Tuple of Symbols giving the dimensions of the variable.\n\ncoords is a NamedTuple giving all the needed coordinates, spectral is a NamedTuple with all the needed 'spectral' objects.\n\ncomm is the communicator to use to allocate shared memory arrays. synchronize is the function used to synchronize between shared-memory operations.\n\nboundary_skip_funcs is a NamedTuple whose keys are the variable names and whose values are functions to use to skip points that would be set by boundary conditions (or nothing if no function is needed for the variable).\n\n\n\n\n\n","category":"method"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices.jacobian_initialize_bc_diagonal!-Tuple{moment_kinetics.jacobian_matrices.jacobian_info, Any}","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices.jacobian_initialize_bc_diagonal!","text":"jacobian_initialize_bc_diagonal!(jacobian::jacobian_info)\n\nInitialize jacobian.matrix to zero, but with ones on the diagonal for rows that correspond to boundary condition points (i.e. those skipped by jacobian.boundary_skip_funcs).\n\n\n\n\n\n","category":"method"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices.jacobian_initialize_identity!-Tuple{moment_kinetics.jacobian_matrices.jacobian_info}","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices.jacobian_initialize_identity!","text":"jacobian_initialize_identity!(jacobian::jacobian_info)\n\nInitialize jacobian.matrix with the identity.\n\n\n\n\n\n","category":"method"},{"location":"zz_jacobian_matrices/#moment_kinetics.jacobian_matrices.jacobian_initialize_zero!-Tuple{moment_kinetics.jacobian_matrices.jacobian_info}","page":"jacobian_matrices","title":"moment_kinetics.jacobian_matrices.jacobian_initialize_zero!","text":"jacobian_initialize_identity!(jacobian::jacobian_info)\n\nInitialize jacobian.matrix to zero.\n\n\n\n\n\n","category":"method"},{"location":"zz_maxwell_diffusion/#maxwell_diffusion","page":"maxwell_diffusion","title":"maxwell_diffusion","text":"","category":"section"},{"location":"zz_maxwell_diffusion/#moment_kinetics.maxwell_diffusion.ion_vpa_maxwell_diffusion!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, Any, Any, T_spectral, Any, Any}} where T_spectral","page":"maxwell_diffusion","title":"moment_kinetics.maxwell_diffusion.ion_vpa_maxwell_diffusion!","text":"Calculate the Maxwellian associated with the current ion pdf moments, and then  subtract this from current pdf. Then take second derivative of this function to act as the diffusion operator. \n\n\n\n\n\n","category":"method"},{"location":"zz_maxwell_diffusion/#moment_kinetics.maxwell_diffusion.neutral_vz_maxwell_diffusion!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, Any, Any, Any, T_spectral, Any, Any}} where T_spectral","page":"maxwell_diffusion","title":"moment_kinetics.maxwell_diffusion.neutral_vz_maxwell_diffusion!","text":"Calculate the Maxwellian associated with the current neutral pdf moments, and then  subtract this from current pdf. Then take second derivative of this function to act as the diffusion operator. \n\n\n\n\n\n","category":"method"},{"location":"zz_maxwell_diffusion/#moment_kinetics.maxwell_diffusion.setup_mxwl_diff_collisions_input-Tuple{AbstractDict, Bool}","page":"maxwell_diffusion","title":"moment_kinetics.maxwell_diffusion.setup_mxwl_diff_collisions_input","text":"Function for reading Maxwell diffusion operator input parameters.  Structure the namelist as follows.\n\n[maxwelldiffusioncollisions] usemaxwelldiffusion = true Dii = 1.0 diffusioncoefficient_option = \"manual\"\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#load_data","page":"load_data","title":"load_data","text":"","category":"section"},{"location":"zz_load_data/#moment_kinetics.load_data","page":"load_data","title":"moment_kinetics.load_data","text":"\n\n\n\n","category":"module"},{"location":"zz_load_data/#moment_kinetics.load_data._get_all_moment_variables-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data._get_all_moment_variables","text":"Load all the moment variables, returning them in a NamedTuple.\n\nIntended for internal use inside get_variable.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data._get_fake_moments_fields_scratch-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data._get_fake_moments_fields_scratch","text":"Create fake scratch and moments structs at time index it from the variables in all_moments.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.close_run_info-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.close_run_info","text":"close_run_info(run_info)\n\nClose all the files in a run_info NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.construct_global_zr_coords-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.construct_global_zr_coords","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.get_r_derivative-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.get_r_derivative","text":"get_r_derivative(run_info, variable_name; kwargs...)\n\nGet (i.e. load or calculate) variable_name from run_info and calculate its r-derivative. Returns the r-derivative\n\nkwargs... are passed through to get_variable().\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.get_run_info_no_setup-Tuple{Vararg{Union{AbstractString, Tuple{AbstractString, Union{Nothing, Int64}}}}}","page":"load_data","title":"moment_kinetics.load_data.get_run_info_no_setup","text":"get_run_info_no_setup(run_dir...; itime_min=1, itime_max=0, itime_skip=1, dfns=false,\n                      initial_electron=false)\nget_run_info_no_setup((run_dir, restart_index)...; itime_min=1, itime_max=0,\n                      itime_skip=1, dfns=false, initial_electron=false)\n\nGet file handles and other info for a single run\n\nrun_dir is either the directory to read output from (whose name should be the run_name), or a momentkinetics binary output file. If a file is passed, it is only used to infer the directory and `runname, so it is possible for example to pass a.moments.h5output file and alsodfns=trueand the.dfns.h5` file will be the one actually opened (as long as it exists).\n\nrestart_index can be given by passing a Tuple, e.g. (\"runs/example\", 42) as the positional argument. It specifies which restart to read if there are multiple restarts. If no restart_index is given or if nothing is passed, read all restarts and concatenate them. An integer value reads the restart with that index - -1 indicates the latest restart (which does not have an index).\n\nSeveral runs can be loaded at the same time by passing multiple positional arguments. Each argument can be a String run_dir giving a directory to read output from or a Tuple (run_dir, restart_index) giving both a directory and a restart index (it is allowed to mix Strings and Tuples in a call).\n\nBy default load data from moments files, pass dfns=true to load from distribution functions files, or initial_electron=true and dfns=true to load from initial electron state files, or electron_debug=true and dfns=true to load from electron debug files.\n\nThe itime_min, itime_max and itime_skip options can be used to select only a slice of time points when loading data. In makie_post_process these options are read from the input (if they are set) before get_run_info_no_setup() is called, so that the run_info returned can be passed to makie_post_processing.setup_makie_post_processing_input!(), to be used for defaults for the remaining options. If either itime_min or itime_max are ≤0, their values are used as offsets from the final time index of the run.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.get_upwind_r_derivative-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.get_upwind_r_derivative","text":"get_upwind_r_derivative(run_info, variable_name; kwargs...)\n\nGet (i.e. load or calculate) variable_name from run_info and calculate its upwinded r-derivative. Returns the upwinded r-derivative\n\nkwargs... are passed through to get_variable().\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.get_upwind_z_derivative-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.get_upwind_z_derivative","text":"get_upwind_z_derivative(run_info, variable_name; kwargs...)\n\nGet (i.e. load or calculate) variable_name from run_info and calculate its upwinded z-derivative. Returns the upwinded z-derivative\n\nkwargs... are passed through to get_variable().\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.get_variable","page":"load_data","title":"moment_kinetics.load_data.get_variable","text":"get_variable(run_info::Tuple, variable_name; kwargs...)\nget_variable(run_info, variable_name; kwargs...)\n\nGet an array (or Tuple of arrays, if run_info is a Tuple) of the data for variable_name from run_info.\n\nSome derived variables need to be calculated from the saved output, not just loaded from file (with postproc_load_variable). This function takes care of that calculation, and handles the case where run_info is a Tuple (which postproc_load_data does not handle).\n\nkwargs... are passed through to postproc_load_variable().\n\n\n\n\n\n","category":"function"},{"location":"zz_load_data/#moment_kinetics.load_data.get_z_derivative-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.get_z_derivative","text":"get_z_derivative(run_info, variable_name; kwargs...)\n\nGet (i.e. load or calculate) variable_name from run_info and calculate its z-derivative. Returns the z-derivative\n\nkwargs... are passed through to get_variable().\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_block_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_block_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_coordinate_data-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.load_coordinate_data","text":"load_coordinate_data(fid, name; printout=false, irank=nothing, nrank=nothing,\n                     run_directory=nothing, warn_unexpected=false,\n                     ignore_MPI=true)\n\nLoad data for the coordinate name from a file-handle fid.\n\nReturns (coord, spectral, chunk_size). coord is a coordinate object. spectral is the object used to implement the discretization in this coordinate. chunk_size is the size of chunks in this coordinate that was used when writing to the output file.\n\nIf printout is set to true a message will be printed when this function is called.\n\nIf irank and nrank are passed, then the coord and spectral objects returned will be set up for the parallelisation specified by irank and nrank, rather than the one implied by the output file.\n\nUnless ignore_MPI=false is passed, the returned coordinates will be created without shared memory scratch arrays (ignore_MPI=true will be passed through to define_coordinate).\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_distributed_electron_pdf_slice-Tuple{Tuple, Tuple, Any, Int64, Vararg{moment_kinetics.moment_kinetics_structs.coordinate, 4}}","page":"load_data","title":"moment_kinetics.load_data.load_distributed_electron_pdf_slice","text":"Read a slice of an electron distribution function\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\nThe slice to take is specified by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_distributed_ion_pdf_slice-Tuple{Tuple, Tuple, Any, Int64, Vararg{moment_kinetics.moment_kinetics_structs.coordinate, 4}}","page":"load_data","title":"moment_kinetics.load_data.load_distributed_ion_pdf_slice","text":"Read a slice of an ion distribution function\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\nThe slice to take is specified by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_distributed_neutral_pdf_slice-Tuple{Tuple, Tuple, Any, Int64, Vararg{moment_kinetics.moment_kinetics_structs.coordinate, 5}}","page":"load_data","title":"moment_kinetics.load_data.load_distributed_neutral_pdf_slice","text":"Read a slice of a neutral distribution function\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\nThe slice to take is specified by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_electron_moments_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_electron_moments_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_fields_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_fields_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_input-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_input","text":"Load saved input settings\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_ion_moments_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_ion_moments_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_mk_options-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_mk_options","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_neutral_pdf_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_neutral_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_pdf_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_rank_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_rank_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_slice","page":"load_data","title":"moment_kinetics.load_data.load_slice","text":"Load a slice of a single variable from a file\n\n\n\n\n\n","category":"function"},{"location":"zz_load_data/#moment_kinetics.load_data.load_species_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_species_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_time_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_time_data","text":"If a tuple is given for fid, concatenate the \"time\" output from each file in the tuple\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_variable","page":"load_data","title":"moment_kinetics.load_data.load_variable","text":"Load a single variable from a file\n\n\n\n\n\n","category":"function"},{"location":"zz_load_data/#moment_kinetics.load_data.open_readonly_output_file-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.open_readonly_output_file","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.postproc_load_variable-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.postproc_load_variable","text":"postproc_load_variable(run_info, variable_name; it=nothing, is=nothing,\n                       ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n                       ivzeta=nothing, ivr=nothing, ivz=nothing, group=nothing)\n\nLoad a variable\n\nrun_info is the information about a run returned by makie_post_processing.get_run_info().\n\nvariable_name is the name of the variable to load.\n\nThe keyword arguments it, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be set to an integer or a range (e.g. 3:8 or 3:2:8) to select subsets of the data. Only the data for the subset requested will be loaded from the output file (mostly - when loading fields or moments from runs which used parallel_io = false, the full array will be loaded and then sliced).\n\nIf a variable is found in a group other than \"dynamic_data\", the group name should be passed to the group argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.read_Dict_from_section-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.read_Dict_from_section","text":"read_Dict_from_section(file_or_group, section_name; ignore_subsections=false)\n\nRead information from section_name in file_or_group, returning a Dict.\n\nBy default, any subsections are included as nested Dicts. If ignore_subsections=true they are ignored.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.read_distributed_zr_data!-Union{Tuple{N}, Tuple{Array{Float64, N}, String, Tuple, String, Tuple, Int64, Int64, Int64}} where N","page":"load_data","title":"moment_kinetics.load_data.read_distributed_zr_data!","text":"Read data which is a function of (z,r,t) or (z,r,species,t)\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.reload_electron_data!-NTuple{14, Any}","page":"load_data","title":"moment_kinetics.load_data.reload_electron_data!","text":"Reload electron pdf and moments from an existing output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.reload_evolving_fields!-NTuple{14, Any}","page":"load_data","title":"moment_kinetics.load_data.reload_evolving_fields!","text":"Reload pdf and moments from an existing output file.\n\n\n\n\n\n","category":"method"},{"location":"post_processing_notes/#Post-processing","page":"Post processing","title":"Post processing","text":"","category":"section"},{"location":"post_processing_notes/#How-to","page":"Post processing","title":"How to","text":"","category":"section"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"Post processing functionality is provided by the makie_post_processing.makie_post_processing module. To run the post processing, call makie_post_processing.makie_post_process e.g.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> using makie_post_processing\njulia> makie_post_process(\"runs/example-run/\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"or","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> makie_post_process(\"runs/example-run1/\", \"runs/example-run2/\", \"runs/example-run3/\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"What this function does is controlled by the settings in an input file, by default post_processing_input.toml.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"note: Example input file\nYou can generate an example input file, with all the options shown (with their default values) but commented out, by running makie_post_processing.generate_example_input_file().","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"To run from the command line","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia --project run_makie_post_processing.jl dir1 [dir2 [dir3 ...]]","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"If multiple directories are passed, comparison plots will be made. This usually means that for line plots and animations the output for all the runs will be drawn on the same plot. For heatmap plots, the runs will be plotted side by side.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"If there is output from several restarts of the same run in a directory, by default they will all be read and plotted. A single restart can be started by passing the restart_id argument to makie_post_process().","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"It is also possible to pass an output file (*.moments.h5 or *.dfns.h5) instead of a directory. The file name is just used to find the directory and run_name (which is the prefix of the file name), so for example you can pass a *.moments.h5 file and ask for distribution function plots (as long as the corresponding *.dfns.h5 file exists). This is useful if some output files were moved to a different directory, or the run directory was renamed (e.g. for backup, or to compare some different input options or code versions).","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"To see all the options that can be set, makie_post_processing.generate_example_input_file can be used to create an example file containing all the options with their default values. The options are all commented out when the file is created.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"note: Viewing animations\nAnimations are produced in .gif format. Most utilities just play gifs, but provide no options to pause them, etc. One that provides a few more features is multigifview (developed by @johnomotani).","category":"page"},{"location":"post_processing_notes/#Interactive-use","page":"Post processing","title":"Interactive use","text":"","category":"section"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"The functions in makie_post_processing.makie_post_processing can be used interactively (or in standalone scripts). To do so, first get the 'info' for a run (file names, metadata, etc.) using makie_post_processing.get_run_info","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> using makie_post_processing\njulia> run_info = get_run_info(\"runs/example-run/\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"or to load from the distribution functions output file .dfns.h5","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> run_info_dfns = get_run_info(\"runs/example-run/\"; dfns=true)","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"Settings for post-processing are read from an input file, by default post_processing_input.toml (you can select a different one using the setup_input_file argument to get_run_info()). The relevant settings for interactive use are the default indices (iz0, ivpa0, etc.) that are used to select slices for 1D/2D plots and animations. The settings are read by setup_makie_post_processing!() which is called by default as part of get_run_info(). You might want to call it directly if you load both 'moments' and 'distribution functions' data, to get sensible settings for both at the same time.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"Then you can make 1d or 2d plots, e.g.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> fig1 = plot_vs_z(run_info, \"phi\")\njulia> fig2 = plot_vs_r_t(run_info, \"density\"; outfile=\"density_vs_r_t.pdf\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"using makie_post_processing.plot_vs_t, etc. for 1d and makie_post_processing.plot_vs_r_t, etc. for 2d plots. The outfile argument can be used to save the plot. You can also change the default values used to select from the other dimensions","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> plot_vs_z(run_info, \"phi\"; outfile=\"phi_vs_z.pdf\", it=42, ir=7)","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"You can make animations in a similar way","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> fig1 = animate_vs_z(run_info, \"phi\"; outfile=\"phi_vs_z.gif\", it=8:12, ir=1)\njulia> fig2 = animate_vs_z_r(run_info, \"density\"; outfile=\"density_vs_z_r.mp4\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"using makie_post_processing.animate_vs_r, etc. for 1d and makie_post_processing.animate_vs_z_r, etc. for 2d animations. Note that outfile is required for animations.","category":"page"},{"location":"post_processing_notes/#API","page":"Post processing","title":"API","text":"","category":"section"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"See makie_post_processing.","category":"page"},{"location":"zz_timer_utils/#timer_utils","page":"timer_utils","title":"timer_utils","text":"","category":"section"},{"location":"zz_timer_utils/#moment_kinetics.timer_utils","page":"timer_utils","title":"moment_kinetics.timer_utils","text":"Utilities for timing functions or blocks of code\n\n\n\n\n\n","category":"module"},{"location":"zz_timer_utils/#moment_kinetics.timer_utils.global_timer","page":"timer_utils","title":"moment_kinetics.timer_utils.global_timer","text":"Global object used to collect timings of various parts of the code\n\n\n\n\n\n","category":"constant"},{"location":"zz_timer_utils/#moment_kinetics.timer_utils.timer_names_all_ranks_dfns","page":"timer_utils","title":"moment_kinetics.timer_utils.timer_names_all_ranks_dfns","text":"Nested SortedDict with the names of all timers that have been created on any MPI rank and added to the dfns output file.\n\n\n\n\n\n","category":"constant"},{"location":"zz_timer_utils/#moment_kinetics.timer_utils.timer_names_all_ranks_moments","page":"timer_utils","title":"moment_kinetics.timer_utils.timer_names_all_ranks_moments","text":"Nested SortedDict with the names of all timers that have been created on any MPI rank and added to the moments output file.\n\n\n\n\n\n","category":"constant"},{"location":"zz_timer_utils/#moment_kinetics.timer_utils.TimerNamesDict","page":"timer_utils","title":"moment_kinetics.timer_utils.TimerNamesDict","text":"\n\n\n\n","category":"type"},{"location":"zz_timer_utils/#moment_kinetics.timer_utils.format_global_timer-Tuple{}","page":"timer_utils","title":"moment_kinetics.timer_utils.format_global_timer","text":"format_global_timer(; show=true, truncate_output=true)\n\nManipulate a copy of the global_timer, to remove some things to reduce the clutter when it is printed.\n\nBy default the resulting TimerOutput is displayed in the terminal. Pass show_output=true to display the resulting TimerOutput in the terminal.\n\nBy default, the output is truncated, removing deeply nested timers and timers with very little time. To include all timers, pass truncate_output=false. The threshold for dropping timers is if their time is less than threshold times the total time.\n\nBy default, returns a string showing the contents of the TimerOutput. When show_output=true is passed, just returns the empty string.\n\n\n\n\n\n","category":"method"},{"location":"zz_timer_utils/#moment_kinetics.timer_utils.reset_mk_timers!-Tuple{}","page":"timer_utils","title":"moment_kinetics.timer_utils.reset_mk_timers!","text":"reset_mk_timers!()\n\nReset all global state of timers.\n\n\n\n\n\n","category":"method"},{"location":"zz_timer_utils/#moment_kinetics.timer_utils.timeit_debug_enabled-Tuple{}","page":"timer_utils","title":"moment_kinetics.timer_utils.timeit_debug_enabled","text":"timeit_debug_enabled()\n\n@timeit_debug uses a function defined in the enclosing module called timeit_debug_enabled() to decide whether to include debug timers (included if this function returns true, or not - with zero overhead - if it returns false).\n\nTo control the debug timers in moment_kinetics we define this function once, in timer_utils, and import it from there into any other modules that use @timeit_debug.\n\nTo activate debug timers, edit this function so that it returns true.\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#chebyshev","page":"chebyshev","title":"chebyshev","text":"","category":"section"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev","page":"chebyshev","title":"moment_kinetics.chebyshev","text":"\n\n\n\n","category":"module"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_base_info","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_base_info","text":"Chebyshev pseudospectral discretization\n\n\n\n\n\n","category":"type"},{"location":"zz_chebyshev/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Any, moment_kinetics.chebyshev.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, ff, adv_fac, spectral::chebyshev_info)\n\nChebyshev transform f to get Chebyshev spectral coefficients and use them to calculate f'.\n\nNote: Chebyshev derivative does not make use of upwinding information within each element.\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, moment_kinetics.chebyshev.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, ff, chebyshev::chebyshev_info)\n\nChebyshev transform f to get Chebyshev spectral coefficients and use them to calculate f'.\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.cheb_derivative_matrix_elementwise!-Tuple{Matrix{Float64}, Int64}","page":"chebyshev","title":"moment_kinetics.chebyshev.cheb_derivative_matrix_elementwise!","text":"derivative matrix for Gauss-Lobatto points using the analytical specification from  Chapter 8.2 from Trefethen 1994  https://people.maths.ox.ac.uk/trefethen/8all.pdf full list of Chapters may be obtained here  https://people.maths.ox.ac.uk/trefethen/pdetext.html\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.cheb_derivative_matrix_elementwise_radau_by_FFT!-Tuple{Matrix{Float64}, Vararg{Any, 5}}","page":"chebyshev","title":"moment_kinetics.chebyshev.cheb_derivative_matrix_elementwise_radau_by_FFT!","text":"Derivative matrix for Chebyshev-Radau grid using the FFT. Note that a similar function could be constructed for the  Chebyshev-Lobatto grid, if desired.\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_backward_transform!-NTuple{5, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_backward_transform!","text":"\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_derivative_single_element!-NTuple{7, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_derivative_single_element!","text":"\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_forward_transform!-NTuple{5, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_forward_transform!","text":"takes the real function ff on a Chebyshev grid in z (domain [-1, 1]), which corresponds to the domain [π, 2π] in variable theta = ArcCos(z). interested in functions of form f(z) = sumn cn Tn(z) using Tn(cos(theta)) = cos(ntheta) and z = cos(theta) gives f(z) = sumn cn cos(ntheta) thus a Chebyshev transform is equivalent to a discrete cosine transform doing this directly turns out to be slower than extending the domain from [0, 2pi] and using the fact that f(z) must be even (as cosines are all even) on this extended domain, can do a standard complex-to-complex fft fext is an array used to store f(theta) on the extended grid theta ∈ [0,2π) ff is f(theta) on the grid [π,2π] the Chebyshev coefficients of ff are calculated and stored in chebyf n is the number of grid points on the Chebyshev-Gauss-Lobatto grid transform is the plan for the complex-to-complex, in-place fft\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_radau_backward_transform!-NTuple{5, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_radau_backward_transform!","text":"\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_radau_points-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_radau_points","text":"returns the Chebyshev-Gauss-Radau grid points on an n point grid in the range (-1,1]\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_spectral_derivative!-Tuple{Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_spectral_derivative!","text":"use Chebyshev basis to compute the first derivative of f\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshevmoments-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshevmoments","text":"compute and return modified Chebyshev moments of the first kind: ∫dx Tᵢ(x) over range [-1,1]\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshevpoints-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshevpoints","text":"returns the Chebyshev-Gauss-Lobatto grid points on an n point grid in the range [-1,1]\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.clenshaw_curtis_weights-NTuple{6, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.clenshaw_curtis_weights","text":"returns wgts array containing the integration weights associated with all grid points for Clenshaw-Curtis quadrature\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.scaled_chebyshev_grid-NTuple{8, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.scaled_chebyshev_grid","text":"initialize chebyshev grid scaled to interval [-boxlength/2, boxlength/2] we no longer pass the boxlength to this function, but instead pass precomputed arrays elementscale and element_shift that are needed to compute the grid.\n\nname – the name of the coordinate that this is the grid for ngrid – number of points per element (including boundary points) nelementlocal – number of elements in the local (distributed memory MPI) grid n – total number of points in the local grid (excluding duplicate points) elementscale – the scale factor in the transform from the coordinates                   where the element limits are -1, 1 to the coordinate where                  the limits are Aj = coord.grid[imin[j]-1] and Bj = coord.grid[imax[j]]                  elementscale = 0.5*(Bj - Aj) elementshift – the centre of the element in the extended grid coordinate                  element_shift = 0.5*(Aj + Bj) imin – the array of minimum indices of each element on the extended grid.         By convention, the duplicated points are not included, so for element index j > 1         the lower boundary point is actually imin[j] - 1 imax – the array of maximum indices of each element on the extended grid.\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.setup_chebyshev_pseudospectral-Tuple{Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.setup_chebyshev_pseudospectral","text":"create arrays needed for explicit Chebyshev pseudospectral treatment and create the plans for the forward and backward fast Fourier transforms\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.update_df_chebyshev!-Tuple{Any, Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.update_df_chebyshev!","text":"compute the Chebyshev spectral coefficients of the spatial derivative of f\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.update_fcheby!-Tuple{Any, Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.update_fcheby!","text":"Chebyshev transform f to get Chebyshev spectral coefficients\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_constraints/#moment_constraints","page":"moment_constraints","title":"moment_constraints","text":"","category":"section"},{"location":"zz_moment_constraints/#moment_kinetics.moment_constraints","page":"moment_constraints","title":"moment_kinetics.moment_constraints","text":"Functions for enforcing integral constraints on the normalised distribution function. Ensures consistency of evolution split into moments and normalised distribution function.\n\n\n\n\n\n","category":"module"},{"location":"zz_moment_constraints/#moment_kinetics.moment_constraints.electron_implicit_constraint_forcing!-NTuple{7, Any}","page":"moment_constraints","title":"moment_kinetics.moment_constraints.electron_implicit_constraint_forcing!","text":"electron_implicit_constraint_forcing!(f_out, f_in, constraint_forcing_rate, vperp,\n                                      vpa, dt, ir)\n\nAdd terms to the electron kinetic equation that force the moment constraints to be approximately satisfied. Needed to avoid large errors when taking large, implicit timesteps that do not guarantee accurate time evolution.\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_constraints/#moment_kinetics.moment_constraints.get_electron_implicit_constraint_forcing_term-Tuple{moment_kinetics.moment_kinetics_structs.ElectronSubTerms}","page":"moment_constraints","title":"moment_kinetics.moment_constraints.get_electron_implicit_constraint_forcing_term","text":"get_electron_implicit_constraint_forcing_term(\n    f::AbstractArray{mk_float,3}, zeroth_moment::AbstractVector{mk_float},\n    first_moment::AbstractVector{mk_float},\n    second_moment::AbstractVector{mk_float}, z::coordinate, vperp::coordinate,\n    vpa::coordinate, constraint_forcing_rate::mk_float, ir::mk_int,\n    include::Symbol=:all)\n\nAdd the contributions corresponding to electron_implicit_constraint_forcing! to jacobian_matrix.\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_constraints/#moment_kinetics.moment_constraints.hard_force_moment_constraints!-NTuple{4, Any}","page":"moment_constraints","title":"moment_kinetics.moment_constraints.hard_force_moment_constraints!","text":"hard_force_moment_constraints!(f, moments, vpa)\n\nForce the moment constraints needed for the system being evolved to be applied to f. Not guaranteed to be a small correction, if f does not approximately obey the constraints to start with, but can be useful at initialisation to ensure a consistent initial state, and when applying boundary conditions.\n\nNote this function assumes the input is given at a single spatial position.\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_constraints/#moment_kinetics.moment_constraints.hard_force_moment_constraints_neutral!-Tuple{Any, Any, Any}","page":"moment_constraints","title":"moment_kinetics.moment_constraints.hard_force_moment_constraints_neutral!","text":"hard_force_moment_constraints_neutral!(f, moments, vz)\n\nForce the moment constraints needed for the system being evolved to be applied to f. Not guaranteed to be a small correction, if f does not approximately obey the constraints to start with, but can be useful at initialisation to ensure a consistent initial state, and when applying boundary conditions.\n\nNotes:\n\nthis function assumes the input is given at a single spatial position.\ncurrently only works with '1V' runs, where vz is the only velocity-space dimension\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_constraints/#moment_kinetics.moment_constraints.moment_constraints_on_residual!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Any, Any}} where {T, N}","page":"moment_constraints","title":"moment_kinetics.moment_constraints.moment_constraints_on_residual!","text":"moment_constraints_on_residual!(residual, f, moments, vpa)\n\nA 'residual' (used in implicit timestepping) is an update to the distribution function f_mathrmnew = f_mathrmold + mathttresidual. f_mathrmnew should obey the moment constraints (Constraints on normalized distribution function), and f_mathrmold already obeys the constraints, which means that the first 3 moments of residual should be zero. We impose this constraint by adding corrections proportional to f.\n\nr = hatr + (A + B w_ + C w_^2) f\n\nNote this function assumes the input is given at a single spatial position.\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#source_terms","page":"source_terms","title":"source_terms","text":"","category":"section"},{"location":"zz_source_terms/#moment_kinetics.source_terms","page":"source_terms","title":"moment_kinetics.source_terms","text":"\n\n\n\n","category":"module"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms!-NTuple{14, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms!","text":"calculate the source terms due to redefinition of the pdf to split off density, flow and/or pressure, and use them to update the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_manufactured!-NTuple{13, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_manufactured!","text":"advance the dfn with an arbitrary source function \n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_neutral!-NTuple{11, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_neutral!","text":"calculate the source terms due to redefinition of the pdf to split off density, flow and/or pressure, and use them to update the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_constants/#constants","page":"constants","title":"constants","text":"","category":"section"},{"location":"zz_constants/#moment_kinetics.constants","page":"constants","title":"moment_kinetics.constants","text":"Some physical constants\n\n\n\n\n\n","category":"module"},{"location":"zz_force_balance/#force_balance","page":"force_balance","title":"force_balance","text":"","category":"section"},{"location":"zz_force_balance/#moment_kinetics.force_balance","page":"force_balance","title":"moment_kinetics.force_balance","text":"\n\n\n\n","category":"module"},{"location":"zz_force_balance/#moment_kinetics.force_balance.force_balance!-NTuple{13, Any}","page":"force_balance","title":"moment_kinetics.force_balance.force_balance!","text":"use the force balance equation d(nu)/dt + d(ppar + nuparupar)/dz = -(dens/2)dphi/dz + Rdensi*densn(uparn-upari) to update the parallel particle flux densupar for each species\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetic_equations_electrons/#Moment-kinetic-equations-for-electrons","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"","category":"section"},{"location":"moment_kinetic_equations_electrons/#Moment-equations","page":"Moment kinetic equations for electrons","title":"Moment equations","text":"","category":"section"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"Quasineutrality gives","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nn_e = n_i\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"while the continuity equation is","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nfracpartial n_epartial t\n+ fracpartialpartial zleft( n_e u_eparallel right)\n= n_e n_n R_mathrmioniz + S_en\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"Subtracting from ion continuity and using quasineutrality","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nfracpartialpartial zleft(n_e (u_iparallel - u_eparallel) right)\n= S_in - S_en\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"giving an equation for u_eparallel. Assuming that the sources do not add any charge S_in = S_en then implies that u_eparallel = u_iparallel + u_0 assuming in addition (at least for the moment) that there is no current through the sheath sets u_0 = 0 so that","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nu_eparallel = u_iparallel\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"In the parallel momentum equation, the inertial terms can be neglected as they are O(m_em_i), leaving","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\n0 = -fracpartial p_eparallelpartial z\n     + e n_e fracpartial phipartial z\n     + F_eiparallel\n     + m_e int v_parallel C_en d^3 v\n     + S_emathrmmom\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"where C_en represents elastic electron-neutral collisions (for collisions see Electron collisions), which gives an equation for E_parallel = -partial phipartial z","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\ne E_parallel = -frac1n_e fracpartial p_eparallelpartial z\n                 + fracF_eiparalleln_e\n                 + fracm_en_e int v_parallel C_en d^3 v\n                 + frac1n_e S_emathrmmom \ne E_parallel = -frac1n_e fracpartial p_eparallelpartial z\n                 + m_e nu_ei left( u_iparallel - u_eparallel right)\n                 + frac1n_e S_emathrmmom \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"where the second line assumes the current Krook collision operator and neglects electron-neutral elastic collisions.","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"The energy equation is similar to the ion one","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nfrac32 fracpartial p_epartial t\n+ fracpartial q_eparallelpartial z\n+ p_eparallel fracpartial u_eparallelpartial z\n+ frac32 u_eparallel fracpartial p_epartial z\n+ frac32 p_e fracpartial u_eparallelpartial z nonumber \nquad= -E_mathrmioniz n_e n_n R_mathrmioniz\n        + int frac12 m_e boldsymbolv - u_eparallel hatboldsymbolz^2 C_ei d^3 v\n        + int frac12 m_e boldsymbolv - u_eparallel hatboldsymbolz^2 C_en d^3 v nonumber \nqquad + frac32 S_ep \n\nfrac32 fracpartial p_epartial t\n+ fracpartial q_eparallelpartial z\n+ p_eparallel fracpartial u_eparallelpartial z\n+ frac32 u_eparallel fracpartial p_epartial z\n+ frac32 p_e fracpartial u_eparallelpartial z nonumber \nquad= -E_mathrmioniz n_e n_n R_mathrmioniz\n        + 3 n_e fracm_em_i nu_ei left( T_i - T_e right)\n        + m_e n_e nu_ei left( u_iparallel - u_e_parallel right)^2 nonumber \nqquad + frac32 S_ep \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"To get the second version we treat the collision operators as described in Electron collisions.","category":"page"},{"location":"moment_kinetic_equations_electrons/#Electron-collisions","page":"Moment kinetic equations for electrons","title":"Electron collisions","text":"","category":"section"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"Currently electron-neutral elastic collisions C_en are not implemented.","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"Electron-electron collisions use a Krook operator","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nC_Kee = -nu_ee(n_eT_e) left(f_e - fracn_epi^32 v_Te^3 expleft(-fracboldsymbolv - u_eparallelhatboldsymbolz^2v_Te^2right) right)\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"with the electron-electron collision frequency","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nnu_ee(n_eT_e) = fracn_e e^4 logLambda_ee4 pi epsilon_0^2 m_e^2 v_Te^3\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"Electron-ion collisions also use a Krook operator","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nC_Kei = -nu_ei(n_eT_e) left(f_e - fracn_epi^32 v_Te^3 expleft(-fracboldsymbolv - u_iparallelhatboldsymbolz^2v_Te^2right) right)\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"with the electron-ion collision frequency","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nnu_ei(n_eT_e) = fracn_e e^4 logLambda_ei4 pi epsilon_0^2 m_e^2 v_Te^3\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"For the Krook operator, the friction is","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nF_eiparallel = -m_e int v_parallel C_Kei d^3 v nonumber \n                = m_e n_e nu_ei left( u_iparallel - u_eparallel right)\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"Energy exchange with ions is kept assuming the distributions are Maxwellian to allow different temperatures (this form comes from the Fokker-Planck collision operator assuming Maxwellian distributions)","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nint frac12 m_i boldsymbolv - u_iparallel hatboldsymbolz^2 C_ief_if_e d^3 v\napprox 3 fracn_e m_e nu_eim_i (T_e - T_i)\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"in the ion energy equation. In the electron energy equation, need the conversion","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nint frac12 m_e boldsymbolv - u_eparallel hatboldsymbolz^2 C_eif_ef_i d^3 v\n= int left(frac12 m_e v^2 - m_e u_eparallel v_parallel + underbracefrac12 m_e u_eparallel^2_=0text particle conservation right) C_ei d^3 v nonumber \n= -int frac12 m_i v^2 C_ie\n   - m_e u_eparallel underbraceint v_parallel C_ei d^3 v_F_eiparallelm_e nonumber \n= -int frac12 m_i boldsymbolv - u_iparallel hatboldsymbolz^2 C_ie d^3 v\n   - underbraceint m_i u_iparallel v_parallel C_ie d^3 v_textmomentum conservation  = u_iparallel (-F_ieparallel) = u_iparallel F_eiparallel\n   - F_eiparallel u_eparallel nonumber \n= 3 n_e fracm_em_i nu_ei left(T_i - T_e right) + F_eiparallel left(u_iparallel - u_eparallel right) \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/#1D2V-kinetic-equation","page":"Moment kinetic equations for electrons","title":"1D2V kinetic equation","text":"","category":"section"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"For the electrons u_eparallel sim u_iparallel by quasineutrality so u_eparallel sim v_Ti ll v_Te, which means we can neglect u_eparallel in most of the terms for evolution of f_e.","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"Similar to the ion shape function equation, but partial F_epartial t is negligible, i.e.  electrons move on timescales faster than the system evolution.","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\ndotz_e fracpartial F_epartial z\n+ dotw_parallele fracpartial F_epartial w_parallel\n+ dotw_perpe fracpartial F_epartial w_perp\n= dotF_e + mathcalC_ee + mathcalC_ei + mathcalC_en + mathcalS_e\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"where","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\ndotz_e = v_Te w_parallel \n\ndotw_parallele = frac1n_e m_e v_Te fracpartial p_eparallelpartial z\n                         + fracw_parallel3 p_e fracpartial q_eparallelpartial z\n                         - w_parallel^2 fracpartial v_T_epartial z nonumber \n                  quad - frac1m_e n_e v_Te (S_emathrmmom - m_e u_eparallel S_en)\n                         - fracw_parallel2 p_e (S_ep - T_e S_en) \n\ndotw_perpe = fracw_perp3 p_e fracpartial q_eparallelpartial z\n                     - w_perp w_parallel fracpartial v_Tepartial z nonumber \n              quad - fracw_perp2 p_e (S_ep - T_e S_en) \n\nfracdotF_eF_e = w_parallel left( 3 fracpartial v_Tepartial z - fracv_Ten_e fracpartial n_epartial z right)\n                         - frac1p_e fracpartial q_eparallelpartial z nonumber \n                  quad + frac32 p_e S_ep - frac52 n_e S_en \n\nmathcalC_ee = fracv_Te^3n_e C_Kee \n                 = -fracv_Te^3n_e nu_ee left( f_e - fracn_epi^32 v_Te^3 expleft( -fracboldsymbolv - u_eparallelhatboldsymbolz^2v_Te^2 right) right) \n                 = - nu_ee left( F_e - frac1pi^32 expleft( -w^2 right) right) \n\nmathcalC_ei = fracv_Te^3n_e C_Kei \n                 = -fracv_Te^3n_e nu_ei left( f_e - fracn_epi^32 v_Te^3 expleft( -fracboldsymbolv - u_iparallelhatboldsymbolz^2v_Te^2 right) right) \n                 = - nu_ei left( F_e - frac1pi^32 expleft( -left( w_parallel - frac(u_iparallel - u_eparallel)v_Te right)^2 - w_perp^2 right) right) \n\nmathcalC_en = textnot implemented yet \n\nmathcalS_e = fracv_Te^3n_e S_e \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"Although S_e should mostly be small in sqrtm_em_i, we keep it for the case when the source is a Maxwellian with a temperature significantly higher than the electron temperature because then the source can contribute significantly to the high energy tail of electrons. As we keep mathcal S_e, to ensure that the first 3 moments of the shape function equation vanish, we must also keep the source contributions to dot w_parallele, dot w_perpe, and dot F_eF_e in the same form as the ion equations.","category":"page"},{"location":"moment_kinetic_equations_electrons/#Reduction-to-1D1V","page":"Moment kinetic equations for electrons","title":"Reduction to 1D1V","text":"","category":"section"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"We can take the T_eperp=0 limit of the equations and marginalise over v_perp/w_perp to reduce to 1D1V in a very similar way as for the ions.","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"Quasineutrality and force balance keep the same form, and the energy equation becomes","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nfrac32 fracpartial p_epartial t\n+ fracpartial q_eparallelpartial z\n+ p_eparallel fracpartial u_eparallelpartial z\n+ frac32 u_eparallel fracpartial p_epartial z\n+ frac32 p_e fracpartial u_eparallelpartial z nonumber \nquad= -E_mathrmioniz n_e n_n R_mathrmioniz\n        + int frac12 m_e (v_parallel - u_eparallel)^2 barC_ei dv_parallel\n        + int frac12 m_e (v_parallel - u_eparallel)^2 barC_en dv_parallel nonumber \nqquad + frac32 S_ep \n\nfrac32 fracpartial p_epartial t\n+ fracpartial q_eparallelpartial z\n+ p_eparallel fracpartial u_eparallelpartial z\n+ frac32 u_eparallel fracpartial p_epartial z\n+ frac32 p_e fracpartial u_eparallelpartial z nonumber \nquad= -E_mathrmioniz n_e n_n R_mathrmioniz\n        + 3 n_e fracm_em_i nu_ei left( T_i - T_e right)\n        + m_e n_e nu_ei left( u_iparallel - u_e_parallel right)^2 nonumber \nqquad + frac32 S_ep \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"The kinetic equation for bar F_e = int F_e d^2 w_perp is","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\ndotz_e fracpartial barF_epartial z\n+ dotw_parallele fracpartial barF_epartial w_parallel\n= dotbarF_e\n   + barmathcalC_ee + barmathcalC_ei + barmathcalC_en\n   + barmathcalS_e\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\ndotz_e = v_Te w_parallel \n\ndotw_parallele = frac1n_e m_e v_Te fracpartial p_eparallelpartial z\n                         + fracw_parallel3 p_e fracpartial q_eparallelpartial z\n                         - w_parallel^2 fracpartial v_T_epartial z nonumber \n                  quad - frac1m_e n_e v_Te (S_emathrmmom - m_e u_eparallel S_en)\n                         - fracw_parallel2 p_e (S_ip - T_e S_en) \n\nfracdotbarF_ebarF_e = w_parallel left( fracpartial v_Tepartial z - fracv_Ten_e fracpartial n_epartial z right)\n                                     - frac13 p_e fracpartial q_eparallelpartial z nonumber \n                              quad + frac12 p_e S_ep\n                                     - frac32 n_e S_en \n\nbarmathcalC_ee = fracv_Ten_e barC_Kee \n                       = -fracv_Ten_e nu_ee left( barf_e - fracn_esqrtpi sqrt2 T_eparallelm_e expleft( -fracm_e (v_parallel - u_eparallel)^22 T_eparallel right) right) \n                       = - nu_ee left( barF_e - frac1sqrt3 pi expleft( - fracw_parallel^23 right) right) \n\nbarmathcalC_ei = fracv_Ten_e barC_Kei \n                       = -fracv_Ten_e nu_ei left( barf_e - fracn_esqrtpi sqrt2 T_eparallelm_e expleft( -fracm_e (v_parallel - u_iparallel)^22 T_eparallel right) right) \n                       = - nu_ei left( barF_e - frac1sqrt3 pi expleft( - fracleft( w_parallel - frac(u_iparallel - u_eparallel)v_Te right)^23 right) right) \n\nbarmathcalC_en = textnot implemented yet \n\nbarmathcalS_e = fracv_Ten_e barS_e = fracv_Ten_e int S_e d^2 v_perp \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"recalling that int w_perp fracpartial F_epartial w_perp d^2 w_perp = 2 bar F_e as for the ions, and noting that in the T_eperp = 0 limit, T_eparallel = T_e3 so that v_Te^2 = 2T_em_e = 6 T_eparallelm_e.","category":"page"},{"location":"moment_kinetic_equations_electrons/#Dimensionless-equations","page":"Moment kinetic equations for electrons","title":"Dimensionless equations","text":"","category":"section"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"We make the equations dimensionless using the conversions defined here.","category":"page"},{"location":"moment_kinetic_equations_electrons/#1D2V","page":"Moment kinetic equations for electrons","title":"1D2V","text":"","category":"section"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"The moment equations become","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nhatn_e = hatn_i \n\nhatu_eparallel = hatu_iparallel \n\nhatE_parallel = -frac1hatn_e fracpartial hatp_eparallelpartial hatz\n                     + frachatF_eiparallelhatn_e\n                     + frachatm_ehatn_e int hatv_parallel hatC_en d^3 hatv\n                     + frac1hatn_e hatS_emathrmmom \nhatE_parallel = -frac1hatn_e fracpartial hatp_eparallelpartial hatz\n                     + hatm_e hatnu_ei left( hatu_iparallel - hatu_eparallel right)\n                     + frac1hatn_e hatS_emathrmmom \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nfrac32 fracpartial hatp_epartial hatt\n+ fracpartial hatq_eparallelpartial hatz\n+ hatp_eparallel fracpartial hatu_eparallelpartial hatz\n+ frac32 hatu_eparallel fracpartial hatp_epartial hatz\n+ frac32 hatp_e fracpartial hatu_eparallelpartial hatz nonumber \nquad= -hatE_mathrmioniz hatn_e hatn_n hatR_mathrmioniz\n        + int frac12 hatm_e hatboldsymbolv - hatu_eparallel hatboldsymbolz^2 hatC_ei d^3 v\n        + int frac12 hatm_e hatboldsymbolv - hatu_eparallel hatboldsymbolz^2 hatC_en d^3 v nonumber \nqquad + frac32 hatS_ep \n\nfrac32 fracpartial hatp_epartial hatt\n+ fracpartial hatq_eparallelpartial hatz\n+ hatp_eparallel fracpartial hatu_eparallelpartial hatz\n+ frac32 hatu_eparallel fracpartial hatp_epartial hatz\n+ frac32 hatp_e fracpartial hatu_eparallelpartial hatz nonumber \nquad= -hatE_mathrmioniz hatn_e hatn_n hatR_mathrmioniz\n        + 3 hatn_e frachatm_ehatm_i hatnu_ei left( hatT_i - hatT_e right)\n        + hatm_e hatn_e hatnu_ei left( hatu_iparallel - hatu_e_parallel right)^2 nonumber \nqquad + frac32 hatS_ep \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"and the dimensionless kinetic equation is","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nhatdotz_e fracpartial F_epartial hatz\n+ hatdotw_parallele fracpartial F_epartial w_parallel\n+ hatdotw_perpe fracpartial F_epartial w_perp\n= hatdotF_e + hatmathcalC_ee + hatmathcalC_ei + hatmathcalC_en + hatmathcalS_e\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"where","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nhatdotz_e = hatv_Te w_parallel \n\nhatdotw_parallele = frac1hatn_e hatm_e hatv_Te fracpartial hatp_eparallelpartial hatz\n                               + fracw_parallel3 hatp_e fracpartial hatq_eparallelpartial hatz\n                               - w_parallel^2 fracpartial hatv_T_epartial hatz nonumber \n                        quad - frac1hatm_e hatn_e hatv_Te (S_emathrmmom - m_e u_eparallel S_en)\n                               - fracw_parallel2 hatp_e (hatS_ep - T_e S_en) \n\nhatdotw_perpe = fracw_perp3 hatp_e fracpartial hatq_eparallelpartial hatz\n                           - w_perp w_parallel fracpartial hatv_Tepartial hatz nonumber \n                    quad - fracw_perp2 hatp_e ()hatS_ep - T_e hatS_en) \n\nfrachatdotF_eF_e = w_parallel left( 3 fracpartial hatv_Tepartial hatz - frachatv_Tehatn_e fracpartial hatn_epartial hatz right)\n                               - frac1hatp_e fracpartial hatq_eparallelpartial hatz nonumber \n                        quad + frac32 hatp_e hatS_ep\n                               - frac52 hatn_e hatS_en \n\nhatmathcalC_ee = frachatv_Te^3hatn_e hatC_Kee \n                       = -frachatv_Te^3hatn_e hatnu_ee left( hatf_e - frachatn_epi^32 hatv_Te^3 expleft( -frachatboldsymbolv - hatu_eparallelhatboldsymbolz^2hatv_Te^2 right) right) \n                       = - hatnu_ee left( F_e - frac1pi^32 expleft( -w^2 right) right) \n\nhatmathcalC_ei = frachatv_Te^3hatn_e hatC_Kei \n                       = -frachatv_Te^3hatn_e hatnu_ei left( hatf_e - frachatn_epi^32 hatv_Te^3 expleft( -frachatboldsymbolv - hatu_iparallelhatboldsymbolz^2hatv_Te^2 right) right) \n                       = - hatnu_ei left( F_e - frac1pi^32 expleft( -left( w_parallel - frac(hatu_iparallel - hatu_eparallel)hatv_Te right)^2 - w_perp^2 right) right) \n\nhatmathcalC_en = textnot implemented yet \n\nhatmathcalS_e = frachatv_Te^3hatn_e hatS_e \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/#1D1V","page":"Moment kinetic equations for electrons","title":"1D1V","text":"","category":"section"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"In 1D1V the dimsionless energy equation is","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nfrac32 fracpartial hatp_epartial hatt\n+ fracpartial hatq_eparallelpartial hatz\n+ hatp_eparallel fracpartial hatu_eparallelpartial hatz\n+ frac32 hatu_eparallel fracpartial hatp_epartial hatz\n+ frac32 hatp_e fracpartial hatu_eparallelpartial hatz nonumber \nquad= -hatE_mathrmioniz hatn_e hatn_n hatR_mathrmioniz\n        + int frac12 hatm_e (hatv_parallel - hatu_eparallel)^2 hatbarC_ei dhatv_parallel\n        + int frac12 hatm_e (hatv_parallel - hatu_eparallel)^2 hatbarC_en dhatv_parallel nonumber \nqquad + frac32 hatbarS_ep \n\nfrac32 fracpartial hatp_epartial hatt\n+ fracpartial hatq_eparallelpartial hatz\n+ hatp_eparallel fracpartial hatu_eparallelpartial hatz\n+ frac32 hatu_eparallel fracpartial hatp_epartial hatz\n+ frac32 hatp_e fracpartial hatu_eparallelpartial hatz nonumber \nquad= -hatE_mathrmioniz hatn_e hatn_n hatR_mathrmioniz\n        + 3 hatn_e frachatm_ehatm_i hatnu_ei left( hatT_i - hatT_e right)\n        + hatm_e hatn_e hatnu_ei left( hatu_iparallel - hatu_e_parallel right)^2 nonumber \nqquad + frac32 hatbarS_ep \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"and the dimensionless kinetic equation is","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nhatdotz_e fracpartial barF_epartial hatz\n+ hatdotw_parallele fracpartial barF_epartial w_parallel\n= hatdotbarF_e\n   + hatbarmathcalC_ee + hatbarmathcalC_ei + hatbarmathcalC_en\n   + hatbarmathcalS_e\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nhatdotz_e = hatv_Te w_parallel \n\nhatdotw_parallele = frac1hatn_e hatm_e hatv_Te fracpartial hatp_eparallelpartial hatz\n                               + fracw_parallel3 hatp_e fracpartial hatq_eparallelpartial hatz\n                               - w_parallel^2 fracpartial hatv_T_epartial hatz nonumber \n                        quad - frac1hatm_e hatn_e hatv_Te (hatS_emathrmmom - hatm_e hatu_eparallel hatS_en)\n                               - fracw_parallel2 hatp_e (hatS_ep - hatT_e hatS_en) \n\nfrachatdotbarF_ebarF_e = w_parallel left( fracpartial hatv_Tepartial hatz - frachatv_Tehatn_e fracpartial hatn_epartial hatz right)\n                                     - frac13 hatp_e fracpartial hatq_eparallelpartial hatz nonumber \n                              quad + frac12 hatp_e hatS_ep\n                                     - frac32 hatn_e hatS_en \n\nhatbarmathcalC_ee = frachatv_Tehatn_e hatbarC_Kee \n                             = - hatnu_ee left( barF_e - frac1sqrt3 pi expleft( - fracw_parallel^23 right) right) \n\nhatbarmathcalC_ei = frachatv_Tehatn_e hatbarC_Kei \n                             = - hatnu_ei left( barF_e - frac1sqrt3 pi expleft( - fracleft( w_parallel - frac(hatu_iparallel - hatu_eparallel)hatv_Te right)^23 right) right) \n\nhatbarmathcalC_en = textnot implemented yet \n\nhatbarmathcalS_e = frachatv_Tehatn_e hatbarS_e = frachatv_Tehatn_e int hatS_e d^2 hatv_perp \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"The conversion to the dimensionless equations in the 1D1V Excalibur reports, and the original version of the code, uses the conversions given here.","category":"page"},{"location":"moment_kinetic_equations_electrons/#Old-1D1V-kinetic-electron-equations","page":"Moment kinetic equations for electrons","title":"Old 1D1V kinetic electron equations","text":"","category":"section"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"These were the form of equations implemented in the code for kinetic electrons before PR #322, April 2025.","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"<details>\n<summary style=\"text-align:center\">[ notes using old definitions and dimensionless variables ]</summary>","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nn_e = n_i \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nGamma_parallelmathrmnet(z=-L_z2) = (n_i(z=-L_z2) u_iparallel(z=-L_z2) - n_e(z=-L_z2) u_eparallel(z=-L_z2)) = 0 \nu_eparallel = fracleft( -Gamma_parallelmathrmnet(z=-L_z2) + n_i u_i right)n_e \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nE_parallel = - frac2n_e fracpartial p_eparallelpartial z \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nfracpartial p_eparallelpartial t\n  = -u_eparallel fracpartial p_eparallelpartial z\n     - 3 p_eparallel fracpartial u_eparallelpartial z\n     - fracpartial q_eparallelpartial z\n     + D_p_ez fracpartial^2 p_eparallelpartial z^2 + S_pe \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"where D_p_ez is a numerical diffusion coefficient, which we usually leave as 0.","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nfracpartial g_epartial t\n  + dotz fracpartial g_epartial z\n  + dotw_parallel fracpartial g_epartial w_parallel\n= dotg + mathcalD_mathrmnum + mathcalC_Ke + mathcalS_e\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"where","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\ndotz = v_Te w_parallel + u_eparallel \nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\ndotw_parallel\n= fracv_Te2 p_eparallel fracpartial p_eparallelpartial z + fracw_parallel2 p_eparallel fracpartial q_eparallelpartial z\n   - w_parallel^2 fracpartial v_Tepartial z\n   + fracS_ne u_eparalleln_e v_Te\n   - w_parallel fracS_pe + 2 u_eparallel S_mathrmmome2 p_eparallel\n   + w_parallel fracS_n2 n_e\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"Think this is missing a S_mathrmmome term that is not multiplied by w_parallel and has an extra one that is multiplied by w_parallel, but so far S_mathrmmoms is always zero anyway, so this doesn't matter.","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nfracdotg_eg_e\n= -frac12 p_eparallel fracpartial q_eparallelpartial z\n   - w_parallel v_Te left( frac1n_e fracpartial n_epartial z\n                               - frac1v_Te fracpartial v_Tepartial z right)\n   - frac3 S_n2 n_e + fracS_pe2 + S_mathrmmomep_eparallel\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nmathcalD_mathrmnum\n= D_w_parallele fracpartial^2 g_epartial w_parallel^2\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nmathcalC_Ke\n= nu_ee left g_e - expleft( -w_parallel^2 right) right\n   + nu_ei left g_e - expleft( -left( w_parallel + (u_iparallel - u_eparallel)v_Te right)^2 right) right\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"beginalign\nmathcalS_e\n= fracv_Ten_e S_e\nendalign","category":"page"},{"location":"moment_kinetic_equations_electrons/","page":"Moment kinetic equations for electrons","title":"Moment kinetic equations for electrons","text":"</details>","category":"page"},{"location":"zz_krook_collisions/#krook_collisions","page":"krook_collisions","title":"krook_collisions","text":"","category":"section"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions","page":"krook_collisions","title":"moment_kinetics.krook_collisions","text":"\n\n\n\n","category":"module"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions.electron_krook_collisions!-NTuple{10, Any}","page":"krook_collisions","title":"moment_kinetics.krook_collisions.electron_krook_collisions!","text":"Add Krook collision operator for electrons\n\nNote that this function operates on a single point in r, so pdf_out, pdf_in, dens_in, upar_in, upar_ion_in, and vth_in should have no r-dimension.\n\n\n\n\n\n","category":"method"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions.krook_collisions!-NTuple{8, Any}","page":"krook_collisions","title":"moment_kinetics.krook_collisions.krook_collisions!","text":"Add collision operator\n\nCurrently Krook collisions\n\n\n\n\n\n","category":"method"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions.setup_krook_collisions_input-Tuple{AbstractDict, Bool}","page":"krook_collisions","title":"moment_kinetics.krook_collisions.setup_krook_collisions_input","text":"Function for reading Krook collision operator input parameters.  Structure the namelist as follows.\n\n[krookcollisions] usekrook = true nuii0 = 1.0 frequency_option = \"manual\"\n\n\n\n\n\n","category":"method"},{"location":"zz_plot_MMS_sequence/#plot_MMS_sequence","page":"plot_MMS_sequence","title":"plot_MMS_sequence","text":"","category":"section"},{"location":"zz_plot_MMS_sequence/#plots_post_processing.plot_MMS_sequence","page":"plot_MMS_sequence","title":"plots_post_processing.plot_MMS_sequence","text":"\n\n\n\n","category":"module"},{"location":"zz_external_sources/#external_sources","page":"external_sources","title":"external_sources","text":"","category":"section"},{"location":"zz_external_sources/#moment_kinetics.external_sources","page":"external_sources","title":"moment_kinetics.external_sources","text":"Maxwellian source terms with spatially varying parameters representing external sources of particles and energy.\n\nNote there is no parallel momentum input from the external sources.\n\nThe sources can be controlled by a PI controller to set density to a target value or profile. Note that the PI controller should not be used with operator splitting - implementing it in a way that would be compatible with splitting is complicated because the source contributes to several terms.\n\n\n\n\n\n","category":"module"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_electron_source!-NTuple{12, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_electron_source!","text":"external_electron_source!(pdf_out, pdf_in, electron_density, electron_upar,\n                          moments, composition, electron_source, index, vperp,\n                          vpa, dt, ir)\n\nAdd external source term to the electron kinetic equation.\n\nNote that this function operates on a single point in r, given by ir, and pdf_out, pdf_in, electron_density, and electron_upar should have no r-dimension.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_electron_source_controller!-NTuple{6, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_electron_source_controller!","text":"external_electron_source_controller!(electron_external_source_controller_integral,\n                                     fvec_in, moments, electron_source_settings, dt)\n\nCalculate the amplitude, e.g. when using a PI controller for the density to set the external source amplitude.\n\nAs the electron density source must be equal to the ion density source in order not to inject charge into the simulation, the electron source (at least in some modes of operation) depends on the ion source, so external_ion_source_controller! must be called before this function is called so that moments.ion.external_source_amplitude is up to date.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_ion_source!-NTuple{9, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_ion_source!","text":"external_ion_source!(pdf, fvec, moments, ion_source_settings, vperp, vpa, dt)\n\nAdd external source term to the ion kinetic equation.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_ion_source_controller!-NTuple{7, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_ion_source_controller!","text":"external_ion_source_controller!(ion_external_source_controller_integral, fvec_in,\n                                moments, ion_source_settings, dt)\n\nCalculate the amplitude when using a PI controller for the density to set the external source amplitude.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_neutral_source!-NTuple{9, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_neutral_source!","text":"external_neutral_source!(pdf, fvec, moments, neutral_source_settings, vzeta, vr,\n                        vz, dt)\n\nAdd external source term to the neutral kinetic equation.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_neutral_source_controller!-NTuple{10, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_neutral_source_controller!","text":"external_neutral_source_controller!(neutral_external_source_controller_integral,\n                                    fvec_in, moments, neutral_source_settings, r, z,\n                                    dt)\n\nCalculate the amplitude when using a PI controller for the density to set the external source amplitude.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.get_source_profile-NTuple{4, Any}","page":"external_sources","title":"moment_kinetics.external_sources.get_source_profile","text":"get_source_profile(profile_type, width, min_val, coord)\n\nCreate a profile of type profile_type with width width for coordinate coord.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.initialize_external_source_amplitude!-NTuple{6, Any}","page":"external_sources","title":"moment_kinetics.external_sources.initialize_external_source_amplitude!","text":"initialize_external_source_amplitude!(moments, external_source_settings, vperp,\n                                      vzeta, vr, n_neutral_species)\n\nInitialize the arrays moments.ion.external_source_amplitude, moments.ion.external_source_density_amplitude, moments.ion.external_source_momentum_amplitude, moments.ion.external_source_pressure_amplitude, moments.electron.external_source_amplitude, moments.electron.external_source_density_amplitude, moments.electron.external_source_momentum_amplitude, moments.electron.external_source_pressure_amplitude, moments.neutral.external_source_amplitude, moments.neutral.external_source_density_amplitude, moments.neutral.external_source_momentum_amplitude, and moments.neutral.external_source_pressure_amplitude, using the settings in external_source_settings\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.initialize_external_source_controller_integral!-Tuple{Any, Any, Any}","page":"external_sources","title":"moment_kinetics.external_sources.initialize_external_source_controller_integral!","text":"function initializeexternalsourcecontrollerintegral!(              moments, externalsourcesettings, nneutralspecies)\n\nInitialize the arrays moments.ion.external_source_controller_integral and moments.neutral.external_source_controller_integral, using the settings in external_source_settings\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.setup_external_sources!-Tuple{Any, Any, Any, Any, Bool}","page":"external_sources","title":"moment_kinetics.external_sources.setup_external_sources!","text":"setup_external_sources!(input_dict, r, z)\n\nSet up parameters for the external sources using settings in input_dict.\n\nUpdates input_dict with defaults for unset parameters.\n\nr and z are the coordinates.coordinate objects for the r- and z-coordinates.\n\nReturns a NamedTuple (ion=ion_source_settings, neutral=neutral_source_settings) containing two NamedTuples of settings.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.total_external_electron_source_controllers!-NTuple{5, Any}","page":"external_sources","title":"moment_kinetics.external_sources.total_external_electron_source_controllers!","text":"total_external_electron_source_controllers!(electron_external_source_controller_integral,\n                                            fvec_in, moments, electron_sources, dt)\n\nContribute all of the electron source controllers to fvec_in, one by one.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.total_external_electron_sources!-NTuple{11, Any}","page":"external_sources","title":"moment_kinetics.external_sources.total_external_electron_sources!","text":"total_external_electron_sources!(pdf_out, pdf_in, electron_density, electron_upar,\n                                 moments, composition, electron_sources, vperp,\n                                 vpa, dt, ir)\n\nContribute all of the electron sources to the electron pdf, one by one.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.total_external_ion_source_controllers!-NTuple{6, Any}","page":"external_sources","title":"moment_kinetics.external_sources.total_external_ion_source_controllers!","text":"total_external_ion_source_controllers!(ion_external_source_controller_integral,\n                                       fvec_in, moments, ion_sources, dt)\n\nContribute all of the ion source controllers to fvec_in, one by one.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.total_external_ion_sources!-NTuple{8, Any}","page":"external_sources","title":"moment_kinetics.external_sources.total_external_ion_sources!","text":"total_external_ion_sources!(pdf, fvec, moments, ion_sources, vperp, vpa, dt, scratch_dummy)\n\nContribute all of the ion sources to the ion pdf, one by one.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.total_external_neutral_source_controllers!-NTuple{9, Any}","page":"external_sources","title":"moment_kinetics.external_sources.total_external_neutral_source_controllers!","text":"total_external_neutral_source_controllers!(neutral_external_source_controller_integral,\n                                           fvec_in, moments, neutral_sources, dt)\n\nContribute all of the neutral source controllers to fvec_in, one by one.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.total_external_neutral_sources!-NTuple{8, Any}","page":"external_sources","title":"moment_kinetics.external_sources.total_external_neutral_sources!","text":"total_external_neutral_sources!(pdf, fvec, moments, ion_sources, vperp, vpa, dt, scratch_dummy)\n\nContribute all of the neutral sources to the neutral pdf, one by one.\n\n\n\n\n\n","category":"method"},{"location":"zz_clenshaw_curtis/#clenshaw_curtis","page":"clenshaw_curtis","title":"clenshaw_curtis","text":"","category":"section"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis","text":"\n\n\n\n","category":"module"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis.chebyshevpoints-Tuple{Any}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.chebyshevpoints","text":"\n\n\n\n","category":"method"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis.clenshawcurtisnodes-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.clenshawcurtisnodes","text":"Compute nodes of the Clenshaw—Curtis quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis.clenshawcurtisweights-Tuple{}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.clenshawcurtisweights","text":"Compute weights of the Clenshaw—Curtis quadrature rule with modified Chebyshev moments of the first kind (μ)\n\n\n\n\n\n","category":"method"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis.plan_clenshawcurtis-Tuple{Any}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.plan_clenshawcurtis","text":"\n\n\n\n","category":"method"},{"location":"zz_loop_ranges_struct/#loop_ranges_struct","page":"loop_ranges_struct","title":"loop_ranges_struct","text":"","category":"section"},{"location":"zz_loop_ranges_struct/#moment_kinetics.loop_ranges_struct.loop_ranges","page":"loop_ranges_struct","title":"moment_kinetics.loop_ranges_struct.loop_ranges","text":"module variable that we can access by giving fully-qualified name in loop macros\n\n\n\n\n\n","category":"constant"},{"location":"zz_loop_ranges_struct/#moment_kinetics.loop_ranges_struct.loop_ranges_store","page":"loop_ranges_struct","title":"moment_kinetics.loop_ranges_struct.loop_ranges_store","text":"module variable used to store LoopRanges that are swapped into the loopranges variable in @begin*_region() functions\n\n\n\n\n\n","category":"constant"},{"location":"zz_loop_ranges_struct/#moment_kinetics.loop_ranges_struct.LoopRanges","page":"loop_ranges_struct","title":"moment_kinetics.loop_ranges_struct.LoopRanges","text":"LoopRanges structs contain information on which points should be included on this process in loops over shared-memory arrays.\n\nMembers\n\nparalleldims::Tuple{Vararg{Symbol}}        Indicates which dimensions are (or might be) parallelized when using        this LoopRanges. Provided for information for developers, to make it        easier to tell (when using a Debugger, or printing debug informatino)        which LoopRanges instance is active in looping.loopranges at any point        in the code. rank0::Bool        Is this process the one with rank 0 in the 'block' which work in        parallel on shared memory arrays. <d>::UnitRange{mkint}        Loop ranges for each dimension <d> in looping.alldimensions.\n\n\n\n\n\n","category":"type"},{"location":"zz_lagrange_polynomials/#lagrange_polynomials","page":"lagrange_polynomials","title":"lagrange_polynomials","text":"","category":"section"},{"location":"zz_lagrange_polynomials/#moment_kinetics.lagrange_polynomials","page":"lagrange_polynomials","title":"moment_kinetics.lagrange_polynomials","text":"Lagrange polynomials can be useful for finite element methods on any set of basis points, as they give a representation of the interpolating function within an element whose coefficients are just the function values at the grid points.\n\nThis module collects some functions related to the use of Lagrange polynomials, to avoid their being scattered (and possibly duplicated) in other modules.\n\n\n\n\n\n","category":"module"},{"location":"zz_lagrange_polynomials/#moment_kinetics.lagrange_polynomials.lagrange_poly-Tuple{Any, Any, Any}","page":"lagrange_polynomials","title":"moment_kinetics.lagrange_polynomials.lagrange_poly","text":"Lagrange polynomial args: j - index of lj from list of nodes xnodes - array of x node values x - point where interpolated value is returned\n\n\n\n\n\n","category":"method"},{"location":"zz_lagrange_polynomials/#moment_kinetics.lagrange_polynomials.lagrange_poly_derivative_optimised-Tuple{Any, Any, Any}","page":"lagrange_polynomials","title":"moment_kinetics.lagrange_polynomials.lagrange_poly_derivative_optimised","text":"lagrange_poly_derivative_optimised(other_nodes, one_over_denominator, x)\n\nOptimised calculation of the first derivative of a Lagrange polynomial, making use of pre-calculated quantities.\n\nother_nodes is a vector of the grid points in this element where this Lagrange polynomial is zero (the other nodes than the one where it is 1).\n\none_over_denominator is 1/prod(x0 - n for n ∈ other_nodes) where x0 is the grid point where this Lagrange polynomial is 1.\n\nx is the point to evaluate the Lagrange polynomial at.\n\n\n\n\n\n","category":"method"},{"location":"zz_lagrange_polynomials/#moment_kinetics.lagrange_polynomials.lagrange_poly_optimised-Tuple{Any, Any, Any}","page":"lagrange_polynomials","title":"moment_kinetics.lagrange_polynomials.lagrange_poly_optimised","text":"lagrange_poly_optimised(other_nodes, one_over_denominator, x)\n\nOptimised version of Lagrange polynomial calculation, making use of pre-calculated quantities.\n\nother_nodes is a vector of the grid points in this element where this Lagrange polynomial is zero (the other nodes than the one where it is 1).\n\none_over_denominator is 1/prod(x0 - n for n ∈ other_nodes) where x0 is the grid point where this Lagrange polynomial is 1.\n\nx is the point to evaluate the Lagrange polynomial at.\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing","page":"plots_post_processing","title":"plots_post_processing","text":"","category":"section"},{"location":"zz_plots_post_processing/#plots_post_processing.plots_post_processing","page":"plots_post_processing","title":"plots_post_processing.plots_post_processing","text":"\n\n\n\n","category":"module"},{"location":"zz_plots_post_processing/#plots_post_processing.allocate_global_zr_fields-Tuple{Any, Any, Any}","page":"plots_post_processing","title":"plots_post_processing.allocate_global_zr_fields","text":"functions to allocate arrays that are used at run-time to postprocess data that is stored in the netcdf files\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.analyze_and_plot_data-Tuple","page":"plots_post_processing","title":"plots_post_processing.analyze_and_plot_data","text":"analyze_and_plot_data(prefix...; run_index=nothing)\n\nMake some plots for the simulation at prefix. If more than one argument is passed to prefix, plot all the simulations together.\n\nThe strings passed to prefix should be either a directory (which contains run output) or the prefix of output files, like <directory>/<prefix> where the output files are <directory>/<prefix>.moments.h5 and <directory>/<prefix>.dfns.h5.\n\nIf a single value is passed for prefix the plots/movies are created in the same directory as the run, and given names based on the name of the run. If multiple values are passed, the plots/movies are given names beginning with compare_ and are created in the comparison_plots/ subdirectory.\n\nBy default plots output from all restarts in a directory. To select a single run, pass the run_index argument - the value corresponds to the _<i> suffix given to output files when restarting. run_index can be an integer (which is applied to all directories in prefix...), or a tuple of integers (which should have the same length as the number of directories passed to prefix...). Use run_index=-1 to get the most recent run (which does not have a _<i> suffix). Note that run_index is only used when a directory (rather than the prefix of a specific output file) is passed to prefix...\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.calculate_differences-Tuple","page":"plots_post_processing","title":"plots_post_processing.calculate_differences","text":"Find the maximum difference, as a function of time, between two or more outputs for each variable.\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.compare_fields_symbolic_test-NTuple{13, Any}","page":"plots_post_processing","title":"plots_post_processing.compare_fields_symbolic_test","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.draw_v_parallel_zero!-Tuple{Plots.Plot, AbstractVector, Any, Any, Bool, Bool}","page":"plots_post_processing","title":"plots_post_processing.draw_v_parallel_zero!","text":"Add a thin, red, dashed line showing vparallel=(vth*wparallel+upar)=0 to a 2d plot with axes (z,vpa).\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.get_tuple_of_return_values-Tuple{Any, Vararg{Any}}","page":"plots_post_processing","title":"plots_post_processing.get_tuple_of_return_values","text":"get_tuple_of_return_values(func, arg_tuples...)\n\nSuppose func(args...) returns a tuple of return values, then get_tuple_of_return_values(func, arg_tuples...) returns a tuple (with an entry for each return value of func) of tuples (one for each argument in each of arg_tuples...) of return values.\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.init_postprocessing_options-NTuple{10, Any}","page":"plots_post_processing","title":"plots_post_processing.init_postprocessing_options","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_1D_1V_diagnostics-NTuple{52, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_1D_1V_diagnostics","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_dfns-NTuple{21, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_dfns","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_fields-NTuple{11, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_fields","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_ion_pdf-NTuple{21, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_ion_pdf","text":"plots various slices of the ion pdf (1d and 2d, stills and animations)\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_moments-NTuple{25, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_moments","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_neutral_pdf-NTuple{23, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_neutral_pdf","text":"plots various slices of the neutral pdf (1d and 2d, stills and animations)\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.read_distributed_zwallr_data!-Union{Tuple{N}, Tuple{Array{Float64, N}, String, Tuple, String, Tuple, Int64, Int64, String}} where N","page":"plots_post_processing","title":"plots_post_processing.read_distributed_zwallr_data!","text":"Read data which is a function of (r,t) or (r,species,t) and associated to one of the wall boundaries\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.trygif-Tuple{Any, Any}","page":"plots_post_processing","title":"plots_post_processing.trygif","text":"Call gif, but catch the exception if there is an error\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.trysavefig-Tuple{Any}","page":"plots_post_processing","title":"plots_post_processing.trysavefig","text":"Call savefig, but catch the exception if there is an error\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.post_processing_input","page":"plots_post_processing","title":"plots_post_processing.post_processing_input","text":"\n\n\n\n","category":"module"},{"location":"zz_plots_post_processing/#plots_post_processing.shared_utils.calculate_and_write_frequencies-NTuple{9, Any}","page":"plots_post_processing","title":"plots_post_processing.shared_utils.calculate_and_write_frequencies","text":"\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#fokker_planck","page":"fokker_planck","title":"fokker_planck","text":"","category":"section"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck","page":"fokker_planck","title":"moment_kinetics.fokker_planck","text":"Module for including the Full-F Fokker-Planck Collision Operator.\n\nThe functions in this module are split into two groups. \n\nThe first set of functions implement the weak-form Collision operator using the Rosenbluth-MacDonald-Judd formulation in a divergence form. The Green's functions for the Rosenbluth potentials are used to obtain the Rosenbluth potentials at the boundaries. To find the potentials everywhere else elliptic solves of the PDEs for the Rosenbluth potentials are performed with Dirichlet boundary conditions. These routines provide the default collision operator used in the code.\n\nThe second set of functions are used to set up the necessary arrays to  compute the Rosenbluth potentials everywhere in vpa, vperp by direct integration of the Green's functions. These functions are  supported for the purposes of testing and debugging.\n\nLower-level routines are provided by functions from moment_kinetics.fokker_planck_calculus.\n\nParallelisation of the collision operator uses a special 'anysv' region type, see Collision operator and anysv region.\n\n\n\n\n\n","category":"module"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.allocate_fokkerplanck_arrays_direct_integration-Tuple{Any, Any}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.allocate_fokkerplanck_arrays_direct_integration","text":"Function that allocates the required ancilliary arrays for direct integration routines.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.calculate_entropy_production!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Int64, Int64, Int64}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.calculate_entropy_production!","text":"Function to calculate entropy production, in place.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.conserving_corrections!-NTuple{4, Any}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.conserving_corrections!","text":"Function that applies numerical-error correcting terms to ensure numerical conservation of the moments density, upar, pressure in the self-collision operator. Modifies the collision operator such that the operator becomes\n\nC_ss = C^ast_ssF_sF_s - left(x_0 + x_1(v_-u_)+ x_2(v_perp^2 +(v_-u_)^2)right)F_s\n\nwhere C^ast_ssF_sF_s is the weak-form self-collision operator computed using  the finite-element implementation, u_ is the parallel velocity of F_s, and x_0x_1x_2 are parameters that are chosen so that C_ss conserves density, parallel velocity and pressure of F_s.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.density_conserving_correction!-NTuple{4, Any}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.density_conserving_correction!","text":"Function that applies a numerical-error correcting term to ensure numerical conservation of the density in the collision operator.\n\nC_ss^prime = C^ast_ssF_sF_s^prime - x_0 F_s\n\nwhere C^ast_ssF_sF_s^prime is the weak-form collision operator computed using  the finite-element implementation.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.explicit_fokker_planck_collisions_weak_form!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, moment_kinetics.fokker_planck_calculus.fokkerplanck_weakform_arrays_struct, Vararg{Any, 7}}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.explicit_fokker_planck_collisions_weak_form!","text":"Function for advancing with the explicit, weak-form, self-collision operator.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.explicit_fp_collisions_weak_form_Maxwellian_cross_species!-Tuple{Any, Any, Any, Any, Any, Any, moment_kinetics.fokker_planck_calculus.fokkerplanck_weakform_arrays_struct, Vararg{Any, 6}}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.explicit_fp_collisions_weak_form_Maxwellian_cross_species!","text":"Function for advancing with the explicit, weak-form, self-collision operator using the existing method for computing the Rosenbluth potentials, with the addition of cross-species collisions against fixed Maxwellian distribution functions where the Rosenbluth potentials are specified using analytical results.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.fokker_planck_collision_operator_weak_form!-Tuple{Any, Any, Any, Any, Any, moment_kinetics.fokker_planck_calculus.fokkerplanck_weakform_arrays_struct, Vararg{Any, 4}}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.fokker_planck_collision_operator_weak_form!","text":"Function for evaluating C_ss = C_ssF_sF_s\n\nThe result is stored in the array fkpl_arrays.CC.\n\nThe normalised collision frequency for collisions between species s and s' is defined by\n\ntildenu_ss = fracL_mathrmrefc_mathrmreffracgamma_ss n_mathrmrefm_s^2 c_mathrmref^3\n\nwith gamma_ss = 2 pi (Z_s Z_s)^2 e^4 ln Lambda_ss  (4 pi epsilon_0)^2. The input parameter to this code is \n\ntildenu_ii = fracL_mathrmrefc_mathrmreffracgamma_mathrmref n_mathrmrefm_mathrmref^2 c_mathrmref^3\n\nwith gamma_mathrmref = 2 pi e^4 ln Lambda_ii  (4 pi epsilon_0)^2. This means that tildenu_ss = (Z_s Z_s)^2tildenu_mathrmref and this conversion is handled explicitly in the code with the charge number input provided by the user.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.fokker_planck_collision_operator_weak_form_Maxwellian_Fsp!-Tuple{Any, Float64, Float64, Float64, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, moment_kinetics.fokker_planck_calculus.fokkerplanck_weakform_arrays_struct, Vararg{Any, 4}}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.fokker_planck_collision_operator_weak_form_Maxwellian_Fsp!","text":"Function for computing the collision operator\n\nsum_s^prime CF_sF_s^prime\n\nwhen F_s^prime is an analytically specified Maxwellian distribution and the corresponding Rosenbluth potentials are specified using analytical results.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.init_fokker_planck_collisions_direct_integration-Tuple{Any, Any}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.init_fokker_planck_collisions_direct_integration","text":"Function that initialises the arrays needed to calculate the Rosenbluth potentials by direct integration. As this function is only supported to keep the testing of the direct integration method, the struct 'fka' created here does not contain all of the arrays necessary to compute the weak-form operator. This functionality could be ported if necessary.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.init_fokker_planck_collisions_weak_form-NTuple{4, Any}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.init_fokker_planck_collisions_weak_form","text":"Function that initialises the arrays needed for Fokker Planck collisions using numerical integration to compute the Rosenbluth potentials only at the boundary and using an elliptic solve to obtain the potentials  in the rest of the velocity space domain.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.moment_kinetic_collision_frequency_prefactor-Tuple{Float64, Float64, Bool, Bool}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.moment_kinetic_collision_frequency_prefactor","text":"Function to account for the normalisation of the moment kinetic normalised distribution function by multiplying the input collision frequency by the normalisation factors.\n\nOnly applicable for self collisions.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.setup_fkpl_collisions_input-Tuple{AbstractDict, Bool}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.setup_fkpl_collisions_input","text":"Function for reading Fokker Planck collision operator input parameters.  Structure the namelist as follows.\n\n[fokker_planck_collisions]\nuse_fokker_planck = true\nnuii = 1.0\nfrequency_option = \"manual\"\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.setup_fp_nl_solve-Tuple{Bool, OrderedCollections.OrderedDict{String, Any}, Any}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.setup_fp_nl_solve","text":"Function to setup nonlinear_solver struct for implicit Fokker-Planck collisions. An input namelist of form\n\n    [fokker_planck_collisions_nonlinear_solver]\n    atol = 1.0e-10\n    rtol = 0.0\n    ...\n\nis used, with the same defaults as the main [nonlinear_solver] namelist, apart from atol and rtol, which are set to their own defaults here.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.symmetric_matrix_inverse-NTuple{8, Any}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.symmetric_matrix_inverse","text":"Function that solves A x = b for a matrix of the form\n\nbeginarrayccc\nA_00  0  A_02 \n0  A_11  A_12 \nA_02  A_12  A_22 \nendarray\n\nappropriate for the moment numerical conserving terms used in the Fokker-Planck collision operator.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.symmetric_matrix_inverse-NTuple{9, Any}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.symmetric_matrix_inverse","text":"Function that solves A x = b for a matrix of the form\n\nbeginarrayccc\nA_00  A_01  A_02 \nA_01  A_11  A_12 \nA_02  A_12  A_22 \nendarray\n\nappropriate for moment numerical conserving terms.\n\n\n\n\n\n","category":"method"},{"location":"zz_reference_parameters/#reference_parameters","page":"reference_parameters","title":"reference_parameters","text":"","category":"section"},{"location":"zz_reference_parameters/#moment_kinetics.reference_parameters","page":"reference_parameters","title":"moment_kinetics.reference_parameters","text":"Reference parameters\n\nReference parameters are not needed or used by the main part of the code, but define the physical units of the simulation, and are needed for a few specific steps during setup (e.g. calculation of normalised collision frequency).\n\n\n\n\n\n","category":"module"},{"location":"zz_reference_parameters/#moment_kinetics.reference_parameters.get_reference_collision_frequency_ee-Tuple{Any}","page":"reference_parameters","title":"moment_kinetics.reference_parameters.get_reference_collision_frequency_ee","text":"Calculate normalized electron-electron collision frequency for Coulomb collisions using reference density, mass and speed. Note this is not the thermal collision frequency evaluated with reference parameters, but rather the quantity that when multiplied by hatnsv_Ts^3 gives the de-dimensionalised thermal collision frequency - the difference is a factor of 2^32.\n\n\n\n\n\n","category":"method"},{"location":"zz_reference_parameters/#moment_kinetics.reference_parameters.get_reference_collision_frequency_ei-Tuple{Any}","page":"reference_parameters","title":"moment_kinetics.reference_parameters.get_reference_collision_frequency_ei","text":"Calculate normalized electron-ion collision frequency for Coulomb collisions using reference density, mass and speed. Note this is not the thermal collision frequency evaluated with reference parameters, but rather the quantity that when multiplied by hatnsv_Ts^3 gives the de-dimensionalised thermal collision frequency - the difference is a factor of 2^32.\n\nCurrently valid only for hydrogenic ions (Z=1)\n\n\n\n\n\n","category":"method"},{"location":"zz_reference_parameters/#moment_kinetics.reference_parameters.get_reference_collision_frequency_ii-Tuple{Any}","page":"reference_parameters","title":"moment_kinetics.reference_parameters.get_reference_collision_frequency_ii","text":"Calculate normalized ion-ion collision frequency for Coulomb collisions using reference density, mass and speed. Note this is not the thermal collision frequency evaluated with reference parameters, but rather the quantity that when multiplied by hatnsv_Ts^3 gives the de-dimensionalised thermal collision frequency - the difference is a factor of 2^32.\n\nCurrently valid only for hydrogenic ions (Z=1)\n\n\n\n\n\n","category":"method"},{"location":"zz_reference_parameters/#moment_kinetics.reference_parameters.setup_reference_parameters-Tuple{Any, Bool}","page":"reference_parameters","title":"moment_kinetics.reference_parameters.setup_reference_parameters","text":"\n\n\n\n","category":"method"},{"location":"zz_electron_fluid_equations/#electron_fluid_equations","page":"electron_fluid_equations","title":"electron_fluid_equations","text":"","category":"section"},{"location":"zz_electron_fluid_equations/#moment_kinetics.electron_fluid_equations.calculate_Epar_from_electron_force_balance!-NTuple{11, Any}","page":"electron_fluid_equations","title":"moment_kinetics.electron_fluid_equations.calculate_Epar_from_electron_force_balance!","text":"solve the electron force balance (parallel momentum) equation for the parallel electric field, Epar:     Epar = -dphi/dz = (2/ne) * (-dppare/dz + frictionforce + ne * me  * nn * Ren * (un - ue))     NB: in 1D only Epar is needed for update of ion pdf, so boundary phi is irrelevant inputs:     dense = electron density     dppardz = zed derivative of electron parallel pressure     nuei = electron-ion collision frequency     friction = electron-ion parallel friction force     nneutralspecies = number of evolved neutral species     chargeexchange = electron-neutral charge exchange frequency     meovermi = electron-ion mass ratio     densn = neutral density     uparn = neutral parallel flow     upare = electron parallel flow output:     Epar = parallel electric field\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_fluid_equations/#moment_kinetics.electron_fluid_equations.calculate_electron_density!-Tuple{Any, Any, Any}","page":"electron_fluid_equations","title":"moment_kinetics.electron_fluid_equations.calculate_electron_density!","text":"use quasineutrality to obtain the electron density from the initial densities of the various ion species:     sumi densi = dense inputs:     dense = electron density at previous time level     updated = flag indicating if the electron density is updated     densi = updated ion density output:     dense = updated electron density     updated = flag indicating that the electron density has been updated\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_fluid_equations/#moment_kinetics.electron_fluid_equations.calculate_electron_parallel_friction_force!-NTuple{8, Any}","page":"electron_fluid_equations","title":"moment_kinetics.electron_fluid_equations.calculate_electron_parallel_friction_force!","text":"\n\n\n\n","category":"method"},{"location":"zz_electron_fluid_equations/#moment_kinetics.electron_fluid_equations.calculate_electron_ppar_no_r!-NTuple{10, Any}","page":"electron_fluid_equations","title":"moment_kinetics.electron_fluid_equations.calculate_electron_ppar_no_r!","text":"calculate the electron parallel pressure\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_fluid_equations/#moment_kinetics.electron_fluid_equations.calculate_electron_qpar!-NTuple{11, Any}","page":"electron_fluid_equations","title":"moment_kinetics.electron_fluid_equations.calculate_electron_qpar!","text":"calculate the parallel component of the electron heat flux. there are currently two supported options for the parallel heat flux:     Braginskii collisional closure - qpare = -3.16*pe/(me*nuei)dT/dz - 0.71pe*(upari-upare)     collisionless closure - d(qpare)/dz = 0 ==> qpare = constant inputs:     qpare = parallel electron heat flux at the previous time level     qparupdated = flag indicating whether qpar is updated already     pdf = electron pdf     pe = electron pressure     upare = electron parallel flow     vthe = electron thermal speed     dTedz = zed derivative of electron temperature     upari = ion parallel flow     nuei = electron-ion collision frequency     meovermi = electron-to-ion mass ratio     electronmodel = choice of model for electron physics      vpa = struct containing information about the vpa coordinate output:     qpare = updated parallel electron heat flux     qparupdated = flag indicating that the parallel electron heat flux is updated\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_fluid_equations/#moment_kinetics.electron_fluid_equations.calculate_electron_qpar_from_pdf!-NTuple{7, Any}","page":"electron_fluid_equations","title":"moment_kinetics.electron_fluid_equations.calculate_electron_qpar_from_pdf!","text":"calculate the parallel component of the electron heat flux, defined as qpar = 0.5 * dens * vth^3 * int dwpa (pdf * wpa * (wpa^2 + wperp^2))\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_fluid_equations/#moment_kinetics.electron_fluid_equations.calculate_electron_qpar_from_pdf_no_r!-NTuple{8, Any}","page":"electron_fluid_equations","title":"moment_kinetics.electron_fluid_equations.calculate_electron_qpar_from_pdf_no_r!","text":"Calculate the parallel component of the electron heat flux, defined as qpar = 0.5 * dens * vth^3 * int dwpa (pdf * wpa * (wpa^2 + wperp^2)). This version of the function does not loop over r. pdf should have no r-dimension, while the moment variables are indexed at ir.\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_fluid_equations/#moment_kinetics.electron_fluid_equations.calculate_electron_upar_from_charge_conservation!-NTuple{8, Any}","page":"electron_fluid_equations","title":"moment_kinetics.electron_fluid_equations.calculate_electron_upar_from_charge_conservation!","text":"use charge conservation equation to solve for the electron parallel flow density:     d/dz(sumi ni upari - ne upare) = 0     ==> {sumi ni upari}(z) - {sumi ni upari}(zbound) = {ne upare}(z) - {ne upare}(zbound) inputs:      upare = should contain updated electron parallel flow at boundaries in zed     updated = flag indicating whether the electron parallel flow is already updated     dense = electron particle density     upari = ion parallel flow density     densi = ion particle density output:     upare = contains the updated electron parallel flow\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_fluid_equations/#moment_kinetics.electron_fluid_equations.electron_braginskii_conduction!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, Vararg{Any, 8}}","page":"electron_fluid_equations","title":"moment_kinetics.electron_fluid_equations.electron_braginskii_conduction!","text":"Add just the braginskii conduction contribution to the electron pressure, and assume that we have to calculate qpar and dqpar_dz from p within this function (they are not pre-calculated).\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_fluid_equations/#moment_kinetics.electron_fluid_equations.electron_energy_equation!-NTuple{20, Any}","page":"electron_fluid_equations","title":"moment_kinetics.electron_fluid_equations.electron_energy_equation!","text":"use the electron energy or temperature equation to evolve the electron temperature via an explicit time advance. NB: so far, this is only set up for 1D problem.\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_fluid_equations/#moment_kinetics.electron_fluid_equations.electron_energy_equation_no_r!-NTuple{20, Any}","page":"electron_fluid_equations","title":"moment_kinetics.electron_fluid_equations.electron_energy_equation_no_r!","text":"\n\n\n\n","category":"method"},{"location":"zz_electron_fluid_equations/#moment_kinetics.electron_fluid_equations.electron_fluid_qpar_boundary_condition!-NTuple{5, Any}","page":"electron_fluid_equations","title":"moment_kinetics.electron_fluid_equations.electron_fluid_qpar_boundary_condition!","text":"electron_fluid_qpar_boundary_condition!(electron_moments, z)\n\nImpose fluid approximation to electron sheath boundary condition on the parallel heat flux. See Stangeby textbook, equations (2.89) and (2.90).\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_z_advection/#neutral_z_advection","page":"neutral_z_advection","title":"neutral_z_advection","text":"","category":"section"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection.neutral_advection_z!-NTuple{14, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.neutral_advection_z!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection.update_speed_neutral_z!-NTuple{11, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.update_speed_neutral_z!","text":"calculate the advection speed in the z-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_grid_transforms/#velocity_grid_transforms","page":"velocity_grid_transforms","title":"velocity_grid_transforms","text":"","category":"section"},{"location":"zz_velocity_grid_transforms/#moment_kinetics.velocity_grid_transforms","page":"velocity_grid_transforms","title":"moment_kinetics.velocity_grid_transforms","text":"\n\n\n\n","category":"module"},{"location":"manual_setup/#Manual-setup","page":"Manual setup","title":"Manual setup","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"If you want or need to set up moment_kinetics without using machines/machine_setup.sh, you will need to follow at least the steps in the following sections.","category":"page"},{"location":"manual_setup/#Install-Julia","page":"Manual setup","title":"Install Julia","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"Download Julia from https://julialang.org/downloads/, and add it to your $PATH so you can execute it from the command line.","category":"page"},{"location":"manual_setup/#Add-moment_kinetics-packages","page":"Manual setup","title":"Add moment_kinetics packages","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"Create a 'project' in the top-level directory by creating an empty Project.toml file, e.g.","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"$ touch Project.toml","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"Without this Project.toml file, running julia --project will activate a global project, not one linked specificially to the repo you are in, which is likely to cause confusion if you have more than one copy of the moment_kinetics repo (experience suggests you are likely to end up with multiple copies eventually!).","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"To add the moment_kinetics package to your project, start Julia, enter 'Package mode' by pressing ']' at the prompt and use develop (to exit 'Package mode' and return to the usual julia> prompt, press backspace):","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"$ julia --project\njulia> ]\npkg> develop ./moment_kinetics/","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"To allow post-processing add one or both of the post processing packages","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> develop ./makie_post_processing/makie_post_processing/","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"and/or","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> develop ./plots_post_processing/plots_post_processing/","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"To use the run_moment_kinetics.jl script, you will need to install MPI into the top-level project","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> add MPI","category":"page"},{"location":"manual_setup/#Set-up-MPI","page":"Manual setup","title":"Set up MPI","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"You probably want to use your system's MPI rather than a Julia-provided version. To do this add (in 'Package mode') the MPIPreferences package (documentation here) and then use its use_system_binary() function.","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> add MPIPreferences\npkg> <press 'backspace'>\njulia> using MPIPreferences\njulia> MPIPreferences.use_system_binary()","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"Normally this should 'just work'. Sometimes, for example if the MPI library file is named something other than libmpi.so, you might have to pass some keyword arguments to use_system_binary() - see https://juliaparallel.org/MPI.jl/stable/reference/mpipreferences/#MPIPreferences.use_system_binary.","category":"page"},{"location":"manual_setup/#Using-the-native-Julia-MPI","page":"Manual setup","title":"Using the native Julia MPI","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"As an alternative, you can also use the MPI that is shipped with Julia.","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"julia> using MPI; MPI.install_mpiexecjl(force=true)\njulia> using MPIPreferences; MPIPreferences.use_jll_binary()","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"The executable for the Julia MPI can be called from the root folder of the project with","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":".julia/bin/mpiexecjl --project=./ -n N julia --project -O3 run_your_script.jl","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"where N is the number of cores used.","category":"page"},{"location":"manual_setup/#Miscellaneous-required-packages","page":"Manual setup","title":"Miscellaneous required packages","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"For full functionality, including precompilation with","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"$ julia --project -O3 precompile.jl","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"and running of tests by","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"$ julia --project -O3 -e 'include(\"moment_kinetics/test/runtests.jl\")'","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"we require to install the following packages","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"$ julia --project -O3\njulia> ]\npkg> add PackageCompiler StatsBase SpecialFunctions Test ","category":"page"},{"location":"manual_setup/#Link-HDF5","page":"Manual setup","title":"Link HDF5","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"To enable parallel I/O, you need to get HDF5.jl to use the system HDF5 library (which must be MPI-enabled and compiled using the same MPI as you run Julia with). To do this (see the HDF5.jl docs) add the HDF5 package and use its HDF5.API.set_libraries!() function","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> add HDF5\npkg> <press backspace>\njulia> using HDF5\njulia> HDF5.API.set_libraries!(\"/path/to/your/hdf5/directory/libhdf5.so\", \"/path/to/your/hdf5/directory/libhdf5_hl.so\")","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"JTO also found that (on a Linux laptop) it was necessary to compile HDF5 from source. The system-provided, MPI-linked libhdf5 depended on libcurl, and Julia links to an incompatible libcurl, causing an error. When compiled from source (enabling MPI!), HDF5 does not require libcurl (guess it is an optional dependency), avoiding the problem.","category":"page"},{"location":"manual_setup/#Enable-MMS-features","page":"Manual setup","title":"Enable MMS features","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"To enable the \"method of manufactured solutions\" (MMS) features, install the Symbolics package (for more explanation, see Optional dependencies)","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> add Symbolics","category":"page"},{"location":"manual_setup/#Enable-NetCDF-output","page":"Manual setup","title":"Enable NetCDF output","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"If you want the option to output to NetCDF instead of HDF5, install the NCDatasets package (for more explanation, see Optional dependencies)","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> add NCDatasets","category":"page"},{"location":"manual_setup/#Set-up-Plots-based-plotting-routines","page":"Manual setup","title":"Set up Plots-based plotting routines","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"The plots_post_processing package has some functions that have to use PyPlot directly to access features not available through the Plots wrapper. This means that Julia has to be able to access an instance of Python which has matplotlib available. If you are going to use plots_post_processing you may well want to use the same Python that you use outside Julia (e.g. a system-provided Python) - to do so:","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"Check that matplotlib is installed, e.g. check that\n$ python\n>>> import matplotlib\ncompletes without an error. If not, install matplotlib, for example with a command like\npip install --user matplotlib\nSet up Julia to use your chosen Python\n$ which python\n/your/python/location\n$ julia -O3 --project\njulia> ENV[\"PYTHON\"]=\"/your/python/location\"\njulia> using Pkg; Pkg.build(\"PyCall\")","category":"page"},{"location":"manual_setup/#An-example-manual-setup-script","page":"Manual setup","title":"An example manual setup script","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"We include an example manual setup script below to show the process of carrying out the above steps together, for a case where no post processing is required, and we only desire to verify the install with an MPI test. We use the  native Julia MPI, and do not link to HDF5.","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"#!/bin/bash\n# simple moment_kinetics install script\n# not supporting parallel HDF5\n# not supporting diagnostics\n\n# first time use, uncomment this\n# otherwise, use from the moment_kinetics_install (root) folder \ngit clone https://github.com/mabarnes/moment_kinetics.git moment_kinetics_test_install\ncd moment_kinetics_test_install\n\n# set up modules and environment variables\n# need this everytime you use Julia\n# e.g. module load julia/1.10.2\n# this will be specific to your system\n# JULIA_DEPOT_PATH must be set to be the same for each use of a specific install\nexport JULIA_DEPOT_PATH=$(pwd)/.julia\n\n# develop moment_kinetics, no plots, no symbolic function tests\ntouch Project.toml\njulia --project -O3 -e 'using Pkg; Pkg.develop(path=\"./moment_kinetics\")'\njulia --project -O3 -e 'using Pkg; Pkg.add(\"MPIPreferences\")'\njulia --project -O3 -e 'using Pkg; Pkg.add(\"MPI\")'\njulia --project -O3 -e 'using Pkg; Pkg.add(\"Test\")'\njulia --project -O3 -e 'using Pkg; Pkg.add(\"SpecialFunctions\")'\njulia --project -O3 -e 'using Pkg; Pkg.add(\"PackageCompiler\")'\njulia --project -O3 -e 'using Pkg; Pkg.add(\"StatsBase\")'\n\n# setup MPI preferences and binary\njulia --project -O3 -e 'using Pkg; Pkg.instantiate()'\njulia --project -O3 -e 'using Pkg; Pkg.resolve()'\njulia --project -O3 -e 'using MPI; MPI.install_mpiexecjl(force=true)'\njulia --project -O3 -e 'using MPIPreferences; MPIPreferences.use_jll_binary()\njulia --project -O3 -e 'using Pkg; Pkg.instantiate()'\njulia --project -O3 -e 'using Pkg; Pkg.resolve()'\n\n# generate moment_kinetics.so\njulia --project -O3 precompile.jl\n\n# check install with tests\necho \"MPI test with precompiled moment_kinetics.so\"\n.julia/bin/mpiexecjl --project=./ -n 2 julia --project -O3 -Jmoment_kinetics.so -e 'include(\"moment_kinetics/test/runtests.jl\")'","category":"page"},{"location":"zz_electron_z_advection/#electron_z_advection","page":"electron_z_advection","title":"electron_z_advection","text":"","category":"section"},{"location":"zz_electron_z_advection/#moment_kinetics.electron_z_advection","page":"electron_z_advection","title":"moment_kinetics.electron_z_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_electron_z_advection/#moment_kinetics.electron_z_advection.electron_z_advection!-NTuple{11, Any}","page":"electron_z_advection","title":"moment_kinetics.electron_z_advection.electron_z_advection!","text":"calculate the z-advection term for the electron kinetic equation = wpa * vthe * df/dz\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_z_advection/#moment_kinetics.electron_z_advection.update_electron_speed_z!-NTuple{5, Any}","page":"electron_z_advection","title":"moment_kinetics.electron_z_advection.update_electron_speed_z!","text":"calculate the electron advection speed in the z-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"constraints_on_normalized_distribution_function/#Constraints-on-normalized-distribution-function","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Note: Equation references give the Excalibur/Neptune report number and equation number, e.g. (TN-04;1) is equation (1) from report TN-04.pdf.","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Constraints","page":"Constraints on normalized distribution function","title":"Constraints","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"The normalized particle distribution function that is evolved when using the moment-kinetic approach has to satisfy integral constraints related to particle number, momentum and energy conservation (TN-04;70-72)","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s  =1\n  frac1sqrtpiint dw_w_tildeg_s  =0\n  frac1sqrtpiint dw_w_^2tildeg_s  =frac12\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Old-algorithm","page":"Constraints on normalized distribution function","title":"Old algorithm","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"The algorithm described in TN-04 used the distribution function from the previous time step and also made use of a symmetrized distribution function tildeg_E(w_)=frac12left(tildeg(w_)+tildeg(-w_)right). These choices caused problems when in combination with the boundary conditions as: applying the boundary condition at the new timestep (with an updated tildeu_) to the old tildeg_s could mean that it no longer satisfied the moment constraints (e.g. if a grid point that was previously non-zero is now set to zero by the ion sheath boundary condition); the symmetrized tildeg_E will be non-zero at places where the boundary condition forces tildeg_s to be zero. It is possible to extend the algorithm to allow the constraints to be enforced using only the initial guess of the distribution function at the new timestep, as described below.","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Current-algorithm","page":"Constraints on normalized distribution function","title":"Current algorithm","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"After the time advance updates the distribution function, it will in general not obey the constraints, but the errors will be small, with the size depending on the accuracy of the spatial and temporal discretizations. We can take this updated value hatg_s as an initial guess, to be corrected to give the actual updated value tildeg_s, which does obey the constraints to machine precision.","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"We define the corrected distribution function as","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  tildeg_s=Ahatg_s+Bw_hatg_s+Cw_^2hatg_s\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"and define the moments of hatg_s","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  I_n=frac1sqrtpiint dw_w_^nhatg_s\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Then the moments of tildeg_s are","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s=1  =frac1sqrtpiint dw_left(Ahatg_s+Bw_hatg_s+Cw_^2hatg_sright)=AI_0+BI_1+CI_2\n  frac1sqrtpiint dw_w_tildeg_s=0  =frac1sqrtpiint dw_left(Aw_hatg_s+Bw_^2hatg_s+Cw_^3hatg_sright)=AI_1+BI_2+CI_3\n  frac1sqrtpiint dw_w_^2tildeg_s=frac12  =frac1sqrtpiint dw_left(Aw_^2hatg_s+Bw_^3hatg_s+Cw_^4hatg_sright)=AI_2+BI_3+CI_4\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Solving the simultaneous equations for A, B, C gives","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  C  =fracfrac12-AI_2-BI_3I_4\n  B  =fracleft(I_2I_3-I_1I_4right)A-fracI_32I_2I_4-I_3^2\n  A  =fracI_2I_4-fracI_2^22+I_3left(fracI_12-I_3right)I_0left(I_2I_4-I_3^2right)+I_1left(I_2I_3-I_1I_4right)+I_2left(I_1I_3-I_2^2right)\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Note that there is no guarantee that tildeg_s is geq0 even if hatg_sgeq0, although if the violations of the integral constraints are small, it should be true that Aapprox1 while B and C are small.","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Evolving-u_\\parallel","page":"Constraints on normalized distribution function","title":"Evolving u_parallel","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"When evolving fewer moments separately, the constraints become simpler. When evolving n and u_parallel, only the first two constraints are needed. This corresponds to C=0 so that","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  1 = AI_0 + BI_1 \n  0 = AI_1 + BI_2 \n  Rightarrow B = -fracAI_1I_2 \n  AI_0 = 1 - BI_1 = 1 + fracAI_1^2I_2 \n  A = frac1I_0 - I_1^2I_2\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Evolving-n","page":"Constraints on normalized distribution function","title":"Evolving n","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"When evolving only n separately, we only need one constraint and the correction is just a re-scaling. This corresponds to B=0C=0 so that","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  1 = AI_0 \n  A = frac1I_0\nendalign","category":"page"},{"location":"zz_command_line_options/#command_line_options","page":"command_line_options","title":"command_line_options","text":"","category":"section"},{"location":"zz_command_line_options/#moment_kinetics.command_line_options","page":"command_line_options","title":"moment_kinetics.command_line_options","text":"Parse command line arguments\n\nHave to include test options here too, because ArgParse errors on unrecognized options.\n\n\n\n\n\n","category":"module"},{"location":"zz_command_line_options/#moment_kinetics.command_line_options.get_options-Tuple{}","page":"command_line_options","title":"moment_kinetics.command_line_options.get_options","text":"\n\n\n\n","category":"method"},{"location":"zz_em_fields/#em_fields","page":"em_fields","title":"em_fields","text":"","category":"section"},{"location":"zz_em_fields/#moment_kinetics.em_fields","page":"em_fields","title":"moment_kinetics.em_fields","text":"\n\n\n\n","category":"module"},{"location":"zz_em_fields/#moment_kinetics.em_fields.setup_em_fields-NTuple{5, Any}","page":"em_fields","title":"moment_kinetics.em_fields.setup_em_fields","text":"\n\n\n\n","category":"method"},{"location":"zz_em_fields/#moment_kinetics.em_fields.update_phi!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, moment_kinetics.gyroaverages.gyro_operators}","page":"em_fields","title":"moment_kinetics.em_fields.update_phi!","text":"update_phi updates the electrostatic potential, phi\n\n\n\n\n\n","category":"method"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for moment_kinetics.jl","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"getting_started.md\",\n         \"input_options.md\",\n         \"post_processing_notes.md\",\n         \"timestepping.md\",\n         \"moment_kinetic_equations.md\",\n         \"moment_kinetic_equations_electrons.md\",\n         \"moment_constraints_notes.md\",\n         \"boundary_conditions_notes.md\",\n         \"external_sources_notes.md\",\n         \"fokker_planck_notes.md\",\n         \"geometry.md\",\n         \"jacobian_matrices.md\",\n         \"debugging-hints.md\",\n         \"developing.md\",\n         \"manual_setup.md\",\n         \"machine_setup_notes.md\",\n         \"parameter_scans.md\",\n         \"manufactured_solution_test_examples.md\",\n        ]","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Order = [:module]","category":"page"},{"location":"jacobian_matrices/#Jacobian-matrix-calculations","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"","category":"section"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"Functions are provided for constructing Jacobian matrices (primarily for use in constructing preconditioners) in moment_kinetics.jacobian_matrices.","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"To illustrate the process and the provided functions, consider a simplified example equation","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"fracpartial fpartial t + sqrtp fracpartial fpartial z = 0","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"where p is another time-evolving variable with a separate evolution equation (p's evolution equation is ignored here for simplicity).","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"The discrete version of this equation (assuming backward-Euler implicit timestepping) is","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"beginalign\nfracf_i^n+1 - f_i^nDelta t + sqrtp_i^n+1 sum_j D_ij f_j^n+1 = 0 \nR_fifp equiv f_i^n+1 - f_i^n + Delta t sqrtp_i^n+1 sum_j D_ij f_j^n+1 = 0\nendalign","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"where D_ij is a matrix representing the discretised derivative. This is part of a non-linear system of equations (with the corresponding equation for p) that we solve with the JFNK method to take implicit timesteps.","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"The Jacobian is the linearisation of R_i around some current value/guess f_(0)p_(0). We use a 'lagged Jacobian' as a preconditioner, which means calculating the Jacobian matrix at some time point, then using that matrix as the preconditioner for several following timesteps.","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"The rows of the Jacobian matrix corresponding to the evolution equation for f are given by","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"fracdelta R_fidelta f_jf_(0)p_(0) = delta_ij + Delta t sqrtp_(0)i D_ij","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"for the columns corresponding to f, and","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"fracdelta R_fidelta p_jf_(0)p_(0) = delta_ij frac12 sqrtp_(0)i left(fracpartial f_(0)partial zright)_i","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"for the columns corresponding to p.","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"These expressions can be constructed by combining some simpler building blocks, represented in the code by instances of the moment_kinetics.jacobian_matrices.EquationTerm struct.","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"f and p themselves are represented by 'simple' objects for which we know the functional derivatives","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"fracdelta f_idelta f_j = delta_ijquad fracdelta p_idelta p_j = delta_ij","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"Derivatives of variables similarly are represented by objects for which we again know the functional derivatives, e.g.","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"fracdelta (partial_z f)_idelta f_j = D_ij","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"Sums or products of other terms are represented by EquationTerm objects that contain other EquationTerm 'sub terms' that we can combine by the chain rule, etc.","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"beginalign\nfracdelta (a + b)_idelta f_j = fracdelta a_idelta f_j + fracdelta b_idelta f_j \nfracdelta (a b)_idelta f_j = b_i fracdelta a_idelta f_j + a_i fracdelta b_idelta f_j\nendalign","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"Powers can also be handled","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"fracdelta (a^p)_idelta f_j = p a^p-1 fracdelta a_idelta f_j","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"The electron kinetic equation also needs an integral over velocity space for partial q_parallel partial z coeffients. For example something like","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"beginalign\nX(z) = int P(v) f(zv) dv \nX_i_z  = sum_j_v P_j_v f_i_zj_v w_j_v \nfracdelta X_i_zdelta f_j_zj_v = delta_i_zj_z P_j_v w_j_v \nendalign","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"where w_j are the weights used to numerically calculate the integral from function values on grid points. For a derivative of an integral","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"beginalign\nX(z) = fracpartialpartial z int P(v) f(zv) dv \nX(z) = int P(v) fracpartial f(zv)partial z dv \nX_i_z  = sum_j_v P_j_v sum_j_z D_i_zj_z f_j_zj_v w_j_v \nfracdelta X_i_zdelta f_j_zj_v = P_j_v D_i_zj_z w_j_v \nendalign","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"By representing the equation for R_fi as a tree of EquationTerm objects, we can travel down the tree until we get to a 'leaf' node, and add its contribution to some element (or multiple elements in different columns for a derivative or integral) of the Jacobian matrix. This is done by moment_kinetics.jacobian_matrices.add_term_to_Jacobian!, which calls recursively moment_kinetics.jacobian_matrices.add_term_to_Jacobian_row!.","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"This setup allows a separation of different parts of the Jacobian construction logic. For example, for the Jacobian for the kinetic electron solve is constructed step by step in moment_kinetics.electron_kinetic_equation.fill_electron_kinetic_equation_Jacobian!:","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"The state vector variables, and basic integrals and derivatives are defined in moment_kinetics.electron_kinetic_equation.get_electron_sub_terms.\nThe 'sub terms' are assembled into an EquationTerm object representing the kinetic and pressure equations in moment_kinetics.electron_kinetic_equation.get_all_electron_terms, which calls other functions that get the contribution from each individual term, e.g. parallel streaming ('z advection'), etc.\nThe contributions of all the terms are added to a Jacobian matrix by calling moment_kinetics.jacobian_matrices.add_term_to_Jacobian!.","category":"page"},{"location":"jacobian_matrices/","page":"Jacobian matrix calculations","title":"Jacobian matrix calculations","text":"There are other types of contribution that are not naturally included within the EquationTerm setup. For example, the wall boundary condition is not simply expressed as an integro-differential operator, so is handled by an ad-hoc function moment_kinetics.electron_kinetic_equation.add_wall_boundary_condition_to_Jacobian!.","category":"page"},{"location":"zz_manufactured_solns/#manufactured_solns","page":"manufactured_solns","title":"manufactured_solns","text":"","category":"section"},{"location":"zz_manufactured_solns/#moment_kinetics.manufactured_solns","page":"manufactured_solns","title":"moment_kinetics.manufactured_solns","text":"\n\n\n\n","category":"module"},{"location":"zz_neutral_vz_advection/#neutral_vz_advection","page":"neutral_vz_advection","title":"neutral_vz_advection","text":"","category":"section"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.neutral_advection_vz!-NTuple{15, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.neutral_advection_vz!","text":"\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_n_p_evolution_neutral!-NTuple{10, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_n_p_evolution_neutral!","text":"update the advection speed in the parallel velocity coordinate for the case where density and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized velocity vpahat = vpa/vth\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_n_u_evolution_neutral!-NTuple{9, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_n_u_evolution_neutral!","text":"update the advection speed in the parallel velocity coordinate for the case where density and flow are evolved independently from the pdf; in this case, the parallel velocity coordinate is the peculiar velocity wpa = vpa-upar\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_n_u_p_evolution_neutral!-NTuple{9, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_n_u_p_evolution_neutral!","text":"update the advection speed (for the neutral distribution function) in the z-velocity coordinate for the case where density, flow and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized peculiar velocity wpahat = (vpa - upar)/vth\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_neutral_vz!-NTuple{12, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_neutral_vz!","text":"calculate the advection speed in the vz-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_nonlinear_solvers/#nonlinear_solvers","page":"nonlinear_solvers","title":"nonlinear_solvers","text":"","category":"section"},{"location":"zz_nonlinear_solvers/#moment_kinetics.nonlinear_solvers","page":"nonlinear_solvers","title":"moment_kinetics.nonlinear_solvers","text":"Nonlinear solvers, using Jacobian-free Newton-Krylov methods.\n\nThese solvers use an outer Newton iteration. Each step of the Newton iteration requires a linear solve of the Jacobian. An 'inexact Jacobian' method is used, and the GMRES method (GMRES is a type of Krylov solver) is used to (approximately) solve the (approximate) linear system.\n\nwarning: parallelisation\nThis module uses shared- and distributed-memory parallelism, so the functions in it should not be called inside any kind of parallelised loop. This restriction should be lifted somehow in future...\n\nparallel_map() is used to apply elementwise functions to arbitrary numbers of arguments using shared-memory parallelism. We do this rather than writing the loops out explicitly so that newton_solve!() and linear_solve!() can work for arrays with any combination of dimensions.\n\nUseful references: [1] V.A. Mousseau and D.A. Knoll, \"Fully Implicit Kinetic Solution of Collisional Plasmas\", Journal of Computational Physics 136, 308–323 (1997), https://doi.org/10.1006/jcph.1997.5736. [2] V.A. Mousseau, \"Fully Implicit Kinetic Modelling of Collisional Plasmas\", PhD thesis, Idaho National Engineering Laboratory (1996), https://inis.iaea.org/collection/NCLCollectionStore/Public/27/067/27067141.pdf. [3] https://en.wikipedia.org/wiki/Generalizedminimalresidualmethod [4] https://www.rikvoorhaar.com/blog/gmres [5] E. Carson , J. Liesen, Z. Strakoš, \"Towards understanding CG and GMRES through examples\", Linear Algebra and its Applications 692, 241–291 (2024), https://doi.org/10.1016/j.laa.2024.04.003.  [6] Q. Zou, \"GMRES algorithms over 35 years\", Applied Mathematics and Computation 445, 127869 (2023), https://doi.org/10.1016/j.amc.2023.127869\n\n\n\n\n\n","category":"module"},{"location":"zz_nonlinear_solvers/#moment_kinetics.nonlinear_solvers.gather_nonlinear_solver_counters!-Tuple{Any}","page":"nonlinear_solvers","title":"moment_kinetics.nonlinear_solvers.gather_nonlinear_solver_counters!","text":"gather_nonlinear_solver_counters!(nl_solver_params)\n\nWhere necessary, gather the iteration counters for the nonlinear solvers.\n\nWhere each solve runs in parallel using all processes, this is unnecessary as the count on each process already represents the global count. Where each solve uses only a subset of processes, the counters from different solves need to be added together to get the global total.\n\n\n\n\n\n","category":"method"},{"location":"zz_nonlinear_solvers/#moment_kinetics.nonlinear_solvers.linear_solve!-Tuple{Any, Any, Any, Any, Any, Any, Val, Any}","page":"nonlinear_solvers","title":"moment_kinetics.nonlinear_solvers.linear_solve!","text":"Apply the GMRES algorithm to solve the 'linear problem' J.δx^n = R(x^n), which is needed at each step of the outer Newton iteration (in newton_solve!()).\n\nUses Givens rotations to reduce the upper Hessenberg matrix to an upper triangular form, which allows conveniently finding the residual at each step, and computing the final solution, without calculating a least-squares minimisation at each step. See 'algorithm 2 MGS-GMRES' in Zou (2023) [https://doi.org/10.1016/j.amc.2023.127869].\n\n\n\n\n\n","category":"method"},{"location":"zz_nonlinear_solvers/#moment_kinetics.nonlinear_solvers.newton_solve!-NTuple{8, Any}","page":"nonlinear_solvers","title":"moment_kinetics.nonlinear_solvers.newton_solve!","text":"newton_solve!(x, rhs_func!, residual, delta_x, rhs_delta, w, nl_solver_params;\n              left_preconditioner=nothing, right_preconditioner=nothing, coords)\n\nx is the initial guess at the solution, and is overwritten by the result of the Newton solve.\n\nrhs_func!(residual, x) is the function we are trying to find a solution of. It calculates\n\nmathttresidual = F(mathttx)\n\nwhere we are trying to solve F(x)=0.\n\nresidual, delta_x, rhs_delta and w are buffer arrays, with the same size as x, used internally.\n\nleft_preconditioner or right_preconditioner apply preconditioning. They should be passed a function that solves Px = b where P is the preconditioner matrix, b is given by the values passed to the function as the argument, and the result x is returned by overwriting the argument.\n\ncoords is a NamedTuple containing the coordinate structs corresponding to each dimension in x.\n\nTolerances\n\nNote that the meaning of the relative tolerance rtol and absolute tolerance atol is very different for the outer Newton iteration and the inner GMRES iteration.\n\nFor the outer Newton iteration the residual R(x^n) measures the departure of the system from the solution (at each grid point). Its size can be compared to the size of the solution x, so it makes sense to define an `error norm' for R(x^n) as\n\nE(x^n) = leftlVert fracR(x^n)mathttrtol x^n mathttatol rightrVert_2\n\nwhere leftlVert cdot rightrVert is the 'L2 norm' (square-root of sum of squares). We can further try to define a grid-size independent error norm by dividing out the number of grid points to get a root-mean-square (RMS) error rather than an L2 norm.\n\nE_mathrmRMS(x^n) = sqrt frac1N sum_i fracR(x^n)_imathttrtol x^n_i mathttatol \n\nwhere N is the total number of grid points.\n\nIn contrast, GMRES is constructed to minimise the L2 norm of r_k = b - Acdot x_k where GMRES is solving the linear system Acdot x = b, x_k is the approximation to the solution x at the k'th iteration and r_k is the residual at the k'th iteration. There is no flexibility to measure error relative to x in any sense. For GMRES, a `relative tolerance' is relative to the residual of the right-hand-side b, which is the first iterate x_0 (when no initial guess is given). [Where a non-zero initial guess is given it might be better to use a different stopping criterion, see Carson et al. section 3.8.]. The stopping criterion for the GMRES iteration is therefore\n\n\\left\\lVert r_k \\right\\rVert < \\max(\\mathtt{linear\\_rtol} \\left\\lVert r_0 \\right\\rVert, \\mathtt{linear\\_atol}) = \\max(\\mathtt{linear\\_rtol} \\left\\lVert b \\right\\rVert, \\mathtt{linear\\_atol})\n\nAs the GMRES solve is only used to get the right direction' for the next Newton step, it is not necessary to have a very tightlinear_rtol` for the GMRES solve.\n\n\n\n\n\n","category":"method"},{"location":"zz_nonlinear_solvers/#moment_kinetics.nonlinear_solvers.reset_nonlinear_per_stage_counters!-Tuple{Union{Nothing, moment_kinetics.nonlinear_solvers.nl_solver_info}}","page":"nonlinear_solvers","title":"moment_kinetics.nonlinear_solvers.reset_nonlinear_per_stage_counters!","text":"reset_nonlinear_per_stage_counters!(nl_solver_params::Union{nl_solver_info,Nothing})\n\nReset the counters that hold per-step totals or maximums in nl_solver_params.\n\nAlso increment nl_solver_params.stage_counter[].\n\n\n\n\n\n","category":"method"},{"location":"zz_nonlinear_solvers/#moment_kinetics.nonlinear_solvers.setup_nonlinear_solve","page":"nonlinear_solvers","title":"moment_kinetics.nonlinear_solvers.setup_nonlinear_solve","text":"coords is a NamedTuple of coordinates corresponding to the dimensions of the variable that will be solved. The entries in coords should be ordered the same as the memory layout of the variable to be solved (i.e. fastest-varying first).\n\nThe nonlinear solver will be called inside a loop over outer_coords, so we might need for example a preconditioner object for each point in that outer loop.\n\n\n\n\n\n","category":"function"},{"location":"chebyshev/#Chebyshev-tranform-via-Fourier-transform","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"","category":"section"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"We express a function f as a sum of Chebyshev polynomials","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nf(x) = sum^N_n=0 a_nT_n(x) tag1\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"The Chebyshev polynomials are defined by ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nT_n(cos theta) = cos n theta rmwithx = cos theta\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"We can see how to find a_n given f(x_j) via Fourier transform.  The Fourier series representation of f on a uniform grid indexed by j is defined by ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nf_j = sum_k=0^M-1 b_kexplefti frac2pi k jMrighttag2\nendequation","category":"page"},{"location":"chebyshev/#Gauss-Chebyshev-Lobotto-points","page":"Chebyshev tranform via Fourier transform","title":"Gauss-Chebyshev-Lobotto points","text":"","category":"section"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"We pick points ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nx_j = cos theta_j quad theta_j = fracj piN quad 0 leq j leq N\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Then ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nT_n(x_j) = cos fracn j piN\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Assuming that M = 2N, with N an integer, and b_k = b_M-k for k0, we have that ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nf_j = b_0 + b_N(-1)^j + sum_n=1^N-1\nb_nleft(explefti fracpi n jNright+expleft-i fracpi n jNrightright)\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Comparing this to the expression for f(x_j) in the Chebyshev representation,","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nf_j = a_0 + a_N(-1)^j + frac12sum_n=1^N-1\na_nleft(explefti fracpi n jNright+expleft-i fracpi n jNrightright)\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"we find that the Chebyshev representation on the Chebyshev points is equivalent  to the Fourier representation on the uniform grid points, if we identify","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nb_0 = a_0 quad  b_N = a_N quad b_j = fraca_j2 rmfor 1 leq j leq N-1\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"This fact allows us to carry out the Chebyshev tranform by Fourier transforming the f_j data and carrying out the correct normalisation of the resulting coefficients. ","category":"page"},{"location":"chebyshev/#Gauss-Chebyshev-Radau-points","page":"Chebyshev tranform via Fourier transform","title":"Gauss-Chebyshev-Radau points","text":"","category":"section"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"The last subsection dealt with grids which contain both endpoints on the -11 domain.  Certain problems require domains which contain a single endpoint, i.e., x in (-11. For  these cases we choose the points ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nx_j = cos theta_j quad theta_j = frac2 j pi2 N + 1 quad 0 leq j leq N\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Writing out the Chebyshev series (1), we have that ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nbeginsplitf(x_j) =  sum^N_n=0 a_n cos frac2 n j pi2 N + 1  \n= a_0 + sum^N_n=1 fraca_n2left(explefti frac2pi n j2N +1right + expleft-i frac2pi n j2N +1rightright)endsplit\ntag3\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"The form of the series (3) is identical to the form of  a Fourier series on an odd number of points, i.e., taking M = 2 N + 1 in equation (2), and assuming b_k = b_M -k for k1, we have that ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nf_j = b_0 + sum_k=1^N b_kleft(explefti frac2pi k j2N+1right + expleft-i frac2pi k j2N+1 rightright)\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"We can thus take a Chebyshev transform using a Fourier transform on Gauss-Chebyshev-Radau points if we identify ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nb_0 = a_0 quad b_j = fraca_j2 rmfor 1 leq j leq N\nendequation","category":"page"},{"location":"chebyshev/#Chebyshev-coefficients-of-derivatives-of-a-function","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev coefficients of derivatives of a function","text":"","category":"section"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Starting from the expression of f as a sum Chebyshev polynomials, equation (1), we can obtain an expression for the derivative","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nfracd fd x = sum^N_n=0 a_nfracd T_nd xtag4\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"We note that we must be able to express d fd x as a sum  of Chebyshev polynomials of up to order N-1, i.e.,","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nfracd fd x = sum^N-1_n=0 d_nT_n\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"We must determine the set d_n in terms of the set a_n. First, we equate the two expressions to find that ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nsum^N_k=0 a_kfracd T_kd x = sum^N-1_n=0 d_nT_ntag5\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"We use the Chebyshev polynomials of the second kind U_nx to aid us in the calculation of the set d_n.  These polynomials are defined by ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nU_0(x) = 1 quad U_1(x) = 2x quad U_n+1 = 2 x U_n(x) - U_n-1(x)\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Note the useful relations ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nfracd T_nd x = n U_n-1 rmforngeq 1 quad fracd T_0d x = 0\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nT_n = frac12left(U_n - U_n -2right) T_0 = U_0quad rm and quad 2 T_1 = U_1\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Using these identities, which may be obtained from the trigonometric definition of U_n(cos theta)","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nU_n(cos theta) sin theta = sin left((n+1)thetaright)\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"we find that equation (5) becomes ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nbeginsplitsum^N_n=1 a_n n U_n-1(x) = fracd_N-12U_N-1+fracd_N-22U_N-2 \n  + sum^N-3_k=1 fracd_k-d_k+22U_k + left(d_0 - fracd_22right)U_0 endsplittag6\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Using the orthogonality relation ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nint^1_-1 U_m(x)U_n(x)sqrt1-x^2  d x = \nleftbeginarrayl 0 rm if nneq m   pi2 rm if n=m  endarray right\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"we obtain the (unqiuely-determined) relations ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nbeginsplit d_N-1 = 2Na_Nquad d_N-2 = 2(N-1)a_N-1  \n d_k = 2(k+1) a_k+1 + d_k+2 quad d_0 = fracd_22 + a_1endsplittag7\nendequation","category":"page"},{"location":"chebyshev/#Clenshaw-Curtis-integration-weights","page":"Chebyshev tranform via Fourier transform","title":"Clenshaw-Curtis integration weights","text":"","category":"section"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"We require the integration weights for the set of points x_j chosen  in our numerical scheme. The weights w_j are defined implicitly by ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nint^1_-1 f(x)  d x = sum_j=0^N f(x_j) w_jtag8\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"In the Chebyshev scheme we use the change of variables x = cos theta to write ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nint^1_-1 f(x)  d x = int^pi_0 f(costheta) sin theta  d theta tag9\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Using the series expansion (1) in equation (9)  we find that ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nint^1_-1 f(x)  d x = sum^N_n=0 a_nint^pi_0 cos (n theta) sin theta  d theta\ntag10\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Note the integral identity","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nint^pi_0 cos(n theta) sin theta  d theta = fraccos(n pi) +11 - n^2 rmfor n geq 0\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Also note that ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nfraccos(n pi) +11 - n^2 = leftbeginarrayl 0 rm if n = 2 r + 1 r in mathbbZ   2(1 - n^2) rm if n=2rr in mathbbZ  endarrayright\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"We define ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nJ_n = fraccos(n pi) +11 - n^2\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Using this definition, we can write the integral of f(x) can be written  in terms of a sum over of the Chebyshev coefficients:","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nint^1_-1 f(x)  d x = sum_n=0^N J_n a_ntag11\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"To avoid computing the set of coefficients a_n every time we wish to integrate f(x_j), we use the inverse transforms. This transform allows us to rewrite equation (11) in the form (8). Since the inverse transform differs between the Gauss-Chebyshev-Lobotto and Gauss-Chebyshev-Radau cases, we treat each  case separately below. ","category":"page"},{"location":"chebyshev/#Weights-on-Gauss-Chebyshev-Lobotto-points","page":"Chebyshev tranform via Fourier transform","title":"Weights on Gauss-Chebyshev-Lobotto points","text":"","category":"section"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"We use the inverse transformation ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\na_n = fracq_n2Nsum^2N-1_j=0 hatf_j expleft- i frac2pi n j2Nright tag12\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"where ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nq_n = leftbeginarrayl 2 rm if nneq0N   1 rm if n=0N  endarrayright\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"and hatf_j is f(x_j) on the extended domain in FFT order, i.e.,","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nhatf_j = f(x_j) rmfor 0 leq j leq N quad hatf_j = f(x_2N-j)rmfor N+1 leq j leq 2N-1\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"With this inverse tranformation, we can write ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nbeginsplitsum_n=0^N J_n a_n  =  sum^2N-1_n=0 fraca_nJ_nq_n \n = sum^2N-1_j=0sum^2N-1_n=0 frachatf_j J_n2N expleft-i frac2pi n j2Nright  \n = sum^2N-1_j=0 hatf_j v_j = sum^N_j=0 hatf_j q_jv_jendsplittag13\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"where in the first step we have extended the sum from N to 2N-1 and used FFT-order definitions of J_n and a_n","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nJ_j = J_2N-j rmfor N+1 leq j leq 2N-1\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\na_j = a_2N-j rmfor N+1 leq j leq 2N-1\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"In the second step we use the definition of the inverse transform (14) , and  in the third step we define ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nv_j = sum_n=0^2N-1fracJ_n2Nexpleft-i frac2pi n j2Nright\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Finally, we can compare equations (8) and (13) and deduce that ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nw_j = q_jv_j rmfor 0 leq j leq N\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"We can write v_j in terms of a discrete cosine transform, i.e.,","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nv_j = frac12Nleft(J_0 + (-1)^jJ_N + 2sum_n=1^N-1J_ncosleft(fracpi n jNright)right)\nendequation","category":"page"},{"location":"chebyshev/#Weights-on-Gauss-Chebyshev-Radau-points","page":"Chebyshev tranform via Fourier transform","title":"Weights on Gauss-Chebyshev-Radau points","text":"","category":"section"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"We use the inverse transformation ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\na_n = fracq_n2N+1sum^2N_j=0 hatf_j expleft- i frac2pi n j2N+1righttag14\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"where ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nq_n = leftbeginarrayl 2 rm if n  0   1 rm if n=0  endarrayright\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"and hatf_j is f(x_j) on the extended domain in FFT order, i.e.,","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nhatf_j = f(x_j) rmfor 0 leq j leq N quad hatf_j = f(x_2N-j+1)rmfor N+1 leq j leq 2N\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Note that the details of what is the appropriate FFT order depends on the order in which the points x_j are stored. The key detail in the Chebyshev-Radau scheme is that (in the notation above) x_0 = 1 is not a repeated point, and must occupy hatf_0.  With this inverse tranformation, we can write ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nbeginsplitsum_n=0^N J_n a_n  =  sum^2N_n=0 fraca_nJ_nq_n \n = sum^2N_j=0sum^2N_n=0 frachatf_j J_n2N+1 expleft-i frac2pi n j2N+1right  \n = sum^2N_j=0 hatf_j v_j = sum^N_j=0 hatf_j q_jv_jendsplittag15endequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"where in the first step we have extended the sum from N to 2N and used FFT-order definitions of J_n and a_n","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nJ_j = J_2N+1-j rmfor N+1 leq j leq 2N\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\na_j = a_2N+1-j rmfor N+1 leq j leq 2N\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"In the second step we use the definition of the inverse transform (14), and  in the third step we define ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nv_j = sum_n=0^2NfracJ_n2N+1expleft-i frac2pi n j2N+1right\nendequation","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"Finally, we can compare equations (8) and (15) and deduce that ","category":"page"},{"location":"chebyshev/","page":"Chebyshev tranform via Fourier transform","title":"Chebyshev tranform via Fourier transform","text":"beginequation\nw_j = q_jv_j rmfor 0 leq j leq N\nendequation","category":"page"},{"location":"zz_advection/#advection","page":"advection","title":"advection","text":"","category":"section"},{"location":"zz_advection/#moment_kinetics.advection","page":"advection","title":"moment_kinetics.advection","text":"\n\n\n\n","category":"module"},{"location":"zz_advection/#moment_kinetics.advection.advection_info","page":"advection","title":"moment_kinetics.advection.advection_info","text":"structure containing the basic arrays associated with the advection terms appearing in the advection equation for each coordinate\n\n\n\n\n\n","category":"type"},{"location":"zz_advection/#moment_kinetics.advection.advance_f_local!-NTuple{9, Any}","page":"advection","title":"moment_kinetics.advection.advance_f_local!","text":"do all the work needed to update f(coord) at a single value of other coords\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.calculate_explicit_advection!-NTuple{4, Any}","page":"advection","title":"moment_kinetics.advection.calculate_explicit_advection!","text":"calculate the explicit advection terms on the rhs of the equation; i.e., -Δt⋅δv⋅f'\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.setup_advection-Tuple{Any, Vararg{Any}}","page":"advection","title":"moment_kinetics.advection.setup_advection","text":"create arrays needed to compute the advection term(s) for a 1D problem\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.setup_advection_per_species-Tuple","page":"advection","title":"moment_kinetics.advection.setup_advection_per_species","text":"create arrays needed to compute the advection term(s)\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.update_advection_factor!-NTuple{4, Any}","page":"advection","title":"moment_kinetics.advection.update_advection_factor!","text":"calculate the factor appearing in front of f' in the advection term at time level n in the frame moving with the approximate characteristic\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.update_f!-Tuple{Any, Any, Any}","page":"advection","title":"moment_kinetics.advection.update_f!","text":"\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.update_rhs!-NTuple{8, Any}","page":"advection","title":"moment_kinetics.advection.update_rhs!","text":"update the righthand side of the equation to account for 1d advection in this coordinate\n\n\n\n\n\n","category":"method"},{"location":"debugging-hints/#Debugging","page":"Debugging","title":"Debugging","text":"","category":"section"},{"location":"debugging-hints/#Shared-memory-parallelism","page":"Debugging","title":"Shared-memory parallelism","text":"","category":"section"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"For information on race conditions and debugging, see Shared memory debugging.","category":"page"},{"location":"debugging-hints/#Identifying-location-of-regressions-(debug-output)","page":"Debugging","title":"Identifying location of regressions (debug output)","text":"","category":"section"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"It can be useful to save output from intermediate points within each timestep. This can be done by setting debug_io=true in the [timestepping] section of the input, which creates a file debug.dfns.h5 containing output from after each call (roughly each kinetic equation term or moment equation) in moment_kinetics.time_advance.euler_time_advance! and a few other useful places (where write_debug_IO() is called, which is a local wrapper for moment_kinetics.file_io.write_debug_data_to_binary).","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"One example where this is useful is when trying to identify a 'regression' - where the output of some run was expected to be the same before and after a change to the code, but is not. Comparing the 'debug output' from the before/after runs can narrow down a lot the (first) place where a difference occured (using debug_io=true should be easier than putting debug prints in the two versions of the code before/after the change being debugged). To compare the outputs and identify the earliest difference, use the script util/regression_test_debug_comparison.jl. This can be imported in the command line to provide a function regression_test_debug_comparison() that can be used to compare debug output from two runs (see its docstring for more details), or run as a command line script (if the default settings are OK) with paths to the two debug files as the command line arguments.","category":"page"},{"location":"zz_file_io/#file_io","page":"file_io","title":"file_io","text":"","category":"section"},{"location":"zz_file_io/#moment_kinetics.file_io","page":"file_io","title":"moment_kinetics.file_io","text":"\n\n\n\n","category":"module"},{"location":"zz_file_io/#moment_kinetics.file_io.ascii_ios","page":"file_io","title":"moment_kinetics.file_io.ascii_ios","text":"structure containing the various input/output streams\n\n\n\n\n\n","category":"type"},{"location":"zz_file_io/#moment_kinetics.file_io.io_dfns_info","page":"file_io","title":"moment_kinetics.file_io.io_dfns_info","text":"structure containing the data/metadata needed for binary file i/o distribution function data only\n\n\n\n\n\n","category":"type"},{"location":"zz_file_io/#moment_kinetics.file_io.io_initial_electron_info","page":"file_io","title":"moment_kinetics.file_io.io_initial_electron_info","text":"structure containing the data/metadata needed for binary file i/o for electron initialization\n\n\n\n\n\n","category":"type"},{"location":"zz_file_io/#moment_kinetics.file_io.io_input_struct","page":"file_io","title":"moment_kinetics.file_io.io_input_struct","text":"Container for I/O settings\n\n\n\n\n\n","category":"type"},{"location":"zz_file_io/#moment_kinetics.file_io.io_moments_info","page":"file_io","title":"moment_kinetics.file_io.io_moments_info","text":"structure containing the data/metadata needed for binary file i/o moments & fields only\n\n\n\n\n\n","category":"type"},{"location":"zz_file_io/#moment_kinetics.file_io.add_attribute!","page":"file_io","title":"moment_kinetics.file_io.add_attribute!","text":"Add an attribute to a file, group or variable\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.append_to_dynamic_var","page":"file_io","title":"moment_kinetics.file_io.append_to_dynamic_var","text":"append_to_dynamic_var(io_var, data, t_idx, parallel_io, coords...; only_root=false)\n\nAppend data to the dynamic variable io_var. The time-index of the data being appended is t_idx. parallel_io indicates whether parallel I/O is being used. coords... is used to get the ranges to write from/to (needed for parallel I/O) - the entries in the coords tuple can be either coordinate instances or integers (for an integer n the range is 1:n).\n\nIf only_root=true is passed, the data is only written once - from the global root process if parallel I/O is being used (if parallel I/O is not used, this has no effect as each file is only written by one process).\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.check_io_implementation-Tuple{Any}","page":"file_io","title":"moment_kinetics.file_io.check_io_implementation","text":"check_io_implementation(binary_format)\n\nCheck that an implementation is available for binary_format, raising an error if not.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.create_dynamic_variable!","page":"file_io","title":"moment_kinetics.file_io.create_dynamic_variable!","text":"create_dynamic_variable!(file_or_group, name, type,\n                         coords::Union{coordinate,NamedTuple}...; parallel_io,\n                         description=nothing, units=nothing)\n\nCreate a time-evolving variable in file_or_group named name of type type.\n\ncoords are the coordinates corresponding to the dimensions of the array, in the order of the array dimensions - they may be either coordinate structs or NamedTuples that contain at least the fields name, n.\n\nA description and/or units can be added with the keyword arguments.\n\nparallel_io is a Bool specifying whether parallel I/O is being used.\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_dfn_variables!-NTuple{16, Any}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_dfn_variables!","text":"define dynamic (time-evolving) distribution function variables for writing to the output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_electron_moment_variables!","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_electron_moment_variables!","text":"define dynamic (time-evolving) electron moment variables for writing to the hdf5 file\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_em_field_variables!-Tuple{Any, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, Any}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_em_field_variables!","text":"define dynamic (time-evolving) electromagnetic field variables for writing to the hdf5 file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_ion_moment_variables!-Tuple{Any, Any, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, Vararg{Any, 7}}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_ion_moment_variables!","text":"define dynamic (time-evolving) ion moment variables for writing to the hdf5 file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_moment_variables!-Tuple{Any, Any, Any, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, Vararg{Any, 8}}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_moment_variables!","text":"define dynamic (time-evolving) moment variables for writing to the hdf5 file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_neutral_moment_variables!-Tuple{Any, Any, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, Vararg{Any, 7}}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_neutral_moment_variables!","text":"define dynamic (time-evolving) neutral moment variables for writing to the hdf5 file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_io_coordinate!-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.define_io_coordinate!","text":"define a sub-group for each code coordinate and write to output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_io_coordinates!-NTuple{9, Any}","page":"file_io","title":"moment_kinetics.file_io.define_io_coordinates!","text":"Define coords group for coordinate information in the output file and write information about spatial and velocity space coordinate grids\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.finish_electron_io-Tuple{Union{Nothing, Bool, Tuple, NamedTuple, moment_kinetics.file_io.io_initial_electron_info}}","page":"file_io","title":"moment_kinetics.file_io.finish_electron_io","text":"close output files for electron initialization\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.finish_file_io-Tuple{Union{Nothing, moment_kinetics.file_io.ascii_ios}, Union{Nothing, Tuple, NamedTuple, moment_kinetics.file_io.io_moments_info}, Union{Nothing, Tuple, NamedTuple, moment_kinetics.file_io.io_dfns_info}}","page":"file_io","title":"moment_kinetics.file_io.finish_file_io","text":"close all opened output files\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.get_electron_io_info-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.get_electron_io_info","text":"Get the file_info for an existing electron I/O file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.get_group","page":"file_io","title":"moment_kinetics.file_io.get_group","text":"Get a (sub-)group from a file or group\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.get_subgroup_keys","page":"file_io","title":"moment_kinetics.file_io.get_subgroup_keys","text":"Get names of all subgroups\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.get_variable_keys","page":"file_io","title":"moment_kinetics.file_io.get_variable_keys","text":"Get names of all variables\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.hdf5_get_dynamic_dim_sizes-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.hdf5_get_dynamic_dim_sizes","text":"given a tuple, fixed_coords, containing all dimensions except the time dimension, get the dimension sizes and chunk sizes\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.hdf5_get_fixed_dim_sizes-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.hdf5_get_fixed_dim_sizes","text":"Get sizes of fixed dimensions and chunks (i.e. everything but time) for I/O\n\ncoords should be a tuple whose elements are coordinate structs or integers (e.g. number of species).\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.input_option_error-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.input_option_error","text":"accepts an option name which has been identified as problematic and returns an appropriate error message\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.io_has_parallel","page":"file_io","title":"moment_kinetics.file_io.io_has_parallel","text":"io_has_parallel(Val(binary_format))\n\nTest if the backend supports parallel I/O.\n\nbinary_format should be one of the values of the binary_format_type enum\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.is_group","page":"file_io","title":"moment_kinetics.file_io.is_group","text":"Test if a member of a (sub-)group is a group\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.modify_attribute!","page":"file_io","title":"moment_kinetics.file_io.modify_attribute!","text":"Modify an attribute to a file, group or variable\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.open_ascii_output_file-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.open_ascii_output_file","text":"opens an output file with the requested prefix and extension and returns the corresponding io stream (identifier)\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.open_output_file-Tuple{Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.open_output_file","text":"Open an output file, selecting the backend based on io_option\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.open_output_file_implementation","page":"file_io","title":"moment_kinetics.file_io.open_output_file_implementation","text":"Low-level function to open a binary output file\n\nEach implementation (HDF5, NetCDF, etc.) defines a method of this function to open a file of the corresponding type.\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.reopen_dfns_io-Tuple{Any}","page":"file_io","title":"moment_kinetics.file_io.reopen_dfns_io","text":"Reopen an existing distribution-functions output file to append more data\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.reopen_initial_electron_io-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.reopen_initial_electron_io","text":"Reopen an existing initial electron output file to append more data\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.reopen_moments_io-Tuple{Any}","page":"file_io","title":"moment_kinetics.file_io.reopen_moments_io","text":"Reopen an existing moments output file to append more data\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.reopen_output_file-Tuple{Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.reopen_output_file","text":"Re-open an existing output file, selecting the backend based on io_option\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.setup_dfns_io-NTuple{23, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_dfns_io","text":"setup file i/o for distribution function variables\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.setup_electron_io-NTuple{16, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_electron_io","text":"open output file to save the initial electron pressure and distribution function\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.setup_file_io-NTuple{21, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_file_io","text":"open the necessary output files\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.setup_io_input-Tuple{Any, Any, Bool}","page":"file_io","title":"moment_kinetics.file_io.setup_io_input","text":"Read the settings for I/O\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.setup_moments_io-NTuple{23, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_moments_io","text":"setup file i/o for moment variables\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_Dict_to_section-Tuple{Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_Dict_to_section","text":"write_Dict_to_section(section_io, section_dict, parallel_io)\n\nWrite the contents of section_dict into the I/O group section_io.\n\nAny nested Dicts in section_dict are written to subsections.\n\nAll the keys in section_dict (and any nested Dicts) should be Strings.\n\nparallel_io is a Bool indicating whether parallel I/O is being used.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_all_dfns_data_to_binary-NTuple{18, Any}","page":"file_io","title":"moment_kinetics.file_io.write_all_dfns_data_to_binary","text":"write time-dependent distribution function data for ions, electrons and neutrals to the binary output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_all_moments_data_to_binary","page":"file_io","title":"moment_kinetics.file_io.write_all_moments_data_to_binary","text":"write time-dependent moments data for ions, electrons and neutrals to the binary output file\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.write_data_to_ascii-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Union{Nothing, moment_kinetics.file_io.ascii_ios}}","page":"file_io","title":"moment_kinetics.file_io.write_data_to_ascii","text":"\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_debug_data_to_binary-NTuple{15, Any}","page":"file_io","title":"moment_kinetics.file_io.write_debug_data_to_binary","text":"write_debug_data_to_binary(this_scratch, moments, fields, composition, t_params,\n                           r, z, vperp, vpa, vzeta, vr, vz, label, istage)\n\nIf t_params.debug_io represents an output file (rather than being nothing), write the state contained in this_scratch, moments, and fields to that output file. label is a String identifying the location this function was called from (for reference when debugging). istage should be the Runge-Kutta stage that this function was called from (when called from within the loop over Runge-Kutta stages).\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_electron_dfns_data_to_binary","page":"file_io","title":"moment_kinetics.file_io.write_electron_dfns_data_to_binary","text":"write time-dependent distribution function data for electrons to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.write_electron_moments_data_to_binary","page":"file_io","title":"moment_kinetics.file_io.write_electron_moments_data_to_binary","text":"write time-dependent moments data for electrons to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.write_electron_state-Tuple{Any, Any, AbstractMatrix{Float64}, Vararg{Any, 9}}","page":"file_io","title":"moment_kinetics.file_io.write_electron_state","text":"write_electron_state(scratch_electron, moments, t_params, io_initial_electron,\n                     t_idx, local_pseudotime, electron_residual, r, z, vperp, vpa;\n                     pdf_electron_converged=false)\n\nWrite the electron state to an output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_em_fields_data_to_binary-Tuple{Any, moment_kinetics.file_io.io_moments_info, Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_em_fields_data_to_binary","text":"write time-dependent EM fields data to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_f_ascii-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.write_f_ascii","text":"write the function f(z,vpa) at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_fields_ascii-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.write_fields_ascii","text":"write electrostatic potential at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_final_timing_data_to_binary-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_final_timing_data_to_binary","text":"write_final_timing_data_to_binary(io_or_file_info_moments)\n\nWrite the timing data in moment_kinetics.timer_utils.global_timer to the output file. Needs to be called after exiting from the @timeit block so that all timers are finalised properly.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_input!-Tuple{Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_input!","text":"Save info from the dict with input settings to the output file\n\nNote: assumes all keys in input_dict are strings.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_ion_dfns_data_to_binary-Tuple{Any, Any, Any, moment_kinetics.file_io.io_dfns_info, Vararg{Any, 5}}","page":"file_io","title":"moment_kinetics.file_io.write_ion_dfns_data_to_binary","text":"write time-dependent distribution function data for ions to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_ion_moments_data_to_binary-Tuple{Any, Any, Any, Any, moment_kinetics.file_io.io_moments_info, Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_ion_moments_data_to_binary","text":"write time-dependent moments data for ions to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_manufactured_solutions!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Bool}","page":"file_io","title":"moment_kinetics.file_io.write_manufactured_solutions!","text":"Write time-independent information about manufactured solutions\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_moments_electron_ascii-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_electron_ascii","text":"write moments of the ion species distribution function f at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_moments_ion_ascii-NTuple{6, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_ion_ascii","text":"write moments of the ion species distribution function f at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_moments_neutral_ascii-NTuple{6, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_neutral_ascii","text":"write moments of the neutral species distribution function f_neutral at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_neutral_dfns_data_to_binary-Tuple{Any, Any, Any, moment_kinetics.file_io.io_dfns_info, Vararg{Any, 6}}","page":"file_io","title":"moment_kinetics.file_io.write_neutral_dfns_data_to_binary","text":"write time-dependent distribution function data for neutrals to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_neutral_moments_data_to_binary-Tuple{Any, Any, Any, Any, moment_kinetics.file_io.io_moments_info, Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_neutral_moments_data_to_binary","text":"write time-dependent moments data for neutrals to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_overview!-NTuple{8, Any}","page":"file_io","title":"moment_kinetics.file_io.write_overview!","text":"write some overview information for the simulation to the binary file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_provenance_tracking_info!-NTuple{6, Any}","page":"file_io","title":"moment_kinetics.file_io.write_provenance_tracking_info!","text":"Write provenance tracking information, to allow runs to be reproduced.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_single_value!","page":"file_io","title":"moment_kinetics.file_io.write_single_value!","text":"write_single_value!(file_or_group, name,\n                    data::Union{Number, AbstractString, AbstractArray{T,N}},\n                    coords::Union{coordinate,mk_int,NamedTuple}...; parallel_io,\n                    description=nothing, units=nothing,\n                    overwrite=false) where {T,N}\n\nWrite a single variable to a file or group. If a description or units are passed, add as attributes of the variable.\n\nIf overwrite=true is passed, overwrite the variable if it already exists in the file. Note that when overwriting a String variable, the new String must have exactly the same length as the original String.\n\n\n\n\n\n","category":"function"},{"location":"zz_velocity_moments/#velocity_moments","page":"velocity_moments","title":"velocity_moments","text":"","category":"section"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments","page":"velocity_moments","title":"moment_kinetics.velocity_moments","text":"\n\n\n\n","category":"module"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.calculate_electron_moment_derivatives!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_electron_moment_derivatives!","text":"Pre-calculate spatial derivatives of the electron moments that will be needed for the time advance\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.calculate_electron_moment_derivatives_no_r!-NTuple{9, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_electron_moment_derivatives_no_r!","text":"Calculate spatial derivatives of the electron moments.\n\nThis version, for use in implicit solvers for electrons, works with a single point in r, given by ir.\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.calculate_ion_moment_derivatives!-NTuple{10, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_ion_moment_derivatives!","text":"Pre-calculate spatial derivatives of the moments that will be needed for the time advance\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.calculate_ion_qpar_from_coll_krook!-NTuple{13, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_ion_qpar_from_coll_krook!","text":"calculate parallel heat flux if ion composition flag is coll_krook fluid ions\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.calculate_ion_qpar_from_pdf!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_ion_qpar_from_pdf!","text":"calculate parallel heat flux if ion composition flag is kinetic ions\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.calculate_neutral_moment_derivatives!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_neutral_moment_derivatives!","text":"Pre-calculate spatial derivatives of the neutral moments that will be needed for the time advance\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.create_moments_electron-NTuple{5, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.create_moments_electron","text":"create a moment struct containing information about the electron moments\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.create_moments_ion-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.create_moments_ion","text":"\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.integrate_over_negative_vpa-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_negative_vpa","text":"computes the integral over vpa <= 0 of the integrand, using the input vpa_wgts this could be made more efficient for the case that dz/dt = vpa is time-independent, but it has been left general for the cases where, e.g., dz/dt = wpa*vth + upar varies in time\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.integrate_over_positive_vpa-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_positive_vpa","text":"computes the integral over vpa >= 0 of the integrand, using the input vpa_wgts this could be made more efficient for the case that dz/dt = vpa is time-independent, but it has been left general for the cases where, e.g., dz/dt = wpa*vth + upar varies in time\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.reset_moments_status!-Tuple{Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.reset_moments_status!","text":"\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_chodura!-NTuple{11, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_chodura!","text":"runtime diagnostic routine for computing the Chodura ratio in a single species plasma with Z = 1\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_chodura_integral_species!-NTuple{14, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_chodura_integral_species!","text":"compute the integral needed for the generalised Chodura condition\n\nIChodura = (Z^2 vBohm^2 / cref^2) * int ( f bz^2 / vz^2 + dfdr*rhostar/vz )  vBohm = sqrt(Z Te/mi)  with Z = 1 and mref = mi  cref = sqrt(2Ti/mi) and normalise to the local ion density, appropriate to assessing the  Chodura condition \n\nIChodura <= (Te/e)d ne / dphi |(sheath entrance) = ni\n\nto a single species plasma with Z = 1\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_density!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_density!","text":"NB: if this function is called and if dens_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_density_species!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_density_species!","text":"calculate the updated density (dens) for a given species; should only be called when evolvedensity = false, in which case the vpa coordinate is vpa/cs\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_derived_electron_moment_time_derivatives!-NTuple{4, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_derived_electron_moment_time_derivatives!","text":"'Primary' time derivatives are calculated when doing the time advance for moment quantities. Moment kinetic equations require in addition some 'derived' time derivatives, which we can calculate by applying the chain rule.\n\nFor electrons the kinetic equation that is solved for the shape function is simplified by using sqrtm_em_i as a small parameter after substituting in the moment equations. Therefore it is not possible (or at least not convenient) to use dp_dt as calculated from the moment equation. The electron moment time derivatives may still be useful as diagnostics, so we calculate them anyway, including the derived versions (calculated in this function), similar to the ion moment time derivatives.\n\nNote that due to the implicit/explicit splitting of terms in the timestep, which means that the density (which is equal to the ion density) does not update during the implicit electron timestep, the time derivative of density dn/dt does not contribute to the chain rule calculations in this function, even though analytically it would contribute (although the contribution would be small in sqrt(me/mi)). Another way of saying this is that due to the operator splitting, the time derivatives during the implicit step are done with the explicit variables (density in particular) held fixed, and so dvth_dt|_n = 0.5 * vth * dp_dt / p.\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_derived_ion_moment_time_derivatives!-Tuple{Any, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_derived_ion_moment_time_derivatives!","text":"'Primary' time derivatives are calculated when doing the time advance for moment quantities. Moment kinetic equations require in addition some 'derived' time derivatives, which we can calculate by applying the chain rule.\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_derived_moments!-NTuple{14, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_derived_moments!","text":"update velocity moments that are calculable from the evolved ion pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_derived_moments_neutral!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_derived_moments_neutral!","text":"update velocity moments that are calculable from the evolved neutral pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_derived_neutral_moment_time_derivatives!-Tuple{Any, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_derived_neutral_moment_time_derivatives!","text":"'Primary' time derivatives are calculated when doing the time advance for moment quantities. Moment kinetic equations require in addition some 'derived' time derivatives, which we can calculate by applying the chain rule.\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_ion_qpar!-NTuple{17, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_ion_qpar!","text":"NB: the incoming pdf is the normalized pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_ion_qpar_species!-NTuple{16, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_ion_qpar_species!","text":"calculate the updated parallel heat flux (qpar) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_moments!-Tuple{Any, Any, moment_kinetics.gyroaverages.gyro_operators, Vararg{Any, 10}}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_moments!","text":"calculate the updated density (dens) and parallel pressure (ppar) for all species this function is only used once after initialisation the function used to update moments at run time is updatederivedmoments! in time_advance.jl\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_moments_neutral!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_moments_neutral!","text":"update velocity moments of the evolved neutral pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_density!-NTuple{9, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_density!","text":"calculate the neutral density from the neutral pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_density_species!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_density_species!","text":"calculate the updated density (dens) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_p_species!-NTuple{15, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_p_species!","text":"calculate the updated pressure (p) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_pr_species!-NTuple{13, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_pr_species!","text":"calculate the updated pressure in rr direction (pr) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_pz_species!-NTuple{13, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_pz_species!","text":"calculate the updated pressure in zz direction (pz) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_pzeta_species!-NTuple{13, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_pzeta_species!","text":"calculate the updated pressure in zeta-zeta direction (pzeta) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_qz_species!-NTuple{13, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_qz_species!","text":"calculate the updated heat flux zzz direction (qz) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_ur_species!-NTuple{11, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_ur_species!","text":"calculate the updated ur (mean velocity in r) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_uz_species!-NTuple{11, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_uz_species!","text":"calculate the updated uz (mean velocity in z) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_uzeta_species!-NTuple{11, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_uzeta_species!","text":"calculate the updated uzeta (mean velocity in zeta) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_p!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_p!","text":"NB: if this function is called and if p_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_p_species!-NTuple{10, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_p_species!","text":"calculate the updated energy density (or pressure, p) for a given species; which of these is calculated depends on the definition of the vpa coordinate\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_ppar!-NTuple{14, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_ppar!","text":"Calculate the parallel pressure p∥=∫d^3v (v∥ - u_∥)^2 f\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_ppar_species!-NTuple{13, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_ppar_species!","text":"calculate the updated energy density (or parallel pressure, ppar) for a given species; which of these is calculated depends on the definition of the vpa coordinate\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_pperp_species!-NTuple{5, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_pperp_species!","text":"calculate the updated perpendicular pressure (pperp) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_upar!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_upar!","text":"NB: if this function is called and if upar_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_upar_species!-NTuple{10, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_upar_species!","text":"calculate the updated parallel flow (upar) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#coordinates","page":"coordinates","title":"coordinates","text":"","category":"section"},{"location":"zz_coordinates/#moment_kinetics.coordinates","page":"coordinates","title":"moment_kinetics.coordinates","text":"\n\n\n\n","category":"module"},{"location":"zz_coordinates/#moment_kinetics.coordinates.define_coordinate","page":"coordinates","title":"moment_kinetics.coordinates.define_coordinate","text":"define_coordinate(input_dict, name; parallel_io::Bool=false,\n                  run_directory=nothing, ignore_MPI=false,\n                  collision_operator_dim::Bool=true)\ndefine_coordinate(coord_input::NamedTuple; parallel_io::Bool=false,\n                  run_directory=nothing, ignore_MPI=false,\n                  collision_operator_dim::Bool=true, irank=0, nrank=1,\n                  comm=MPI.COMM_NULL)\n\nCreate arrays associated with a given coordinate, setup the coordinate grid, and populate the coordinate structure containing all of this information.\n\nWhen input_dict is passed, any missing settings will be set with default values.\n\nWhen coord_input is passed, it should be a NamedTuple as generated by get_coordinate_input, which contains a field for every coordinate input option.\n\n\n\n\n\n","category":"function"},{"location":"zz_coordinates/#moment_kinetics.coordinates.define_test_coordinate","page":"coordinates","title":"moment_kinetics.coordinates.define_test_coordinate","text":"define_test_coordinate(input_dict::AbstractDict; kwargs...)\ndefine_test_coordinate(name; collision_operator_dim=true, kwargs...)\n\nWrapper for define_coordinate() to make creating a coordinate for tests slightly less verbose.\n\nWhen passing input_dict, it must contain a \"name\" field, and can contain other settings\n\n\"ngrid\", \"nelement\", etc. Options other than \"name\" will be set using defaults if they\n\nare not passed. kwargs are the keyword arguments for define_coordinate.\n\nThe second form allows the coordinate input options to be passed as keyword arguments. For this form, apart from collision_operator_dim, the keyword arguments of define_coordinate cannot be passed, and ignore_MPI=true is always set, as this is most often useful for tests.\n\n\n\n\n\n","category":"function"},{"location":"zz_coordinates/#moment_kinetics.coordinates.elemental_to_full_grid_map-Tuple{Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.elemental_to_full_grid_map","text":"returns imin and imax, which contain the minimum and maximum indices on the full grid for each element\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.equally_spaced_grid-NTuple{4, Any}","page":"coordinates","title":"moment_kinetics.coordinates.equally_spaced_grid","text":"setup an equally spaced grid with n_global grid points between [-L/2,L/2]\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.equally_spaced_grid_shifted-NTuple{4, Any}","page":"coordinates","title":"moment_kinetics.coordinates.equally_spaced_grid_shifted","text":"setup an equally spaced grid with n_global grid points between [0,L]\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.full_to_elemental_grid_map-Tuple{Any, Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.full_to_elemental_grid_map","text":"setup arrays containing a map from the unpacked grid point indices to the element index and the grid point index within each element\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.get_coordinate_input-Tuple{Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.get_coordinate_input","text":"get_coordinate_input(input_dict, name; ignore_MPI=false,\n                     warn_unexpected::Bool=false)\n\nRead the input for coordinate name from input_dict, setting defaults, etc.\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.grid_spacing-Tuple{Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.grid_spacing","text":"given a set of grid point locations calculate and return the length associated with the cell between adjacent grid points\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.init_grid-NTuple{13, Any}","page":"coordinates","title":"moment_kinetics.coordinates.init_grid","text":"setup a grid with n_global grid points on the interval [-L/2,L/2]\n\n\n\n\n\n","category":"method"},{"location":"zz_type_definitions/#type_definitions","page":"type_definitions","title":"type_definitions","text":"","category":"section"},{"location":"zz_type_definitions/#moment_kinetics.type_definitions","page":"type_definitions","title":"moment_kinetics.type_definitions","text":"\n\n\n\n","category":"module"},{"location":"zz_type_definitions/#moment_kinetics.type_definitions.MPISharedArray","page":"type_definitions","title":"moment_kinetics.type_definitions.MPISharedArray","text":"Type used to declare a shared-memory array. When debugging is not active MPISharedArray is just an alias for Array, but when @debug_shared_array is activated, it is instead defined as an alias for DebugMPISharedArray.\n\n\n\n\n\n","category":"type"},{"location":"zz_type_definitions/#moment_kinetics.type_definitions.OptionsDict","page":"type_definitions","title":"moment_kinetics.type_definitions.OptionsDict","text":"\n\n\n\n","category":"type"},{"location":"zz_type_definitions/#moment_kinetics.type_definitions.mk_float","page":"type_definitions","title":"moment_kinetics.type_definitions.mk_float","text":"\n\n\n\n","category":"type"},{"location":"zz_type_definitions/#moment_kinetics.type_definitions.mk_int","page":"type_definitions","title":"moment_kinetics.type_definitions.mk_int","text":"\n\n\n\n","category":"type"},{"location":"zz_communication/#communication","page":"communication","title":"communication","text":"","category":"section"},{"location":"zz_communication/#moment_kinetics.communication","page":"communication","title":"moment_kinetics.communication","text":"Communication functions and setup\n\nSplit the grid into 'blocks'. Each block can use shared memory (MPI shared memory arrays). At the moment only works with a single 'block' containing the whole grid - eventually add more MPI communication functions to communicate between blocks. A block should probably be a 'NUMA region' for maximum efficiency.\n\nNote: charge-exchange collisions loop over neutral species for each ion species. At the moment this loop is not parallelised (although it could be, by introducing some more loop ranges), as at the moment we only run with 1 ion species and 1 neutral species.\n\n\n\n\n\n","category":"module"},{"location":"zz_communication/#moment_kinetics.communication.anysv_isubblock_index","page":"communication","title":"moment_kinetics.communication.anysv_isubblock_index","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.anysv_nsubblocks_per_block","page":"communication","title":"moment_kinetics.communication.anysv_nsubblocks_per_block","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.anysv_subblock_rank","page":"communication","title":"moment_kinetics.communication.anysv_subblock_rank","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.anysv_subblock_size","page":"communication","title":"moment_kinetics.communication.anysv_subblock_size","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.anyzv_isubblock_index","page":"communication","title":"moment_kinetics.communication.anyzv_isubblock_index","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.anyzv_nsubblocks_per_block","page":"communication","title":"moment_kinetics.communication.anyzv_nsubblocks_per_block","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.anyzv_subblock_rank","page":"communication","title":"moment_kinetics.communication.anyzv_subblock_rank","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.anyzv_subblock_size","page":"communication","title":"moment_kinetics.communication.anyzv_subblock_size","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.block_rank","page":"communication","title":"moment_kinetics.communication.block_rank","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.block_size","page":"communication","title":"moment_kinetics.communication.block_size","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.comm_anysv_subblock","page":"communication","title":"moment_kinetics.communication.comm_anysv_subblock","text":"Communicator for the local velocity-space subset of a shared-memory block in a 'anysv' region\n\nThe 'anysv' region is used to parallelise the collision operator. See moment_kinetics.looping.get_best_anysv_split.\n\nMust use a Ref{MPI.Comm} to allow a non-const MPI.Comm to be stored. Need to actually assign to this and not just copy a pointer into the .val member because otherwise the MPI.Comm object created by MPI.Comm_split() would be deleted, which probably makes MPI.jl delete the communicator.\n\n\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.comm_anyzv_subblock","page":"communication","title":"moment_kinetics.communication.comm_anyzv_subblock","text":"Communicator for the local velocity-space subset of a shared-memory block in a 'anyzv' region\n\nThe 'anyzv' region is used to parallelise the kinetic electron solve. See moment_kinetics.looping.get_best_anyzv_split.\n\nMust use a Ref{MPI.Comm} to allow a non-const MPI.Comm to be stored. Need to actually assign to this and not just copy a pointer into the .val member because otherwise the MPI.Comm object created by MPI.Comm_split() would be deleted, which probably makes MPI.jl delete the communicator.\n\n\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.comm_block","page":"communication","title":"moment_kinetics.communication.comm_block","text":"Communicator connecting a shared-memory region\n\nMust use a Ref{MPI.Comm} to allow a non-const MPI.Comm to be stored. Need to actually assign to this and not just copy a pointer into the .val member because otherwise the MPI.Comm object created by MPI.Comm_split() would be deleted, which probably makes MPI.jl delete the communicator.\n\n\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.comm_inter_block","page":"communication","title":"moment_kinetics.communication.comm_inter_block","text":"Communicator connecting the root processes of each shared memory block\n\nMust use a Ref{MPI.Comm} to allow a non-const MPI.Comm to be stored. Need to actually assign to this and not just copy a pointer into the .val member because otherwise the MPI.Comm object created by MPI.Comm_split() would be deleted, which probably makes MPI.jl delete the communicator.\n\n\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.comm_world","page":"communication","title":"moment_kinetics.communication.comm_world","text":"Can use a const MPI.Comm for comm_world and just copy the pointer from MPI.COMM_WORLD because MPI.COMM_WORLD is never deleted, so pointer stays valid.\n\n\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.global_Win_store","page":"communication","title":"moment_kinetics.communication.global_Win_store","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.global_rank","page":"communication","title":"moment_kinetics.communication.global_rank","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.global_size","page":"communication","title":"moment_kinetics.communication.global_size","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.iblock_index","page":"communication","title":"moment_kinetics.communication.iblock_index","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.n_blocks","page":"communication","title":"moment_kinetics.communication.n_blocks","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.__init__-Tuple{}","page":"communication","title":"moment_kinetics.communication.__init__","text":"\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication._anysv_subblock_synchronize-Tuple{Union{Missing, Nothing, UInt64}}","page":"communication","title":"moment_kinetics.communication._anysv_subblock_synchronize","text":"Internal function called by anysv synchronization macros.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication._anyzv_subblock_synchronize-Tuple{Union{Missing, Nothing, UInt64}}","page":"communication","title":"moment_kinetics.communication._anyzv_subblock_synchronize","text":"Internal function called by anyzv synchronization macros.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication._block_synchronize-Tuple{Union{Nothing, UInt64}}","page":"communication","title":"moment_kinetics.communication._block_synchronize","text":"Internal function to be called by @blocksynchronize() and @begin*region(). call_site will be either nothing or a hash of the file and line number of the calling site of the function.\n\nNote: some debugging code currently assumes that if blocksynchronize() is called on one block, it is called simultaneously on all blocks. It seems likely that this will always be true, but if it ever changes (i.e. different blocks doing totally different work), the debugging routines need to be updated.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.allocate_shared","page":"communication","title":"moment_kinetics.communication.allocate_shared","text":"allocate_shared(T; comm=nothing, maybe_debug=true, kwargs...)\nallocate_shared(T, dims...; comm=nothing, maybe_debug=true)\n\nGet a shared-memory array of mk_float (shared by all processes in a 'block').\n\nCreate a shared-memory array using MPI.Win_allocate_shared(). Pointer to the memory allocated is wrapped in a Julia array. Memory is not managed by the Julia array though. A reference to the MPI.Win needs to be freed - this is done by saving the MPI.Win into a Vector in the Communication module, which has all its entries freed by the finalize_comms!() function, which should be called when moment_kinetics is done running a simulation/test.\n\nArguments\n\nkwargs - mkint     Dimensions must be named to support shared-memory debugging tools. They can be either     passed as `name=dimsizekeyword arguments (coordinateobjects can also be passed     as the kwarg values, for convenienc), or usingdims.     Dimensions of the array to be created. Dimensions passed define the size of the     array which is being handled by the 'block' (rather than the global array, or a     subset for a single process). dims - coordinate, NamedTuple, Pair{Symbol,Integer}, or Pair{String,Integer}     Alternative tokwargs. May be passedcoordinate,NamedTuple,Pair{Symbol,Integer}(enter as e.g.:z => nwherenis anmkint),Pair{String,Integer}(enter as e.g.\"z\" => nwherenis anmkint),Pair{Symbol,coordinate},Pair{String,coordinate},Pair{Symbol,NamedTuple}, orPair{String,NamedTuple}arguments from which the name and size of the name and size     of the dimension will be extracted. comm -MPI.Comm, defaultcommblock[]`     MPI communicator containing the processes that share the array. maybedebug - Bool     Can be set to false to force not creating a DebugMPISharedArray when debugging is     active. This avoids recursion when including a shared-memory array as a member of a     DebugMPISharedArray for debugging purposes.\n\nReturns\n\nArray{mk_float}\n\n\n\n\n\n","category":"function"},{"location":"zz_communication/#moment_kinetics.communication.finalize_comms!-Tuple{}","page":"communication","title":"moment_kinetics.communication.finalize_comms!","text":"Clean up from communications\n\nDo any needed clean-up for MPI, etc. Does not call MPI.Finalize() - this is called anyway when Julia exits, and we do not want to call it explicitly so that multiple runs can be done in a single Julia session.\n\nFrees any shared-memory arrays.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.free_MPI_comm!-Tuple{Any}","page":"communication","title":"moment_kinetics.communication.free_MPI_comm!","text":"free_MPI_comm!(comm)\n\nIf comm is not null or one of the default communicators (COMMWORLD or COMMSELF), free it to avoid leaking MPI communicators. To be called before, e.g. comm_block[] is assigned (in case it is being reassigned). This is necessary because some MPI installations have a very limited number of communicators, and will error if this limit is exceeded.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.free_shared_arrays-Tuple{}","page":"communication","title":"moment_kinetics.communication.free_shared_arrays","text":"\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.halo_swap!","page":"communication","title":"moment_kinetics.communication.halo_swap!","text":"halo_swap!(x::AbstractArray, r, z)\n\nEnforce consistency of 'halo cells' - i.e. the grid points on block boundaries (in the r and z directions) that are shared by the grids owned by two processes (or more on block corners).\n\nFor consistency when adding random noise, just chooses the value from the upper/outer process rather than averaging.\n\n\n\n\n\n","category":"function"},{"location":"zz_communication/#moment_kinetics.communication.initialize_comms!-Tuple{}","page":"communication","title":"moment_kinetics.communication.initialize_comms!","text":"Set up communications\n\nCheck that global variables are in the correct state (i.e. caches were emptied correctly if they were used before).\n\nAlso does some set up for debugging routines, if they are active.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.setup_distributed_memory_MPI-NTuple{4, Any}","page":"communication","title":"moment_kinetics.communication.setup_distributed_memory_MPI","text":"Function to take information from user about r z grids and  number of processes allocated to set up communicators notation definitions:     - block: group of processes that share data with shared memory     - z group: group of processes that need to communicate data for z derivatives     - r group: group of processes that need to communicate data for r derivatives This routine assumes that the number of processes is selected by the user to match exactly the number the ratio \n\nnblocks = (rnelementglobal/rnelementlocal)*(znelementglobal/znelementlocal)\n\nThis guarantees perfect load balancing. Shared memory is used to parallelise the other dimensions within each distributed-memory parallelised rz block.   \n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.setup_distributed_memory_MPI_for_weights_precomputation-NTuple{5, Any}","page":"communication","title":"moment_kinetics.communication.setup_distributed_memory_MPI_for_weights_precomputation","text":"Function to take information from user about vpa vperp grids and  number of processes allocated to set up communicators for  precomputation of the Rosenbluth potential integration weights notation definitions:     - block: group of processes that share data with shared memory     - vpa group: group of processes that need to communicate data for vpa derivatives/integrals     - vperp group: group of processes that need to communicate data for vperp derivatives/integrals This routine assumes that the number of processes is selected by the user to match or be larger than the ratio \n\nnblocks = (vpanelementglobal/vpanelementlocal)*(vperpnelementglobal/vperpnelementlocal)\n\nWe also need to know (from user input) the maximum number of cores per shared memory region. A fraction of the cores will not contribute to the calculation, as we cannot guarantee that  the same number of cores is required for the rz parallelisation as the vpa vperp parallelisation \n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.setup_serial_MPI-Tuple{}","page":"communication","title":"moment_kinetics.communication.setup_serial_MPI","text":"Used for post-processing when we want various communicators to be initialised, but always for serial operation.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.@_anysv_subblock_synchronize-Tuple{}","page":"communication","title":"moment_kinetics.communication.@_anysv_subblock_synchronize","text":"Call an MPI Barrier for all processors in an 'anysv' sub-block.\n\nThe 'anysv' region is used to parallelise the collision operator. See moment_kinetics.looping.get_best_anysv_split.\n\nUsed to synchronise processors that are working on the same shared-memory array(s) between operations, to avoid race conditions. Should be even cheaper than @_block_synchronize because it only requires communication on a smaller communicator.\n\nNote: _anysv_subblock_synchronize() may be called different numbers of times on different sub-blocks, depending on how the species and spatial dimensions are split up. @debug_detect_redundant_block_synchronize is not implemented (yet?) for _anysv_subblock_synchronize().\n\n\n\n\n\n","category":"macro"},{"location":"zz_communication/#moment_kinetics.communication.@_anyzv_subblock_synchronize-Tuple{}","page":"communication","title":"moment_kinetics.communication.@_anyzv_subblock_synchronize","text":"Call an MPI Barrier for all processors in an 'anyzv' sub-block.\n\nThe 'anyzv' region is used to parallelise the kinetic electron implicit solve. See moment_kinetics.looping.get_best_anyzv_split.\n\nUsed to synchronise processors that are working on the same shared-memory array(s) between operations, to avoid race conditions. Should be even cheaper than @_block_synchronize because it only requires communication on a smaller communicator.\n\nNote: _anyzv_subblock_synchronize() may be called different numbers of times on different sub-blocks, depending on iteration counts and how the r-dimension is split up. @debug_detect_redundant_block_synchronize is not implemented (yet?) for _anyzv_subblock_synchronize().\n\n\n\n\n\n","category":"macro"},{"location":"zz_communication/#moment_kinetics.communication.@_block_synchronize-Tuple{}","page":"communication","title":"moment_kinetics.communication.@_block_synchronize","text":"Call an MPI Barrier for all processors in a block.\n\nUsed to synchronise processors that are working on the same shared-memory array(s) between operations, to avoid race conditions. Should be (much) cheaper than a global MPI Barrier because it only requires communication within a single node.\n\n\n\n\n\n","category":"macro"},{"location":"geometry/#Magnetic-Geometry","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"","category":"section"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"We take the magnetic field mathbfB to have the form ","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"beginequation\nmathbfB = B_z hatmathbfz + B_zeta hatmathbfzeta\nendequation","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"with B_zeta = B(rz) b_zeta, B_z = B(rz) b_z and b_z and b_zeta the direction cosines of the magnetic field vector. Here the basis vectors are those of cylindrical geometry (rzzeta), i.e., hatmathbfr = nabla r  hatmathbfz = nabla z,  and hatmathbfzeta = r nabla zeta. The unit vectors hatmathbfr, hatmathbfz, and hatmathbfzeta form a right-handed orthonormal basis.","category":"page"},{"location":"geometry/#Supported-options","page":"Magnetic Geometry","title":"Supported options","text":"","category":"section"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"To choose the type of geometry, set the value of \"option\" in the geometry namelist. The namelist will have the following appearance in the TOML file.","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"[geometry]\noption=\"constant-helical\" # ( or \"1D-mirror\" )\npitch = 1.0\nrhostar = 1.0\nDeltaB = 0.0","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"If rhostar is not set then it is computed from reference parameters.","category":"page"},{"location":"geometry/#[geometry]-option-\"constant-helical\"","page":"Magnetic Geometry","title":"[geometry] option = \"constant-helical\"","text":"","category":"section"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"Here b_zeta = sqrt1 - b_z^2 is a constant, b_z is a constant input parameter (\"pitch\") and B is taken to be 1 with respect to the reference value B_rm ref.","category":"page"},{"location":"geometry/#[geometry]-option-\"1D-mirror\"","page":"Magnetic Geometry","title":"[geometry] option = \"1D-mirror\"","text":"","category":"section"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"Here b_zeta = sqrt1 - b_z^2 is a constant, b_z is a constant input parameter (\"pitch\") and B = B(z) is taken to be  the function ","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"beginequation\nfracB(z)B_rm ref = \n    1 + Delta B left( 2left(frac2zL_zright)^2 - left(frac2zL_zright)^4right)\nendequation","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"where Delta B  is an input parameter (DeltaB) that must satisfy Delta B  -1. Recalling that the coordinate z runs from  z = -L_z2 to L_z2, if Delta B  0 than the field represents a magnetic mirror which traps particles, whereas if Delta B  0 then the magnetic field accelerates particles by the mirror force as they approach the wall. Note that this field does not satisfy nabla cdot mathbfB = 0, and is only used to test the implementation of the magnetic mirror terms. 2D simulations with a radial domain andmathbfEtimesmathbfB drifts are supported in the \"1D-mirror\" geometry option.","category":"page"},{"location":"geometry/#Geometric-coefficients","page":"Magnetic Geometry","title":"Geometric coefficients","text":"","category":"section"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"Here, we write the geometric coefficients appearing in the characteristic equations explicitly.","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"The z component of the mathbfEtimesmathbfB drift is given by","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"beginequation fracmathbfEtimesmathbfBB^2 cdot nabla z = fracE_r B_zetaB^2 nabla r times hatmathbfzeta cdot nabla z \n= - J fracE_r B_zetaB^2\nendequation","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"where we have defined J = r nabla r times nabla z cdot nabla zeta. Note that J is dimensionless. The r component of the mathbfEtimesmathbfB drift is given by","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"beginequation fracmathbfEtimesmathbfBB^2 cdot nabla r = fracE_z B_zetaB^2 nabla z times hatmathbfzeta cdot nabla r \n=  J fracE_z B_zetaB^2\nendequation","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"Due to the axisymmetry of the system, the differential operator  mathbfb cdot nabla (cdot)  = b_z partial (cdot)partial z,  and the convective derivative","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"beginequation\nfracd Bd t = fracd zd t fracpartial B partial z + fracdrdtfracpartial Bpartial r\nendequation","category":"page"},{"location":"zz_looping/#looping","page":"looping","title":"looping","text":"","category":"section"},{"location":"zz_looping/#moment_kinetics.looping","page":"looping","title":"moment_kinetics.looping","text":"Provides convenience macros for shared-memory-parallel loops\n\n\n\n\n\n","category":"module"},{"location":"zz_looping/#moment_kinetics.looping.debug_setup_loop_ranges_split_one_combination!-Tuple{NTuple{N, Symbol} where N, Vararg{Symbol}}","page":"looping","title":"moment_kinetics.looping.debug_setup_loop_ranges_split_one_combination!","text":"For debugging the shared-memory parallelism, create ranges where only the loops for a single combinations of variables (given by combination_to_split) are parallelised, and which dimensions are parallelised can be set with the dims_to_split... arguments.\n\nArguments\n\nKeyword arguments dim=n are required for each dim in all_dimensions where n is an integer giving the size of the dimension.\n\nthis_block_rank and this_block_size are overridable so that this function can be tested when running in serial.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.dims_string-Tuple{Tuple}","page":"looping","title":"moment_kinetics.looping.dims_string","text":"Construct a string composed of the dimension names given in the Tuple dims, separated by underscores\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_anysv_ranges-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.get_anysv_ranges","text":"\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_anyzv_ranges-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.get_anyzv_ranges","text":"\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_best_anysv_split-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_best_anysv_split","text":"Find the numbers of processes for each dimension that optimize load balance for 'anysv' type loops for a certain block_size.\n\nThe 'anysv' parallelisation patterns are designed for use in the collision operator. They all share the same parallelisation in spatial dimensions so that the region type can be switched between 'anysv' types within a loop over spatial dimensions (@looprz). It is only defined for ions, not for neutrals.\n\nParts of the collision operator cannot conveniently be parallelised over velocity dimensions, so this function aims to assign as much parallelism as possible to the spatial dimensions.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_best_anyzv_split-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_best_anyzv_split","text":"Find the numbers of processes for each dimension that optimize load balance for 'anyzv' type loops for a certain block_size.\n\nThe 'anyzv' parallelisation patterns are designed for use in the kinetic electron implicit solve. They all share the same parallelisation in the r-dimension so that the region type can be switched between 'anyzv' types within a loop over r (@loop_r).\n\nThe matrix-solve needed for the kinetic electron preconditioner is a bottleneck and requires a relatively large amount of communication so probably does not scale perfectly. To maximise parallelism, parallelise the r-dimension as much as possible before parallelising z/vperp/vpa.\n\nThis region type excludes the final point in the r-dimension, assuming that it will be filled in by a boundary condition or call to moment_kinetics.communication.halo_swap!.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_best_ranges-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.get_best_ranges","text":"Find the ranges for loop variables that optimize load balance for a certain block_size\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_local_range-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.get_local_range","text":"Get local range of indices when splitting a loop over processes in a sub-block\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_max_work-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_max_work","text":"Calculate the maximum number of grid points on any process\n\nThis is a measure of the maximum amount of work to do on a single process. Minimising this will make the parallelisation as efficient as possible.\n\nArguments\n\nnprocslist : Vector{mkint}     Number of processes for each dimension sizes : Vector{mk_int}     Size of each dimension\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_ranges_from_split-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.get_ranges_from_split","text":"\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_splits-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_splits","text":"Find possible divisions of each number less than or equal to block_size into n factors.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_splits_and_max_work_from_sizes-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_splits_and_max_work_from_sizes","text":"\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_subblock_splits-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_subblock_splits","text":"Find possible divisions of subblocksize into n factors\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.setup_loop_ranges!-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.setup_loop_ranges!","text":"Create ranges for loops with different combinations of variables\n\nArguments\n\nKeyword arguments dim=n are required for each dim in [:s, :r, :z, :vperp, :vpa, :sn, :vzeta, :vr, :vz] where n is an integer giving the size of the dimension.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.@anysv_serial_region-Tuple{Any}","page":"looping","title":"moment_kinetics.looping.@anysv_serial_region","text":"Run a block of code on only anysv-subblock-rank-0 of each group of processes operating on an 'anysv' shared-memory subblock\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@anyzv_serial_region-Tuple{Any}","page":"looping","title":"moment_kinetics.looping.@anyzv_serial_region","text":"Run a block of code on only anyzv-subblock-rank-0 of each group of processes operating on an 'anyzv' shared-memory subblock\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anysv_region","page":"looping","title":"moment_kinetics.looping.@begin_anysv_region","text":"Begin 'anysv' sub-region in which () species/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanysv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anysv_subblock_synchronize() to synchronize the processes operating on an 'anysv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anysv_s_region","page":"looping","title":"moment_kinetics.looping.@begin_anysv_s_region","text":"Begin 'anysv' sub-region in which (:s,) species/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanysv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anysv_subblock_synchronize() to synchronize the processes operating on an 'anysv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anysv_s_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_anysv_s_vpa_region","text":"Begin 'anysv' sub-region in which (:s, :vpa) species/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanysv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anysv_subblock_synchronize() to synchronize the processes operating on an 'anysv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anysv_s_vperp_region","page":"looping","title":"moment_kinetics.looping.@begin_anysv_s_vperp_region","text":"Begin 'anysv' sub-region in which (:s, :vperp) species/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanysv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anysv_subblock_synchronize() to synchronize the processes operating on an 'anysv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anysv_s_vperp_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_anysv_s_vperp_vpa_region","text":"Begin 'anysv' sub-region in which (:s, :vperp, :vpa) species/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanysv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anysv_subblock_synchronize() to synchronize the processes operating on an 'anysv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anysv_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_anysv_vpa_region","text":"Begin 'anysv' sub-region in which (:vpa,) species/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanysv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anysv_subblock_synchronize() to synchronize the processes operating on an 'anysv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anysv_vperp_region","page":"looping","title":"moment_kinetics.looping.@begin_anysv_vperp_region","text":"Begin 'anysv' sub-region in which (:vperp,) species/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanysv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anysv_subblock_synchronize() to synchronize the processes operating on an 'anysv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anysv_vperp_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_anysv_vperp_vpa_region","text":"Begin 'anysv' sub-region in which (:vperp, :vpa) species/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanysv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anysv_subblock_synchronize() to synchronize the processes operating on an 'anysv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anyzv_region","page":"looping","title":"moment_kinetics.looping.@begin_anyzv_region","text":"Begin 'anyzv' sub-region in which () z/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanyzv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anyzv_subblock_synchronize() to synchronize the processes operating on an 'anyzv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anyzv_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_anyzv_vpa_region","text":"Begin 'anyzv' sub-region in which (:vpa,) z/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanyzv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anyzv_subblock_synchronize() to synchronize the processes operating on an 'anyzv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anyzv_vperp_region","page":"looping","title":"moment_kinetics.looping.@begin_anyzv_vperp_region","text":"Begin 'anyzv' sub-region in which (:vperp,) z/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanyzv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anyzv_subblock_synchronize() to synchronize the processes operating on an 'anyzv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anyzv_vperp_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_anyzv_vperp_vpa_region","text":"Begin 'anyzv' sub-region in which (:vperp, :vpa) z/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanyzv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anyzv_subblock_synchronize() to synchronize the processes operating on an 'anyzv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anyzv_z_region","page":"looping","title":"moment_kinetics.looping.@begin_anyzv_z_region","text":"Begin 'anyzv' sub-region in which (:z,) z/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanyzv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anyzv_subblock_synchronize() to synchronize the processes operating on an 'anyzv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anyzv_z_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_anyzv_z_vpa_region","text":"Begin 'anyzv' sub-region in which (:z, :vpa) z/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanyzv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anyzv_subblock_synchronize() to synchronize the processes operating on an 'anyzv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anyzv_z_vperp_region","page":"looping","title":"moment_kinetics.looping.@begin_anyzv_z_vperp_region","text":"Begin 'anyzv' sub-region in which (:z, :vperp) z/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanyzv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anyzv_subblock_synchronize() to synchronize the processes operating on an 'anyzv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_anyzv_z_vperp_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_anyzv_z_vperp_vpa_region","text":"Begin 'anyzv' sub-region in which (:z, :vperp, :vpa) z/velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @beginanyzv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anyzv_subblock_synchronize() to synchronize the processes operating on an 'anyzv' shared-memory sub-block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_anyzv_region","page":"looping","title":"moment_kinetics.looping.@begin_r_anyzv_region","text":"Begin region in which r-dimension and z/velocity dimensions are parallelized by being split between processes, and which z/velocity dimensions are parallelized can be switched within the outer loop over r. This parallelization scheme is intended for use in the kinetic electron implicit solve.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_region","page":"looping","title":"moment_kinetics.looping.@begin_r_region","text":"Begin region in which (:r,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_r_vpa_region","text":"Begin region in which (:r, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_vperp_region","page":"looping","title":"moment_kinetics.looping.@begin_r_vperp_region","text":"Begin region in which (:r, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_vperp_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_r_vperp_vpa_region","text":"Begin region in which (:r, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_r_vr_region","text":"Begin region in which (:r, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_r_vr_vz_region","text":"Begin region in which (:r, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_r_vz_region","text":"Begin region in which (:r, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_vzeta_region","page":"looping","title":"moment_kinetics.looping.@begin_r_vzeta_region","text":"Begin region in which (:r, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_vzeta_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_r_vzeta_vr_region","text":"Begin region in which (:r, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_vzeta_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_r_vzeta_vr_vz_region","text":"Begin region in which (:r, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_vzeta_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_r_vzeta_vz_region","text":"Begin region in which (:r, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_z_anysv_region","page":"looping","title":"moment_kinetics.looping.@begin_r_z_anysv_region","text":"Begin region in which (:r,:z) dimensions and species/velocity dimensions are parallelized by being split between processes, and which species/velocity dimensions are parallelized can be switched within the outer loop over (:r,:z). This parallelization scheme is intended for use in the collision operator.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_z_region","page":"looping","title":"moment_kinetics.looping.@begin_r_z_region","text":"Begin region in which (:r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_z_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_r_z_vpa_region","text":"Begin region in which (:r, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_z_vperp_region","page":"looping","title":"moment_kinetics.looping.@begin_r_z_vperp_region","text":"Begin region in which (:r, :z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_z_vperp_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_r_z_vperp_vpa_region","text":"Begin region in which (:r, :z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_z_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_r_z_vr_region","text":"Begin region in which (:r, :z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_z_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_r_z_vr_vz_region","text":"Begin region in which (:r, :z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_z_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_r_z_vz_region","text":"Begin region in which (:r, :z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_z_vzeta_region","page":"looping","title":"moment_kinetics.looping.@begin_r_z_vzeta_region","text":"Begin region in which (:r, :z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_z_vzeta_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_r_z_vzeta_vr_region","text":"Begin region in which (:r, :z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_z_vzeta_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_r_z_vzeta_vr_vz_region","text":"Begin region in which (:r, :z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_r_z_vzeta_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_r_z_vzeta_vz_region","text":"Begin region in which (:r, :z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_r_region","page":"looping","title":"moment_kinetics.looping.@begin_s_r_region","text":"Begin region in which (:s, :r) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_r_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_s_r_vpa_region","text":"Begin region in which (:s, :r, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_r_vperp_region","page":"looping","title":"moment_kinetics.looping.@begin_s_r_vperp_region","text":"Begin region in which (:s, :r, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_r_vperp_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_s_r_vperp_vpa_region","text":"Begin region in which (:s, :r, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_r_z_region","page":"looping","title":"moment_kinetics.looping.@begin_s_r_z_region","text":"Begin region in which (:s, :r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_r_z_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_s_r_z_vpa_region","text":"Begin region in which (:s, :r, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_r_z_vperp_region","page":"looping","title":"moment_kinetics.looping.@begin_s_r_z_vperp_region","text":"Begin region in which (:s, :r, :z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_r_z_vperp_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_s_r_z_vperp_vpa_region","text":"Begin region in which (:s, :r, :z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_region","page":"looping","title":"moment_kinetics.looping.@begin_s_region","text":"Begin region in which (:s,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_s_vpa_region","text":"Begin region in which (:s, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_vperp_region","page":"looping","title":"moment_kinetics.looping.@begin_s_vperp_region","text":"Begin region in which (:s, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_vperp_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_s_vperp_vpa_region","text":"Begin region in which (:s, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_z_region","page":"looping","title":"moment_kinetics.looping.@begin_s_z_region","text":"Begin region in which (:s, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_z_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_s_z_vpa_region","text":"Begin region in which (:s, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_z_vperp_region","page":"looping","title":"moment_kinetics.looping.@begin_s_z_vperp_region","text":"Begin region in which (:s, :z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_s_z_vperp_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_s_z_vperp_vpa_region","text":"Begin region in which (:s, :z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_serial_region","page":"looping","title":"moment_kinetics.looping.@begin_serial_region","text":"Begin region in which only rank-0 in each group of processes operating on a shared-memory block operates on shared-memory arrays.\n\nReturns immediately if loopranges[] is already set for a serial region. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_region","text":"Begin region in which (:sn, :r) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_vr_region","text":"Begin region in which (:sn, :r, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_vr_vz_region","text":"Begin region in which (:sn, :r, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_vz_region","text":"Begin region in which (:sn, :r, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_vzeta_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_vzeta_region","text":"Begin region in which (:sn, :r, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_vzeta_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_vzeta_vr_region","text":"Begin region in which (:sn, :r, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_vzeta_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_vzeta_vr_vz_region","text":"Begin region in which (:sn, :r, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_vzeta_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_vzeta_vz_region","text":"Begin region in which (:sn, :r, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_z_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_z_region","text":"Begin region in which (:sn, :r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_z_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_z_vr_region","text":"Begin region in which (:sn, :r, :z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_z_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_z_vr_vz_region","text":"Begin region in which (:sn, :r, :z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_z_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_z_vz_region","text":"Begin region in which (:sn, :r, :z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_z_vzeta_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_z_vzeta_region","text":"Begin region in which (:sn, :r, :z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_z_vzeta_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_z_vzeta_vr_region","text":"Begin region in which (:sn, :r, :z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_z_vzeta_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_z_vzeta_vr_vz_region","text":"Begin region in which (:sn, :r, :z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_r_z_vzeta_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_r_z_vzeta_vz_region","text":"Begin region in which (:sn, :r, :z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_region","text":"Begin region in which (:sn,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_vr_region","text":"Begin region in which (:sn, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_vr_vz_region","text":"Begin region in which (:sn, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_vz_region","text":"Begin region in which (:sn, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_vzeta_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_vzeta_region","text":"Begin region in which (:sn, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_vzeta_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_vzeta_vr_region","text":"Begin region in which (:sn, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_vzeta_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_vzeta_vr_vz_region","text":"Begin region in which (:sn, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_vzeta_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_vzeta_vz_region","text":"Begin region in which (:sn, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_z_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_z_region","text":"Begin region in which (:sn, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_z_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_z_vr_region","text":"Begin region in which (:sn, :z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_z_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_z_vr_vz_region","text":"Begin region in which (:sn, :z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_z_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_z_vz_region","text":"Begin region in which (:sn, :z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_z_vzeta_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_z_vzeta_region","text":"Begin region in which (:sn, :z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_z_vzeta_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_z_vzeta_vr_region","text":"Begin region in which (:sn, :z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_z_vzeta_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_z_vzeta_vr_vz_region","text":"Begin region in which (:sn, :z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_sn_z_vzeta_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_sn_z_vzeta_vz_region","text":"Begin region in which (:sn, :z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_vpa_region","text":"Begin region in which (:vpa,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_vperp_region","page":"looping","title":"moment_kinetics.looping.@begin_vperp_region","text":"Begin region in which (:vperp,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_vperp_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_vperp_vpa_region","text":"Begin region in which (:vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_vr_region","text":"Begin region in which (:vr,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_vr_vz_region","text":"Begin region in which (:vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_vz_region","text":"Begin region in which (:vz,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_vzeta_region","page":"looping","title":"moment_kinetics.looping.@begin_vzeta_region","text":"Begin region in which (:vzeta,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_vzeta_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_vzeta_vr_region","text":"Begin region in which (:vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_vzeta_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_vzeta_vr_vz_region","text":"Begin region in which (:vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_vzeta_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_vzeta_vz_region","text":"Begin region in which (:vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_z_region","page":"looping","title":"moment_kinetics.looping.@begin_z_region","text":"Begin region in which (:z,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_z_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_z_vpa_region","text":"Begin region in which (:z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_z_vperp_region","page":"looping","title":"moment_kinetics.looping.@begin_z_vperp_region","text":"Begin region in which (:z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_z_vperp_vpa_region","page":"looping","title":"moment_kinetics.looping.@begin_z_vperp_vpa_region","text":"Begin region in which (:z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_z_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_z_vr_region","text":"Begin region in which (:z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_z_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_z_vr_vz_region","text":"Begin region in which (:z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_z_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_z_vz_region","text":"Begin region in which (:z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_z_vzeta_region","page":"looping","title":"moment_kinetics.looping.@begin_z_vzeta_region","text":"Begin region in which (:z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_z_vzeta_vr_region","page":"looping","title":"moment_kinetics.looping.@begin_z_vzeta_vr_region","text":"Begin region in which (:z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_z_vzeta_vr_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_z_vzeta_vr_vz_region","text":"Begin region in which (:z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@begin_z_vzeta_vz_region","page":"looping","title":"moment_kinetics.looping.@begin_z_vzeta_vz_region","text":"Begin region in which (:z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the @begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless true is passed as the no_synchronize argument.\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r","text":"Loop over (:r,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vpa","text":"Loop over (:r, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vperp-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vperp","text":"Loop over (:r, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vperp_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vperp_vpa","text":"Loop over (:r, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vr","text":"Loop over (:r, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vr_vz","text":"Loop over (:r, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vz","text":"Loop over (:r, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vzeta-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta","text":"Loop over (:r, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vzeta_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta_vr","text":"Loop over (:r, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vzeta_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta_vr_vz","text":"Loop over (:r, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vzeta_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta_vz","text":"Loop over (:r, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z","text":"Loop over (:r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vpa","text":"Loop over (:r, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vperp-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vperp","text":"Loop over (:r, :z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vperp_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vperp_vpa","text":"Loop over (:r, :z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vr","text":"Loop over (:r, :z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vr_vz","text":"Loop over (:r, :z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vz","text":"Loop over (:r, :z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vzeta-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta","text":"Loop over (:r, :z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vzeta_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta_vr","text":"Loop over (:r, :z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vzeta_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta_vr_vz","text":"Loop over (:r, :z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vzeta_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta_vz","text":"Loop over (:r, :z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s","text":"Loop over (:s,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r","text":"Loop over (:s, :r) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vpa","text":"Loop over (:s, :r, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_vperp-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vperp","text":"Loop over (:s, :r, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_vperp_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vperp_vpa","text":"Loop over (:s, :r, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_z-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z","text":"Loop over (:s, :r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_z_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vpa","text":"Loop over (:s, :r, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_z_vperp-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vperp","text":"Loop over (:s, :r, :z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_z_vperp_vpa-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vperp_vpa","text":"Loop over (:s, :r, :z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vpa","text":"Loop over (:s, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_vperp-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vperp","text":"Loop over (:s, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_vperp_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vperp_vpa","text":"Loop over (:s, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z","text":"Loop over (:s, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_z_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vpa","text":"Loop over (:s, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_z_vperp-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vperp","text":"Loop over (:s, :z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_z_vperp_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vperp_vpa","text":"Loop over (:s, :z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn","text":"Loop over (:sn,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r","text":"Loop over (:sn, :r) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vr","text":"Loop over (:sn, :r, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vr_vz","text":"Loop over (:sn, :r, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vz","text":"Loop over (:sn, :r, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vzeta-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta","text":"Loop over (:sn, :r, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vzeta_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta_vr","text":"Loop over (:sn, :r, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vzeta_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta_vr_vz","text":"Loop over (:sn, :r, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vzeta_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta_vz","text":"Loop over (:sn, :r, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z","text":"Loop over (:sn, :r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vr","text":"Loop over (:sn, :r, :z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vr_vz","text":"Loop over (:sn, :r, :z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vz","text":"Loop over (:sn, :r, :z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta","text":"Loop over (:sn, :r, :z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta_vr-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta_vr","text":"Loop over (:sn, :r, :z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta_vr_vz-NTuple{7, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta_vr_vz","text":"Loop over (:sn, :r, :z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta_vz","text":"Loop over (:sn, :r, :z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vr","text":"Loop over (:sn, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vr_vz","text":"Loop over (:sn, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vz","text":"Loop over (:sn, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vzeta-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta","text":"Loop over (:sn, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vzeta_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta_vr","text":"Loop over (:sn, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vzeta_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta_vr_vz","text":"Loop over (:sn, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vzeta_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta_vz","text":"Loop over (:sn, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z","text":"Loop over (:sn, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vr","text":"Loop over (:sn, :z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vr_vz","text":"Loop over (:sn, :z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vz","text":"Loop over (:sn, :z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vzeta-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta","text":"Loop over (:sn, :z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vzeta_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta_vr","text":"Loop over (:sn, :z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vzeta_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta_vr_vz","text":"Loop over (:sn, :z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vzeta_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta_vz","text":"Loop over (:sn, :z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vpa-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vpa","text":"Loop over (:vpa,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vperp-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vperp","text":"Loop over (:vperp,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vperp_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vperp_vpa","text":"Loop over (:vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vr-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vr","text":"Loop over (:vr,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vr_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vr_vz","text":"Loop over (:vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vz-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vz","text":"Loop over (:vz,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vzeta-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta","text":"Loop over (:vzeta,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vzeta_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta_vr","text":"Loop over (:vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vzeta_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta_vr_vz","text":"Loop over (:vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vzeta_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta_vz","text":"Loop over (:vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z","text":"Loop over (:z,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vpa","text":"Loop over (:z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vperp-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vperp","text":"Loop over (:z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vperp_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vperp_vpa","text":"Loop over (:z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vr","text":"Loop over (:z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vr_vz","text":"Loop over (:z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vz","text":"Loop over (:z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vzeta-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta","text":"Loop over (:z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vzeta_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta_vr","text":"Loop over (:z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vzeta_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta_vr_vz","text":"Loop over (:z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vzeta_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta_vz","text":"Loop over (:z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@serial_region-Tuple{Any}","page":"looping","title":"moment_kinetics.looping.@serial_region","text":"Run a block of code on only rank-0 of each group of processes operating on a shared-memory block\n\n\n\n\n\n","category":"macro"},{"location":"zz_geo/#geo","page":"geo","title":"geo","text":"","category":"section"},{"location":"zz_geo/#moment_kinetics.geo","page":"geo","title":"moment_kinetics.geo","text":"module for including axisymmetric geometry in coordinates (z,r), with z the vertical  coordinate and r the radial coordinate\n\n\n\n\n\n","category":"module"},{"location":"zz_geo/#moment_kinetics.geo.geometric_coefficients","page":"geo","title":"moment_kinetics.geo.geometric_coefficients","text":"struct containing the geometric data necessary for  non-trivial axisymmetric geometries, to be passed  around the inside of the code, replacing the  geometry_input struct from input_structs.jl\n\nThe arrays of 2 dimensions are functions of (z,r)\n\n\n\n\n\n","category":"type"},{"location":"zz_geo/#moment_kinetics.geo.get_default_rhostar-Tuple{Any}","page":"geo","title":"moment_kinetics.geo.get_default_rhostar","text":"function get_default_rhostar(reference_params)\n\nCalculate c_mathrmref  Omega_mathrmref L_mathrmref = m_i c_mathrmref  e B_mathrmref L_mathrmref.\n\nThis is similar to the de-dimensionalised ion gyroradius at reference parameters, which would be sqrt(2)*rhostar, as v_Ti(T_mathrmref) = sqrt2 T_mathrmref  m_i = sqrt2 c_mathrmref.\n\n\n\n\n\n","category":"method"},{"location":"zz_geo/#moment_kinetics.geo.init_magnetic_geometry-Tuple{moment_kinetics.input_structs.geometry_input, Any, Any, Any}","page":"geo","title":"moment_kinetics.geo.init_magnetic_geometry","text":"function to initialise the geometry coefficients inputdata – geometryinput type z – coordinate type r – coordinate type\n\n\n\n\n\n","category":"method"},{"location":"zz_geo/#moment_kinetics.geo.setup_geometry_input-Tuple{AbstractDict, Bool}","page":"geo","title":"moment_kinetics.geo.setup_geometry_input","text":"function to read the geometry input data from the TOML file\n\nthe TOML namelist should be structured like\n\n[geometry] pitch = 1.0 rhostar = 1.0 DeltaB = 0.0 option = \"\"\n\n\n\n\n\n","category":"method"},{"location":"zz_bgk/#bgk","page":"bgk","title":"bgk","text":"","category":"section"},{"location":"zz_bgk/#moment_kinetics.bgk","page":"bgk","title":"moment_kinetics.bgk","text":"\n\n\n\n","category":"module"},{"location":"zz_bgk/#moment_kinetics.bgk.allowed_wave_amplitude!-NTuple{5, Any}","page":"bgk","title":"moment_kinetics.bgk.allowed_wave_amplitude!","text":"\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.init_bgk_pdf!-NTuple{6, Any}","page":"bgk","title":"moment_kinetics.bgk.init_bgk_pdf!","text":"\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.passing_pdf!-NTuple{5, Any}","page":"bgk","title":"moment_kinetics.bgk.passing_pdf!","text":"inputs\n\npdf is the particle distribution function, with the passing part of phase space not filled in\nphi_max is the maximum value that e * phi / Te takes\ntau = Ti/Te is the ion-electron temperature ratio\nx = mvpa^2/2Te + ephi/Te is 1D array containing the total parallel energy (conserved)\n\noutput\n\npdf = particle distribution function; this function fills in the part of phase space where x > e*phi_max/T\n\n\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.setup_dummy_integrals-Tuple{}","page":"bgk","title":"moment_kinetics.bgk.setup_dummy_integrals","text":"\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.total_energy_grid-Tuple{Any, Any}","page":"bgk","title":"moment_kinetics.bgk.total_energy_grid","text":"inputs:\n\nvpa = parallel velocity normalized by vts = sqrt(2*Te/ms)\nphi = electrostatic potential normalized by Te/e\n\noutput: x = vpa^2 + phi is the total parallel energy\n\n\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.trapped_passing_boundary-Tuple{Any, Any}","page":"bgk","title":"moment_kinetics.bgk.trapped_passing_boundary","text":"\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.trapped_pdf!-NTuple{8, Any}","page":"bgk","title":"moment_kinetics.bgk.trapped_pdf!","text":"inputs\n\nphi_max is the maximum value that e * phi / Te takes\ntau = Ti/Te is the ion-electron temperature ratio\nx = vpa^2 + e*phi is a 2D array containing the total parallel energy on the (z,vpa) grid\ny = dummy coordinate for the necessary integrals in the function\nintegrand = dummy array used to hold integrands defined and integrated in this function\nwgts = integration weights associated with y integrals\n\noutput\n\npdf is the particle distribution function for all of phase space, with this function filling in only the part with x < e*phi_max/T\n\n\n\n\n\n","category":"method"},{"location":"zz_continuity/#continuity","page":"continuity","title":"continuity","text":"","category":"section"},{"location":"zz_continuity/#moment_kinetics.continuity","page":"continuity","title":"moment_kinetics.continuity","text":"\n\n\n\n","category":"module"},{"location":"zz_continuity/#moment_kinetics.continuity.continuity_equation!-NTuple{11, Any}","page":"continuity","title":"moment_kinetics.continuity.continuity_equation!","text":"use the continuity equation dn/dt + d(n*upar)/dz to update the density n for all ion species\n\n\n\n\n\n","category":"method"},{"location":"zz_continuity/#moment_kinetics.continuity.neutral_continuity_equation!-NTuple{9, Any}","page":"continuity","title":"moment_kinetics.continuity.neutral_continuity_equation!","text":"use the continuity equation dn/dt + d(n*upar)/dz to update the density n for all neutral species\n\n\n\n\n\n","category":"method"},{"location":"zz_debugging/#debugging","page":"debugging","title":"debugging","text":"","category":"section"},{"location":"zz_debugging/#moment_kinetics.debugging","page":"debugging","title":"moment_kinetics.debugging","text":"Define debugging levels that can be used to include extra debugging steps\n\nProvides a bunch of macros (see the macronames Vector) that can be used to surround code in other modules so that it only runs if the 'debug level' passed to the --debug or -d command line argument is high enough.\n\nAlso provides macro *_ifelse whose names are taken from macronames, which can be used to switch definitions, etc. For example, if debug_shared_array is in macronames, then\n\nconst MPISharedArray = @debug_shared_array_ifelse(DebugMPISharedArray, Array)\n\ncan be used to make the type represented by MPISharedArray depend on the debug level.\n\n\n\n\n\n","category":"module"},{"location":"zz_debugging/#moment_kinetics.debugging._debug_level","page":"debugging","title":"moment_kinetics.debugging._debug_level","text":"\n\n\n\n","category":"constant"},{"location":"zz_debugging/#moment_kinetics.debugging.macronames","page":"debugging","title":"moment_kinetics.debugging.macronames","text":"\n\n\n\n","category":"constant"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_block_synchronize_backtrace-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_block_synchronize_backtrace","text":"Check blocksynchronize() was called from the same place on every process, checking the full backtrace of each call.  Activated at _debug_level >= 4  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_block_synchronize_backtrace_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_block_synchronize_backtrace_ifelse","text":"Evaluate first expression if debugblocksynchronizebacktrace is active, second expression if not  debugblocksynchronizebacktrace is inactive (_debug_level = 0 < 4).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_block_synchronize_quick-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_block_synchronize_quick","text":"Check blocksynchronize() was called from the same place on every process, with quick check of call site.  Activated at _debug_level >= 1  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_block_synchronize_quick_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_block_synchronize_quick_ifelse","text":"Evaluate first expression if debugblocksynchronizequick is active, second expression if not  debugblocksynchronizequick is inactive (_debug_level = 0 < 1).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_consistency_checks-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_consistency_checks","text":"Some extra checks that we do not want in production runs.  Activated at _debug_level >= 1  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_consistency_checks_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_consistency_checks_ifelse","text":"Evaluate first expression if debugconsistencychecks is active, second expression if not  debugconsistencychecks is inactive (_debug_level = 0 < 1).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_detect_redundant_block_synchronize-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_detect_redundant_block_synchronize","text":"Check if any blocksynchronize() call could have been skipped without resulting in an error.  Activated at _debug_level >= 5  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_detect_redundant_block_synchronize_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_detect_redundant_block_synchronize_ifelse","text":"Evaluate first expression if debugdetectredundantblocksynchronize is active, second expression if not  debugdetectredundantblocksynchronize is inactive (_debug_level = 0 < 5).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_initialize_NaN-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_initialize_NaN","text":"Initialize arrays with NaN.  Activated at _debug_level >= 1  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_initialize_NaN_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_initialize_NaN_ifelse","text":"Evaluate first expression if debuginitializeNaN is active, second expression if not  debuginitializeNaN is inactive (_debug_level = 0 < 1).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_shared_array-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array","text":"Check for incorrect reads/writes to shared-memory arrays  Activated at _debug_level >= 2  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_shared_array_allocate-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_allocate","text":"Check that allocateshared() was called from the same place on every process.  Activated at `debuglevel >= 4Currently inactive (debug_level = 0`).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_shared_array_allocate_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_allocate_ifelse","text":"Evaluate first expression if debugsharedarrayallocate is active, second expression if not  debugsharedarrayallocate is inactive (_debug_level = 0 < 4).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_shared_array_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_ifelse","text":"Evaluate first expression if debugsharedarray is active, second expression if not  debugsharedarray is inactive (_debug_level = 0 < 2).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_track_array_allocate_location-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_array_allocate_location","text":"Record where every array was allocated.  Activated at _debug_level >= 3  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_track_array_allocate_location_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_array_allocate_location_ifelse","text":"Evaluate first expression if debugtrackarrayallocatelocation is active, second expression if not  debugtrackarrayallocatelocation is inactive (_debug_level = 0 < 3).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_track_initialized-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_initialized","text":"Check that every array is initialized before being used.  Activated at _debug_level >= 3  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_track_initialized_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_initialized_ifelse","text":"Evaluate first expression if debugtrackinitialized is active, second expression if not  debugtrackinitialized is inactive (_debug_level = 0 < 3).\n\n\n\n\n\n","category":"macro"},{"location":"zz_time_advance/#time_advance","page":"time_advance","title":"time_advance","text":"","category":"section"},{"location":"zz_time_advance/#moment_kinetics.time_advance","page":"time_advance","title":"moment_kinetics.time_advance","text":"\n\n\n\n","category":"module"},{"location":"zz_time_advance/#moment_kinetics.time_advance.adaptive_timestep_update!-NTuple{30, Any}","page":"time_advance","title":"moment_kinetics.time_advance.adaptive_timestep_update!","text":"adaptive_timestep_update!(scratch, scratch_implicit, scratch_electron,\n                          t_params, pdf, moments, fields, boundaries, composition,\n                          collisions, geometry, external_source_settings,\n                          spectral_objects, advect_objects, gyroavs, num_diss_params,\n                          nl_solver_params, advance, scratch_dummy, r, z, vperp, vpa,\n                          vzeta, vr, vz, success, nl_max_its_fraction,\n                          nl_total_its_soft_limit, nl_total_its_soft_limit_reduce_dt)\n\nCheck the error estimate for the embedded RK method and adjust the timestep if appropriate.\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.apply_all_bcs_constraints_update_moments!-NTuple{28, Any}","page":"time_advance","title":"moment_kinetics.time_advance.apply_all_bcs_constraints_update_moments!","text":"Apply boundary conditions and moment constraints to updated pdfs and calculate derived moments and moment derivatives\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.euler_time_advance!-NTuple{28, Any}","page":"time_advance","title":"moment_kinetics.time_advance.euler_time_advance!","text":"eulertimeadvance! advances the vector equation dfvec/dt = G[f] that includes the kinetic equation + any evolved moment equations using the forward Euler method: fvecout = fvecin + dt*fvecin, with fvecin an input and fvec_out the output.\n\nNote dt is passed separately from t_params because sometimes (in the IMEX Runge-Kutta implementation), a call needs to be made with dt scaled by some coefficient.\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.implicit_ion_advance!-NTuple{29, Any}","page":"time_advance","title":"moment_kinetics.time_advance.implicit_ion_advance!","text":"implicit_ion_advance!(fvec_out, fvec_in, pdf, fields, moments, advect_objects,\n                      vz, vr, vzeta, vpa, vperp, gyrophase, z, r, t_params, dt,\n                      spectral_objects, composition, collisions, geometry,\n                      scratch_dummy, manufactured_source_list,\n                      external_source_settings, num_diss_params,\n                      nl_solver_params, advance, fp_arrays, istage)\n\nDo a backward-Euler timestep for all terms in the ion kinetic equation.\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.normalize_pdf!-Tuple{Any, Any, Any}","page":"time_advance","title":"moment_kinetics.time_advance.normalize_pdf!","text":"if evolving the density via continuity equation, redefine the normalised f → f/n if evolving the parallel pressure via energy equation, redefine f -> f * vth / n 'scratch' should be a (nz,nspecies) array\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.rk_update!-NTuple{6, Any}","page":"time_advance","title":"moment_kinetics.time_advance.rk_update!","text":"Use the result of the forward-Euler timestep and the previous Runge-Kutta stages to compute the updated pdfs, and any evolved moments.\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.setup_advance_flags-NTuple{14, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_advance_flags","text":"create the 'advance_info' struct to be used in later Euler advance to indicate which parts of the equations are to be advanced concurrently. if no splitting of operators, all terms advanced concurrently; else, will advance one term at a time.\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.setup_implicit_advance_flags-NTuple{14, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_implicit_advance_flags","text":"create the 'advanceinfo' struct to be used in the time advance to indicate which parts of the equations are to be advanced implicitly (using `backwardeuler!()`).\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.setup_scratch_arrays-NTuple{12, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_scratch_arrays","text":"create an array of structs containing scratch arrays for the normalised pdf and low-order moments that may be evolved separately via fluid equations\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.setup_time_advance!-NTuple{37, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_time_advance!","text":"create arrays and do other work needed to setup the main time advance loop. this includes creating and populating structs for Chebyshev transforms, velocity space moments, EM fields, and advection terms\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.setup_time_info-NTuple{10, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_time_info","text":"setup_time_info(t_input, n_variables, code_time, dt_reload,\n                dt_before_last_fail_reload, composition,\n                manufactured_solns_input, io_input, input_dict, r;\n                electron=nothing, debug_io=nothing)\n\nCreate a input_structs.time_info struct using the settings in t_input.\n\nIf something is passed in electron, it is stored in the electron_t_params member of the returned time_info.\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.ssp_rk!-NTuple{32, Any}","page":"time_advance","title":"moment_kinetics.time_advance.ssp_rk!","text":"\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.time_advance!-NTuple{33, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance!","text":"solve ∂f/∂t + v(z,t)⋅∂f/∂z + dvpa/dt ⋅ ∂f/∂vpa= 0 define approximate characteristic velocity v₀(z)=vⁿ(z) and take time derivative along this characteristic df/dt + δv⋅∂f/∂z = 0, with δv(z,t)=v(z,t)-v₀(z) for prudent choice of v₀, expect δv≪v so that explicit time integrator can be used without severe CFL condition\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.time_advance_no_splitting!-NTuple{32, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance_no_splitting!","text":"\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.time_advance_split_operators!-NTuple{21, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance_split_operators!","text":"\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.update_solution_vector!-NTuple{8, Any}","page":"time_advance","title":"moment_kinetics.time_advance.update_solution_vector!","text":"update the vector containing the pdf and any evolved moments of the pdf for use in the Runge-Kutta time advance\n\n\n\n\n\n","category":"method"},{"location":"zz_energy_equation/#energy_equation","page":"energy_equation","title":"energy_equation","text":"","category":"section"},{"location":"zz_energy_equation/#moment_kinetics.energy_equation","page":"energy_equation","title":"moment_kinetics.energy_equation","text":"\n\n\n\n","category":"module"},{"location":"zz_energy_equation/#moment_kinetics.energy_equation.energy_equation!-NTuple{11, Any}","page":"energy_equation","title":"moment_kinetics.energy_equation.energy_equation!","text":"evolve the parallel pressure by solving the energy equation\n\n\n\n\n\n","category":"method"},{"location":"zz_energy_equation/#moment_kinetics.energy_equation.neutral_energy_equation!-NTuple{9, Any}","page":"energy_equation","title":"moment_kinetics.energy_equation.neutral_energy_equation!","text":"evolve the neutral parallel pressure by solving the energy equation\n\n\n\n\n\n","category":"method"},{"location":"zz_charge_exchange/#charge_exchange","page":"charge_exchange","title":"charge_exchange","text":"","category":"section"},{"location":"zz_charge_exchange/#moment_kinetics.charge_exchange","page":"charge_exchange","title":"moment_kinetics.charge_exchange","text":"\n\n\n\n","category":"module"},{"location":"zz_charge_exchange/#moment_kinetics.charge_exchange.charge_exchange_collisions_single_species!-NTuple{14, Any}","page":"charge_exchange","title":"moment_kinetics.charge_exchange.charge_exchange_collisions_single_species!","text":"update the evolved pdf for a single species to account for charge exchange collisions with a single species of the opposite type; e.g., ions with neutrals or neutrals with ions\n\n\n\n\n\n","category":"method"},{"location":"zz_charge_exchange/#moment_kinetics.charge_exchange.ion_charge_exchange_collisions_1V!-NTuple{10, Any}","page":"charge_exchange","title":"moment_kinetics.charge_exchange.ion_charge_exchange_collisions_1V!","text":"update the evolved pdf for each ion species to account for charge exchange collisions between ions and neutrals\n\n\n\n\n\n","category":"method"},{"location":"zz_charge_exchange/#moment_kinetics.charge_exchange.neutral_charge_exchange_collisions_1V!-NTuple{10, Any}","page":"charge_exchange","title":"moment_kinetics.charge_exchange.neutral_charge_exchange_collisions_1V!","text":"update the evolved pdf for each neutral species to account for charge exchange collisions between ions and neutrals\n\n\n\n\n\n","category":"method"},{"location":"zz_plot_sequence/#plot_sequence","page":"plot_sequence","title":"plot_sequence","text":"","category":"section"},{"location":"zz_plot_sequence/#plots_post_processing.plot_sequence","page":"plot_sequence","title":"plots_post_processing.plot_sequence","text":"\n\n\n\n","category":"module"},{"location":"timestepping/#Timestepping","page":"Timestepping","title":"Timestepping","text":"","category":"section"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"Timestepping in moment_kinetics can be done with various explicit Runge-Kutta (RK) schemes. The default is a fixed-timestep 3rd-order, 4-stage, strong stability preserving (SSP) RK scheme.","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"Several schemes (including all the fixed-timestep schemes) use a 'low storage' option, where only values from the first stage and previous stage are required for each stage update[1].","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"[1]: At present, we take advantage of this property to reduce the number of computations in the RK update step, but do not actually reduce the memory usage - we still store the results from every RK stage. It would be fairly straightforward to save memory, but would only reduce from 4 copies to 3 for the standard cases, so not a big saving.","category":"page"},{"location":"timestepping/#Fixed-timestep-schemes","page":"Timestepping","title":"Fixed-timestep schemes","text":"","category":"section"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"The fixed timestep schemes use a constant dt, specified in the input file, for the whole simulation. The available types are:","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"\"SSPRK1\" - forward Euler method\n\"SSPRK2\" - Heun's method\n\"SSPRK3\" - a 3-stage, 3rd order method, see this Wikipedia list\n\"SSPRK4\" - the default, a 4-stage, 3rd order method, see [R.J. Spiteri, and S.J.  Ruuth. \"A new class of optimal high-order strong-stability-preserving time discretization methods.\" SIAM Journal on Numerical Analysis 40.2 (2002): 469-491., referenced in Dale E. Durran, “Numerical Methods for Fluid Dynamics”, Springer. Second Edition].","category":"page"},{"location":"timestepping/#Adaptive-timestep-schemes","page":"Timestepping","title":"Adaptive-timestep schemes","text":"","category":"section"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"Several SSP schemes are included from [Fekete, Conde and Shadid, \"Embedded pairs for optimal explicit strong stability preserving Runge-Kutta methods\", Journal of Computational and Applied Mathematics 421 (2022) 114325, https://doi.org/10.1016/j.cam.2022.114325]:","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"\"Fekete4(3)\" a 4-stage, 3rd order method, the recommended 3rd order method in Fekete et al. Identical to the default \"SSPRK4\" fixed-step method, but with an embedded 2nd order method used to provide error control for adaptive timestepping. This is probably a good first choice for an adaptive timestep method.\n\"Fekete4(2)\" a 4-stage, 2nd order method, the recommended 2nd order method in Fekete et al.\n\"Fekete10(4)\" a 10-stage, 4th order method, the recommended 4th order method in Fekete et al. May allow longer timesteps than \"Fekete4(3)\", but probably not any faster as more stages are required per timestep. However, if very high accuracy is required (very tight rtol and atol tolerances), the higher accuracy may be an advantage.\n\"Fekete6(4)\" a 6-stage, 4th order method.","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"The classic \"Runge-Kutta-Fehlberg\" method [https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method, 'COEFFICIENTS FOR RK4(5), FORMULA 2 Table III in Fehlberg' - note the Wikipedia page seems to have a typo in one of the error coefficients, see comment in utils/calculate_rk_coeffs.jl] is also provided as \"RKF5(4)\". This method seems to require a significantly smaller timestep to be stable than the SSP methods from Fekete et al., but might be useful if very high accuracy is required as it is a 5th-order accurate method. It uses 6 stages per step.","category":"page"},{"location":"timestepping/#Algorithm-for-choosing-the-next-timestep","page":"Timestepping","title":"Algorithm for choosing the next timestep","text":"","category":"section"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"These adaptive timestepping methods use several criteria to set or limit the timestep:","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"Truncation error, which is estimated by the difference between the higher and lower order methods of an 'embedded pair'. The timestep size needed to maintain a specified accuracy can be estimated from the size of the trucation error (knowing the order of accuracy of the method), as described for example in Fehlberg et al. This estimate is used unless it is larger than any of the following limits. The error limit is set by relative tolerance \"rtol\" and absolute tolerance \"atol\" parameters. For each variable X the error metric (calculated in moment_kinetics.time_advance.local_error_norm is the root-mean-square (RMS, or 'L2 norm') of epsilon:\nepsilon = fracE_X(mathttrtol*X + mathttatol)\nwhere E_X is the truncation error estimate for X. If the RMS of epsilon, averaged over all evolved variables, is greater than 1, then the step is considered 'failed' and is re-done with a shorter timestep (set by the lower of half of the failed timestep, or the timestep calculated using the estimate based on epsilon).\nCFL criteria [https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition]. These are estimated for the spatial advection and velocity-space advection terms in the kinetic equation(s), using the methods moment_kinetics.utils.get_minimum_CFL_z, moment_kinetics.utils.get_minimum_CFL_vpa, moment_kinetics.utils.get_minimum_CFL_neutral_z, moment_kinetics.utils.get_minimum_CFL_neutral_vz. These estimates are multiplied by a user-set prefactor - the correct value for the prefactor depends on both the timestepping scheme and the spatial discretisation, so to be pragmatic we tune the value by trial and error. [CFL limits associated with other terms in the equations could be added in a similar way if it is useful.]\nAt each step, the timestep is allowed to increase by at most a (user-set) factor, to avoid large jumps that might cause numerical instability.\nThere is an option to set a minimum timestep, which may be useful to push the simulation through initial transients where there is some numerical instability which would make the truncation error estimate push the timestep to ridiculously small values. Since we might not care about accuracy too much during these initial transients, it can be useful to set a minimum to stop the timestep getting too small (as long as the minimum is small enough that the simulation does not crash).","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"The estimates and limits just described are controlled by various tuning parameters, described in timestepping-input-parameters, that may need to be set appropriately to get good performance from the adaptive timestepping methods.  The timestep achievable may be limited by accuracy or by stability. If the CFL_prefactor is set too high (or the relevant CFL limit is not being checked) then the timestep will try to increase too high for stability - when this happens, the step will also become inaccurate, causing timestep failures and reducing the timestep. So the simulation should continue without crashing, however it will be inefficient as the truncation error estimate will not 'see' the stability limit until the limit is exceeded, resulting in a cycle of increasing timestep followed by (probably repeated) timestep failures. The aim should probably be to set the CFL_limit_prefactor and max_increase_factor to the highest values that do not lead to too many timestep failures (a few failures are OK, especially during the initial transient phase of simulations). step_update_prefactor can also be decreased to use a bigger margin in the timestep estimated from the error metric epsilon - using a smaller step_update_prefactor will make the timestep smaller when it is limited by accuracy, but this can (sometimes!) help avoid timestep failures, which might decrease the total number of steps. ","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"Special treatment is needed for the time points where output is to be written. When the next timestep would take the simulation time beyond the next time where output is to be written, the timestep is set instead to take the simulation to the output time. Then output is written and the timestep is reset to the last full timestep value from before the output.","category":"page"},{"location":"timestepping/#Alternative-algorithm-for-choosing-the-next-timestep","page":"Timestepping","title":"Alternative algorithm for choosing the next timestep","text":"","category":"section"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"It might turn out that the particular CFL limits that are included in the algorithm described in Algorithm for choosing the next timestep are not a complete set of the things that set the stability limit for the explicit RK timestep. If that is the case, it may be useful to have a more generic algorithm that can still fairly robustly choose a good timestep size, without a large number of timestep failures. One option is described in this subsection. For the parameters discussed, see again timestepping-input-parameters.","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"If we assume that dt that last failed the timestep truncation error test is a good estimate of the dt that is the boundary between stable and unstable timstep values, then it makes sense to try to keep timesteps close to that (to avoid failures), although we also want to allow the timestep to increase past that value in case it was a bad estimate (e.g. during some sort of transient) or because the stability limits have changed (e.g. parallel gradients in the simulation have changed significantly). We would like to stay close to a marginally stable (rather than marginally unstable) timestep, so take as the estimate the last successful timestep before the most recent failed timestep (this is stored in the code as t_params.dt_before_last_fail[]). When dt is within a factor last_fail_proximity_factor of this value, we limit the increase in timestep to max_increase_factor_near_last_fail, rather than max_increase_factor. Suggested setup (which of course is likely to need adjusting depending on the simulation!):","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"Set max_increase_factor_near_last_fail to a value very close to 1, say 1.001. This means that the timestep can only very slowly approach and exceed t_params.dt_before_last_fail[]. Setting this value closer to 1 should decrease the number of timestep failures.\nSet max_increase_factor to a relatively large value, say 1.5 or 2, so that when a timestep does fail, dt quickly recovers to a value close to the last successful value before the failure.\nSet step_update_prefactor to a relatively small value, say 0.5. step_update_prefactor controls how far dt is set below the value needed to comply with the requested tolerances. Setting a smallish value (so a large margin below the value that would trigger a timestep failure) seems to help - current guess (JTO 20/3/2024) is that: when dt is close to (or maybe just above) the value that would be unstable, the error starts to grow; with some margin, and with the factor by which dt increases limited to a small value, so that dt is at worst very marginally unstable, the truncation error estimate can feel the error and decrease dt (modestly) back to a stable value, before the error becomes big enough to cause a timestep failure. Once dt has been decreased (but not too much) it is again only allowed to increase slowly, so as long as these decreases happen often enough, dt can stay around the stability boundary without causing timestep failures. Decreasing this value should decrease the number of timestep failures.\nlast_fail_proximity_factor - current guess (JTO 20/3/2024) is that the default value of 1.05 is reasonable. Increasing this value should decrease the number of timestep failures, but will also increase the number of steps needed before the timestep can increase past a too-low value (from a bad estimate, transient, changed simulation conditions, etc.).\nAs a rough guideline, more than one timestep failures on average per 100 timesteps is probably too many to be efficient, while around or less than this many is probably acceptable. If there are too many failures, try tweaking parameters as indicated above.","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"In at least one case JTO has been able to use this method to get a simulation to run without imposing CFL restrictions explicitly, in a similar number of steps as when using (well-tuned) explicit CFL restrictions.","category":"page"},{"location":"timestepping/#timestepping-input-parameters","page":"Timestepping","title":"Input parameters","text":"","category":"section"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"Option name Default value Description\nnstep 5 nstep*dt is the total length of the run. For fixed-step timestepping, nstep is the total number of timesteps\ndt 000025T For fixed-step, gives the length of the timestep. For adaptive-step gives the initial guess for the timestep. T in the default value is the initial temperature of the ions\nCFL_prefactor -1.0 Prefactor that the CFL limits from moment_kinetics.utils.get_minimum_CFL_z, moment_kinetics.utils.get_minimum_CFL_vpa, moment_kinetics.utils.get_minimum_CFL_neutral_z, moment_kinetics.utils.get_minimum_CFL_neutral_vz are multiplied by to set the timestep limit. If no value is given, a default is set according to which timestepping scheme is chosen (see moment_kinetics.runge_kutta.setup_runge_kutta_coefficients!).\nnwrite 1 Output of moment quantities is written every nwrite*dt time units.\nnwrite_dfns nothing Output of distribution function quantities is written every nwrite_dfns*dt time units. By default distribution function quantities are written only at the beginning and end of the simulation.\ntype \"SSPRK4\" Timestepping method, see Fixed-timestep schemes and Adaptive-timestep schemes.\nsplit_operators false If true, use operator splitting. Operator splitting is currently only partially implemented.\nstopfile_name \"stop\" Name of the file that can be created in the output directory to stop the simulation cleanly after the next output is written.\nsteady_state_residual false Set to true to print out the maximum residual r(t) = fracleft n(t)-n(t-delta t)right delta t of the density for each species at each output step\nconverged_residual_value -1.0 If steady_state_residual = true and converged_residual_value is set to a positive value, then the simulation will be stopped if all the density residuals are less than converged_residual_value. Note the residuals are only calculated and checked at time steps where output for moment variables is written.\nrtol 1.0e-5 Relative tolerance used for the truncation error metric.\natol 1.0e-12 Absolute tolerance used for the truncation error metric.\natol_upar 1.0e-2*rtol Absolute tolerance used parallel flow moment variables in the truncation error metric. This is separate from atol as the flow moments are expected to pass through zero somewhere, unlike distribution functions, densities, or pressures that should always be positive.\nstep_update_prefactor 0.9 When timestep is limited by accuracy (rather than something else), it is set to step_update_prefactor times the estimated timestep which would give an RMS error metric $\\epsilon$ of 1 at the next step. This value should always be less than 1. Smaller values give a bigger margin under the failure threshold, so may help reduce the number of timestep failures.\nmax_increase_factor 1.05 Timestep can be increased by at most this factor at each step.\nmax_increase_factor_near_last_fail Inf If set to finite value, replaces max_increase_factor when the timestep is near the last failed dt value (defined as within last_fail_proximity_factor of the last successful dt value before a timestep failure). If set, must be less than max_increase_factor.\nlast_fail_proximity_factor 1.05 Defines the range considered 'near to' the last failed dt value: dt_before_last_fail/last_fail_proximity_factor < dt < dt_before_last_fail*last_fail_proximity_factor.\nminimum_dt 0.0 Timestep is not allowed to decrease below this value, regardless of accuracy or stability limits.\nmaximum_dt Inf Timestep is not allowed to increase above this value.\nhigh_precision_error_sum false If this is set to true, then quad-precision values (Float128 from the Quadmath package) are used to calculate the sum in the truncation error estimates. When different numbers of processes are used, the sums are calculated in different orders, so the rounding errors will be different. When adaptive timestepping is used this means that different timesteps will be used when different numbers of processes are used, so results will not be exactly the same (although they should be consistent within the timestepper tolerances and discretisation errors). When comparing 'identical' simulations run on different numbers of processes (e.g. for debugging), these differences can be inconvenient. The differences can be avoided (or at least massively reduced) by using a higher precision for the sum, so that the order of the addition operations does not matter (at least until there are so many contributions to the sum that the rounding errors reduce the precision of the quad-precision result to less than double-precision, which would take a very large number!). This feature was originally added in an attempt to make adaptive-timestepping tests give consistent results (at a level sim 10^-14) on the CI servers. However, rounding errors change randomly on different systems (operating system, compiler, hardware, etc.), not only because of the different order of terms in the sum in the truncation error norm, so consistency is not possible between different systems even with this feature.","category":"page"},{"location":"timestepping/#Diagnostics","page":"Timestepping","title":"Diagnostics","text":"","category":"section"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"To help tune the settings for adaptive timestepping methods, several diagnostics are written to the output files:","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"step_counter is the cumulative number of time steps taken to reach each output.\ndt is the most recent timestep size at each output.\nfailure_counter is the cumulative number of timestep failures.\nfailure_caused_by counts the (cumulative) number of times each evolved variable (distribution functions or, for moment-kinetic simulations, moment variables) caused a timestep failure. failure_caused_by is a 2d array - the second dimension is time, the index of the first indicates the variable (see below for plotting of the diagnostics).\nlimit_caused_by counts the (cumulative) number of times each factor (accuracy, CFL limits, maximum timestep increase factor, minimum timestep) set the timestep limit. limit_caused_by is a 2d array - the second dimension is time, the index of the first indicates the factor (see below for plotting of the diagnostics).","category":"page"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"These diagnostics (after being converted from cumulative counts to counts per output step) as well as the CFL limits are plotted and/or animated by makie_post_processing.timestep_diagnostics. This function will be called when running makie_post_processing.makie_post_process if options in the [timestep_diagnostics] section of the post processing input are set: plot=true for plots or animate_CFL=true to make animations of the CFL limits for various terms.","category":"page"},{"location":"timestepping/#Developing","page":"Timestepping","title":"Developing","text":"","category":"section"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"The script utils/calculate_rk_coeffs.jl provides some functions to convert a 'Butcher tableau' to the rk_coefs array used internally in moment_kinetics. To add more RK methods (adaptive or fixed-step) it may be useful to add them in this script, to get the rk_coefs values, which can be copied into moment_kinetics.runge_kutta.setup_runge_kutta_coefficients!.","category":"page"},{"location":"timestepping/#API","page":"Timestepping","title":"API","text":"","category":"section"},{"location":"timestepping/","page":"Timestepping","title":"Timestepping","text":"See moment_kinetics.time_advance, moment_kinetics.runge_kutta.","category":"page"},{"location":"zz_runge_kutta/#runge_kutta","page":"runge_kutta","title":"runge_kutta","text":"","category":"section"},{"location":"zz_runge_kutta/#moment_kinetics.runge_kutta","page":"runge_kutta","title":"moment_kinetics.runge_kutta","text":"Runge Kutta timestepping\n\n\n\n\n\n","category":"module"},{"location":"zz_runge_kutta/#moment_kinetics.runge_kutta.adaptive_timestep_update_t_params!-NTuple{11, Any}","page":"runge_kutta","title":"moment_kinetics.runge_kutta.adaptive_timestep_update_t_params!","text":"adaptive_timestep_update_t_params!(t_params, CFL_limits, error_norms,\n                                   total_points, error_norm_method, success,\n                                   nl_max_its_fraction, nl_total_its_soft_limit,\n                                   nl_total_its_soft_limit_reduce_dt,\n                                   composition, z; electron=false,\n                                   local_max_dt::mk_float=Inf, ir=nothing)\n\nUse the calculated CFL_limits and error_norms to update the timestep in t_params.\n\n\n\n\n\n","category":"method"},{"location":"zz_runge_kutta/#moment_kinetics.runge_kutta.local_error_norm","page":"runge_kutta","title":"moment_kinetics.runge_kutta.local_error_norm","text":"local_error_norm(error, f, rtol, atol; ir=nothing)\nlocal_error_norm(error, f, rtol, atol, neutral=false; method=\"Linf\",\n                 skip_r_inner=false, skip_z_lower=false, error_sum_zero=0.0,\n                 ir=nothing)\n\nMaximum error norm in the range owned by this MPI process, given by\n\nmax(fracmathtterrormathttrtol*mathttf + mathttatol)\n\n3 dimensional arrays (which represent moments) are treated as ion moments unless neutral=true is passed.\n\nmethod can be \"Linf\" (to take the maximum error) or \"L2\" to take the root-mean-square (RMS) error.\n\nskip_r_inner and skip_z_lower can be set to true to skip the contribution from the inner/lower boundaries, to avoid double-counting those points when using distributed-memory MPI.\n\nerror_sum_zero should always have value 0.0, but is included so that different types can be used for L2sum. For testing, if we want consistency of results when using different numbers of processes (when the number of processes changes the order of operations in the sum is changed, which changes the rounding errors) then we have to use higher precision (i.e. use the Float128 type from the Quadmath package). The type of a 0.0 value can be set according to the high_precision_error_sum option in the [timestepping] section, and stored in a template-typed value in the t_params object - when that value is passed in as the argument to error_sum_zero, that type will be used for L2sum, and the type will be known at compile time, allowing this function to be efficient.\n\nir can be passed to calculate the error norm at a single r-index.\n\n\n\n\n\n","category":"function"},{"location":"zz_runge_kutta/#moment_kinetics.runge_kutta.rk_loworder_solution!-Tuple{Any, Any, Symbol, Any}","page":"runge_kutta","title":"moment_kinetics.runge_kutta.rk_loworder_solution!","text":"Calculate a lower-order approximation for the variable named var_symbol, which can be used to calculate an error estimate for adaptive timestepping methods.\n\nThe lower-order approximation is stored in var_symbol in scratch[2] (as this entry should not be needed again after the lower-order approximation is calculated).\n\n\n\n\n\n","category":"method"},{"location":"zz_runge_kutta/#moment_kinetics.runge_kutta.rk_update_evolved_moments!-NTuple{5, Any}","page":"runge_kutta","title":"moment_kinetics.runge_kutta.rk_update_evolved_moments!","text":"use Runge Kutta to update any ion velocity moments evolved separately from the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_runge_kutta/#moment_kinetics.runge_kutta.rk_update_evolved_moments_electron!-NTuple{5, Any}","page":"runge_kutta","title":"moment_kinetics.runge_kutta.rk_update_evolved_moments_electron!","text":"use Runge Kutta to update any electron velocity moments evolved separately from the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_runge_kutta/#moment_kinetics.runge_kutta.rk_update_evolved_moments_neutral!-NTuple{5, Any}","page":"runge_kutta","title":"moment_kinetics.runge_kutta.rk_update_evolved_moments_neutral!","text":"use Runge Kutta to update any neutral-particle velocity moments evolved separately from the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_runge_kutta/#moment_kinetics.runge_kutta.rk_update_variable!-Tuple{Any, Any, Symbol, Any, Any}","page":"runge_kutta","title":"moment_kinetics.runge_kutta.rk_update_variable!","text":"Update the variable named var_symbol in scratch to the current Runge-Kutta stage istage. The current value in scratch[istage+1] is the result of the forward-Euler update, which needs to be corrected using values from previous stages with the Runge-Kutta coefficients. scratch_implicit contains the results of backward-Euler updates, which are needed for IMEX timestepping schemes.\n\n\n\n\n\n","category":"method"},{"location":"zz_runge_kutta/#moment_kinetics.runge_kutta.setup_runge_kutta_coefficients!-Tuple{Any, Any, Any}","page":"runge_kutta","title":"moment_kinetics.runge_kutta.setup_runge_kutta_coefficients!","text":"given the number of Runge Kutta stages that are requested, returns the needed Runge Kutta coefficients; e.g., if f is the function to be updated, then f^{n+1}[stage+1] = rkcoef[1,stage]*f^{n} + rkcoef[2,stage]f^{n+1}[stage] + rk_coef[3,stage](f^{n}+dt*G[f^{n+1}[stage]]\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#finite_differences","page":"finite_differences","title":"finite_differences","text":"","category":"section"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences","page":"finite_differences","title":"moment_kinetics.finite_differences","text":"\n\n\n\n","category":"module"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.finite_difference_info","page":"finite_differences","title":"moment_kinetics.finite_differences.finite_difference_info","text":"Finite difference discretization\n\n\n\n\n\n","category":"type"},{"location":"zz_finite_differences/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Any, moment_kinetics.finite_differences.finite_difference_info}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, adv_fac, not_spectral::finite_difference_info)\n\nCalculate the derivative of f using finite differences, with particular scheme specified by coord.finitedifferenceoption; result stored in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, moment_kinetics.finite_differences.finite_difference_info}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, not_spectral::finite_difference_info)\n\nCalculate the derivative of f using 4th order centered finite differences; result stored in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.calculus.elementwise_indefinite_integration!-Tuple{Any, Any, moment_kinetics.finite_differences.finite_difference_info}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_indefinite_integration!","text":"elementwise_indefinite_integration!(coord, f, not_spectral::finite_difference_info)\n\nCalculate the primitive of f using second-order accurate trapezium rule; result stored in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.centered_fourth_order!-Tuple{Matrix{Float64}, Vararg{Any, 5}}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_fourth_order!","text":"take the derivative of input function f and return as df using fourth-order, centered differences. input/output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.centered_second_order!-Tuple{Matrix{Float64}, Vararg{Any, 5}}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_second_order!","text":"take the derivative of input function f and return as df using second-order, centered differences. input/output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.centered_second_order!-Tuple{Vector{Float64}, Vararg{Any, 5}}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_second_order!","text":"take the derivative of input function f and return as df using second-order, centered differences. input/output df is 1D array of size n (full grid)\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.derivative_finite_difference!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.derivative_finite_difference!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.derivative_finite_difference!-NTuple{8, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.derivative_finite_difference!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.elementwise_second_derivative!-Tuple{Any, Any, moment_kinetics.finite_differences.finite_difference_info}","page":"finite_differences","title":"moment_kinetics.finite_differences.elementwise_second_derivative!","text":"elementwise_second_derivative!(coord, f, not_spectral::finite_difference_info)\n\nCalculate the second derivative of f using 2nd order centered finite differences; result stored in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.fd_check_option-Tuple{Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.fd_check_option","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.primitive_finite_difference_integration!-Tuple{Any, Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.primitive_finite_difference_integration!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.primitive_second_order_integration!-Tuple{Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.primitive_second_order_integration!","text":"Integrate the input function f and return as pf using second-order trapezium rule. Do the integral on each element separately.\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.second_derivative_finite_difference!-Tuple{Matrix{Float64}, Vararg{Any, 5}}","page":"finite_differences","title":"moment_kinetics.finite_differences.second_derivative_finite_difference!","text":"Take the second derivative of input function f and return as df using second-order, centered differences. output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.upwind_first_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_first_order!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.upwind_second_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_second_order!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.upwind_third_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_third_order!","text":"\n\n\n\n","category":"method"},{"location":"external_sources_notes/#External-sources","page":"External sources","title":"External sources","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"Sometimes it is useful to have a source term for the plasma or neutrals (the S_i and S_n of Moment kinetic equations). The currently-implemented source term has the form of a Maxwellian with constant temperature and spatially-varying amplitude","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\nS_i = A_i(rz) frac1(pi)^32 (2 T_mathrmsourcei  m_i)^32 expleft( -frac(v_perp^2 + v_parallel^2)T_mathrmsourcei right) \nS_n = A_n(rz) frac1(pi)^32 (2 T_mathrmsourcen  m_n)^32 expleft( -frac(v_zeta^2 + v_r^2 + v_z^2)T_mathrmsourcen right)\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"or in 1V simulations that do not include v_perp, v_zeta, v_r dimensions","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\nS_i = A_i(rz) frac1sqrtpi sqrt2 T_mathrmsourcei  m_i expleft( -fracv_perp^2T_mathrmsourcei right) \nS_n = A_n(rz) frac1sqrtpi sqrt2 T_mathrmsourcen  m_n expleft( -fracv_z^2T_mathrmsourcen right)\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The sources are controlled by options in the [ion_source] and [neutral_source] sections of the input file. The source terms are enabled by setting active = true. The constant temperature is set with the source_T option (default is 1 for ions and T_mathrmwall for neutrals). The amplitude can be set or controlled in various ways depending on the source_type setting, as explained in the following subsection.","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"Note that all the settings mentioned below have values given in normalised units (in the same way as the settings for initial profiles, etc.).","category":"page"},{"location":"external_sources_notes/#Amplitude","page":"External sources","title":"Amplitude","text":"","category":"section"},{"location":"external_sources_notes/#Fixed-amplitude-(default)","page":"External sources","title":"Fixed amplitude (default)","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"When source_type = \"Maxwellian\" (the default), the amplitude of the source is fixed in time and controled by the profile options. The profile has the form","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"A(rz) = A_0 R(r) Z(z)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"where A_0 is given by the source_strength option. R(r) and Z(z) are controlled by the r_profile and z_profile options respectively. The available options for either are the same, so letting x stand for either of r or z, and X for the corresponding R or Z:","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"x_profile = \"constant\" (the default) means X(x)=1.\nx_profile = \"gaussian\" means   X(x) = (1 - X_mathrmmin) expleft( -left(fracxwright)^2 right) + X_mathrmmin   where X_mathrmmin is set by x_relative_minimum and w is set by   x_width.\nx_profile = \"parabolic\" means   P(x) = left( 1 - left(frac2xwright)^2 right),    X(x) = (1 - X_mathrmmin) H(P(x)) P(x) + X_mathrmmin   where X_mathrmmin is set by x_relative_minimum and w is set by   x_width. The effect of the step function H is to let the profile be a   quadratic in the range -w2  x  w2, but equal to a floor (by default   0, so that the source is just not allowed to become negative) outside that   range.","category":"page"},{"location":"external_sources_notes/#Midpoint-density-controller","page":"External sources","title":"Midpoint density controller","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"When source_type = \"density_midpoint_control\" a PI controller (Wikipedia) is used to control the ion/neutral density. The 'midpoint' for the purposes of this controller is the point on the grid where r=0 and z=0 (there must be a grid point there).","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The spatial profile of the source (R(r) and Z(z)) is set in the same way as for the 'Fixed amplitude' source (see above), but now the prefactor changes with time","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"A(rz) = A_0(t) R(r) Z(z)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The prefactor A_0(t) is controlled to set the midpoint density to some value n(r=0z=0)rightarrow n_mathrmPI where n_mathrmPI is set by PI_density_target_amplitude. Specifically,","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\n  A_0(t) = mathttmaxleft(P(n_mathrmPI - n(r=0z=0)) + iota(t) 0right) \n  fracpartial iotapartial t = I(n_mathrmPI - n(r=0z=0))\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The 'proportional' coefficient P is set by PI_density_controller_P and the 'integral' coefficient I is set by PI_density_controller_I. The mathrmmax(ldots0) is to ensure that the 'source term' is never negative (i.e. a sink), to avoid the possibility of driving the system towards negative density.","category":"page"},{"location":"external_sources_notes/#Density-profile-controller","page":"External sources","title":"Density profile controller","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"When source_type = \"density_profile_control\" a PI controller (Wikipedia) is used to control the ion/neutral density profile.","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The target profile is","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"n_mathrmPI(rz) = n_mathrmPI0 R(r) Z(z)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"where n_mathrmPI0 is set by PI_density_target_amplitude and R(r) and Z(z) are set as described in Fixed amplitude (default).","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The source amplitude A(rz) is controlled to set the density profile to n(rz)rightarrow n_mathrmPI(rz). Specifically,","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\n  A(rz) = mathttmaxleft(P(n_mathrmPI(rz) - n(rz)) + iota(trz) 0right) \n  fracpartial iota(trz)partial t = I(n_mathrmPI(rz) - n(rz))\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The 'proportional' coefficient P is set by PI_density_controller_P and the 'integral' coefficient I is set by PI_density_controller_I. The mathrmmax(ldots0) is to ensure that the 'source term' is never negative (i.e. a sink), to avoid the possibility of driving the system towards negative density.","category":"page"},{"location":"external_sources_notes/#Recycling","page":"External sources","title":"Recycling","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The source of neutrals can be set so that some fraction of the flux of ions to the walls is recycled into the volume of the domain as neutrals by using the source_type = \"recycling\" option.","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The profile is set up whose spatial integral is 1","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"A(rz) = A_0 R(r) Z(z)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"where A_0 = leftint drdz R(r) Z(z)right^-1 and R(r) and Z(z) are set as described in Fixed amplitude (default). The source is","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"S_n(trz) = F(t) A(rz)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"where F(t) is the sum of the integrated ion flux to the lower and upper targets.","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"warning: Warning\nThe target flux calculated for this controller does not account for magnetic field lines that are not perpendicular to the wall, or for drifts to the target, so needs updating (within moment_kinetics.external_sources.external_neutral_source_controller!) to be used in 2D simulations.","category":"page"},{"location":"external_sources_notes/#Energy-source","page":"External sources","title":"Energy source","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"When source_type = \"energy\", rather than just adding particles with temperature T_mathrmsources, the existing plasma or neutrals in the domain are swapped with plasma/neutrals from a Maxwellian with T_mathrmsources, so that the density is unchanged, but energy is added (or potentially removed if the plasma/neutrals are hotter than T_mathrmsources).","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\nS_i = A_i(rz) left frac1(pi)^32 (2 T_mathrmsourcei  m_i)^32 expleft( -frac(v_perp^2 + v_parallel^2)T_mathrmsourcei - f_i(v_perp v_parallel) right) right \nS_n = A_n(rz) left frac1(pi)^32 (2 T_mathrmsourcen  m_n)^32 expleft( -frac(v_zeta^2 + v_r^2 + v_z^2)T_mathrmsourcen - f_n(v_zeta v_r v_z) right) right\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"or in 1V simulations","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\nS_i = A_i(rz) left frac1sqrtpi sqrt2 T_mathrmsourcei  m_i expleft( -fracv_perp^2T_mathrmsourcei - f_i(v_parallel) right) right \nS_n = A_n(rz) left frac1sqrtpi sqrt2 T_mathrmsourcen  m_n expleft( -fracv_z^2T_mathrmsourcen - f_n(v_z) right) right\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"Note that this source does not give a fixed power input (although that might be a nice feature to have), it just swaps plasma/neutral particles at a constant rate.","category":"page"},{"location":"external_sources_notes/#API","page":"External sources","title":"API","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"See external_sources.","category":"page"},{"location":"manufactured_solution_test_examples/#List-of-Manufactured-Solutions-Test-TOML-inputs","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"","category":"section"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"Here we list the existing manufactured solution test inputs. These inputs are examples only, and in most cases we only keep the lowest resolution examples. The user should copy these inputs and make a series of TOML with increasing resolutions to generate a series of simulations on which the numerical errors can be tested and compared to the expected scaling of the  numerical method employed.","category":"page"},{"location":"manufactured_solution_test_examples/#1D1V-tests","page":"List of Manufactured Solutions Test TOML inputs","title":"1D1V tests","text":"","category":"section"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"There are 1D1V tests which complement the check-in testing suite. The example input files in this category are as follows:","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"1D1V simulation of kinetic ions (no neutrals) and numerical velocity dissipation.","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/1D-wall_MMS_new_nel_r_1_z_16_vpa_16_vperp_1_diss.toml","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"1D1V simulation of kinetic ions (no neutrals) and a krook collision operator.","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/1D-wall_MMS_new_nel_r_1_z_16_vpa_16_vperp_1_krook.toml","category":"page"},{"location":"manufactured_solution_test_examples/#1D2V-tests","page":"List of Manufactured Solutions Test TOML inputs","title":"1D2V tests","text":"","category":"section"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"1D2V simulation of kinetic ions (no neutrals) and a krook collision operator.","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/1D-wall_MMS_new_nel_r_1_z_16_vpa_8_vperp_8_krook.toml","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"1D2V simulation of a open field lines in 1D magnetic mirror (no neutrals)","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/1D-mirror_MMS_ngrid_9_nel_r_1_z_4_vpa_4_vperp_2_diss.toml\nruns/1D-mirror_MMS_ngrid_9_nel_r_1_z_8_vpa_8_vperp_4_diss.toml\nruns/1D-mirror_MMS_ngrid_9_nel_r_1_z_16_vpa_16_vperp_8_diss.toml\nruns/1D-mirror_MMS_ngrid_9_nel_r_1_z_32_vpa_32_vperp_16_diss.toml","category":"page"},{"location":"manufactured_solution_test_examples/#1D2V/1D3V-test-(with-neutrals)","page":"List of Manufactured Solutions Test TOML inputs","title":"1D2V/1D3V test (with neutrals)","text":"","category":"section"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"A test with periodic boundary conditions in 1D, Boltzmann electrons, neutrals, and ions.","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/1D-sound-wave_cheb_nel_r_1_z_2_vpa_4_vperp_4.toml","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"A test with ions and neutral species and wall boundary conditions,  using the Boltzmann electron response to model the electron species.","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/1D-wall_cheb-with-neutrals_nel_r_1_z_2_vpa_4_vperp_4.toml","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"A test with neutral species and wall boundary conditions, using a simple sheath model for electrons based on the Boltzmann electron response.","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/1D-wall_cheb-with-neutrals-with-sheath_nel_r_1_z_2_vpa_4_vperp_4.toml","category":"page"},{"location":"manufactured_solution_test_examples/#2D1V-tests","page":"List of Manufactured Solutions Test TOML inputs","title":"2D1V tests","text":"","category":"section"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"These tests are used to test the spatial advection in simple cases with wall boundary conditions.","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"2D1V test of wall boundary conditions and the E x B drift. Numerical dissipation in the radial domain is imposed to stabilise an instability that otherwise appears at the grid scale.","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/2D-wall_MMS_nel_r_32_z_32_vpa_16_vperp_1_diss.toml","category":"page"},{"location":"manufactured_solution_test_examples/#2D2V-tests","page":"List of Manufactured Solutions Test TOML inputs","title":"2D2V tests","text":"","category":"section"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"These tests are used to test the spatial advection in cases with wall boundary conditions or geometrical features where two velocity dimensions are necessary.","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"2D2V simulation with periodic boundary conditions,  Boltzmann electrons and ions","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/2D-sound-wave_cheb_ion_only_nel_r_2_z_2_vpa_4_vperp_4.toml","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"2D2V simulation of a open field lines in 1D magnetic mirror (no neutrals)","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/2D-mirror_MMS_ngrid_5_nel_r_8_z_8_vpa_8_vperp_4_diss.toml\nruns/2D-mirror_MMS_ngrid_5_nel_r_16_z_16_vpa_16_vperp_8_diss.toml\nruns/2D-mirror_MMS_ngrid_5_nel_r_32_z_32_vpa_16_vperp_16_diss.toml","category":"page"},{"location":"manufactured_solution_test_examples/#2D2V/2D3V-tests","page":"List of Manufactured Solutions Test TOML inputs","title":"2D2V/2D3V tests","text":"","category":"section"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"These tests include a two-dimensional domain, ions, and neutrals  (which have three velocity dimensions).","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"2D2V/2D3V simulation on a domain with wall boundaries, with helical geometry, Boltzmann electrons, neutrals, and ions.","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/2D-wall_cheb-with-neutrals_nel_r_2_z_2_vpa_4_vperp_4.toml","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"2D2V/2D3V simulation on a periodic domain, with helical geometry, Boltzmann electrons, neutrals, and ions.","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/2D-sound-wave_cheb_nel_r_2_z_2_vpa_4_vperp_4.toml","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"2D2V/2D3V simulation on a periodic domain, with model charge exchange and ionisation collisions, helical geometry, Boltzmann electrons, neutrals, and ions.","category":"page"},{"location":"manufactured_solution_test_examples/","page":"List of Manufactured Solutions Test TOML inputs","title":"List of Manufactured Solutions Test TOML inputs","text":"runs/2D-sound-wave_cheb_cxiz_nel_r_2_z_2_vpa_4_vperp_4.toml","category":"page"},{"location":"zz_electron_kinetic_equation/#electron_kinetic_equation","page":"electron_kinetic_equation","title":"electron_kinetic_equation","text":"","category":"section"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.add_contribution_from_pdf_term!-Tuple{AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, Any, Any, moment_kinetics.moment_kinetics_structs.coordinate, Any, Any, Any}","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.add_contribution_from_pdf_term!","text":"add contribution to the kinetic equation coming from the term proportional to the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.add_dissipation_term!-Tuple{AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, Any, Any, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, Any, Any, Any}","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.add_dissipation_term!","text":"\n\n\n\n","category":"method"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.add_wall_boundary_condition_to_Jacobian!","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.add_wall_boundary_condition_to_Jacobian!","text":"add_wall_boundary_condition_to_Jacobian!(jacobian, phi, pdf, p, vthe, upar, z, vperp,\n                                         vpa, vperp_spectral, vpa_spectral, vpa_adv,\n                                         moments, vpa_diffusion, me_over_mi, ir)\n\nAll the contributions that we add in this function have to be added with a -'ve sign so that they combine with the 1 on the diagonal of the preconditioner matrix to make rows corresponding to the boundary points which define constraint equations imposing the boundary condition on those entries of δg (when the right-hand-side is set to zero).\n\n\n\n\n\n","category":"function"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.electron_adaptive_timestep_update!-Tuple{Any, Any, Any, Any, AbstractVector{Float64}, Any, Any, Any, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, Vararg{Any, 6}}","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.electron_adaptive_timestep_update!","text":"electron_adaptive_timestep_update!(scratch, t, t_params, moments, phi, z_advect,\n                                   vpa_advect, composition, r, z, vperp, vpa,\n                                   vperp_spectral, vpa_spectral,\n                                   external_source_settings, num_diss_params, ir;\n                                   evolve_p=false)\n\nCheck the error estimate for the embedded RK method and adjust the timestep if appropriate.\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.electron_backward_euler!-Tuple{Any, Any, Any, AbstractMatrix{Float64}, Any, Any, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, Vararg{Any, 11}}","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.electron_backward_euler!","text":"electron_backward_euler!(old_scratch, new_scratch, moments, phi,\n    collisions, composition, r, z, vperp, vpa, z_spectral, vperp_spectral,\n    vpa_spectral, z_advect, vpa_advect, scratch_dummy, t_params,\n    external_source_settings, num_diss_params, nl_solver_params, ir;\n    evolve_p=false, ion_dt=nothing) = begin\n\nTake a single backward euler timestep for the electron shape function g_e and parallel pressure p_e.\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.electron_backward_euler_pseudotimestepping!-Tuple{Any, Any, Any, AbstractMatrix{Float64}, Any, Any, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, Vararg{Any, 12}}","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.electron_backward_euler_pseudotimestepping!","text":"Update the electron distribution function using backward-Euler for an artifical time advance of the electron kinetic equation until a steady-state solution is reached.\n\nNote that this function does not use the runge_kutta timestep functionality. t_params.previous_dt[] is used to store the (adaptively updated) initial timestep of the pseudotimestepping loop (initial value of t_params.dt[] within electron_backward_euler_pseudotimestepping!()). t_params.dt[] is adapted according to the iteration counts of the Newton solver.\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.electron_kinetic_equation_euler_update!-Tuple{Any, AbstractArray{Float64, 3}, AbstractVector{Float64}, Any, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, Vararg{Any, 11}}","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.electron_kinetic_equation_euler_update!","text":"electron_kinetic_equation_euler_update!(result_object, f_in, p_in, moments, z, vperp,\n                                        vpa, z_spectral, vpa_spectral, z_advect,\n                                        vpa_advect, scratch_dummy, collisions,\n                                        composition, external_source_settings,\n                                        num_diss_params, t_params, ir; evolve_p=false,\n                                        ion_dt=nothing, soft_force_constraints=false,\n                                        debug_io=nothing, fields=nothing, r=nothing,\n                                        vzeta=nothing, vr=nothing, vz=nothing,\n                                        istage=0)\n\nDo a forward-Euler update of the electron kinetic equation.\n\nWhen evolve_p=true is passed, also updates the electron parallel pressure.\n\nNote that this function operates on a single point in r, given by ir, and f_out, p_out, f_in, and p_in should have no r-dimension.\n\nresult_object should be either a scratch_pdf object (which contains data for all r-indices) or a Tuple containing (pdf_electron, electron_p) fields for r-index ir only. This allows result_object to be (possibly) passed to write_debug_data_to_binary() when result_object is a scratch_pdf.\n\nfields, r, vzeta, vr, vz, and istage are only required when a non-nothing debug_io is passed.\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.fill_electron_kinetic_equation_Jacobian!","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.fill_electron_kinetic_equation_Jacobian!","text":"fill_electron_kinetic_equation_Jacobian!(jacobian, f, p, moments, phi, collisions,\n                                         composition, z, vperp, vpa, z_spectral,\n                                         vperp_specral, vpa_spectral, z_advect,\n                                         vpa_advect, scratch_dummy,\n                                         external_source_settings, num_diss_params,\n                                         t_params, ion_dt, ir, evolve_p, include=:all,\n                                         include_qpar_integral_terms=true,\n                                         add_identity=true)\n\nFill a jacobian_info object with the Jacobian matrix for electron kinetic equation and (if evolve_p=true) the electron energy equation.\n\nadd_identity=false can be passed to skip adding 1's on the diagonal. Doing this would produce the Jacobian for a steady-state solve, rather than a backward-Euler timestep solve. [Note that rows representing boundary points still need the 1 added to their diagonal, as that 1 is used to impose the boundary condition, not to represent the 'new f' in the time derivative term as it is for the non-boundary points.]\n\n\n\n\n\n","category":"function"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.fill_electron_kinetic_equation_v_only_Jacobian!","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.fill_electron_kinetic_equation_v_only_Jacobian!","text":"fill_electron_kinetic_equation_v_only_Jacobian!()\n    jacobian_matrix, f, p, dpdf_dz, dpdf_dvpa, d2pdf_dvpa2, z_speed, vpa_speed,\n    moments, zeroth_moment, first_moment, second_moment, third_moment,\n    dthird_moment_dz, phi, collisions, composition, z, vperp, vpa, z_spectral,\n    vperp_spectral, vpa_spectral, z_advect, vpa_advect, scratch_dummy,\n    external_source_settings, num_diss_params, t_params, ion_dt, ir, iz, evolve_p,\n    add_idenity=true)\n\nFill a pre-allocated matrix with the Jacobian matrix for a velocity-space solve part of the ADI method for electron kinetic equation and (if evolve_p=true) the electron energy equation.\n\n\n\n\n\n","category":"function"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.fill_electron_kinetic_equation_z_only_Jacobian_f!","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.fill_electron_kinetic_equation_z_only_Jacobian_f!","text":"fill_electron_kinetic_equation_z_only_Jacobian_f!(\n    jacobian_matrix, f, p, dpdf_dz, dpdf_dvpa, z_speed, moments, zeroth_moment,\n    first_moment, second_moment, third_moment, dthird_moment_dz, collisions,\n    composition, z, vperp, vpa, z_spectral, vperp_spectral, vpa_spectral, z_advect,\n    vpa_advect, scratch_dummy, external_source_settings, num_diss_params, t_params,\n    ion_dt, ir, ivperp, ivpa, add_idenity=true)\n\nFill a pre-allocated matrix with the Jacobian matrix for a z-direction solve part of the ADI method for the electron kinetic equation.\n\n\n\n\n\n","category":"function"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.fill_electron_kinetic_equation_z_only_Jacobian_p!","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.fill_electron_kinetic_equation_z_only_Jacobian_p!","text":"fill_electron_kinetic_equation_z_only_Jacobian_p!(\n    jacobian_matrix, p, moments, zeroth_moment, first_moment, second_moment,\n    third_moment, dthird_moment_dz, collisions, composition, z, vperp, vpa,\n    z_spectral, vperp_spectral, vpa_spectral, z_advect, vpa_advect, scratch_dummy,\n    external_source_settings, num_diss_params, t_params, ion_dt, ir, evolve_p,\n    add_identity=true)\n\nFill a pre-allocated matrix with (if evolve_p=true) the Jacobian matrix for a z-direction solve part of the ADI method for the electron energy equation.\n\n\n\n\n\n","category":"function"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.get_all_electron_terms-Tuple{moment_kinetics.moment_kinetics_structs.ElectronSubTerms}","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.get_all_electron_terms","text":"\n\n\n\n","category":"method"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.get_electron_sub_terms","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.get_electron_sub_terms","text":"\n\n\n\n","category":"function"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.implicit_electron_advance!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, Vararg{Any, 11}}","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.implicit_electron_advance!","text":"implicit_electron_advance!()\n\nDo an implicit solve which finds: the steady-state electron shape function g_e; the backward-Euler advanced electron pressure which is updated using g_e at the new time-level.\n\nThe r-dimension is not parallelised. For 1D runs this makes no difference. In 2D it might or might not be necessary. If r-dimension parallelisation is needed, it would need some work. The simplest option would be a non-parallelised outer loop over r, with each nonlinear solve being parallelised over {z,vperp,vpa}. More efficient might be to add an equivalent to the 'anysv' parallelisation used for the collision operator (e.g. 'anyzv'?) to allow the outer r-loop to be parallelised.\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.update_electron_pdf!-Tuple{Any, Any, Any, AbstractMatrix{Float64}, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, Vararg{Any, 14}}","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.update_electron_pdf!","text":"updateelectronpdf is a function that uses the electron kinetic equation  to solve for the updated electron pdf\n\nThe electron kinetic equation is:     zdot * d(pdf)/dz + wpadot * d(pdf)/dwpa = pdf * pre_factor\n\nINPUTS:\nscratch = `scratch_pdf` struct used to store Runge-Kutta stages\npdf = modified electron pdf @ previous time level = (true electron pdf / dens_e) * vth_e\nmoments = struct containing electron moments\nr = struct containing r-coordinate information\nz = struct containing z-coordinate information\nvperp = struct containing vperp-coordinate information\nvpa = struct containing vpa-coordinate information\nz_spectral = struct containing spectral information for the z-coordinate\nvperp_spectral = struct containing spectral information for the vperp-coordinate\nvpa_spectral = struct containing spectral information for the vpa-coordinate\nz_advect = struct containing information for z-advection\nvpa_advect = struct containing information for vpa-advection\nscratch_dummy = dummy arrays to be used for temporary storage\nt_params = parameters, etc. for time-stepping\ncollisions = parameters for charged species collisions and neutral reactions\ncomposition = parameters describing number and type of species\nmax_electron_pdf_iterations = maximum number of iterations to use in the solution of the electron kinetic equation\nmax_electron_sim_time = maximum amount of de-dimensionalised time to use in the solution of the electron kinetic equation\nio_electorn = if this is passed, write some output from the electron pseudo-timestepping\ninitial_time = if this is passed set the initial pseudo-time to this value\nresidual_tolerance = if this is passed, it overrides the value of `t_params.converged_residual_value`\nevolve_p = if set to true, update the electron pressure as part of the solve\nion_dt = if this is passed, the electron pressure is evolved in a form that results in\n         a backward-Euler update on the ion timestep (ion_dt) once the electron\n         pseudo-timestepping reaches steady state.\nsolution_method = if this is passed, choose a non-standard method for the solution\n\nOUTPUT:     pdf = updated (modified) electron pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_electron_kinetic_equation/#moment_kinetics.electron_kinetic_equation.update_electron_pdf_with_time_advance!-Tuple{Any, Any, Any, AbstractMatrix{Float64}, Any, Any, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate, Vararg{Any, 11}}","page":"electron_kinetic_equation","title":"moment_kinetics.electron_kinetic_equation.update_electron_pdf_with_time_advance!","text":"updateelectronpdfwithtime_advance is a function that introduces an artifical time derivative to advance  the electron kinetic equation until a steady-state solution is reached.\n\nThe electron kinetic equation is:     zdot * d(pdf)/dz + wpadot * d(pdf)/dwpa = pdf * pre_factor\n\nINPUTS:\nscratch = `scratch_pdf` struct used to store Runge-Kutta stages\npdf = modified electron pdf @ previous time level = (true electron pdf / dens_e) * vth_e\nmoments = struct containing electron moments\nr = struct containing r-coordinate information\nz = struct containing z-coordinate information\nvperp = struct containing vperp-coordinate information\nvpa = struct containing vpa-coordinate information\nz_spectral = struct containing spectral information for the z-coordinate\nvperp_spectral = struct containing spectral information for the vperp-coordinate\nvpa_spectral = struct containing spectral information for the vpa-coordinate\nz_advect = struct containing information for z-advection\nvpa_advect = struct containing information for vpa-advection\nscratch_dummy = dummy arrays to be used for temporary storage\nt_params = parameters, etc. for time-stepping\ncollisions = parameters for charged species collisions and neutral reactions\ncomposition = parameters describing number and type of species\nmax_electron_pdf_iterations = maximum number of iterations to use in the solution of the electron kinetic equation\nmax_electron_sim_time = maximum amount of de-dimensionalised time to use in the solution of the electron kinetic equation\nio_electorn = if this is passed, write some output from the electron pseudo-timestepping\ninitial_time = if this is passed set the initial pseudo-time to this value\nresidual_tolerance = if this is passed, it overrides the value of `t_params.converged_residual_value`\nevolve_p = if set to true, update the electron pressure as part of the solve\nion_dt = if this is passed, the electron pressure is evolved in a form that results in\n         a backward-Euler update on the ion timestep (ion_dt) once the electron\n         pseudo-timestepping reaches steady state.\n\nOUTPUT:     pdf = updated (modified) electron pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#boundary_conditions","page":"boundary_conditions","title":"boundary_conditions","text":"","category":"section"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions","text":"Functions for applying boundary conditions\n\n\n\n\n\n","category":"module"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_boundary_conditions!-Tuple{Any, Any, Any, Any, Any, moment_kinetics.moment_kinetics_structs.boundary_info, Vararg{Any, 17}}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_boundary_conditions!","text":"enforce boundary conditions in vpa and z on the evolved pdf; also enforce boundary conditions in z on all separately evolved velocity space moments of the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_electron_r_boundary_condition!-Tuple{AbstractArray{Float64, 4}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, AbstractMatrix{Float64}, moment_kinetics.moment_kinetics_structs.r_boundary_info, Any, Any, Any, Any, Any, Any, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, Bool}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_electron_r_boundary_condition!","text":"enforce boundary conditions on electrons in r\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_initial_tapered_zero_incoming!-Tuple{Any, moment_kinetics.moment_kinetics_structs.coordinate, moment_kinetics.moment_kinetics_structs.coordinate}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_initial_tapered_zero_incoming!","text":"Set up an initial condition that tries to be smoothly compatible with the sheath boundary condition for ions, by setting f(±(v_parallel-u0)<0) where u0=0 at the sheath boundaries and for z<0 increases linearly to u0=vpa.L at z=0, while for z>0 increases from u0=-vpa.L at z=0 to zero at the z=z.L/2 sheath.\n\nTo be applied to 'full-f' distribution function on vparallel grid (not wparallel grid).\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_neutral_boundary_conditions!-Tuple{Any, Any, Any, Any, Any, Any, moment_kinetics.moment_kinetics_structs.boundary_info, Vararg{Any, 22}}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_neutral_boundary_conditions!","text":"enforce boundary conditions on neutral particle distribution function\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_neutral_r_boundary_condition!-Tuple{AbstractArray{Float64, 6}, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, moment_kinetics.moment_kinetics_structs.r_boundary_info, Any, Any, Any, Any, Any, Any, Any, AbstractArray{Float64, 5}, AbstractArray{Float64, 5}, AbstractArray{Float64, 5}, AbstractArray{Float64, 5}, Bool}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_neutral_r_boundary_condition!","text":"enforce boundary conditions on neutrals in r\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_neutral_wall_bc!-NTuple{18, Any}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_neutral_wall_bc!","text":"enforce the wall boundary condition on neutrals; i.e., the incoming flux of neutrals equals the sum of the ion/neutral outgoing fluxes\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_neutral_z_boundary_condition!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Vararg{AbstractArray{Float64, 5}, 5}}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_neutral_z_boundary_condition!","text":"enforce boundary conditions on neutral particle f in z\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_r_boundary_condition!-Tuple{AbstractArray{Float64, 5}, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractArray{Float64, 3}, AbstractMatrix{Float64}, moment_kinetics.moment_kinetics_structs.r_boundary_info, Any, Any, Any, Any, Any, Any, AbstractArray{Float64, 4}, AbstractArray{Float64, 4}, AbstractArray{Float64, 4}, AbstractArray{Float64, 4}, Bool}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_r_boundary_condition!","text":"enforce boundary conditions on ions in r\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_v_boundary_condition_local!-NTuple{6, Any}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_v_boundary_condition_local!","text":"\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_vperp_boundary_condition!","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_vperp_boundary_condition!","text":"enforce zero boundary condition at vperp -> infinity\n\n\n\n\n\n","category":"function"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_z_boundary_condition!-Tuple{Any, Any, Any, Any, Any, Any, String, Any, Any, Any, Any, Any, Any, AbstractArray{Float64, 4}, AbstractArray{Float64, 4}, AbstractArray{Float64, 4}, AbstractArray{Float64, 4}, AbstractMatrix{Float64}}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_z_boundary_condition!","text":"enforce boundary conditions on ion particle f in z\n\nvpavperp_buffer should be an unshared array, as it is used inside a shared-memory-parallelised loop.\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_z_boundary_condition_moments!-Tuple{Any, Any, String}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_z_boundary_condition_moments!","text":"enforce the z boundary condition on the evolved velocity space moments of f\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.enforce_zero_incoming_bc!-NTuple{6, Any}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.enforce_zero_incoming_bc!","text":"enforce a zero incoming BC in z for given species pdf at each radial location\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.skip_f_electron_bc_points_in_Jacobian-NTuple{7, Any}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.skip_f_electron_bc_points_in_Jacobian","text":"skip_f_electron_bc_points_in_Jacobian(z_speed, ivpa, ivperp, iz, vpa, vperp, z)\n\nThis function returns true when the grid point specified by iz, ivperp, ivpa would be set by the boundary conditions on the electron distribution function. When this happens, the corresponding row should be skipped when adding contributions to the Jacobian matrix, so that the row remains the same as a row of the identity matrix, so that the Jacobian matrix does not modify those points. Returns false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.vpa_to_wpa-NTuple{5, Any}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.vpa_to_wpa","text":"create an array of w_∥ values corresponding to the given vpa values\n\n\n\n\n\n","category":"method"},{"location":"zz_boundary_conditions/#moment_kinetics.boundary_conditions.vpagrid_to_vpa-NTuple{5, Any}","page":"boundary_conditions","title":"moment_kinetics.boundary_conditions.vpagrid_to_vpa","text":"create an array of v_∥ values corresponding to the given vpagrid values\n\n\n\n\n\n","category":"method"},{"location":"zz_r_advection/#r_advection","page":"r_advection","title":"r_advection","text":"","category":"section"},{"location":"zz_r_advection/#moment_kinetics.r_advection","page":"r_advection","title":"moment_kinetics.r_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_r_advection/#moment_kinetics.r_advection.r_advection!-NTuple{14, Any}","page":"r_advection","title":"moment_kinetics.r_advection.r_advection!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"zz_r_advection/#moment_kinetics.r_advection.r_advection_1D_ITG!-NTuple{14, Any}","page":"r_advection","title":"moment_kinetics.r_advection.r_advection_1D_ITG!","text":"1D false r advection, intended to provoke ITG in 1D. Despite there being no real r  advection, we insist that a radial temperature gradient exists, and add the ExB drift term to the DKE anyway to bring in temperature gradient drive. Since f is not known  along r, and hence its temperature dependence is not known, it is assumed that f  is roughly a Maxwellian with an R dependent temperature only. This means we can control L_T through this term.\n\n\n\n\n\n","category":"method"},{"location":"zz_r_advection/#moment_kinetics.r_advection.update_speed_r!-NTuple{11, Any}","page":"r_advection","title":"moment_kinetics.r_advection.update_speed_r!","text":"calculate the advection speed in the r-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetic_equations/#Moment-kinetic-equations","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In 2D, assuming no variation in the zeta direction partial (cdot)  partial zeta = 0 and a tilted (or 'helical') magnetic field boldsymbolB = B_z(rz) hatboldsymbolz + B_zeta(rz) hatboldsymbolzeta the ion kinetic equation for the distribution function f_i(t boldsymbolr boldsymbolv)=f_i(t r z v_parallel v_perp) is","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial f_ipartial t\n    + v_E^r fracpartial f_ipartial r\n    + left( v_E^z + b^z v_parallel right) fracpartial f_ipartial z\n    - b^z fracem_i fracpartialphipartial z fracpartial f_ipartial v_parallel\n    = C_iif_if_i + C_inf_if_n + S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"where","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nb^z = nabla z cdot boldsymbolb = (B_zB)\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"is the z-projection of boldsymbolb, and","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nv_E^r = nabla r cdot boldsymbol v_E\n       = nabla r cdot fracboldsymbolb times nabla phiB\n       = - (nabla r times nabla z) cdot boldsymbolb frac1B fracpartial phipartial z\n       = - hatboldsymbolzeta cdot boldsymbolb frac1B fracpartial phipartial z\n       = - fracb_zetaB fracpartial phipartial z \n\nv_E^z = nabla z cdot boldsymbol v_E\n       = nabla z cdot fracboldsymbolb times nabla phiB\n       = (nabla r times nabla z) cdot boldsymbolb frac1B fracpartial phipartial r\n       = hatboldsymbolzeta cdot boldsymbolb frac1B fracpartial phipartial r\n       = fracb_zetaB fracpartial phipartial r \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"are the r- and z-components of the E times B drift.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The 1D version takes partial (cdot)  partial r = 0, B_zeta = 0, B_z = B so that v_E^r = v_E^z = 0, b^z = 1, b_zeta = 0.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"C_ii are ion-ion collisions, C_in ion-neutral collisions/reactions, and S_i a source term.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Simplified neutral interactions C_in including charge exchange and ionization with constant R_mathrmCX and R_mathrmioniz","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nC_in = -R_mathrmCX(n_n f_i - n_i f_n) + R_mathrmioniz n_e f_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Want to normalise the distribution for any species s to extract low-order moments.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nF_s(tzw_parallelw_perp) =\n  fracv_Ts^3n_s f_s(t z u_sparallel(tz) + v_Ts(tz)w_parallel v_Ts(tz)w_perp)\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"with normalised velocities","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nw_parallel(tzv_parallel) = fracv_parallel - u_sparallel(tz)v_Ts(tz) \nw_perp(tzv_perp) = fracv_perpv_Ts(tz)\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"the density","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nn_s(tz) = 2piint_-infty^infty dv_parallel int_0^infty dv_perp v_perp f_s(tzv_parallelv_perp)\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"the average parallel velocity","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nu_sparallel(tz) = frac2pin_sint_-infty^infty dv_parallel int_0^infty dv_perp v_perp v_parallel f_s(tzv_parallelv_perp)\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and the thermal speed","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nv_Ts^2(tz) = frac4pi3n_sint_-infty^infty dv_parallel int_0^infty dv_perp v_perp\n    left (v_parallel - u_sparallel(tz))^2 + v_perp^2 right f_s(tzv_parallelv_perp)\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"For use later, we also give the definitions of the parallel and perpendicular pressure","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\np_sparallel(tz) = 2piint_-infty^infty dv_parallel int_0^infty dv_perp v_perp\n    m_s left( v_parallel - u_sparallel(tz) right)^2 f_s(tzv_parallelv_perp) nonumber \n    = m_s n_s v_Ts^2 2pi int_-infty^infty dw_parallel int_0^infty dw_perp w_perp\n        w_parallel^2 F_s(tzw_parallelw_perp) \n\np_sperp(tz) = 2piint_-infty^infty dv_parallel int_0^infty dv_perp v_perp\n    m_s fracv_perp^22 f_s(tzv_parallelv_perp) \n    = frac12 m_s n_s v_Ts^2 2pi int_-infty^infty dw_parallel int_0^infty dw_perp w_perp\n        w_perp^2 F_s(tzw_parallelw_perp) \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and T_sparallel = p_sparalleln_s, T_sperp = p_sperpn_s, which we can note means that","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\np_s = n_s T_s = fracm_s2 n_s v_Ts^2 = frac13(p_sparallel + 2p_sperp) \nT_s = frac13(T_sparallel + 2T_sperp) \nv_Ts = sqrtfrac2T_sm_s= sqrtfrac2(T_sparallel + 2T_sperp)3m_s \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The parallel heat flux is","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nq_sparallel = int fracm_s2 left( (v_parallel - u_sparallel)^2 + v_perp^2 right) (v_parallel - u_sparallel) f_s d^3 v \n    = fracn_sv_Ts^3 int fracm_s2 left( (v_parallel - u_sparallel)^2 + v_perp^2 right) (v_parallel - u_sparallel) F_s d^3 v nonumber \n    = n_s int fracm_s2 v_Ts^2 left( w_parallel^2 + w_perp^2 right) v_Ts w_parallel F_s d^3 w nonumber \n    = n_s v_Ts^3 int fracm_s2 left( w_parallel^2 + w_perp^2 right) w_parallel F_s d^3 w \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"F_s must therefore satisfy the conditions","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n2pi int_-infty^infty dw_parallel int_0^infty dw_perp w_perp F_s(tzw_parallelw_perp) = 1 \n2pi int_-infty^infty dw_parallel int_0^infty dw_perp w_perp w_parallel F_s(tzw_parallelw_perp) = 0 \n2pi int_-infty^infty dw_parallel int_0^infty dw_perp w_perp (w_parallel^2 + w_perp^2) F_s(tzw_parallelw_perp) = frac32 \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Ion-moment-equations","page":"Moment kinetic equations","title":"Ion moment equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Can integrate the drift kinetic equation to give the moment equations:","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"continuity\n<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>\nbeginalign\n int fracpartial f_ipartial t d^3 v\n    + underbraceint v_E^r fracpartial f_ipartial r d^3 v_texttake prefactors and derivative out of velocity integral nonumber \n   + underbraceint v_E^z fracpartial f_ipartial z d^3 v_texttake prefactors and derivative out of velocity integral\n   + underbraceint v_parallel b^z fracpartial f_ipartial z d^3 v_texttake prefactor and derivative out of velocity integral nonumber \n   - b^z fracem_i fracpartialphipartial z underbraceint fracpartial f_ipartial v_parallel d^3 v_texttotal derivative integrates to 0 nonumber \n= underbraceint C_iif_if_i d^3 v_=0text collisions conserve particles +\n    int left underbrace-R_mathrmCX(n_n f_i - n_i f_n)_=0text no particle source from CX + R_mathrmioniz n_e f_n right d^3 v\n    + underbraceint S_i d^3 v_S_in \nendalign\n</details>\nbeginalign\nfracpartial n_ipartial t\n    + v_E^r fracpartial n_ipartial r\n    + v_E^z fracpartial n_ipartial z\n    + b^z fracpartialpartial zleft( n_i u_iparallel right)\n    = R_mathrmioniz n_e n_n + S_in\nendalign\nwhere the density source is S_sn = int S_s d^3 v\nmomentum\n<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>\nbeginalign\n int v_parallel fracpartial f_ipartial t d^3 v\n    + int v_parallel v_E^r fracpartial f_ipartial r d^3 v\n    + int v_parallel v_E^z fracpartial f_ipartial z d^3 v\n    + int v_parallel^2 b^z fracpartial f_ipartial z d^3 v\n    - b^z fracem_i fracpartialphipartial z int v_parallel fracpartial f_ipartial v_parallel d^3 v nonumber \n= underbraceint v_parallel C_iif_if_i d^3 v_=0text collisions conserve momentum +\n    int v_parallel left -R_mathrmCX(n_n f_i - n_i f_n) + R_mathrmioniz n_e f_n right d^3 v\n    + underbraceint v_parallel S_i d^3 v_S_imathrmmom  m_i \n fracpartialpartial t int v_parallel f_i d^3 v\n    + v_E^r fracpartialpartial r int v_parallel f_i d^3 v\n    + v_E^z fracpartialpartial z int v_parallel f_i d^3 v\n    + b^z fracpartialpartial z int v_parallel^2 f_i d^3 v\n    + b^z fracem_i fracpartialphipartial z int f_i d^3 v nonumber \n= int v_parallel left -R_mathrmCX(n_n f_i - n_i f_n) + R_mathrmioniz n_e f_n right d^3 v\n    + frac1m_i S_imathrmmom \n fracpartialpartial t int v_parallel f_i d^3 v\n    + v_E^r fracpartialpartial r int v_parallel f_i d^3 v\n    + v_E^z fracpartialpartial z int v_parallel f_i d^3 v\n    + b^z fracpartialpartial z(u_iparallel^2 n_i) + b^z fracpartialpartial z int v_Ti^2 left( v_parallel - u_iparallel right)^2 f_i d^3 v\n    + b^z fracem_i fracpartialphipartial z int f_i d^3 v nonumber \n= int v_parallel left -R_mathrmCX(n_n f_i - n_i f_n) + R_mathrmioniz n_e f_n right d^3 v\n    + frac1m_i S_imathrmmom \nendalign\n</details>\nbeginalign\n m_i fracpartialpartial t(n_i u_iparallel)\n  + m_i v_E^r fracpartialpartial r (n_i u_iparallel)\n  + m_i v_E^z fracpartialpartial z (n_i u_iparallel)\n  + m_i b^z fracpartialpartial z(n_i u_iparallel^2)\n  + b^z fracpartial p_iparallelpartial z\n  + b^z e n_i fracpartial phipartial z nonumber \nquad= R_mathrmCX m_i n_i n_n (u_nparallel - u_iparallel)\n        + R_mathrmioniz m_i n_e n_n u_nparallel\n        + S_imathrmmom \nendalign\nwhere the momentum source is S_smathrmmom = m_s int v_parallel S_s d^3 v, which can also be manipulated into an equation for partial u_iparallelpartial t using the continuity equation\n<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>\ntake u_iparalleltimescontinuity rightarrow\nbeginalign\n m_i u_iparallel fracpartial n_ipartial t\n    + m_i u_iparallel v_E^r fracpartial n_ipartial r\n    + m_i u_iparallel v_E^z fracpartial n_ipartial z\n    + m_i u_iparallel b^z fracpartialpartial z(n_i u_iparallel)\n= R_mathrmioniz n_e n_n u_iparallel + u_iparallel S_in \nendalign\nbeginalign\nm_i u_iparallel fracpartial n_ipartial t\n= - m_i u_iparallel v_E^r fracpartial n_ipartial r\n   - m_i u_iparallel v_E^z fracpartial n_ipartial z\n   - m_i u_iparallel b^z fracpartialpartial z(n_i u_iparallel)\n   + R_mathrmioniz n_e n_n u_iparallel + u_iparallel S_in\nendalign\nMomentum rightarrow\nbeginalign\nm_i u_iparallel fracpartial n_ipartial t + m_i n_i fracpartial u_iparallelpartial t\n + m_i n_i v_E^r fracpartial u_iparallelpartial r\n + m_i n_i v_E^r fracpartial n_ipartial r\n + m_i n_i v_E^z fracpartial u_iparallelpartial z\n + m_i n_i v_E^z fracpartial n_ipartial z\n + m_i b^z u_iparallel^2 fracpartial n_ipartial z\n + m_i b^z n_i 2u_iparallel fracpartial u_iparallelpartial z\n + b^z fracpartial p_iparallelpartial z\n + b^z e n_i fracpartialphipartial z nonumber \n= R_mathrmCX m_i n_i n_n (u_nparallel - u_iparallel)\n   + R_mathrmioniz m_i n_e n_n u_nparallel\n   + S_imathrmmom \nendalign\nSub from continuity rightarrow cancellation\n</details>\nbeginalign\nm_i n_i fracpartial u_iparallelpartial t\n + m_i n_i v_E^r fracpartial u_iparallelpartial r\n + m_i n_i v_E^z fracpartial u_iparallelpartial z nonumber \n + m_i b^z n_i u_iparallel fracpartial u_iparallelpartial z\n= - b^z fracpartial p_iparallelpartial z - b^z e n_i fracpartialphipartial z\n   + R_mathrmCX m_i n_i n_n (u_nparallel - u_iparallel)\n   + R_mathrmioniz m_i n_e n_n (u_nparallel - u_iparallel)\n   + S_imathrmmom - m_i u_iparallel S_in \nendalign\nEnergy\n<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>\nbeginalign\n frac12 int v^2 fracpartial f_ipartial t d^3 v\n    + frac12 int v^2 v_E^r f_ipartial r d^3 v\n    + frac12 int v^2 v_E^z f_ipartial z d^3 v\n    + frac12 int v^2 b^z v_parallel fracpartial f_ipartial z d^3 v\n    - frac12 b^z fracem_i fracpartialphipartial z int v^2 fracpartial f_ipartial v_parallel d^3 v nonumber \nquad= frac12 underbraceint v^2 C_iif_if_i d^3 v_=0text collisions conserve energy\n      + frac12 int v^2 left -R_mathrmCX(n_n f_i - n_i f_n) + R_mathrmioniz n_e f_n right d^3 v\n      + underbracefrac12 int v^2 S_i d^3 v_S_iE  m_i \n\n frac12 fracpartialpartial t int v^2 f_i d^3 v\n    + frac12 v_E^r r int v^2 f_i d^3 v\n    + frac12 v_E^z z int v^2 f_i d^3 v\n    + frac12 b^z fracpartialpartial z int v^2 v_parallel f_i d^3 v\n    + frac12 b^z fracem_i fracpartialphipartial z int 2 v_parallel f_i d^3 v nonumber \nquad= frac12 int v^2 left -R_mathrmCX(n_n f_i - n_i f_n) + R_mathrmioniz n_e f_n right d^3 v\n      + frac1m_i S_iE \n\n frac12 fracpartialpartial t int left((v_parallel - u_iparallel)^2 + cancel2(v_parallel - u_iparallel) u_iparallel + u_iparallel^2 + v_perp^2 right) f_i d^3 v nonumber \n+ frac12 v_E^r fracpartialpartial r int left((v_parallel - u_iparallel)^2 + cancel2(v_parallel - u_iparallel) u_iparallel + u_iparallel^2 + v_perp^2 right) f_i d^3 v nonumber \n+ frac12 v_E^z fracpartialpartial z int left((v_parallel - u_iparallel)^2 + cancel2(v_parallel - u_iparallel) u_iparallel + u_iparallel^2 + v_perp^2 right) f_i d^3 v nonumber \n+ frac12 b^z fracpartialpartial z int underbraceleft((v_parallel - u_iparallel)^2 + 2(v_parallel - u_iparallel) u_iparallel + u_iparallel^2 + v_perp^2 right) left( (v_parallel - u_iparallel) + u_iparallel right)_(v_parallel - u_iparallel)^3 + 2(v_parallel - u_iparallel)^2 u_iparallel + cancelu_iparallel^2(v_parallel - u_iparallel) + v_perp^2(v_parallel - u_iparallel) + (v_parallel - u_iparallel)^2 u_iparallel + cancel2(v_parallel - u_iparallel)u_iparallel^2 + u_iparallel^3 + v_perp^2 u_iparallel f_i d^3 v nonumber \n+ frac12 b^z fracem_i fracpartialphipartial z int 2 left( cancel(v_parallel - u_iparallel) + u_iparallel right) f_i d^3 v nonumber \nquad= - frac12 int left((v_parallel - u_iparallel)^2 + cancel2(v_parallel - u_iparallel) u_iparallel + u_iparallel^2 + v_perp^2 right) R_mathrmCX n_n f_i d^3 v nonumber \nqquad+ frac12 int left((v_parallel - u_nparallel)^2 + cancel2(v_parallel - u_nparallel) u_nparallel + u_nparallel^2 + v_perp^2 right) R_mathrmCX n_i f_n d^3 v nonumber \nqquad+ frac12 int left((v_parallel - u_nparallel)^2 + cancel2(v_parallel - u_nparallel) u_nparallel + u_nparallel^2 + v_perp^2 right) R_mathrmioniz n_e f_n d^3 v nonumber \nqquad+ frac1m_i S_iE \n\n frac12 fracpartialpartial t left( frac3 p_im_i + n_i u_iparallel^2 right) nonumber \n+ frac12 v_E^r fracpartialpartial r left( frac3 p_im_i + n_i u_iparallel^2 right) nonumber \n+ frac12 v_E^z fracpartialpartial z left( frac3 p_im_i + n_i u_iparallel^2 right) nonumber \n+ frac12 b^z fracpartialpartial z left int left( (v_parallel - u_iparallel)^3 + v_perp^2(v_parallel - u_iparallel) right) f_i d^3 v + 2fracp_iparallelm_i u_iparallel + frac3 p_im_i u_iparallel + n_i u_iparallel^3 right nonumber \n+ b^z fracem_i fracpartialphipartial z n_i u_iparallel nonumber \nquad= - frac12 R_mathrmCX left(frac3 p_im_i n_n + n_i n_n u_iparallel^2 - frac3 p_nm_i n_i - n_i n_n u_nparallel^2 right) nonumber \nqquad+ frac12 R_mathrmioniz n_e left(frac3 p_nm_i + n_n u_nparallel^2 right) nonumber \nqquad+ frac1m_i S_iE \n\n frac12 fracpartialpartial t left( frac3 p_im_i + n_i u_iparallel^2 right)\n  - frac12 v_E^r fracpartialpartial r left( frac3 p_im_i + n_i u_iparallel^2 right)\n  + frac12 v_E^z fracpartialpartial z left( frac3 p_im_i + n_i u_iparallel^2 right)\n  + frac12 b^z fracpartialpartial z left frac2 q_iparallelm_i + 2fracp_iparallelm_i u_iparallel + frac3 p_im_i u_iparallel + n_i u_iparallel^3 right\n  + b^z fracem_i fracpartialphipartial z n_i u_iparallel nonumber \nquad= - frac12 R_mathrmCX left(frac3 p_im_i n_n + n_i n_n u_iparallel^2 - frac3 p_nm_i n_i - n_i n_n u_nparallel^2 right)\n      + frac12 R_mathrmioniz n_e left(frac3 p_nm_i + n_n u_nparallel^2 right) nonumber \nqquad+ frac1m_i S_iE \n\n frac32 fracpartial p_ipartial t + m_i u_iparallel fracpartial(n_i u_iparallel)partial t - frac12 m_i u_iparallel^2 fracpartial n_ipartial t\n  + frac32 v_E^r fracpartial p_ipartial r\n  + m_i n_i u_iparallel v_E^r fracpartial u_iparallelpartial r\n  + frac12 m_i u_iparallel^2 v_E^r fracpartial n_ipartial r\n  + frac32 v_E^z fracpartial p_ipartial z\n  + m_i n_i u_iparallel v_E^z fracpartial u_iparallelpartial z\n  + frac12 m_i u_iparallel^2 v_E^z fracpartial n_ipartial z\n  + b^z fracpartial q_iparallelpartial z + u_iparallel fracpartial p_iparallelpartial z + b^z p_iparallel fracpartial u_iparallelpartial z nonumber \nquad+ frac32 b^z u_iparallel fracpartial p_ipartial z + frac32 b^z p_i fracpartial u_iparallelpartial z + frac32 b^z m_i n_i u_iparallel^2 fracpartial u_iparallelpartial z + frac12 m_i u_iparallel^3 fracpartial n_ipartial z\n  + b^z e fracpartialphipartial z n_i u_iparallel nonumber \nquad= - frac12 R_mathrmCX left(3 p_i n_n + m_i n_i n_n u_iparallel^2 - 3 p_n n_i - m_i n_i n_n u_nparallel^2 right)\n      + frac12 R_mathrmioniz n_e left(3 p_n + m_i n_n u_nparallel^2 right) nonumber \nqquad+ frac1m_i S_iE \n\n frac32 fracpartial p_ipartial t nonumber \nquad- m_i u_iparallel v_E^r fracpartialpartial r (n_i u_iparallel) - b^z m_i u_iparallel fracpartialpartial z(n_i u_iparallel^2) - m_i u_iparallel v_E^z fracpartialpartial z (n_i u_iparallel) - b^z u_iparallel fracpartial p_iparallelpartial z - b^z e n_i u_iparallel fracpartial phipartial z + u_iparallel R_mathrmCX m_i n_i n_n (u_nparallel - u_iparallel) + u_iparallel R_mathrmioniz m_i n_e n_n u_nparallel + u_iparallel S_imathrmmom nonumber \nquad+ frac12 m_i u_iparallel^2 v_E^r fracpartial n_ipartial r + frac12 m_i u_iparallel^2 v_E^z fracpartial n_ipartial z + frac12 b^z m_i u_iparallel^2 fracpartialpartial z(n_i u_iparallel) - frac12 m_i u_iparallel^2 R_mathrmioniz n_e n_n - frac12 m_i u_iparallel^2 S_in nonumber \n+ frac32 v_E^r fracpartial p_ipartial r\n  + m_i n_i u_iparallel v_E^r fracpartial u_iparallelpartial r\n  + frac12 m_i u_iparallel^2 v_E^r fracpartial n_ipartial r nonumber \n+ frac32 v_E^z fracpartial p_ipartial z\n  + m_i n_i u_iparallel v_E^z fracpartial u_iparallelpartial z\n  + frac12 m_i u_iparallel^2 v_E^z fracpartial n_ipartial z nonumber \nquad+ b^z fracpartial q_iparallelpartial z + b^z u_iparallel fracpartial p_iparallelpartial z + b^z p_iparallel fracpartial u_iparallelpartial z nonumber \nquad+ b^z frac32 u_iparallel fracpartial p_ipartial z + frac32 b^z p_i fracpartial u_iparallelpartial z + frac32 b^z m_i n_i u_iparallel^2 fracpartial u_iparallelpartial z + frac12 b^z m_i u_iparallel^3 fracpartial n_ipartial z nonumber \n+ b^z e fracpartialphipartial z n_i u_iparallel nonumber \nquad= - frac12 R_mathrmCX left(3 p_i n_n + m_i n_i n_n u_iparallel^2 - 3 p_n n_i - m_i n_i n_n u_nparallel^2 right)\n      + frac12 R_mathrmioniz n_e left(3 p_n + m_i n_n u_nparallel^2 right) nonumber \nqquad+ S_iE \n\n frac32 fracpartial p_ipartial t nonumber \nquad- cancelm_i n_i u_iparallel v_E^r fracpartial u_iparallelpartial r - cancelm_i u_iparallel^2 v_E^r fracpartial n_ipartial r - cancelm_i n_i u_iparallel v_E^z fracpartial u_iparallelpartial z - cancelm_i u_iparallel^2 v_E^z fracpartial n_ipartial z - cancel2 b^z m_i n_i u_iparallel^2 fracpartial u_iparallelpartial z - cancelb^z m_i u_iparallel^3 fracpartial n_ipartial z - cancelb^z u_iparallel fracpartial p_iparallelpartial z - cancelb^z e n_i u_iparallel fracpartial phipartial z + u_iparallel R_mathrmCX m_i n_i n_n (u_nparallel - u_iparallel) + u_iparallel R_mathrmioniz m_i n_e n_n u_nparallel + u_iparallel S_imathrmmom nonumber \nquad+ cancelfrac12 m_i u_iparallel^2 v_E^r fracpartial n_ipartial r + cancelfrac12 b^z m_i u_iparallel^2 v_E^z fracpartial n_ipartial z + cancelfrac12 b^z m_i n_i u_iparallel^2 fracpartial u_iparallelpartial z + cancelfrac12 b^z m_i u_iparallel^3 fracpartial n_ipartial z - frac12 m_i u_iparallel^2 R_mathrmioniz n_e n_n - frac12 m_i u_iparallel^2 S_in nonumber \n+ frac32 v_E^r fracpartial p_ipartial r\n  + cancelm_i n_i u_iparallel v_E^r fracpartial u_iparallelpartial r\n  + cancelfrac12 m_i u_iparallel^2 v_E^r fracpartial n_ipartial r nonumber \n+ frac32 v_E^z fracpartial p_ipartial z\n  + cancelm_i n_i u_iparallel v_E^z fracpartial u_iparallelpartial z\n  + cancelfrac12 m_i u_iparallel^2 v_E^z fracpartial n_ipartial z nonumber \nquad+ b^z fracpartial q_iparallelpartial z + cancelb^z u_iparallel fracpartial p_iparallelpartial z + b^z p_iparallel fracpartial u_iparallelpartial z nonumber \nquad+ frac32 b^z u_iparallel fracpartial p_ipartial z + frac32 b^z p_i fracpartial u_iparallelpartial z + cancelfrac32 b^z m_i n_i u_iparallel^2 fracpartial u_iparallelpartial z + cancelfrac12 b^z m_i u_iparallel^3 fracpartial n_ipartial z nonumber \n+ cancelb^z e fracpartialphipartial z n_i u_iparallel nonumber \nquad= - frac12 R_mathrmCX left(3 p_i n_n + m_i n_i n_n u_iparallel^2 - 3 p_n n_i - m_i n_i n_n u_nparallel^2 right)\n      + frac12 R_mathrmioniz n_e left(3 p_n + m_i n_n u_nparallel^2 right) nonumber \nqquad+ S_iE \n\n frac32 fracpartial p_ipartial t\n  + frac32 v_E^r fracpartial p_ipartial r\n  + frac32 v_E^z fracpartial p_ipartial z\n  + b^z fracpartial q_iparallelpartial z + b^z p_iparallel fracpartial u_iparallelpartial z\n  + frac32 b^z u_iparallel fracpartial p_ipartial z + frac32 b^z p_i fracpartial u_iparallelpartial z nonumber \nquad= - frac12 R_mathrmCX left(3 p_i n_n - m_i n_i n_n u_iparallel^2 + 2 m_i n_i n_n u_iparallelu_nparallel - 3 p_n n_i - m_i n_i n_n u_nparallel^2 right)\n      + frac12 R_mathrmioniz n_e left(3 p_n + m_i n_n u_iparallel^2 - 2 m_i n_n u_iparallel u_nparallel + m_i n_n u_nparallel^2 right) nonumber \nqquad+ S_iE\n       - u_iparallel S_imathrmmom\n       + frac12 m_i u_iparallel^2 S_in \nendalign\n</details>\nbeginalign\n frac32 fracpartial p_ipartial t\n  + frac32 v_E^r fracpartial p_ipartial r\n  + frac32 v_E^z fracpartial p_ipartial z\n  + b^z fracpartial q_iparallelpartial z + b^z p_iparallel fracpartial u_iparallelpartial z\n  + frac32 b^z u_iparallel fracpartial p_ipartial z + frac32 b^z p_i fracpartial u_iparallelpartial z nonumber \nquad= - frac12 R_mathrmCX n_i n_n left(3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2 right)\n      + frac12 R_mathrmioniz n_e n_n left(3 T_n + m_i (u_iparallel - u_nparallel)^2 right) nonumber \nqquad+ frac32 S_ip \nendalign\nwhere the energy source is S_sE = frac12 m_s int v^2 S_s d^3 v, and the pressure source is S_sp = frac13 m_s int boldsymbolv - u_sparallelhatboldsymbolz^2 S_s d^3 v = frac23 S_sE - frac23 u_sparallel S_smathrmmom + frac13 m_s u_sparallel^2 S_sn. We use the pressure as an evolving variable in the code, so this is the energy equation used. It is also useful to subsitute in the continuity equation to convert this to a temperature equation and then a v_Ti equation, as the latter will be used to form the kinetic equation for F_i.\n<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>\nbeginalign\n frac32 fracpartial n_i T_ipartial t\n  + frac32 v_E^r fracpartial n_i T_ipartialr\n  + frac32 v_E^z fracpartial n_i T_ipartialz\n  + b^z fracpartial q_iparallelpartial z + b^z p_iparallel fracpartial u_iparallelpartial z\n  + frac32 b^z u_iparallel fracpartial n_i T_ipartial z + frac32 b^z n_i T_i fracpartial u_iparallelpartial z nonumber \nquad= - frac12 R_mathrmCX n_i n_n left(3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2 right)\n      + frac12 R_mathrmioniz n_e n_n left(3 T_n + m_i (u_iparallel - u_nparallel)^2 right) nonumber \nqquad+ frac32 S_ip \n\n frac32 n_i fracpartial T_ipartial t + frac32 T_i fracpartial n_ipartial t\n  + frac32 n_i v_E^r fracpartial T_ipartialr\n  + frac32 T_i v_E^r fracpartial n_ipartialr\n  + frac32 n_i v_E^z fracpartial T_ipartialz\n  + frac32 T_i v_E^z fracpartial n_ipartialz\n  + b^z fracpartial q_iparallelpartial z + b^z p_iparallel fracpartial u_iparallelpartial z\n  + frac32 b^z n_i u_iparallel fracpartial T_ipartial z + frac32 b^z u_iparallel T_i fracpartial n_ipartial z + frac32 b^z n_i T_i fracpartial u_iparallelpartial z nonumber \nquad= - frac12 R_mathrmCX n_i n_n left(3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2 right)\n      + frac12 R_mathrmioniz n_e n_n left(3 T_n + m_i (u_iparallel - u_nparallel)^2 right) nonumber \nqquad+ frac32 S_ip \n\n frac32 n_i fracpartial T_ipartial t\n  - frac32 T_i v_E^r fracpartial n_ipartial r - frac32 T_i v_E^z fracpartial n_ipartial z - frac32 b^z n_i T_i fracpartial u_iparallelpartial z - frac32 b^z u_iparallel T_i fracpartial n_ipartial z + frac32 T_i R_mathrmioniz n_e n_n + frac32 T_i S_in\n  + frac32 n_i v_E^r fracpartial T_ipartialr\n  + frac32 T_i v_E^r fracpartial n_ipartialr\n  + frac32 n_i v_E^z fracpartial T_ipartialz\n  + frac32 T_i v_E^z fracpartial n_ipartialz\n  + b^z fracpartial q_iparallelpartial z + b^z p_iparallel fracpartial u_iparallelpartial z\n  + frac32 b^z n_i u_iparallel fracpartial T_ipartial z + frac32 b^z u_iparallel T_i fracpartial n_ipartial z + frac32 b^z n_i T_i fracpartial u_iparallelpartial z nonumber \nquad= - frac12 R_mathrmCX n_i n_n left(3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2 right)\n      + frac12 R_mathrmioniz n_e n_n left(3 T_n + m_i (u_iparallel - u_nparallel)^2 right) nonumber \nqquad+ frac32 S_ip \nendalign\n</details>\nbeginalign\n frac32 n_i fracpartial T_ipartial t\n  + frac32 n_i v_E^r fracpartial T_ipartialr\n  + frac32 n_i v_E^z fracpartial T_ipartialz\n  + b^z fracpartial q_iparallelpartial z + b^z p_iparallel fracpartial u_iparallelpartial z\n  + frac32 b^z n_i u_iparallel fracpartial T_ipartial z nonumber \nquad= - frac12 R_mathrmCX n_i n_n left(3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2 right)\n      + frac12 R_mathrmioniz n_e n_n left(3 T_n - 3 T_i + m_i (u_iparallel - u_nparallel)^2 right) nonumber \nqquad+ frac32 S_ip - frac32 T_i S_in \nendalign\n<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>\nbeginalign\nfracpartial T_ipartial t = frac12 m_i fracpartial v_Ti^2partial t nonumber \n= m_i v_Ti fracpartial v_Tipartial t \nfracpartial T_ipartial z = frac12 m_i fracpartial v_Ti^2partial z nonumber \n= m_i v_Ti fracpartial v_Tipartial z \nfracpartial T_ipartial r = frac12 m_i fracpartial v_Ti^2partial r nonumber \n= m_i v_Ti fracpartial v_Tipartial r \nendalign\nbeginalign\n frac32 m_i n_i v_Ti fracpartial v_Tipartial t\n  + frac32 m_i n_i v_Ti v_E^r fracpartial v_Tipartialr\n  + frac32 m_i n_i v_Ti v_E^z fracpartial v_Tipartialz\n  + b^z fracpartial q_iparallelpartial z + b^z p_iparallel fracpartial u_iparallelpartial z\n  + frac32 b^z m_i n_i u_iparallel v_Ti fracpartial v_Tipartial z nonumber \nquad= - frac12 R_mathrmCX n_i n_n left(3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2 right)\n      + frac12 R_mathrmioniz n_e n_n left(3 T_n - 3 T_i + m_i (u_iparallel - u_nparallel)^2 right) nonumber \nqquad+ frac32 S_ip - frac32 T_i S_in \nendalign\n</details>\nbeginalign\n frac32 m_i n_i v_Ti left( fracpartial v_Tipartial t + v_E^r fracpartial v_Tipartialr + v_E^z fracpartial v_Tipartialz + b^z u_iparallel fracpartial v_Tipartial z right) nonumber \nquad= - b^z fracpartial q_iparallelpartial z - b^z p_iparallel fracpartial u_iparallelpartial z\n     nonumber \nqquad- frac12 R_mathrmCX n_i n_n left(3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2 right)\n      + frac12 R_mathrmioniz n_e n_n left(3 T_n - 3 T_i + m_i (u_iparallel - u_nparallel)^2 right) nonumber \nqquad+ frac32 S_ip - frac32 T_i S_in \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Ion-kinetic-equation","page":"Moment kinetic equations","title":"Ion kinetic equation","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Before giving the full 'moment kinetic' equation, we consider two reduced versions which evolve separately only n_i, or only n_i and u_iparallel.","category":"page"},{"location":"moment_kinetic_equations/#Separate-n_i","page":"Moment kinetic equations","title":"Separate n_i","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Normalise n_i out of the distribution function. Velocity coordinates do not need to be modified.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nF_s(trzv_parallelv_perp) = fracf_s(trzv_parallelv_perp)n_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial n_i F_ipartial t + v_E^r fracpartial n_i F_ipartial r + (v_E^z + b^z v_parallel) fracpartial n_i F_ipartial z\n    - b^z fracem_i fracpartialphipartial z fracpartial n_i F_ipartial v_parallel nonumber \nquad= C_iin_i F_i n_i F_i - R_mathrmCX(n_n n_i F_i - n_i n_n F_n) + R_mathrmioniz n_e n_n F_n + S_i \n\n n_i fracpartial F_ipartial t + F_i fracpartial n_ipartial t\n    + n_i v_E^r fracpartial F_ipartial r + v_E^r F_i fracpartial n_ipartial r\n    + n_i (v_E^z + b^z v_parallel) fracpartial F_ipartial z + (v_E^z + b^z v_parallel) F_i fracpartial n_ipartial z\n    - n_i b^z fracem_i fracpartialphipartial z fracpartial F_ipartial v_parallel nonumber \nquad= C_iin_i F_i n_i F_i - R_mathrmCX n_i n_n (F_i - F_n) + R_mathrmioniz n_e n_n F_n + S_i \n\n n_i fracpartial F_ipartial t - F_i v_E^r fracpartial n_ipartial r - F_i v_E^z fracpartial n_ipartial z - F_i b^z n_i fracpartial u_iparallelpartial z - F_i b^z u_iparallel fracpartial n_ipartial z + F_i R_mathrmioniz n_e n_n + F_i S_in\n    + n_i v_E^r fracpartial F_ipartial r + v_E^r F_i fracpartial n_ipartial r\n    + n_i (v_E^z + b^z v_parallel) fracpartial F_ipartial z + (v_E^z + b^z v_parallel) F_i fracpartial n_ipartial z\n    - n_i b^z fracem_i fracpartialphipartial z fracpartial F_ipartial v_parallel nonumber \nquad= C_iin_i F_i n_i F_i - R_mathrmCX n_i n_n (F_i - F_n) + R_mathrmioniz n_e n_n F_n + S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial F_ipartial t\n  + v_E^r fracpartial F_ipartial r\n  + (v_E^z + b^z v_parallel) fracpartial F_ipartial z\n  - b^z fracem_i fracpartialphipartial z fracpartial F_ipartial v_parallel\n  + left( frac(b^z v_parallel - b^z u_iparallel)n_i fracpartial n_ipartial z - b^z fracpartial u_iparallelpartial z + R_mathrmioniz fracn_e n_nn_i + frac1n_i S_in right) F_i nonumber \nquad= frac1n_i C_iin_i F_i n_i F_i - R_mathrmCX n_n (F_i - F_n) + R_mathrmioniz fracn_e n_nn_i F_n + frac1n_i S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Separate-n_i-and-u_{i\\parallel}","page":"Moment kinetic equations","title":"Separate n_i and u_iparallel","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Normalise n_i out of the distribution function. Shift to peculiar velocity.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nF_s(trzhatw_parallelv_perp) = fracf_s(trzhatw_parallelv_perp)n_s \nhatw_parallel = v_parallel - u_sparallel\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nleft fracpartialpartial t right_rzv_parallelv_perp\n  = left fracpartial tpartial t right_rzv_parallelv_perp left fracpartialpartial t right_rzhatw_parallelv_perp\n    + left fracpartial rpartial t right_rzv_parallelv_perp left fracpartialpartial r right_tzhatw_parallelv_perp\n    + left fracpartial zpartial t right_rzv_parallelv_perp left fracpartialpartial z right_trhatw_parallelv_perp\n    + left fracpartial hatw_parallelpartial t right_rzv_parallelv_perp left fracpartialpartial hatw_parallel right_trzv_perp\n    + left fracpartial v_perppartial t right_rzv_parallelv_perp left fracpartialpartial v_perp right_trzhatw_parallel \n\n  = left fracpartialpartial t right_rzhatw_parallelv_perp\n    - left fracpartial u_sparallelpartial t right_rzv_parallelv_perp left fracpartialpartial hatw_parallel right_trzv_perp \n\n  equiv left fracpartialpartial t right_rzhatw_parallelv_perp\n    - fracpartial u_sparallelpartial t left fracpartialpartial hatw_parallel right_trzv_perp \n\nleft fracpartialpartial z right_trv_parallelv_perp\n  = left fracpartial tpartial z right_trv_parallelv_perp left fracpartialpartial z right_trhatw_parallelv_perp\n    + left fracpartial rpartial z right_trv_parallelv_perp left fracpartialpartial r right_tzhatw_parallelv_perp\n    + left fracpartial zpartial z right_trv_parallelv_perp left fracpartialpartial z right_trhatw_parallelv_perp\n    + left fracpartial hatw_parallelpartial z right_trv_parallelv_perp left fracpartialpartial hatw_parallel right_trzv_perp\n    + left fracpartial v_perppartial z right_trv_parallelv_perp left fracpartialpartial v_perp right_trzhatw_parallel \n\n  = left fracpartialpartial z right_trhatw_parallelv_perp\n    - left fracpartial u_sparallelpartial z right_trv_parallelv_perp left fracpartialpartial hatw_parallel right_trzv_perp \n\n  equiv left fracpartialpartial z right_trhatw_parallelv_perp\n    - fracpartial u_sparallelpartial z left fracpartialpartial hatw_parallel right_trzv_perp \n\nleft fracpartialpartial r right_tzv_parallelv_perp\n  = left fracpartialpartial r right_tzhatw_parallelv_perp\n    - fracpartial u_sparallelpartial r left fracpartialpartial hatw_parallel right_trzv_perp \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"partial  partial v_parallel _trzv_perp = partial  partial hatw_parallel _trzv_perp and partial  partial v_perp _trzv_parallel = partial  partial v_perp _trzhatw_parallel as u_sparallel does not depend on v_parallel or v_perp.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The normalisation by n_s to define F_s is the same as for the 'separate n_i' case, so we can start from the kinetic equation there and then transform the coordinates to rzhatw_parallelv_perpt","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n left fracpartial F_ipartial t right_rzv_parallelv_perp\n  + v_E^r left  fracpartial F_ipartial r right_tzv_parallelv_perp\n  + (v_E^z + b^z v_parallel) left  fracpartial F_ipartial z right_trv_parallelv_perp\n  - b^z fracem_i fracpartialphipartial z left fracpartial F_ipartial v_parallel right_trzv_perp\n  + left( frac(b^z v_parallel - b^z u_iparallel)n_i fracpartial n_ipartial z - b^z fracpartial u_iparallelpartial z + R_mathrmioniz fracn_e n_nn_i + frac1n_i S_in right) F_i nonumber \nquad= frac1n_i C_iin_i F_i n_i F_i - R_mathrmCX n_n (F_i - F_n) + R_mathrmioniz fracn_e n_nn_i F_n + frac1n_i S_i \n\n left fracpartial F_ipartial t right_rzhatw_parallelv_perp\n  - fracpartial u_iparallelpartial t left fracpartial F_ipartial hatw_parallel right_trzv_perp nonumber \n + v_E^r left fracpartial F_ipartial r right_tzhatw_parallelv_perp\n  - v_E^r fracpartial u_iparallelpartial r left  fracpartial F_ipartial hatw_parallel right_trzv_perp nonumber \n + (v_E^z + b^z hatw_parallel + b^z u_iparallel) left fracpartial F_ipartial z right_trhatw_parallelv_perp\n  - (v_E^z + b^z hatw_parallel + b^z u_iparallel) fracpartial u_iparallelpartial z left  fracpartial F_ipartial hatw_parallel right_trzv_perp nonumber \n - b^z fracem_i fracpartialphipartial z left fracpartial F_ipartial hatw_parallel right_trzv_perp nonumber \n + left( fracb^z hatw_paralleln_i fracpartial n_ipartial z - fracpartial u_iparallelpartial z + R_mathrmioniz fracn_e n_nn_i + frac1n_i S_in right) F_i nonumber \nquad= frac1n_i C_iin_i F_i n_i F_i - R_mathrmCX n_n (F_i - F_n) + R_mathrmioniz fracn_e n_nn_i F_n + frac1n_i S_i \n\n fracpartial F_ipartial t\n  + v_E^r left fracpartial F_ipartial r right_tzhatw_parallelv_perp\n  + (v_E^z + b^z hatw_parallel + b^z u_iparallel) fracpartial F_ipartial z\n  - left( fracpartial u_iparallelpartial t\n           + v_E^r fracpartial u_iparallelpartial r\n           + (v_E^z + b^z hatw_parallel + b^z u_iparallel) fracpartial u_iparallelpartial z \n           + b^z fracem_i fracpartialphipartial z right) fracpartial F_ipartial hatw_parallel nonumber \n  quad+ left( b^z frachatw_paralleln_i fracpartial n_ipartial z - fracpartial u_iparallelpartial z + R_mathrmioniz fracn_e n_nn_i + frac1n_i S_in right) F_i nonumber \nquad= frac1n_i C_iin_i F_i n_i F_i - R_mathrmCX n_n (F_i - F_n) + R_mathrmioniz fracn_e n_nn_i F_n + frac1n_i S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"subsitute from the parallel flow equation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial F_ipartial t\n  + v_E^r left fracpartial F_ipartial r right_tzhatw_parallelv_perp\n  + (v_E^z + b^z hatw_parallel + b^z u_iparallel) fracpartial F_ipartial z\n  - left( - cancelv_E^r fracpartial u_iparallelpartial r - cancelv_E^z fracpartial u_iparallelpartial z - cancelb^z u_iparallel fracpartial u_iparallelpartial z\n           - b^z frac1m_i n_i fracpartial p_iparallelpartial z\n           - cancelb^z fracem_i fracpartial phipartial z\n           + R_mathrmCX n_n (u_nparallel - u_iparallel)\n           + R_mathrmioniz fracn_e n_nn_i u_nparallel\n           + frac1m_i n_i S_imathrmmom\n           + cancelv_E^r fracpartial u_iparallelpartial r\n           + (cancelv_E^z + b^z hatw_parallel + cancelb^z u_iparallel) fracpartial u_iparallelpartial z\n           + cancelb^z fracem_i fracpartialphipartial z right) fracpartial F_ipartial hatw_parallel nonumber \n  quad+ left( b^z frachatw_paralleln_i fracpartial n_ipartial z - b^z fracpartial u_iparallelpartial z + R_mathrmioniz fracn_e n_nn_i + frac1n_i S_in right) F_i nonumber \nquad= frac1n_i C_iin_i F_i n_i F_i - R_mathrmCX n_n (F_i - F_n) + R_mathrmioniz fracn_e n_nn_i F_n + frac1n_i S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial F_ipartial t\n  + v_E^r fracpartial F_ipartial r\n  + (v_E^z + b^z hatw_parallel + b^z u_iparallel) fracpartial F_ipartial z nonumber \n  quad- left( b^z hatw_parallel fracpartial u_iparallelpartial z\n                 - b^z frac1m_i n_i fracpartial p_iparallelpartial z\n                 + R_mathrmCX n_n (u_nparallel - u_iparallel)\n                 + R_mathrmioniz fracn_e n_nn_i u_nparallel\n                 + frac1m_i n_i S_imathrmmom\n               right) fracpartial F_ipartial hatw_parallel nonumber \n  quad+ left( b^z frachatw_paralleln_i fracpartial n_ipartial z - b^z fracpartial u_iparallelpartial z + R_mathrmioniz fracn_e n_nn_i + frac1n_i S_in right) F_i nonumber \nquad= frac1n_i C_iin_i F_i n_i F_i - R_mathrmCX n_n (F_i - F_n) + R_mathrmioniz fracn_e n_nn_i F_n + frac1n_i S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/#ion_full_moment_kinetic_equation","page":"Moment kinetic equations","title":"Full moment-kinetics (separate n_i, u_iparallel and p_i)","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Form evolution equation for F_i(trzw_parallelw_perp), starting from kinetic equation for f_i(trzv_parallelv_perp)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nleft fracpartial f_ipartial t right_rzv_parallelv_perp\n    + dotr_i left fracpartial f_ipartial r right_tzv_parallelv_perp\n    + dotz_i left fracpartial f_ipartial z right_trv_parallelv_perp\n    + dotv_iparallel left fracpartial f_ipartial v_parallel right_trzv_perp\n    + dotv_iperp left fracpartial f_ipartial v_perp right_trzv_parallel nonumber \n    quad = C_iif_i f_i - R_mathrmCX(n_n f_i - n_i f_n) + R_mathrmioniz n_e f_n + S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"where","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ndotr_i = v_E^r \ndotz_i = v_E^z + b^z v_parallel \ndotv_iparallel = -b^z fracem_i fracpartialphipartial z \ndotv_iperp = 0 \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and using the definitions of the normalised distribution function and coordinates (repeated here for convenience)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nF_s(trzw_parallelw_perp) =\n  fracv_Ts^3n_s f_s(t r z u_sparallel(tz) + v_Ts(tz)w_parallel v_Ts(tz)w_perp) nonumber \n\nw_parallel(trzv_parallel) = fracv_parallel - u_sparallel(tz)v_Ts(tz) nonumber \n\nw_perp(trzv_perp) = fracv_perpv_Ts(tz) nonumber \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Substituting the definition of F_i gives","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nleft fracpartial f_ipartial t right_rzv_parallelv_perp\n  = left fracpartialpartial t right_rzv_parallelv_perp left(fracn_i F_iv_Ti^3right) nonumber \n  = left fracpartial n_ipartial t right_rzv_parallelv_perp fracF_iv_Ti^3\n     - 3 left fracpartial v_Tipartial t right_rzv_parallelv_perp fracn_i F_iv_Ti^4\n     + fracn_iv_Ti^3 left fracpartial F_ipartial t right_rzv_parallelv_perp \n\ndotr_i left fracpartial f_ipartial r right_tzv_parallelv_perp\n  = dotr_i left fracpartialpartial r right_tzv_parallelv_perp left(fracn_i F_iv_Ti^3right) nonumber \n  = dotr_i left fracpartial n_ipartial r right_tzv_parallelv_perp fracF_iv_Ti^3\n     - 3 dotr_i left fracpartial v_Tipartial r right_tzv_parallelv_perp fracn_i F_iv_Ti^4\n     + dotr_i fracn_iv_Ti^3 left fracpartial F_ipartial r right_tzv_parallelv_perp \n\ndotz_i left fracpartial f_ipartial z right_trv_parallelv_perp\n  = dotz_i left fracpartialpartial z right_trv_parallelv_perp left(fracn_i F_iv_Ti^3right) nonumber \n  = dotz_i left fracpartial n_ipartial z right_trv_parallelv_perp fracF_iv_Ti^3\n     - 3 dotz_i left fracpartial v_Tipartial z right_trv_parallelv_perp fracn_i F_iv_Ti^4\n     + dotz_i fracn_iv_Ti^3 left fracpartial F_ipartial z right_trv_parallelv_perp \n\ndotv_iparallel left fracpartial f_ipartial v_parallel right_trzv_perp\n  = dotv_iparallel left fracpartialpartial v_parallel right_trzv_perp left(fracn_i F_iv_Ti^3right) nonumber \n  = fracn_iv_Ti^3 dotv_iparallel left fracpartial F_ipartial v_parallel right_trzv_perp \n\ndotv_iperp left fracpartial f_ipartial v_perp right_trzv_parallel\n  = dotv_iperp left fracpartialpartial v_perp right_trzv_parallel left(fracn_i F_iv_Ti^3right) nonumber \n  = fracn_iv_Ti^3 dotv_iperp left fracpartial F_ipartial v_perp right_trzv_parallel \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"making the kinetic equation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracn_iv_Ti^3 left fracpartial F_ipartial t right_rzv_parallelv_perp\n    + dotr_i fracn_iv_Ti^3 left fracpartial F_ipartial r right_tzv_parallelv_perp\n    + dotz_i fracn_iv_Ti^3 left fracpartial F_ipartial z right_trv_parallelv_perp\n    + dotv_iparallel fracn_iv_Ti^3 left fracpartial F_ipartial v_parallel right_trzv_perp\n    + dotv_iperp fracn_iv_Ti^3 left fracpartial F_ipartial v_perp right_trzv_parallel nonumber \n    quad + left( frac1v_Ti^3 fracpartial n_ipartial t - frac3 n_iv_Ti^4 fracpartial v_Tipartial t + dotr_i left( frac1v_Ti^3 fracpartial n_ipartial r - frac3 n_iv_Ti^4 fracpartial v_Tipartial r right) + dotz_i left( frac1v_Ti^3 fracpartial n_ipartial z - frac3 n_iv_Ti^4 fracpartial v_Tipartial z right) right) F_i nonumber \n    quad= C_iifracn_i F_iv_Ti^3 fracn_i F_iv_Ti^3 - R_mathrmCX left( n_n fracn_i F_iv_Ti^3 - n_i fracn_n F_nv_Tn^3 right) + R_mathrmioniz n_e fracn_n F_nv_Tn^3 + S_i \n\nleft fracpartial F_ipartial t right_rzv_parallelv_perp\n    + dotr_i left fracpartial F_ipartial r right_tzv_parallelv_perp\n    + dotz_i left fracpartial F_ipartial z right_trv_parallelv_perp\n    + dotv_iparallel left fracpartial F_ipartial v_parallel right_trzv_perp\n    + dotv_iperp left fracpartial F_ipartial v_perp right_trzv_parallel nonumber \n    quad + left( frac1n_i fracpartial n_ipartial t - frac3v_Ti fracpartial v_Tipartial t + dotr_i left( frac1n_i fracpartial n_ipartial r - frac3v_Ti fracpartial v_Tipartial r right) + dotz_i left( frac1n_i fracpartial n_ipartial z - frac3v_Ti fracpartial v_Tipartial z right) right) F_i nonumber \n    quad= fracv_Ti^3n_i C_iifracn_i F_iv_Ti^3 fracn_i F_iv_Ti^3 - R_mathrmCX n_n left( F_i - fracv_Ti^3v_Tn^3 F_n right) + R_mathrmioniz fracn_e n_nn_i fracv_Ti^3v_Tn^3 F_n + fracv_Ti^3n_i S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The change of coordinates transforms the derivatives as","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nleft fracpartialpartial t right_rzv_parallelv_perp\n  = left fracpartial tpartial t right_rzv_parallelv_perp left fracpartialpartial t right_rzw_parallelw_perp\n    + left fracpartial rpartial t right_rzv_parallelv_perp left fracpartialpartial r right_tzw_parallelw_perp\n    + left fracpartial zpartial t right_rzv_parallelv_perp left fracpartialpartial z right_trw_parallelw_perp\n    + left fracpartial w_parallelpartial t right_rzv_parallelv_perp left fracpartialpartial w_parallel right_trzw_perp\n    + left fracpartial w_perppartial t right_rzv_parallelv_perp left fracpartialpartial w_perp right_trzw_parallel \n  = fracpartialpartial t\n    + left( -frac1v_Ti fracpartial u_iparallelpartial t - frac(v_parallel - u_iparallel)v_Ti^2 fracpartial v_Tipartial t right) fracpartialpartial w_parallel\n    - fracv_perpv_Ti^2 fracpartial v_Tipartial t fracpartialpartial w_perp \n  = fracpartialpartial t\n    + left( -frac1v_Ti fracpartial u_iparallelpartial t - fracw_parallelv_Ti fracpartial v_Tipartial t right) fracpartialpartial w_parallel\n    - fracw_perpv_Ti fracpartial v_Tipartial t fracpartialpartial w_perp \n\nleft fracpartialpartial r right_tzv_parallelv_perp\n  = left fracpartial tpartial r right_tzv_parallelv_perp left fracpartialpartial t right_rzw_parallelw_perp\n    + left fracpartial rpartial r right_tzv_parallelv_perp left fracpartialpartial r right_trw_parallelw_perp\n    + left fracpartial zpartial r right_tzv_parallelv_perp left fracpartialpartial z right_trw_parallelw_perp\n    + left fracpartial w_parallelpartial r right_tzv_parallelv_perp left fracpartialpartial w_parallel right_trzw_perp\n    + left fracpartial w_perppartial r right_tzv_parallelv_perp left fracpartialpartial w_perp right_trzw_parallel \n  = fracpartialpartial r\n    + left( -frac1v_Ti fracpartial u_iparallelpartial r - frac(v_parallel - u_iparallel)v_Ti^2 fracpartial v_Tipartial r right) fracpartialpartial w_parallel\n    - fracv_perpv_Ti^2 fracpartial v_Tipartial r fracpartialpartial w_perp \n  = fracpartialpartial r\n    + left( -frac1v_Ti fracpartial u_iparallelpartial r - fracw_parallelv_Ti fracpartial v_Tipartial r right) fracpartialpartial w_parallel\n    - fracw_perpv_Ti fracpartial v_Tipartial r fracpartialpartial w_perp \n\nleft fracpartialpartial z right_trv_parallelv_perp\n  = left fracpartial tpartial z right_trv_parallelv_perp left fracpartialpartial t right_rzw_parallelw_perp\n    + left fracpartial rpartial z right_trv_parallelv_perp left fracpartialpartial r right_tzw_parallelw_perp\n    + left fracpartial zpartial z right_trv_parallelv_perp left fracpartialpartial z right_trw_parallelw_perp\n    + left fracpartial w_parallelpartial z right_trv_parallelv_perp left fracpartialpartial w_parallel right_trzw_perp\n    + left fracpartial w_perppartial z right_trv_parallelv_perp left fracpartialpartial w_perp right_trzw_parallel \n  = fracpartialpartial z\n    + left( -frac1v_Ti fracpartial u_iparallelpartial z - frac(v_parallel - u_iparallel)v_Ti^2 fracpartial v_Tipartial z right) fracpartialpartial w_parallel\n    - fracv_perpv_Ti^2 fracpartial v_Tipartial z fracpartialpartial w_perp \n  = fracpartialpartial z\n    + left( -frac1v_Ti fracpartial u_iparallelpartial z - fracw_parallelv_Ti fracpartial v_Tipartial z right) fracpartialpartial w_parallel\n    - fracw_perpv_Ti fracpartial v_Tipartial z fracpartialpartial w_perp \n\nleft fracpartialpartial v_parallel right_trzv_perp\n  = left fracpartial tpartial v_parallel right_trzv_perp left fracpartialpartial t right_rzw_parallelw_perp\n    + left fracpartial rpartial v_parallel right_trzv_perp left fracpartialpartial r right_tzw_parallelw_perp\n    + left fracpartial zpartial v_parallel right_trzv_perp left fracpartialpartial z right_trw_parallelw_perp\n    + left fracpartial w_parallelpartial v_parallel right_trzv_perp left fracpartialpartial w_parallel right_trzw_perp\n    + left fracpartial w_perppartial v_parallel right_trzv_perp left fracpartialpartial w_perp right_trzw_parallel \n  = frac1v_Ti fracpartialpartial w_parallel \n\nleft fracpartialpartial v_perp right_trzv_parallel\n  = left fracpartial tpartial v_perp right_trzv_parallel left fracpartialpartial t right_rzw_parallelw_perp\n    + left fracpartial rpartial v_perp right_trzv_parallel left fracpartialpartial r right_tzw_parallelw_perp\n    + left fracpartial zpartial v_perp right_trzv_parallel left fracpartialpartial z right_trw_parallelw_perp\n    + left fracpartial w_parallelpartial v_perp right_trzv_parallel left fracpartialpartial w_parallel right_trzw_perp\n    + left fracpartial w_perppartial v_perp right_trzv_parallel left fracpartialpartial w_perp right_trzw_parallel \n  = frac1v_Ti fracpartialpartial w_perp \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and so the kinetic equation becomes","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial F_ipartial t \n           + left( -frac1v_Ti fracpartial u_iparallelpartial t - fracw_parallelv_Ti fracpartial v_Tipartial t right) fracpartial F_ipartial w_parallel\n           - fracw_perpv_Ti fracpartial v_Tipartial t fracpartial F_ipartial w_perp nonumber \n    quad + dotr_i fracpartial F_ipartial r\n           + dotr_i left( -frac1v_Ti fracpartial u_iparallelpartial r - fracw_parallelv_Ti fracpartial v_Tipartial r right) fracpartial F_ipartial w_parallel\n           - dotr_i fracw_perpv_Ti fracpartial v_Tipartial r fracpartial F_ipartial w_perp nonumber \n    quad + dotz_i fracpartial F_ipartial z\n           + dotz_i left( -frac1v_Ti fracpartial u_iparallelpartial z - fracw_parallelv_Ti fracpartial v_Tipartial z right) fracpartial F_ipartial w_parallel\n           - dotz_i fracw_perpv_Ti fracpartial v_Tipartial z fracpartial F_ipartial w_perp nonumber \n    quad + fracdotv_iparallelv_Ti fracpartial F_ipartial w_parallel nonumber \n    quad + fracdotv_iperpv_Ti fracpartial F_ipartial w_perp nonumber \n    quad + left( frac1n_i fracpartial n_ipartial t - frac3v_Ti fracpartial v_Tipartial t + dotr_i left( frac1n_i fracpartial n_ipartial r - frac3v_Ti fracpartial v_Tipartial r right) + dotz_i left( frac1n_i fracpartial n_ipartial z - frac3v_Ti fracpartial v_Tipartial z right) right) F_i nonumber \n    quad= fracv_Ti^3n_i C_iifracn_i F_iv_Ti^3 fracn_i F_iv_Ti^3 - R_mathrmCX n_n left( F_i - fracv_Ti^3v_Tn^3 F_n right) + R_mathrmioniz fracn_e n_nn_i fracv_Ti^3v_Tn^3 F_n + fracv_Ti^3n_i S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial F_ipartial t + dotr_i fracpartial F_ipartial r + dotz_i fracpartial F_ipartial z nonumber \n    quad + left( fracdotv_iparallelv_Ti - frac1v_Ti left( fracpartial u_iparallelpartial t + dotr_i fracpartial u_iparallelpartial r + dotz_i fracpartial u_iparallelpartial z right) right nonumber \n    qquadquad  left - fracw_parallelv_Ti left( fracpartial v_Tipartial t + dotr_i fracpartial v_Tipartial r + dotz_i fracpartial v_Tipartial z right) right) fracpartial F_ipartial w_parallel nonumber \n    quad + left( fracdotv_iperpv_Ti - fracw_perpv_Ti left( fracpartial v_Tipartial t + dotr_i fracpartial v_Tipartial r + dotz_i fracpartial v_Tipartial z right) right) fracpartial F_ipartial w_perp nonumber \n    quad + left( frac1n_i left( fracpartial n_ipartial t + dotr_i fracpartial n_ipartial r + dotz_i fracpartial n_ipartial z right) - frac3v_Ti left( fracpartial v_Tipartial t + dotr_i fracpartial v_Tipartial r + dotz_i fracpartial v_Tipartial z right) right) F_i nonumber \n    quad= fracv_Ti^3n_i C_iifracn_i F_iv_Ti^3 fracn_i F_iv_Ti^3 - R_mathrmCX n_n left( F_i - fracv_Ti^3v_Tn^3 F_n right) + R_mathrmioniz fracn_e n_nn_i fracv_Ti^3v_Tn^3 F_n + fracv_Ti^3n_i S_i \n\nfracpartial F_ipartial t + dotr fracpartial F_ipartial r + dotz fracpartial F_ipartial z + dotw_parallel fracpartial F_ipartial w_parallel + dotw_perp fracpartial F_ipartial w_perp\n    = dotF_i + mathcalC_i + fracv_Ti^3n_i S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"where","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ndotr = v_E^r \n\ndotz = v_E^z + b^z v_parallel = v_E^z + b^z v_Ti w_parallel + b^z u_iparallel \n\ndotw_parallel = fracdotv_iparallelv_Ti - frac1v_Ti left( fracpartial u_iparallelpartial t + dotr fracpartial u_iparallelpartial r + dotz fracpartial u_iparallelpartial z right)\n    - fracw_parallelv_Ti left( fracpartial v_Tipartial t + dotr fracpartial v_Tipartial r + dotz fracpartial v_Tipartial z right) \n\ndotw_perp = fracdotv_iperpv_Ti - fracw_perpv_Ti left( fracpartial v_Tipartial t + dotr fracpartial v_Tipartial r + dotz fracpartial v_Tipartial z right) \n\nfracdotF_iF_i = frac3v_Ti left( fracpartial v_Tipartial t + dotr fracpartial v_Tipartial r + dotz fracpartial v_Tipartial z right) - frac1n_i left( fracpartial n_ipartial t + dotr fracpartial n_ipartial r + dotz fracpartial n_ipartial z right) \n\nmathcalC_i = fracv_Ti^3n_i C_iifracn_i F_iv_Ti^3 fracn_i F_iv_Ti^3 - R_mathrmCX n_n left( F_i - fracv_Ti^3v_Tn^3 F_n right) + R_mathrmioniz fracn_e n_nn_i fracv_Ti^3v_Tn^3 F_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"We could substitute in the moment equations to eliminate the time-derivative-of-moment terms","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracdotv_iparallelv_Ti - frac1v_Ti left( fracpartial u_iparallelpartial t + dotr_i fracpartial u_iparallelpartial r + dotz fracpartial u_iparallelpartial z right) nonumber \nquad= - cancelb^z fracem_i v_Ti fracpartial phipartial z nonumber \nqquad - frac1v_Ti left( - cancelv_E^r fracpartial u_iparallelpartial r - cancelv_E^z fracpartial u_iparallelpartial z - cancelb^z u_iparallel fracpartial u_iparallelpartial z - b^z frac1m_i n_i fracpartial p_iparallelpartial z - cancelb^z fracem_i fracpartial phipartial z + R_mathrmCX n_n left(u_nparallel - u_iparallelright) + R_mathrmioniz fracn_e n_nn_i left(u_nparallel - u_iparallelright) + fracS_imathrmmomm_i n_i - fracu_iparallel S_inn_i right) nonumber \nqquad - cancelfrac1v_Ti v_E^r fracpartial u_iparallelpartial r nonumber \nqquad - frac1v_Ti left( cancelv_E^z + b^z v_Ti w_parallel + cancelb^z u_iparallel right) fracpartial u_iparallelpartial z nonumber \nquad= - b^z w_parallel fracpartial u_iparallelpartial z + b^z frac1v_Ti fracpartial p_iparallelpartial z - frac1v_Ti R_mathrmCX n_n left(u_nparallel - u_iparallelright) - frac1v_Ti R_mathrmioniz fracn_e n_nn_i left(u_nparallel - u_iparallelright) - fracS_imathrmmomm_i n_iv_Ti + fracu_iparallel S_inn_i v_Ti \n\nfrac1v_Ti left( fracpartial v_Tipartial t + dotrfracpartial v_Tipartial r + dotzfracpartial v_Tipartial z right) nonumber \nquad= frac1v_Ti left( - cancelv_E^r fracpartial v_Tipartial r - cancelv_E^z fracpartial v_Tipartial z - cancelb^z u_iparallel fracpartial v_Tipartial z - frac2 b^z3 m_i n_i v_Ti fracpartial q_iparallelpartial z - frac2 b^z3 m_i n_i v_Ti p_iparallel fracpartial u_iparallelpartial z - frac13 m_i v_Ti R_mathrmCX n_n left(3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2right) + frac13 m_i n_i v_Ti R_mathrmioniz n_e n_n left(3 T_n - 3 T_i + m_i (u_iparallel - u_nparallel)^2right) + fracS_ipm_i n_i v_Ti - fracT_i S_inm_i n_i v_Ti right) nonumber \nqquad + cancelfrac1v_Ti v_E^r fracpartial v_Tipartial r nonumber \nqquad + frac1v_Ti left( cancelv_E^z + b^z v_Ti w_parallel + cancelb^z u_iparallel right) fracpartial v_Tipartial z nonumber \nquad= b^z w_parallel fracpartial v_Tipartial z - fracb^z3 p_i fracpartial q_iparallelpartial z - fracb^z3 p_i p_iparallel fracpartial u_iparallelpartial z - frac16 T_i R_mathrmCX n_n left(3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2right) + frac16 p_i R_mathrmioniz n_e n_n left(3 T_n - 3 T_i + m_i (u_iparallel - u_nparallel)^2right) + fracS_ip2 p_i - fracS_in2 n_i nonumber \n\nfrac1n_i left( fracpartial n_ipartial t + dotrfracpartial n_ipartial r + dotz fracpartial n_ipartial z right) nonumber \nquad= frac1n_i left( - cancelv_E^r fracpartial n_ipartial r - cancelv_E^z fracpartial n_ipartial z - b^z n_i fracpartial u_iparallelpartial z - cancelb^z u_iparallel fracpartial n_ipartial z + R_mathrmioniz n_e n_n + S_in\n                               + cancelv_E^r fracpartial n_ipartial r\n                               + left( cancelv_E^z + b^z v_Ti w_parallel + cancelb^z u_iparallel right) fracpartial n_ipartial z\n                        right) nonumber \nquad= b^z fracv_Ti w_paralleln_i fracpartial npartial z - b^z fracpartial u_iparallelpartial z + R_mathrmioniz fracn_e n_nn_i + fracS_inn_i \n\ndotw_parallel = - b^z w_parallel fracpartial u_iparallelpartial z + b^z frac1v_Ti fracpartial p_iparallelpartial z - frac1v_Ti R_mathrmCX n_n left(u_nparallel - u_iparallelright) - frac1v_Ti R_mathrmioniz fracn_e n_nn_i left(u_nparallel - u_iparallelright) - fracS_imathrmmomm_i n_iv_Ti + fracu_iparallel S_inn_i v_Ti nonumber \nquad - b^z w_parallel^2 fracpartial v_Tipartial z + fracb^z w_parallel3 p_i fracpartial q_iparallelpartial z + fracb^z w_parallel3 p_i p_iparallel fracpartial u_iparallelpartial z + fracw_parallel6 T_i R_mathrmCX n_n left(3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2right) - fracw_parallel6 p_i R_mathrmioniz n_e n_n left(3 T_n - 3 T_i + m_i (u_iparallel - u_nparallel)^2right) - fracw_parallel S_ip2 p_i + fracw_parallel S_in2 n_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ndotw_parallel = b^z frac1m_i n_i v_Ti fracpartial p_iparallelpartial z - frac1v_Ti R_mathrmCX n_n left(u_nparallel - u_iparallelright) - frac1v_Ti R_mathrmioniz fracn_e n_nn_i left(u_nparallel - u_iparallelright) - fracS_imathrmmomm_i n_iv_Ti + fracu_iparallel S_inn_i v_Ti nonumber \nquad + w_parallel left( - b^z fracpartial u_iparallelpartial z + fracb^z3 p_i fracpartial q_iparallelpartial z + fracb^z3 p_i p_iparallel fracpartial u_iparallelpartial z right nonumber \nqquadqquad + frac16 T_i R_mathrmCX n_n left(3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2right) nonumber \nqquadqquad left - frac16 p_i R_mathrmioniz n_e n_n left(3 T_n - 3 T_i + m_i (u_iparallel - u_nparallel)^2right) - fracS_ip2 p_i + fracS_in2 n_i right) nonumber \nquad - b^z w_parallel^2 fracpartial v_Tipartial z \n\ndotw_perp = w_perp left( - b^z w_parallel fracpartial v_Tipartial z + fracb^z3 p_i fracpartial q_iparallelpartial z + fracb^z3 p_i p_iparallel fracpartial u_iparallelpartial z right  nonumber \nqquadqquad + frac16 T_i R_mathrmCX n_n left(3 T_i + 3 T_n - m_i (u_iparallel - u_nparallel)^2right) nonumber \nqquadqquad left  - frac16 p_i R_mathrmioniz n_e n_n left(3 T_n - 3 T_i + m_i (u_iparallel - u_nparallel)^2right) - fracS_ip2 p_i + fracS_in2 n_i right) nonumber \n\nfracdotF_iF_i = 3 b^z w_parallel fracpartial v_Tipartial z - fracb^zp_i fracpartial q_iparallelpartial z - fracb^zp_i p_iparallel fracpartial u_iparallelpartial z nonumber \nquad - frac12 T_i R_mathrmCX n_n left(3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2right) nonumber \nquad + frac12 p_i R_mathrmioniz n_e n_n left(3 T_n - 3 T_i + m_i (u_iparallel - u_nparallel)^2right) + frac3 S_ip2 p_i - frac3 S_in2 n_i nonumber \nquad - b^z fracv_Ti w_paralleln_i fracpartial npartial z + b^z fracpartial u_iparallelpartial z - R_mathrmioniz fracn_e n_nn_i - fracS_inn_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"However, the expressions for dotw_parallel, dotw_perp, and dot F_i become much longer. In the code, we have to calculate partial n_ipartial t, etc. anyway to evolve the moment equations, so it will be simpler to save these values, and implement the kinetic equation coefficients in terms of partial n_ipartial t, etc. Especially if/when new terms (e.g.  inter-species friction) are added to the model, this approach will minimise the number of places in the code that need to be updated.","category":"page"},{"location":"moment_kinetic_equations/#Neutral-equations","page":"Moment kinetic equations","title":"Neutral equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Neutrals do not see phi in their kinetic equation, and signs of ion-neutral reaction terms are flipped","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial f_npartial t + v_parallel fracpartial f_npartial z\n    = mathcalC_nif_nf_i + S_n \n mathcalC_nif_nf_i = -mathcalC_inf_if_n\n    = R_mathrmCX (n_n f_i - n_i f_n) - R_mathrmioniz n_e f_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The moment equations are therefore very similar to those of the ions","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial n_npartial t + fracpartialpartial zleft( n_n u_nparallel right)\n    = - R_mathrmioniz n_e n_n + S_nn \n\n m_n fracpartialpartial t(n_n u_nparallel)\n  + m_n fracpartialpartial z(n_n u_nparallel^2)\n  + fracpartial p_nparallelpartial z nonumber \nquad= -R_mathrmCX m_n n_i n_n (u_nparallel - u_iparallel)\n    - R_mathrmioniz m_n n_e n_n u_nparallel\n    + S_nmathrmmom \n\n frac32 fracpartialpartial t left( frac3 p_nm_n + n_n u_nparallel^2 right)\n  + frac32 fracpartialpartial z left frac2 q_nparallelm_n + 2fracp_nparallelm_n u_nparallel + frac3 p_nm_n u_nparallel + n_n u_nparallel^3 right nonumber \nquad= frac32 R_mathrmCX fracn_i n_nm_i left(3 T_i + m_i u_iparallel^2 - 3 T_n - m_i u_nparallel^2 right)\n      - frac32 R_mathrmioniz fracn_e n_nm_i left(3 T_n + m_i u_nparallel^2 right) nonumber \nqquad+ frac3m_i S_nE \n\n frac32 fracpartial p_npartial t\n  + fracpartial q_nparallelpartial z + p_nparallel fracpartial u_nparallelpartial z\n  + frac32 u_nparallel fracpartial p_npartial z + frac32 p_n fracpartial u_nparallelpartial z nonumber \nquad= frac12 R_mathrmCX n_i n_n left(3 T_i - 3 T_n + m_i (u_iparallel - u_nparallel)^2 right)\n      - frac32 R_mathrmioniz n_e n_n T_n nonumber \nqquad+ frac32 S_np \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The alternative forms of equation for partial u_nparallelpartial t and partial v_Tn  partial t may also be useful","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nm_n n_n fracpartial u_nparallelpartial t\n + m_n n_n u_nparallel fracpartial u_nparallelpartial z nonumber \n= - fracpartial p_nparallelpartial z\n   - R_mathrmCX m_n n_i n_n (u_nparallel - u_iparallel)\n   + S_nmathrmmom - m_n u_nparallel S_nn \n\n frac32 m_n n_n v_Tn left( fracpartial v_Tnpartial t + u_nparallel fracpartial v_Tnpartial z right) nonumber \nquad= - fracpartial q_nparallelpartial z - p_nparallel fracpartial u_nparallelpartial z\n     nonumber \nqquad+ frac12 R_mathrmCX n_i n_n left(3 T_i - 3 T_n + m_i (u_iparallel - u_nparallel)^2 right) nonumber \nqquad+ frac32 S_np - frac32 T_n S_nn \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The 3 variants on the moment-kinetic equation, given in the following subsections, are also very similar to the ion ones.","category":"page"},{"location":"moment_kinetic_equations/#Separate-n_n","page":"Moment kinetic equations","title":"Separate n_n","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial F_npartial t + v_parallel fracpartial F_npartial z\n  + left( frac(v_parallel - u_nparallel)n_n fracpartial n_npartial z - fracpartial u_nparallelpartial z + frac1n_n S_nn right) F_n nonumber \nquad= R_mathrmCX n_i (F_i - F_n) + frac1n_n S_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Separate-n_n-and-u_{n\\parallel}","page":"Moment kinetic equations","title":"Separate n_n and u_nparallel","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial F_npartial t\n  + (hatw_parallel + u_nparallel) fracpartial F_npartial z nonumber \n  quad- left( hatw_parallel fracpartial u_nparallelpartial z\n                 - frac1m_n n_n fracpartial p_nparallelpartial z\n                 - R_mathrmCX n_i (u_nparallel - u_iparallel)\n                 + frac1m_n n_n S_nmathrmmom\n               right) fracpartial F_npartial hatw_parallel nonumber \n  quad+ left( frachatw_paralleln_n fracpartial n_npartial z - fracpartial u_nparallelpartial z + frac1n_n S_nn right) F_n nonumber \nquad= R_mathrmCX n_i (F_i - F_n) + frac1n_n S_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Full-moment-kinetics-(separate-n_n,-u_{n\\parallel}-and-p_{n})","page":"Moment kinetic equations","title":"Full moment-kinetics (separate n_n, u_nparallel and p_n)","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial F_npartial t + dotz fracpartial F_npartial z + dotw_parallel fracpartial F_npartial w_parallel + dotw_perp fracpartial F_npartial w_perp\n    = dotF_n + mathcalC_n + fracv_Tn^3n_n S_n \n\ndotz = v_Tn w_parallel + u_nparallel \n\ndotw_parallel = - left( frac1v_Tn fracpartial u_nparallelpartial t + left( w_parallel + fracu_n_parallelv_Tn right) fracpartial u_nparallelpartial z right nonumber \n    qquadquad  left + fracw_parallelv_Tn fracpartial v_Tnpartial t + w_parallel left( w_parallel + fracu_nparallelv_Tn right) fracpartial v_Tnpartial z right) \n\ndotw_perp = -left( fracw_perpv_Tn fracpartial v_Tnpartial t + left( w_parallel + fracu_nparallelv_Tn right) w_perp fracpartial v_Tnpartial z right) \n\nfracdotF_nF_n = frac3v_Tn fracpartial v_Tnpartial t + frac3 (v_Tn w_parallel + u_nparallel)v_Tn fracpartial v_Tnpartial z\n                   - frac1n_n fracpartial n_npartial t - frac(v_Tn w_parallel + u_nparallel)n_n fracpartial n_npartial z \n\nmathcalC_n = R_mathrmCX n_i left( fracv_Tn^3v_Ti^3 F_i - F_n right) - R_mathrmioniz n_e F_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Again, we could substitute in the moment equations","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ndotw_parallel = w_parallel fracpartial u_nparallelpartial z\n                     + frac1m_n n_n v_Tn fracpartial p_nparallelpartial z\n                     + R_mathrmCX fracn_iv_Tn (u_nparallel - u_iparallel)\n                     - frac1m_n n_n v_Tn (S_nmathrmmom - u_nparallel S_nn) nonumber \n        qquadquad - w_parallel^2 fracpartial v_Tnpartial z\n                     + fracw_parallel3 p_n fracpartial q_nparallelpartial z\n                     + fracw_parallel p_nparallel3 p_n fracpartial u_nparallelpartial z\n                     - fracw_parallel6 p_n R_mathrmCX n_i n_n left( 3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2 right)\n                     - fracw_parallel2 p_n S_np + fracw_parallel2 p_n T_n S_nn \ndotw_perp = -w_parallel w_perp fracpartial v_Tnpartial z\n                 + fracw_perp3 p_n fracpartial q_nparallelpartial z\n                 + fracw_perp p_nparallel3 p_n fracpartial u_nparallelpartial z\n                 - fracw_perp6 p_n R_mathrmCX n_i n_n left( 3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2 right)\n                 - fracw_perp2 p_n S_np + fracw_perp2 p_n T_n S_nn \nfracdotF_nF_n = 3 w_parallel fracpartial v_Tnpartial z\n                         - frac1p_n fracpartial q_nparallelpartial z\n                         - fracp_nparallelp_n fracpartial u_nparallelpartial z\n                         + frac12 p_n R_mathrmCX n_i n_n left( 3 T_i - 3 T_n - m_i (u_iparallel - u_nparallel)^2 right)\n                         + frac32 p_n S_np - frac52 n_n S_nn nonumber \n            qquadquad - fracv_Tn w_paralleln_n fracpartial n_npartial z\n                         + fracpartial u_nparallelpartial z - R_mathrmioniz n_e nonumber \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"noting that ionization does not appear in the equations for partial u_nparallel  partial t or partial v_Tn  partial t so that the only contributions are from partial n_n  partial t that contributes to dotF and the explicit term in mathcal C_n, and these will cancel.","category":"page"},{"location":"moment_kinetic_equations/#Wall-boundary-condition-(Knudsen-cosine-distribution)","page":"Moment kinetic equations","title":"Wall boundary condition (Knudsen cosine distribution)","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Neutrals returning from the wall belong to a Knudsen cosine distribution, defined with a wall temperature T_mathrmwall, which is given by [Excalibur report TN-05]","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nf_n(0v_parallel0v_perpt) = Gamma_0 f_mathrmKw(v_parallelv_perp) \nf_n(Lv_parallel0v_perpt) = Gamma_L f_mathrmKw(v_parallelv_perp) \nGamma_0 = sum_s=in 2 pi int_-infty^0 dv_parallel int_0^infty dv_perp v_perp v_parallel f_s(0v_parallelv_perpt) \nGamma_L = sum_s=in 2 pi int_0^infty dv_parallel int_0^infty dv_perp v_perp v_parallel f_s(Lv_parallelv_perpt) \nf_mathrmKw(v_parallelv_perp) = frac34pi left( fracm_nT_w right)^2 fracv_parallelsqrtv_parallel^2 + v_perp^2 expleft( -fracm_n(v_parallel^2 + v_perp^2)2T_w right) \nendalign","category":"page"},{"location":"moment_kinetic_equations/#ion_reduction_to_2d1v","page":"Moment kinetic equations","title":"Reduction to 2D1V","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"To reduce the model to 2D1V, we take the limit T_sperp rightarrow 0, and marginalise over v_perp to remove one velocity space dimension.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"One way to do this formally is to assume that","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nf_s = barf_s(tzv_parallel) f_sperp(v_perp) \ntextwith  f_sperp(v_perp) = fracexp(-v_perp^2v_Tsperp^2)pi v_Tsperp^2 \ntextwhere  frac12 m_s v_Tsperp^2 = T_perp \ntextand similarly  S_s = barS_s(tzv_parallel) f_sperp(v_perp)\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"f_sperp is defined so that","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nint f_sperp d^2 v_perp = 2pi int_0^infty f_sperp v_perp dv_perp nonumber \n  = 2pi int_0^infty fracexp(-v_perp^2v_Tsperp^2)pi v_Tsperp^2 v_perp dv_perp nonumber \n  = 2 int_0^infty exp(-x^2) x dx nonumber \n  = 2 left -frac12 exp(-x^2) right_0^infty nonumber \n  = 1 \nint v_perp f_sperp d^2 v_perp = 2pi int_0^infty v_perp f_sperp v_perp dv_perp nonumber \n  = lim_v_Tsperprightarrow 0 2pi int_0^infty v_perp^2 fracexp(-v_perp^2v_Tsperp^2)pi v_Tsperp^2 dv_perp nonumber \n  = lim_v_Tsperprightarrow 0 2 v_Tsperp int_0^infty x^2 exp(-x^2) dx nonumber \n  = lim_v_Tsperprightarrow 0 2 v_Tsperp left( left -frac12 x exp(-x^2) right_0^infty + frac12 int_0^infty exp(-x^2) right) nonumber \n  = lim_v_Tsperprightarrow 0 2 v_Tsperp left( 0 + frac12 fracsqrtpi2 right) nonumber \n  = 0\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and so","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nint f_s(tzv_parallelv_perp) d^2 v_perp = barf_s(tzv_parallel) \nint S_s(tzv_parallelv_perp) d^2 v_perp = barS_s(tzv_parallel) \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Integrals with any higher powers of v_perp also vanish.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The source integrals are the same, but can be written in terms of bar S_s, S_sn = int bar S_s dv_parallel, S_smathrmmom = int m_s v_parallel bar S_s dv_parallel, S_sE = int frac12 m_s v_parallel^2 bar S_s dv_parallel, and S_sp = frac23 S_iE - frac23 u_iparallel S_imathrmmom + frac13 m_s u_sparallel^2 S_sn.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The marginalised shape function must be marginalised over w_perp, not v_perp because F_s is dimensionless, and bar F_s should be dimensionless too.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nbarF_s(tzw_parallel) = int F_s(tzw_parallelw_perp) d^2 w_perp nonumber \n  = int F_s(tzw_parallelw_perp) frac1v_Ts^2 d^2 v_perp nonumber \n  = int fracv_Ts^3n_s f_s(tzv_parallelv_perp) frac1v_Ts^2 d^2 v_perp nonumber \n  = fracv_Tsn_s int f_s(tzv_parallelv_perp) d^2 v_perp nonumber \n  = fracv_Tsn_s barf_s(tzv_parallel) \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and like the integrals above, int w_perp F_s(tzw_parallelw_perp) d^2 w_perp = 0.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Setting T_perp = 0 in the expressions in section Moment kinetic equations,","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\np_s = frac13(p_sparallel + 2p_sperp) = fracp_sparallel3 \nT_s = frac13(T_sparallel + 2T_sperp) = fracT_sparallel3 \nv_Ts = sqrtfrac2(T_sparallel + 2 T_sperp)3 m_s = sqrtfrac2T_sparallel3 m_s \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The parallel heat flux reduces to","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nq_sparallel = int fracm_s2 left( (v_parallel - u_sparallel)^2 + v_perp^2 right) (v_parallel - u_sparallel) f_s d^3 v nonumber \n    = int fracm_s2 left( (v_parallel - u_sparallel)^2 right) (v_parallel - u_sparallel) left(int f_s d^2 v_perp right) dv_parallel nonumber \n    quad + cancelint fracm_s2 (v_parallel - u_sparallel) left(int v_perp^2 f_s d^2 v_perp right) d^3 v nonumber \n    = int fracm_s2 (v_parallel - u_sparallel)^3 barf_s dv_parallel nonumber \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"or in terms of bar F_s","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nq_sparallel = n_s v_Ts^3 int fracm_s2 left( w_parallel^2 + cancelw_perp^2 right) w_parallel F_s d^3 w nonumber \nq_sparallel = n_s v_Ts^3 int fracm_s2 w_parallel^3 left(int F_s d^2 w_perp right) dw_parallel \nq_sparallel = n_s v_Ts^3 int fracm_s2 w_parallel^3 barF_s dw_parallel \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The moment constraints reduce to","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n1 = int dw_parallel int d^2 w_perp F_s(tzw_parallelw_perp) = int dw_parallel barF_s(tzw_parallel) \n0 = int dw_parallel int d^2 w_perp w_parallel F_s(tzw_parallelw_perp) = int dw_parallel w_parallel barF_s(tzw_parallel) \nfrac32 = int dw_parallel int d^2 w_perp (w_parallel^2 + cancelw_perp^2) F_s(tzw_parallelw_perp) = int dw_parallel w_parallel^2 barF_s(tzw_parallelw_perp) \nendalign","category":"page"},{"location":"moment_kinetic_equations/#2D1V-ion-moment-equations","page":"Moment kinetic equations","title":"2D1V ion moment equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The moment equations are identical to the 2D2V case, although in 2D1V p_iperp = 0 so that p_i = p_iparallel3.","category":"page"},{"location":"moment_kinetic_equations/#2D1V-ion-kinetic-equation","page":"Moment kinetic equations","title":"2D1V ion kinetic equation","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"When we marginalise the ion kinetic equation to reduce it to 1D1V form, we note that dot w_perp propto w_perp, so the term","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ndotw_perp fracpartial F_ipartial w_perp = - fracw_perpv_Ti left( fracpartial v_Tipartial t + dotr fracpartial v_Tipartial r + dotz fracpartial v_Tipartial z right) fracpartial F_ipartial w_perp\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and marginalising","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nint w_perp fracpartial F_ipartial w_perp d^2 w_perp\n    = 2 pi int_0^infty w_perp fracpartial F_ipartial w_perp w_perp dw_perp nonumber \n    = 2 pi int_0^infty w_perp^2 fracpartial F_ipartial w_perp dw_perp nonumber \n    = 2 pi left(\n                   left w_perp^2 F_i right_0^infty\n                   - int_0^infty 2 w_perp F_i dw_perp\n             right) nonumber \n    = -2 pi int_0^infty 2 w_perp F_i dw_perp nonumber \n    = -2 pi int_0^infty 2 w_perp fracv_Ti^3n_i f_i dw_perp nonumber \n    = -2 pi fracv_Ti^3n_i frac1v_Ti^2 int_0^infty 2 v_perp f_i dv_perp nonumber \n    = -2 pi fracv_Tin_i barf_i int_0^infty 2 v_perp f_iperp dv_perp nonumber \n    = -2 pi fracv_Tin_i barf_i lim_v_Tiperp rightarrow 0 int_0^infty 2 v_perp fracexp(-v_perp^2v_Tiperp^2)pi v_Tiperp^2 dv_perp nonumber \n    = -2 pi fracv_Tin_i barf_i lim_v_Tiperp rightarrow 0 int_0^infty 2 x fracexp(-x^2)pi dx nonumber \n    = -4 fracv_Tin_i barf_i lim_v_Tiperp rightarrow 0 left -frac12 exp(-x^2) right_0^infty nonumber \n    = -2 fracv_Tin_i barf_i nonumber \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nint w_perp fracpartial F_ipartial w_perp d^2 w_perp\n    = -2 barF_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"This term cancels with the contribution to dot F_i that was associated with having three powers of v_Ti in F_s(tzw_parallelw_perp) = fracv_Ti^3n_i f_s(tzv_parallelv_perp) rather than the one power of v_Ti in barF_s(tzw_parallelw_perp) = fracv_Tin_i barf_s(tzv_parallelv_perp). Finally","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial barF_ipartial t + dotz fracpartial barF_ipartial z + dotw_parallel fracpartial barF_ipartial w_parallel + dotw_perp fracpartial barF_ipartial w_perp\n    = dotbarF_i + barmathcalC_i + fracv_Tin_i barS_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"(noting that int S_i d^2 w_perp = v_Ti^-2 int S_i d^2 v_perp = v_Ti^-2 bar S_i), where (for now?) we assume there is no B-variation for the 2D1V case, so dot v_perp = 0, giving","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ndotr = v_E^r \n\ndotz = v_E^z + b^z v_Ti w_parallel + b^z u_iparallel \n\ndotw_parallel =\n  fracdotv_parallelv_Ti\n  - frac1v_Ti left( fracpartial u_iparallelpartial t + dotr fracpartial u_iparallelpartial r + dotz fracpartial u_iparallelpartial z right)\n  + fracw_parallelv_Ti left( fracpartial v_Tipartial t + dotr fracpartial v_Tipartial r + dotz fracpartial v_Tipartial z right) \n\nfracdotbarF_ibarF_i = frac3v_Ti left( fracpartial v_Tipartial t + dotr fracpartial v_Tipartial r + dotz fracpartial v_Tipartial z right)\n                   - frac1n_i left( fracpartial n_ipartial t + dotr fracpartial n_ipartial r + dotz fracpartial n_ipartial z right)\n                   - underbracefrac2v_Ti left( fracpartial v_Tipartial t + dotr fracpartial v_Tipartial r + dotz fracpartial v_Tipartial z right)_textterm coming from dotw_perp partial F_i  partial w_perp nonumber \n= frac1v_Ti left( fracpartial v_Tipartial t + dotr fracpartial v_Tipartial r + dotz fracpartial v_Tipartial z right)\n                   - frac1n_i left( fracpartial n_ipartial t + dotr fracpartial n_ipartial r + dotz fracpartial n_ipartial z right) \n\nbarmathcalC_i = fracv_Tin_i int C_iif_i f_i d^2 v_perp - R_mathrmCX n_n left( barF_i - fracv_Tiv_Tn barF_n right) + R_mathrmioniz fracn_e n_nn_i fracv_Tiv_Tn barF_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The separate-n_i and separate-n_i,u_iparallel equations are simpler to marginalise, as they contained no partial F_i  partial w_iperp term.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Separate n_i\nbeginalign\n fracpartial barF_ipartial t + v_E^r fracpartial barF_ipartial r + (v_E^z + b^z v_parallel) fracpartial barF_ipartial z\n  - b^z fracem_i fracpartialphipartial z fracpartial barF_ipartial v_parallel nonumber \n  + left( frac(b^z v_parallel - b^z u_iparallel)n_i fracpartial n_ipartial z - b^z fracpartial u_iparallelpartial z + R_mathrmioniz fracn_e n_nn_i + frac1n_i S_in right) barF_i nonumber \nquad= frac1n_i int C_iin_i F_i n_i F_i d^2 v_perp - R_mathrmCX n_n (barF_i - barF_n) + R_mathrmioniz fracn_e n_nn_i barF_n + frac1n_i barS_i \nendalign\nSeparate n_i and u_iparallel, with again hat w_parallel = v_parallel - u_sparallel\nbeginalign\n fracpartial barF_ipartial t\n  + v_E^r fracpartial barF_ipartial r\n  + (v_E^z + b^z hatw_parallel + b^z u_iparallel) fracpartial barF_ipartial z nonumber \n  quad- left( b^z hatw_parallel fracpartial u_iparallelpartial z\n                 - b^z frac1m_i n_i fracpartial p_iparallelpartial z\n                 + R_mathrmCX n_n (u_nparallel - u_iparallel)\n                 + R_mathrmioniz fracn_e n_nn_i u_nparallel\n                 + frac1m_i n_i S_imathrmmom\n               right) fracpartial barF_ipartial hatw_parallel nonumber \n  quad+ left( b^z frachatw_paralleln_i fracpartial n_ipartial z - b^z fracpartial u_iparallelpartial z + R_mathrmioniz fracn_e n_nn_i + frac1n_i S_in right) barF_i nonumber \nquad= frac1n_i int C_iin_i F_i n_i F_i d^2 v_perp - R_mathrmCX n_n (barF_i - barF_n) + R_mathrmioniz fracn_e n_nn_i barF_n + frac1n_i barS_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/#1D1V-neutral-equations","page":"Moment kinetic equations","title":"1D1V neutral equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Similarly setting T_iperp = 0 in the moment equations for neutrals","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial n_npartial t + fracpartialpartial zleft( n_n u_nparallel right)\n    = - R_mathrmioniz n_e n_n + S_nn \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n m_n fracpartialpartial t(n_n u_nparallel)\n  + m_n fracpartialpartial z(n_n u_nparallel^2)\n  + fracpartial p_nparallelpartial z nonumber \nquad= -R_mathrmCX m_n n_i n_n (u_nparallel - u_iparallel)\n    - R_mathrmioniz m_n n_e n_n u_nparallel\n    + S_nmathrmmom \n\n frac32 fracpartial p_npartial t\n  + fracpartial q_nparallelpartial z + p_nparallel fracpartial u_nparallelpartial z\n  + frac32 u_nparallel fracpartial p_npartial z + frac32 p_n fracpartial u_nparallelpartial z nonumber \nquad= frac12 R_mathrmCX n_i n_n left(3 T_i - 3 T_n + m_i (u_iparallel - u_nparallel)^2 right)\n      - frac32 R_mathrmioniz n_e n_n T_n nonumber \nqquad+ frac32 S_np \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Marginalising gives the 1D1V moment-kinetic neutral equation in a very similar form as for the ions","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial barF_npartial t + dotz fracpartial barF_npartial z + dotw_parallel fracpartial barF_npartial w_parallel\n    = dotbarF_n + barmathcalC_n + fracv_Tnn_n barS_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"where","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ndotz = v_Tn w_parallel + u_nparallel \n\ndotw_parallel = - left( frac1v_Tn fracpartial u_nparallelpartial t + left( w_parallel + fracu_n_parallelv_Tn right) fracpartial u_nparallelpartial z right nonumber \n    qquadquad  left + fracw_parallelv_Tn fracpartial v_Tnpartial t + w_parallel left( w_parallel + fracu_nparallelv_Tn right) fracpartial v_Tnpartial z right) \n\nfracdotbarF_nbarF_n = frac1v_Tn fracpartial v_Tnpartial t + frac(v_Tn w_parallel + u_nparallel)v_Tn fracpartial v_Tnpartial z\n                   - frac1n_n fracpartial n_npartial t - frac(v_Tn w_parallel + u_nparallel)n_n fracpartial n_npartial z \n\nbarmathcalC_n = R_mathrmCX n_i left( fracv_Tnv_Ti barF_i - barF_n right) - R_mathrmioniz n_e barF_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Separate n_n\nbeginalign\n fracpartial barF_npartial t + v_parallel fracpartial barF_npartial z\n  + left( frac(v_parallel - u_nparallel)n_n fracpartial n_npartial z - fracpartial u_nparallelpartial z + frac1n_n S_nn right) barF_n nonumber \nquad= R_mathrmCX n_i (barF_i - barF_n) + frac1n_n barS_n \nendalign\nSeparate n_n and u_nparallel\nbeginalign\n fracpartial barF_npartial t\n  + (hatw_parallel + u_nparallel) fracpartial barF_npartial z nonumber \n  quad- left( hatw_parallel fracpartial u_nparallelpartial z \n                 - frac1m_n n_n fracpartial p_nparallelpartial z\n                 - R_mathrmCX n_i (u_nparallel - u_iparallel)\n                 + frac1m_n n_n S_nmathrmmom\n               right) fracpartial barF_npartial hatw_parallel nonumber \n  quad+ left( frachatw_paralleln_n fracpartial n_npartial z - fracpartial u_nparallelpartial z + frac1n_n S_nn right) barF_n nonumber \nquad= R_mathrmCX n_i (barF_i - barF_n) + frac1n_n barS_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Wall-boundary-condition-(Knudsen-cosine-distribution)-2","page":"Moment kinetic equations","title":"Wall boundary condition (Knudsen cosine distribution)","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"For the 1D1V model, the Knudsen cosine distribution is marginalised over v_perp [Excalibur report TN-08]","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nbarf_mathrmKw(v_parallel) = 2 pi int_0^infty dv_perp v_perp f_mathrmKw(v_parallelv_perp) nonumber \n    = 3 sqrtpi left( fracm_n2T_w right)^32 v_parallel mathrmerfcleft( sqrtfracm_n2 T_w v_parallel right) \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Conversion-to-conventions-of-1D1V-Excalibur-reports","page":"Moment kinetic equations","title":"Conversion to conventions of 1D1V Excalibur reports","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The notes above follow the conventions of the nD2V systems of equations in the Excalibur reports. The original version of the 1D1V system as defined in the Excalibur reports had some conventions chosen differently. Quantities as defined in that original version are denoted by checkcdot where they differ from those defined here.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The thermal speed was defined using the parallel temperature","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ncheckv_Ts = sqrtfrac2 T_sparallelm_s nonumber \n               = sqrtfrac2 (3 T_s)m_s nonumber \n               = sqrt3 v_Ts\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"with a corresponding change in the normalised velocity coordinate","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ncheckw_parallel = fracv_parallel - u_sparallelcheckv_Ts nonumber \n                    = fracv_parallel - u_sparallelsqrt3 v_Ts nonumber \n                    = fracw_parallelsqrt3\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and in the shape function check F_s (it might be more consistent for the symbol for this shape function to have a barcdot as well as a checkcdot, but that would look messy so the barcdot is omitted)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ncheckF_s(tzcheckw_parallel) = fraccheckv_Tsn_s barf_s(tzv_parallel) nonumber \n                                           = sqrt3 fracv_Tsn_s barf_s(tzv_parallel) nonumber \n                                           = sqrt3 barF_s(tzw_parallel) nonumber \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Finally, the parallel heat flux was defined without the factor of 12","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ncheckq_sparallel = int m_s (v_parallel - u_sparallel)^3 barf_s dv_parallel nonumber \n                       = 2 q_sparallel\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Note that the different definition of check w_parallel compared to w_parallel and of check F_s compared to bar F_s can change form of the moment constraints - actually this only affects the energy constraint","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n1 = int barF_s dw_parallel = int frac1sqrt3 checkF_s sqrt3 dcheckw_parallel = int checkF_s dcheckw_parallel \n0 = int w_parallel barF_s dw_parallel = int sqrt3 checkw_parallel frac1sqrt3 checkF_s sqrt3 dcheckw_parallel = sqrt3 int checkw_parallel checkF_s dcheckw_parallel \nfrac32 = int w_parallel^2 barF_s dw_parallel = int 3 checkw_parallel^2 frac1sqrt3 checkF_s sqrt3 dcheckw_parallel = 3 int checkw_parallel^2 checkF_s dcheckw_parallel nonumber \nRightarrow frac12 = int checkw_parallel^2 checkF_s dcheckw_parallel \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"These conversions translate the equations as given above into the 1D1V forms in the Excalibur reports.","category":"page"},{"location":"moment_kinetic_equations/#Dimensionless-equations-for-code","page":"Moment kinetic equations","title":"Dimensionless equations for code","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"To put the equations on a computer, we need to make them dimensionless. We choose a reference density n_mathrmref, temperature T_mathrmref, length L_mathrmref, and magnetic field B_mathrmref, and use the ion mass m_i as the reference value (it might be useful to change this to 1 amu in future when we fully implement multi-species?). Denote dimensionless variables with a hatcdot in this section.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"We also define a reference speed, derived from the temperature and mass c_mathrmref = sqrtT_mathrmrefm_i, chosen so that the relation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfrac12 m_i v_Ts^2 = T_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"de-dimensionalises to","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfrac12 hatv_Ts^2 = hatT_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The full set of dimensionless variables are related to the dimensional ones by","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nhatn_s = fracn_sn_mathrmref \nhatT_s = fracT_sT_mathrmref \nhatL_z = fracL_zL_mathrmref \nhatB = fracBB_mathrmref \nhatm_i = fracm_im_i = 1 \nhatm_e = fracm_em_i \nhatv_Ts = fracv_Tsc_mathrmref \nhatf_s = fracc_mathrmref^3n_mathrmref f_s \nhatF_s = F_s \nhatbarf_s = fracc_mathrmrefn_mathrmref barf_s \nhatbarF_s = barF_s \nhatphi = frace phiT_mathrmref \nhatE_parallel = fracpartial hatphipartial hat z = frace L_mathrmrefT_mathrmref E_parallel \nhatt = fracc_mathrmref tL_mathrmref \nfracpartialpartial hatt = fracL_mathrmrefc_mathrmref fracpartialpartial t \nhatz = fraczL_mathrmref \nfracpartialpartial hatz = L_mathrmref fracpartialpartial z \nhatv_parallel = fracv_parallelc_mathrmref \nfracpartialpartial hatv_parallel = c_mathrmref fracpartialpartial v_parallel \nhatv_perp = fracv_perpc_mathrmref \nfracpartialpartial hatv_perp = c_mathrmref fracpartialpartial v_perp \nhatp_s = hatn_s hatT_s = fracp_sn_mathrmref T_mathrmref \nhatq_sparallel = fracq_sparallelm_i n_mathrmref c_mathrmref^3 = fracq_sparalleln_mathrmref T_mathrmref c_mathrmref \nhatR_mathrmCX = fracL_mathrmref n_mathrmref R_mathrmCXc_mathrmref \nhatR_mathrmioniz = fracL_mathrmref n_mathrmref R_mathrmionizc_mathrmref \nhatS_s = fracL_mathrmref c_mathrmref^2 S_sn_mathrmref \nhatbarS_s = fracL_mathrmref barS_sn_mathrmref \nhatS_sn = fracL_mathrmref S_snc_mathrmref n_mathrmref \nhatS_smathrmmom = fracL_mathrmref S_smathrmmomm_mathrmi n_mathrmref c_mathrmref^2 \nhatS_sE = fracL_mathrmref S_sEc_mathrmref m_mathrmi n_mathrmref T_mathrmref \nhatS_sp = fracL_mathrmref S_spc_mathrmref m_mathrmi n_mathrmref T_mathrmref \nhatC_ii(hatf_i hatf_i) = fracL_mathrmref c_mathrmref^2n_mathrmref C_ii(f_i f_i) \nhatf_mathrmKw = c_mathrmref^4 f_mathrmKw \nhatbarf_mathrmKw = c_mathrmref^2 barf_mathrmKw \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Using these definitions, the dimensionful equations above are converted to dimensionless equations mostly just by putting a hatcdot on all dimensionful quantities. The exceptions are:","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nhatdotv_parallel\n=fract_mathrmrefc_mathrmref dotv_parallel\n = fracL_mathrmrefc_mathrmref^2 dotv_parallel nonumber \n= - fracL_mathrmrefc_mathrmref^2 b^z fracem_i fracpartial phipartial z\n = - fraccancelL_mathrmrefc_mathrmref^2 b^z fraccancelem_i fracT_mathrmrefcancele cancelL_mathrmref fracpartial hatphipartial hatz\n = - frac1c_mathrmref^2 b^z underbracefracT_mathrmrefm_i_c_mathrmref^2 fracpartial hatphipartial hatz\n = - b^z fracpartial hatphipartial hatz \n\nhatv_E^r\n=fracv_E^rc_mathrmref\n = - frac1c_mathrmref fracb_zetaB fracpartial phipartial z\n = - frac1c_mathrmref fracT_mathrmrefe B_mathrmref L_mathrmref fracb_zetahatB fracpartial hatphipartial hatz\n = - fracm_i c_mathrmrefe B_mathrmref L_mathrmref fracb_zetahatB fracpartial hatphipartial hatz\n = - rho_* fracb_zetahatB fracpartial hatphipartial hatz \n\nhatv_E^z\n=fracv_E^zc_mathrmref\n = frac1c_mathrmref fracb_zetaB fracpartial phipartial r\n = frac1c_mathrmref fracT_mathrmrefe B_mathrmref L_mathrmref fracb_zetahatB fracpartial hatphipartial hatr\n = fracm_i c_mathrmrefe B_mathrmref L_mathrmref fracb_zetahatB fracpartial hatphipartial hatr\n = rho_* fracb_zetahatB fracpartial hatphipartial hatr \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"defining","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nOmega_mathrmref = frace B_mathrmrefm_i \n\nrho_* = fracc_mathrmrefOmega_mathrmref L_mathrmref\n        = fracm_i c_mathrmrefe B_mathrmref L_mathrmref \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Definitions-for-any-species","page":"Moment kinetic equations","title":"Definitions for any species","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nhatp_sparallel = 2piint_-infty^infty dhatv_parallel int_0^infty dhatv_perp hatv_perp\n    hatm_s left( hatv_parallel - hatu_sparallel right)^2 hatf_s nonumber \n    = hatm_s hatn_s hatv_Ts^2 2pi int_-infty^infty dw_parallel int_0^infty dw_perp w_perp\n        w_parallel^2 F_s \n\nhatp_sperp = 2piint_-infty^infty dhatv_parallel int_0^infty dhatv_perp hatv_perp\n    hatm_s frachatv_perp^22 hatf_s \n    = frac12 hatm_s hatn_s hatv_Ts^2 2pi int_-infty^infty dw_parallel int_0^infty dw_perp w_perp\n        w_perp^2 F_s \n\nhatp_s = hatn_s hatT_s = frachatm_s2 hatn_s hatv_Ts^2 = frac13(hatp_sparallel + 2hatp_sperp) \n\nhatT_s = frac13(hatT_sparallel + 2hatT_sperp) \n\nhatv_Ts = sqrtfrac2hatT_shatm_s= sqrtfrac2(hatT_sparallel + 2hatT_sperp)3hatm_s \n\nhatq_sparallel = int frachatm_s2 left( (hatv_parallel - hatu_sparallel)^2 + hatv_perp^2 right) (hatv_parallel - hatu_sparallel) hatf_s d^3 hatv \n    = hatn_s hatv_Ts^3 int frachatm_s2 left( w_parallel^2 + w_perp^2 right) w_parallel F_s d^3 w \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Dimensionless-1D2V-ion-equations","page":"Moment kinetic equations","title":"Dimensionless 1D2V ion equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"For convenience in future extension to multi-ion-species in future, we keep hat m_i in the equations below, even though it is equal to 1 in the conventions here.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial hatn_ipartial hatt\n+ hatv_E^r fracpartial hatn_ipartial hatr\n+ hatv_E^z fracpartial hatn_ipartial hatz\n+ b^z fracpartialpartial hatzleft( hatn_i hatu_iparallel right)\n    = hatR_mathrmioniz hatn_e hatn_n + hatS_in \n\n hatm_i fracpartialpartial hatt(hatn_i hatu_iparallel)\n  + hatm_i hatv_E^r fracpartialpartial hatr (hatn_i hatu_iparallel)\n  + hatm_i hatv_E^z fracpartialpartial hatz (hatn_i hatu_iparallel)\n  + hatm_i b^z fracpartialpartial hatz(hatn_i hatu_iparallel^2)\n  + b^z fracpartial hatp_iparallelpartial hatz\n  + b^z hatn_i fracpartial hatphipartial hatz nonumber \nquad= hatm_i hatR_mathrmCX hatn_i hatn_n (hatu_nparallel - hatu_iparallel)\n        + hatm_i hatR_mathrmioniz hatn_e hatn_n hatu_nparallel\n        + hatS_imathrmmom \n\n frac32 fracpartial hatp_ipartial hatt\n  + frac32 hatv_E^r fracpartial hatp_ipartial hatr\n  + frac32 hatv_E^z fracpartial hatp_ipartial hatz\n  + b^z fracpartial hatq_iparallelpartial hatz + b^z hatp_iparallel fracpartial hatu_iparallelpartial hatz\n  + frac32 b^z hatu_iparallel fracpartial hatp_ipartial hatz + frac32 b^z hatp_i fracpartial hatu_iparallelpartial hatz nonumber \nquad= - frac12 hatR_mathrmCX hatn_i hatn_n left(3 hatT_i - 3 hatT_n - hatm_i (hatu_iparallel - hatu_nparallel)^2 right)\n      + frac12 hatR_mathrmioniz hatn_e hatn_n left(3 hatT_n + hatm_i (hatu_iparallel - hatu_nparallel)^2 right) nonumber \nqquad+ frac32 hatS_ip \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Full-kinetic-equation","page":"Moment kinetic equations","title":"Full kinetic equation","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial hatf_ipartial hatt\n    + hatv_E^r fracpartial hatf_ipartial hatr\n    + (hatv_E^z + b^z hatv_parallel) fracpartial hatf_ipartial hatz\n    - b^z frac1hatm_i fracpartialhatphipartial hatz fracpartial hatf_ipartial hatv_parallel\n    = hatC_iihatf_i hatf_i - hatR_mathrmCX (hatn_n hatf_i - hatn_i hatf_n) + hatR_mathrmioniz hatn_e hatf_n + hatS_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/#Separate-\\hat-n_i","page":"Moment kinetic equations","title":"Separate hat n_i","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In this subsection hat F_s = c_mathrmref^3 f_s.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial hatF_ipartial hatt + hatv_E^r fracpartial hatF_ipartial hatr + (hatv_E^z + b^z hatv_parallel) fracpartial hatF_ipartial hatz\n  - b^z frac1hatm_i fracpartialhatphipartial hatz fracpartial hatF_ipartial hatv_parallel\n  + left( frac(b^z hatv_parallel - b^z hatu_iparallel)hatn_i fracpartial hatn_ipartial hatz - b^z fracpartial hatu_iparallelpartial hatz + hatR_mathrmioniz frachatn_e hatn_nhatn_i + frac1hatn_i hatS_in right) hatF_i nonumber \nquad= frac1hatn_i hatC_iihatn_i hatF_i hatn_i hatF_i - hatR_mathrmCX hatn_n (hatF_i - hatF_n) + hatR_mathrmioniz frachatn_e hatn_nhatn_i hatF_n + frac1hatn_i hatS_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Separate-\\hat-n_i-and-\\hat-u_{i\\parallel}","page":"Moment kinetic equations","title":"Separate hat n_i and hat u_iparallel","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In this subsection hat F_s = c_mathrmref^3 f_s and hathatw_parallel = hatw_parallel  c_mathrmref.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial F_ipartial t\n  + hatv_E^r fracpartial hatF_ipartial hatr\n  + (hatv_E^z + b^z hathatw_parallel + b^z hatu_iparallel) fracpartial hatF_ipartial hatz nonumber \n  quad- left( b^z hathatw_parallel fracpartial hatu_iparallelpartial hatz\n                 - b^z frac1hatm_i hatn_i fracpartial hatp_iparallelpartial hatz\n                 + hatR_mathrmCX hatn_n (hatu_nparallel - hatu_iparallel)\n                 + hatR_mathrmioniz frachatn_e hatn_nhatn_i hatu_nparallel\n                 + frac1hatm_i hatn_i hatS_imathrmmom\n               right) fracpartial hatF_ipartial hathatw_parallel nonumber \n  quad+ left( b^z frachathatw_parallelhatn_i fracpartial hatn_ipartial hatz - b^z fracpartial hatu_iparallelpartial hatz + hatR_mathrmioniz frachatn_e hatn_nhatn_i + frac1hatn_i hatS_in right) hatF_i nonumber \nquad= frac1hatn_i hatC_iihatn_i hatF_i hatn_i hatF_i - hatR_mathrmCX hatn_n (hatF_i - hatF_n) + hatR_mathrmioniz frachatn_e hatn_nhatn_i hatF_n + frac1hatn_i hatS_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Full-moment-kinetics-(separate-\\hat-n_i,-\\hat-u_{i\\parallel}-and-\\hat-p_i)","page":"Moment kinetic equations","title":"Full moment-kinetics (separate hat n_i, hat u_iparallel and hat p_i)","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Note that we do not put a hatcdot on the already dimensionless quantities F_s, w_parallel, w_perp.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial F_ipartial hatt + hatdotr fracpartial F_ipartial hatr + hatdotz fracpartial F_ipartial hatz + hatdotw_parallel fracpartial F_ipartial w_parallel + hatdotw_perp fracpartial F_ipartial w_perp\n    = hatdotF_i + hatmathcalC_i + frachatv_Ti^3hatn_i hatS_i \n\nhatdotr = hatv_E^r \n\nhatdotz = hatv_E^z + b^z hatv_Ti w_parallel + b^z hatu_iparallel \n\nhatdotw_parallel =\n  frachatdotv_iparallelhatv_Ti\n  - frac1hatv_Ti left( fracpartial hatu_iparallelpartial hatt + hatdotr fracpartial hatu_iparallelpartial hatr + hatdotz fracpartial hatu_iparallelpartial hatz right)\n  - fracw_parallelhatv_Ti left( fracpartial hatv_Tipartial hatt + hatdotr fracpartial hatv_Tipartial hatr + hatdotz fracpartial hatv_Tipartial hatz right) \n\nhatdotv_iparallel = - b^z frac1hatm_i fracpartial hatphipartial hatz \n\nhatdotw_perp = hatdotv_iperp - fracw_perphatv_Ti left( fracpartial hatv_Tipartial hatt + hatdotr fracpartial hatv_Tipartial hatr + hatdotz fracpartial hatv_Tipartial hatz right) \n\nhatdotv_iperp = 0 \n\nfrachatdotF_iF_i =\n  frac3hatv_Ti left( fracpartial hatv_Tipartial hatt\n                                + hatdotr fracpartial hatv_Tipartial hatr\n                                + hatdotz fracpartial hatv_Tipartial hatz right)\n  - frac1hatn_i left( fracpartial hatn_ipartial hatt\n                               + hatdotr fracpartial hatn_ipartial hatr\n                               + hatdotz fracpartial hatn_ipartial hatz right) \n\nhatmathcalC_i = frachatv_Ti^3hatn_i hatC_iifrachatn_i F_ihatv_Ti^3 frachatn_i F_ihatv_Ti^3 - hatR_mathrmCX hatn_n left( F_i - frachatv_Ti^3hatv_Tn^3 F_n right) + hatR_mathrmioniz frachatn_e hatn_nhatn_i frachatv_Ti^3hatv_Tn^3 hatF_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Collision-coefficient","page":"Moment kinetic equations","title":"Collision coefficient","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The coefficient in front of the Fokker-Planck collision operator is","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ngamma_ss = frac2 pi Z_s^2 Z_s^2 e^4 logLambda_ss(4 pi epsilon_0)^2\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and is made dimensionless as","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nhatgamma_ss = fracn_mathrmref t_mathrmrefm_mathrmref^2 c_mathrmref^3 gamma_ss\n                   = fracn_mathrmref L_mathrmrefm_mathrmref^2 c_mathrmref^4 gamma_ss\n                   = frac12 fracn_mathrmref Z_s^2 Z_s^2 e^4 logLambda_ss L_mathrmref4 pi epsilon_0^2 m_mathrmref^2 c_mathrmref^4\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"hat gamma_ss is called nuii in moment_kinetics.fokker_planck.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"nuii can also be set manually in the [fokker_planck_collisions] input section, which could be thought of as choosing logLambda_ss to set the requested dimensionless nuii.","category":"page"},{"location":"moment_kinetic_equations/#Dimensionless-1D2V-neutral-equations","page":"Moment kinetic equations","title":"Dimensionless 1D2V neutral equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial hatn_npartial hatt + fracpartialpartial hatzleft( hatn_n hatu_nparallel right)\n    = - hatR_mathrmioniz hatn_e hatn_n + hatS_nn \n\n hatm_n fracpartialpartial hatt(hatn_n hatu_nparallel)\n  + hatm_n fracpartialpartial hatz(hatn_n hatu_nparallel^2)\n  + fracpartial hatp_nparallelpartial hatz nonumber \nquad= -hatR_mathrmCX hatm_n hatn_i hatn_n (hatu_nparallel - hatu_iparallel)\n    - hatR_mathrmioniz hatm_n hatn_e hatn_n hatu_nparallel\n    + hatS_nmathrmmom \n\n frac32 fracpartial hatp_npartial hatt\n  + fracpartial hatq_nparallelpartial hatz + hatp_nparallel fracpartial hatu_nparallelpartial hatz\n  + frac32 hatu_nparallel fracpartial hatp_npartial hatz + frac32 hatp_n fracpartial hatu_nparallelpartial hatz nonumber \nquad= frac12 hatR_mathrmCX hatn_i hatn_n left(3 hatT_i - 3 hatT_n + hatm_i (hatu_iparallel - hatu_nparallel)^2 right)\n      - frac32 hatR_mathrmioniz hatn_e hatn_n hatT_n nonumber \nqquad+ frac32 hatS_np \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Full-kinetic-equation-2","page":"Moment kinetic equations","title":"Full kinetic equation","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial hatf_npartial hatt + hatv_parallel fracpartial hatf_npartial hatt\n    = hatR_mathrmCX (hatn_n hatf_i - hatn_i hatf_n) - hatR_mathrmioniz hatn_e hatf_n + hatS_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Separate-\\hat-n_n","page":"Moment kinetic equations","title":"Separate hat n_n","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In this subsection hat F_s = c_mathrmref^3 f_s.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial hatF_npartial hatt + hatv_parallel fracpartial hatF_npartial hatz\n  + left( frac(hatv_parallel - hatu_nparallel)hatn_n fracpartial hatn_npartial hatz - fracpartial hatu_nparallelpartial hatz + frac1hatn_n hatS_nn right) hatF_n nonumber \nquad= hatR_mathrmCX hatn_i (hatF_i - hatF_n) + frac1hatn_n hatS_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Separate-\\hat-n_n-and-\\hat-u_{n\\parallel}","page":"Moment kinetic equations","title":"Separate hat n_n and hat u_nparallel","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In this subsection hat F_s = c_mathrmref^3 f_s and hathatw_parallel = hatw_parallel  c_mathrmref.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial hatF_npartial hatt\n  + (hathatw_parallel + hatu_nparallel) fracpartial hatF_npartial hatz nonumber \n  quad- left( hathatw_parallel fracpartial hatu_nparallelpartial hatz\n                 - frac1hatm_n hatn_n fracpartial hatp_nparallelpartial hatz\n                 - hatR_mathrmCX hatn_i (hatu_nparallel - hatu_iparallel)\n                 + frac1hatm_n hatn_n hatS_nmathrmmom\n               right) fracpartial hatF_npartial hathatw_parallel nonumber \n  quad+ left( frachathatw_parallelhatn_n fracpartial hatn_npartial hatz - fracpartial hatu_nparallelpartial hatz + frac1hatn_n hatS_nn right) hatF_n nonumber \nquad= hatR_mathrmCX hatn_i (hatF_i - hatF_n) + frac1hatn_n hatS_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Full-moment-kinetics-(separate-\\hat-n_n,-\\hat-u_{n\\parallel}-and-\\hat-p_{n})","page":"Moment kinetic equations","title":"Full moment-kinetics (separate hat n_n, hat u_nparallel and hat p_n)","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Note that we do not put a hatcdot on the already dimensionless quantities F_s, w_parallel, w_perp.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial F_npartial hatt + hatdotz fracpartial F_npartial hatz + hatdotw_parallel fracpartial F_npartial w_parallel + hatdotw_perp fracpartial F_npartial w_perp\n    = hatdotF_n + hatmathcalC_n + frachatv_Tn^3hatn_n hatS_n \n\nhatdotz = hatv_Tn w_parallel + hatu_nparallel \n\nhatdotw_parallel = - left( frac1hatv_Tn fracpartial hatu_nparallelpartial hatt + left( w_parallel + frachatu_n_parallelhatv_Tn right) fracpartial hatu_nparallelpartial hatz right nonumber \n    qquadquad  left + fracw_parallelhatv_Tn fracpartial hatv_Tnpartial hatt + w_parallel left( w_parallel + frachatu_nparallelhatv_Tn right) fracpartial hatv_Tnpartial hatz right) \n\nhatdotw_perp = -left( fracw_perphatv_Tn fracpartial hatv_Tnpartial hatt + left( w_parallel + frachatu_nparallelhatv_Tn right) w_perp fracpartial hatv_Tnpartial hatz right) \n\nfrachatdotF_nF_n = frac3hatv_Tn fracpartial hatv_Tnpartial hatt + frac3 (hatv_Tn w_parallel + hatu_nparallel)hatv_Tn fracpartial hatv_Tnpartial hatz\n                   - frac1hatn_n fracpartial hatn_npartial hatt - frac(hatv_Tn w_parallel + hatu_nparallel)hatn_n fracpartial hatn_npartial hatz \n\nhatmathcalC_n = hatR_mathrmCX hatn_i left( frachatv_Tn^3hatv_Ti^3 F_i - F_n right) \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Dimensionless-2D1V-ion-equations","page":"Moment kinetic equations","title":"Dimensionless 2D1V ion equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The moment equations for 2D1V are identical to those for 2D2V, although in 2D1V p_iperp = 0.","category":"page"},{"location":"moment_kinetic_equations/#Full-kinetic-equation-3","page":"Moment kinetic equations","title":"Full kinetic equation","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial hatbarf_ipartial hatt + hatv_E^r fracpartial hatbarf_ipartial hatr + left(hatv_E^z + b^z hatv_parallelright) fracpartial hatbarf_ipartial hatz\n    - b^z frac1hatm_i fracpartialhatphipartial hatz fracpartial hatbarf_ipartial hatv_parallel\n    = hatbarC_iihatbarf_i hatbarf_i - hatR_mathrmCX (hatn_n hatbarf_i - hatn_i hatbarf_n) + hatR_mathrmioniz hatn_e hatbarf_n + hatbarS_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/#Separate-\\hat-n_i-2","page":"Moment kinetic equations","title":"Separate hat n_i","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In this subsection hatbarF_s = c_mathrmref bar f_s.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial hatbarF_ipartial hatt\n  + hatv_E^r fracpartial hatbarF_ipartial hatr\n  + (hatv_E^z + b^z hatv_parallel) fracpartial hatbarF_ipartial hatz\n  - b^z frac1hatm_i fracpartialhatphipartial hatz fracpartial hatbarF_ipartial hatv_parallel nonumber \n + left( frac(b^z hatv_parallel - b^z hatu_iparallel)hatn_i fracpartial hatn_ipartial hatz - b^z fracpartial hatu_iparallelpartial hatz + hatR_mathrmioniz frachatn_e hatn_nhatn_i + frac1hatn_i hatS_in right) hatbarF_i nonumber \nquad= frac1hatn_i int hatC_iihatn_i hatF_i hatn_i hatF_i d^2 hatv_perp - hatR_mathrmCX hatn_n (hatbarF_i - hatbarF_n) + hatR_mathrmioniz frachatn_e hatn_nhatn_i hatbarF_n + frac1hatn_i hatbarS_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Separate-\\hat-n_i-and-\\hat-u_{i\\parallel}-2","page":"Moment kinetic equations","title":"Separate hat n_i and hat u_iparallel","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In this subsection hatbarF_s = c_mathrmref bar f_s and hathatw_parallel = hatw_parallel  c_mathrmref.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial hatbarF_ipartial hatt\n  + hatv_E^r fracpartial hatbarF_ipartial hatr\n  + (hatv_E^z + b^z hathatw_parallel + b^z hatu_iparallel) fracpartial hatbarF_ipartial hatz nonumber \n  quad- left( b^z hatw_parallel fracpartial hatu_iparallelpartial hatz\n                 - b^z frac1hatm_i hatn_i fracpartial hatp_iparallelpartial hatz\n                 + hatR_mathrmCX hatn_n (hatu_nparallel - hatu_iparallel)\n                 + hatR_mathrmioniz frachatn_e hatn_nhatn_i hatu_nparallel\n                 + frac1hatm_i hatn_i hatS_imathrmmom\n               right) fracpartial hatbarF_ipartial hathatw_parallel nonumber \n  quad+ left( b^z frachathatw_parallelhatn_i fracpartial hatn_ipartial hatz\n                 - b^z fracpartial hatu_iparallelpartial hatz\n                 + hatR_mathrmioniz frachatn_e hatn_nhatn_i\n                 + frac1hatn_i hatS_in right) hatbarF_i nonumber \nquad= frac1hatn_i int hatC_iihatn_i hatF_i hatn_i hatF_i d^2 hatv_perp - hatR_mathrmCX hatn_n (hatbarF_i - hatbarF_n) + hatR_mathrmioniz frachatn_e hatn_nhatn_i hatbarF_n + frac1hatn_i hatbarS_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Full-moment-kinetics-(separate-\\hat-n_i,-\\hat-u_{i\\parallel}-and-\\hat-p_i)-2","page":"Moment kinetic equations","title":"Full moment-kinetics (separate hat n_i, hat u_iparallel and hat p_i)","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial barF_ipartial hatt + hatdotz fracpartial barF_ipartial hatr + hatdotz fracpartial barF_ipartial hatz + hatdotw_parallel fracpartial barF_ipartial w_parallel + hatdotw_perp fracpartial barF_ipartial w_perp\n    = hatdotbarF_i + hatbarmathcalC_i + frachatv_Tihatn_i hatbarS_i \n\nhatdotr = hatv_E^r \n\nhatdotz = hatv_E^z + b^z hatv_Ti w_parallel + b^z hatu_iparallel \n\nhatdotw_parallel =\n  frachatdotv_iparallelhatv_Ti\n  - frac1hatv_Ti left( fracpartial hatu_iparallelpartial hatt\n                                  + hatdotr fracpartial hatu_iparallelpartial hatr\n                                  + hatdotz fracpartial hatu_iparallelpartial hatz right)\n  - fracw_parallelhatv_Ti left( fracpartial hatv_Tipartial hatt\n                                            + hatdotr fracpartial hatv_Tipartial hatr\n                                            + hatdotz fracpartial hatv_Tipartial hatz right) \n\nhatdotv_iparallel = - b^z frac1hatm_i fracpartial hatphipartial hatz \n\nfrachatdotbarF_ibarF_i =\n  frac1hatv_Ti left(fracpartial hatv_Tipartial hatt\n                               + hatdotr fracpartial hatv_Tipartial hatr\n                               + hatdotz fracpartial hatv_Tipartial hatz right)\n  - frac1hatn_i left(fracpartial hatn_ipartial hatt\n                              + hatdotr fracpartial hatn_ipartial hatr\n                              + hatdotz fracpartial hatn_ipartial hatz right) \n\nhatbarmathcalC_i =\n  frachatv_Tihatn_i int hatC_iileftfrachatn_ihatv_Ti^3 F_i frachatn_ihatv_Ti^3 F_iright d^2 hatv_perp\n  - hatR_mathrmCX hatn_n left( barF_i - frachatv_Tihatv_Tn barF_n right)\n  + hatR_mathrmioniz frachatn_e hatn_nhatn_i frachatv_Tihatv_Tn barF_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Dimensionless-1D1V-neutral-equations","page":"Moment kinetic equations","title":"Dimensionless 1D1V neutral equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial hatn_npartial hatt + fracpartialpartial hatzleft( hatn_n hatu_nparallel right)\n    = - hatR_mathrmioniz hatn_e hatn_n + hatS_nn \n hatm_n fracpartialpartial hatt(hatn_n hatu_nparallel)\n  + hatm_n fracpartialpartial hatz(hatn_n hatu_nparallel^2)\n  + fracpartial hatp_nparallelpartial hatz nonumber \nquad= -hatR_mathrmCX hatm_n hatn_i hatn_n (hatu_nparallel - hatu_iparallel)\n    - hatR_mathrmioniz hatm_n hatn_e hatn_n hatu_nparallel\n    + hatS_nmathrmmom \n\n frac32 fracpartial hatp_npartial hatt\n  + fracpartial hatq_nparallelpartial hatz + hatp_nparallel fracpartial hatu_nparallelpartial hatz\n  + frac32 hatu_nparallel fracpartial hatp_npartial hatz + frac32 hatp_n fracpartial hatu_nparallelpartial hatz nonumber \nquad= frac12 hatR_mathrmCX hatn_i hatn_n left(3 hatT_i - 3 hatT_n + hatm_i (hatu_iparallel - hatu_nparallel)^2 right)\n      - frac32 hatR_mathrmioniz hatn_e hatn_n hatT_n nonumber \nqquad+ frac32 hatS_np \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Full-kinetic-equation-4","page":"Moment kinetic equations","title":"Full kinetic equation","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial hatbarf_npartial hatt + hatv_parallel fracpartial hatbarf_npartial hatz\n    = hatR_mathrmCX (hatn_n hatbarf_i - hatn_i hatbarf_n) - hatR_mathrmioniz hatn_e hatbarf_n + hatbarS_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Separate-\\hat-n_n-2","page":"Moment kinetic equations","title":"Separate hat n_n","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In this subsection hatbarF_s = c_mathrmref bar f_s.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial hatbarF_npartial hatt + hatv_parallel fracpartial hatbarF_npartial hatz\n  + left( frac(hatv_parallel - hatu_nparallel)hatn_n fracpartial hatn_npartial hatz - fracpartial hatu_nparallelpartial hatz + frac1hatn_n hatS_nn right) hatbarF_n nonumber \nquad= hatR_mathrmCX hatn_i (hatbarF_i - hatbarF_n) + frac1hatn_n hatbarS_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Separate-\\hat-n_n-and-\\hat-u_{n\\parallel}-2","page":"Moment kinetic equations","title":"Separate hat n_n and hat u_nparallel","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In this subsection hatbarF_s = c_mathrmref bar f_s and hathatw_parallel = hatw_parallel  c_mathrmref.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n fracpartial hatbarF_npartial hatt\n  + (hathatw_parallel + hatu_nparallel) fracpartial hatbarF_npartial hatz nonumber \n  quad- left( hathatw_parallel fracpartial hatu_nparallelpartial hatz\n                 - frac1hatm_n hatn_n fracpartial hatp_nparallelpartial hatz\n                 - hatR_mathrmCX hatn_i (hatu_nparallel - hatu_iparallel)\n                 + frac1hatm_n hatn_n hatS_nmathrmmom\n               right) fracpartial hatbarF_npartial hathatw_parallel nonumber \n  quad+ left( frachathatw_parallelhatn_n fracpartial hatn_npartial hatz - fracpartial hatu_nparallelpartial hatz + frac1hatn_n hatS_nn right) hatbarF_n nonumber \nquad= hatR_mathrmCX hatn_i (hatbarF_i - hatbarF_n) + frac1hatn_n hatbarS_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Full-moment-kinetics-(separate-\\hat-n_n,-\\hat-u_{n\\parallel}-and-\\hat-p_{n})-2","page":"Moment kinetic equations","title":"Full moment-kinetics (separate hat n_n, hat u_nparallel and hat p_n)","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Note that we do not put a hatcdot on the already dimensionless quantities bar F_s, w_parallel, w_perp.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nfracpartial barF_npartial hatt + hatdotz fracpartial barF_npartial hatz + hatdotw_parallel fracpartial barF_npartial w_parallel\n    = hatdotbarF_n + hatbarmathcalC_n + frachatv_Tnhatn_n hatbarS_n \n\nhatdotz = hatv_Tn w_parallel + hatu_nparallel \n\nhatdotw_parallel = - left( frac1hatv_Tn fracpartial hatu_nparallelpartial hatt + left( w_parallel + frachatu_n_parallelhatv_Tn right) fracpartial hatu_nparallelpartial hatz right nonumber \n    qquadquad  left + fracw_parallelhatv_Tn fracpartial hatv_Tnpartial hatt + w_parallel left( w_parallel + frachatu_nparallelhatv_Tn right) fracpartial hatv_Tnpartial hatz right) \n\nfrachatdotbarF_nbarF_n = frac1hatv_Tn fracpartial hatv_Tnpartial hatt + frac(hatv_Tn w_parallel + hatu_nparallel)hatv_Tn fracpartial hatv_Tnpartial hatz\n                   - frac1hatn_n fracpartial hatn_npartial hatt - frac(hatv_Tn w_parallel + hatu_nparallel)hatn_n fracpartial hatn_npartial hatz \n\nhatbarmathcalC_n = hatR_mathrmCX hatn_i left( frachatv_Tnhatv_Ti barF_i - barF_n right) - R_mathrmioniz n_e barF_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Conversion-to-old-dimensionless-equations","page":"Moment kinetic equations","title":"Conversion to old dimensionless equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In the 1D1V Excalibur reports, and the original version of the code, a different set of dimensionless variables were chosen, where check c_mathrmref = sqrt2 check T_mathrmref  m_i was used as the primary reference variable, along with a reference density check n_mathrmref, length check L_mathrmref, and magnetic field check B_mathrmref. In the Excalibur reports where a Boltzmann electron response, which implies constant electron temperature, was used the reference temperature was taken to be check T_mathrmref = T_e, but this was later generalised in the code to an arbitrary check T_mathrmref to allow non-constant electron temperature (with Braginskii or kinetic electrons) or for varying the constant electron temperature of the Boltzmann response without re-scaling the rest of the dimensionless variables. Temperatures were de-dimensionalised using check T_mathrmref, not check m_mathrmref check c_mathrmref^2.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In this section, denote dimensionless variables of the original version's conventions with a mathringcdot.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The 2V distribution function f_s is de-dimensionalised so that a Maxwellian check f_Ms = fracn_s(pi)^32 check v_Ts expleft(-v_parallel^2  check v_Ts^2 right) would have a maximum value of mathring n_s  mathring v_Ts^3.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The 1V, marginalised distribution function bar f_s is de-dimensionalised so that a 1V Maxwellian checkbarf_Ms = fracn_ssqrtpi check v_Ts expleft(-v_parallel^2  check v_Ts^2 right) would have a maximum value of mathring n_s  mathring v_Ts, and its shape function check F_s would have a maximum value of 1.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Important to note, in the original version, the dimensionless electrostatic potential was defined using check T_mathrmref, as mathring phi = e phi  check T_mathrmref, not using m_i check c_mathrmref^2 that was used for temperatures.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In the original, for 1D1V runs the input temperatures were T_sparallel not T_s, whereas in the updated version the input temperatures are always T_s, which for 1D1V is T_s = T_sparallel3. However the electron temperature T_e, which is used when calculating the electrostatic potential using the Boltzmann response, is constant and is effectively always T_eparallel which is assumed equal to T_e for Boltzmann response (i.e. do not assume T_eperp=0 for Boltzmann electrons in 1D1V).","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Using these definitions, the old dimensionless variables in terms of the physical variables and of the current dimensionless variables (where we assume for the conversion that check n_mathrmref = n_mathrmref, check T_mathrmref = T_mathrmref, and check B_mathrmref = B_mathrmref) are, listing the ones with differences first","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalignat2\nmathringv_Ts = fraccheckv_Tscheckc_mathrmref = fracsqrt3 v_Tssqrt2 c_mathrmref = sqrtfrac32 hatv_Ts\n     hatv_Ts = sqrtfrac23 mathringv_Ts \nmathringf_s = fracpi^32 checkc_mathrmref^3checkn_mathrmref f_s = frac(2 pi)^32 c_mathrmref^3n_mathrmref f_s = (2 pi)^32 hatf_s\n     hatf_s = frac1(2 pi)^32 mathringf_s \nmathringbarf_s = fracsqrtpi checkc_mathrmrefcheckn_mathrmref barf_s = fracsqrt2 pi c_mathrmrefn_mathrmref barf_s = sqrt2 pi hatbarf_s\n     hatbarf_s = frac1sqrt2 pi mathringbarf_s \nmathringF_s = sqrtpi checkF_s = sqrtpi sqrt3 barF_s\n     barF_s = frac1sqrtpi sqrt3 mathringbarF_s \nmathringf_mathrmKw = fracpi^32 checkc_mathrmref^4checkn_mathrmref f_mathrmKw = 4pi^32 fracc_mathrmref^4n_mathrmref f_mathrmKw = 4pi^32 hatf_mathrmKw\n     hatf_mathrmKw = frac14pi^32 mathringf_mathrmKw \nmathringbarf_mathrmKw = sqrtpi checkc_mathrmref^2 barf_mathrmKw = 2sqrtpi c_mathrmref barf_mathrmKw = 2sqrtpi hatbarf_mathrmKw\n     hatbarf_mathrmKw = frac12sqrtpi mathringbarf_mathrmKw \nmathringt = fraccheckc_mathrmref tcheckL_mathrmref = sqrt2 fracc_mathrmref tL_mathrmref = sqrt2 hatt\n     hatt = frac1sqrt2 mathringt \nfracpartialpartial mathringt = fraccheckL_mathrmrefcheckc_mathrmref fracpartialpartial t = fracL_mathrmrefsqrt2 c_mathrmref fracpartialpartial hatt = frac1sqrt2 fracpartialpartial hatt\n     fracpartialpartial hatt = sqrt2 fracpartialpartial mathringt \nmathringv_parallel = fracv_parallelcheckc_mathrmref = fracv_parallelsqrt2 c_mathrmref = frachatv_parallelsqrt2\n     hatv_parallel = sqrt2 mathringv_parallel \nfracpartialpartial mathringv_parallel = checkc_mathrmref fracpartialpartial v_parallel = sqrt2 c_mathrmref fracpartialpartial v_parallel = sqrt2 fracpartialpartial hatv_parallel\n     fracpartialpartial hatv_parallel = frac1sqrt2 fracpartialpartial mathringv_parallel \nmathringv_perp = fracv_perpcheckc_mathrmref = fracv_perpsqrt2 c_mathrmref = frachatv_perpsqrt2\n     hatv_perp = sqrt2 mathringv_perp \nfracpartialpartial mathringv_perp = checkc_mathrmref fracpartialpartial v_perp = sqrt2 c_mathrmref fracpartialpartial v_perp = sqrt2 fracpartialpartial hatv_perp\n     fracpartialpartial hatv_perp = frac1sqrt2 fracpartialpartial mathringv_perp \nmathringw_parallel = fracmathringv_parallelmathringv_Ts = fracv_parallelcheckv_Ts = fracv_parallelsqrt3v_Ts = fracw_parallelsqrt3\n     w_parallel = sqrt3 mathringw_parallel \nmathringu_sparallel = fracu_sparallelcheckc_mathrmref = fracu_sparallelsqrt2 c_mathrmref = frachatu_sparallelsqrt2\n     hatu_sparallel = sqrt2 mathringu_sparallel \nmathringp_s = fracp_scheckn_mathrmref m_i checkc_mathrmref^2 = fracp_scheckn_mathrmref m_i 2 checkT_mathrmref = frachatp_s2\n     hatp_s = 2 mathringp_s \nmathringq_sparallel = fraccheckq_sparallelm_i checkn_mathrmref checkc_mathrmref^3 = frac2 q_sparallelm_i n_mathrmref 2^32 c_mathrmref^3 = frachatq_sparallelsqrt2\n     hatq_sparallel = sqrt2mathringq_sparallel \nmathringR_mathrmCX = fraccheckL_mathrmref checkn_mathrmref R_mathrmCXcheckc_mathrmref = fracL_mathrmref n_mathrmref R_mathrmCXsqrt2 c_mathrmref = frac1sqrt2 hatR_mathrmCX\n     hatR_mathrmCX = sqrt2 mathringR_mathrmCX \nmathringR_mathrmioniz = fraccheckL_mathrmref checkn_mathrmref R_mathrmionizcheckc_mathrmref = fracL_mathrmref n_mathrmref R_mathrmionizsqrt2 c_mathrmref = frac1sqrt2 hatR_mathrmioniz quad\n     hatR_mathrmioniz = sqrt2 mathringR_mathrmioniz \nmathringS_s = fracpi^32 checkL_mathrmref checkc_mathrmref^2 S_scheckn_mathrmref = fracpi^32 L_mathrmref 2 c_mathrmref^2 S_sn_mathrmref = 2 pi^32 hatS_s\n     hatS_s = frac12 pi^32 mathringS_s \nmathringbarS_s = fracsqrtpi checkL_mathrmref barS_scheckn_mathrmref = sqrtpi hatbarS_s\n     hatbarS_s = frac1sqrtpi mathringbarS_s \nmathringS_sn = fraccheckL_mathrmref S_sncheckc_mathrmref checkn_mathrmref = fracL_mathrmref S_snsqrt2 c_mathrmref n_mathrmref = frac1sqrt2 hatS_sn\n     hatS_sn = sqrt2 mathringS_sn \nmathringS_smathrmmom = fraccheckL_mathrmref S_smathrmmomcheckm_mathrmref checkn_mathrmref checkc_mathrmref^2 = fracL_mathrmref S_smathrmmom2 m_mathrmref n_mathrmref c_mathrmref^2 = frac12 hatS_smathrmmom\n     hatS_smathrmmom = 2 mathringS_smathrmmom \nmathringS_sE = fraccheckL_mathrmref S_sEcheckm_mathrmref checkn_mathrmref checkc_mathrmref^3 = fracL_mathrmref S_sE2^32 m_mathrmref n_mathrmref c_mathrmref^2 = frac12 sqrt2 hatS_sE\n     hatS_sE = 2 sqrt2 mathringS_sE \nmathringS_sp = fraccheckL_mathrmref S_spcheckm_mathrmref checkn_mathrmref checkc_mathrmref^3 = fracL_mathrmref S_sp2^32 m_mathrmref n_mathrmref c_mathrmref^2 = frac12 sqrt2 hatS_sp\n     hatS_sp = 2 sqrt2 mathringS_sp \nmathringS_sp_parallel = frac12 sqrt2 hatS_sp_parallel = frac32 sqrt2 hatS_sp\n     hatS_sp = frac2 sqrt23 mathringS_sp_parallel \nmathringgamma_ss = fraccheckn_mathrmref checkL_mathrmrefcheckm_mathrmref^2 checkc_mathrmref^4 gamma_ss = fracn_mathrmref L_mathrmref4 m_mathrmref^2 c_mathrmref^4 gamma_ss = frac14 hatgamma_ss\n     hatgamma_ss = 4 mathringgamma_ss \nmathringn_s = fracn_scheckn_mathrmref = hatn_s\n     hatn_s = mathringn_s \nmathringT_s = fracT_scheckT_mathrmref = fracT_scheckT_mathrmref = hatT_s\n     hatT_s = mathringT_s \nmathringL_z = fracL_zcheckL_mathrmref = hatL_z\n     hatL_z = mathringL_z \nmathringB = fracBcheckB_mathrmref = hatB\n     hatB = mathringB \nmathringm_i = fracm_im_i = 1 = hatm_i\n     hatm_i = mathringm_i \nmathringm_e = fracm_em_i = hatm_e\n     hatm_e = mathringm_e \nmathringphi = frace phicheckT_mathrmref = hatphi\n     hatphi = mathringphi \nmathringE_parallel = frace checkL_mathrmref E_parallelcheckT_mathrmref = hatE_parallel\n     hatE_parallel = mathringE_parallel \nmathringz = fraczcheckL_mathrmref = hatz\n     hatz = mathringz \nfracpartialpartial mathringz = checkL_mathrmref fracpartialpartial z = fracpartialpartial hatz\n     fracpartialpartial hatz = fracpartialpartial mathringz \nendalignat","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"In the 'old' equations a parallel-pressure source term S_sp_parallel = int m_s (v_parallel - u_sparallel)^2 bar S_s dv_parallel was used in the parallel pressure equation. In the 1D1V limit the pressure source is S_sp = int frac13 m_s (v_parallel - u_sparallel)^2 bar S_s dv_parallel = S_sp_parallel3.","category":"page"},{"location":"moment_kinetic_equations/#Old-1D1V-moment-kinetic-equations","page":"Moment kinetic equations","title":"Old 1D1V moment kinetic equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"These were the definitions and dimensionless variables used before PR #322, April 2025.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ notes using old definitions and dimensionless variables ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The following are partial notes on the derivation of the equations being solved by moment_kinetics. It would be useful to expand them with more details from the Excalibur/Neptune reports. Equation references give the report number and equation number, e.g. (TN-04;1) is equation (1) from report TN-04.pdf.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The drift kinetic equation (DKE), marginalised over v_perp, for ions is, adding ionization and a source term to the form in (TN-04;1),","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial f_ipartial t\n  +v_fracpartial f_ipartial z\n  -fracemfracpartialphipartial zfracpartial f_ipartial v_\n  = -R_mathrminleft(n_nf_i-n_if_nright)+R_mathrmionn_if_n\n    + S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and for neutrals, adding ionization and a source term to (TN-04;2)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial f_npartial t\n  +v_fracpartial f_npartial z\n  = -R_mathrminleft(n_if_n-n_nf_iright)-R_mathrmionn_if_n\n    + S_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Using the normalizations (TN04;5-11)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  tildef_s  doteq f_sfracc_ssqrtpiN_e\n  tildet  doteq tfracc_sL_z\n  tildez  doteqfraczL_z\n  tildev_  doteqfracv_c_s\n  tilden_s  doteqfracn_sN_e\n  tildephi  doteqfracephiT_e\n  tildeR_mathrmin  doteq R_mathrminfracN_eL_zc_s\n  tildeR_mathrmion  doteq R_mathrmionfracN_eL_zc_s\n  tildeS_i = S_i fracc_ssqrtpiN_e fracL_zc_s = S_i fracL_zsqrtpiN_e\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"with c_sdoteqsqrt2T_em_s where L_z, N_e and T_e are constant reference parameters, the ion DKE is","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartialtildef_ipartialtildet\n  + tildev_fracpartialtildef_ipartialtildez\n  - frac12fracpartialtildephipartialtildez\n    fracpartialtildef_ipartialtildev_\n  = -tildeR_inleft(tilden_ntildef_i-tilden_itildef_nright)\n    + tildeR_mathrmiontilden_itildef_n\n    + tildeS_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and the neutral DKE is","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartialtildef_npartialtildet\n  + v_fracpartialtildef_npartialtildez\n  = -tildeR_inleft(tilden_itildef_n-tilden_ntildef_iright)\n    - tildeR_mathrmiontilden_itildef_n\n    + tildeS_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/#Moment-equations","page":"Moment kinetic equations","title":"Moment equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Recalling the definitions (TN-04;15,29,63-66), but writing the integral in the energy equation over tildev_ instead of w_,","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  tilden_s\n   = frac1sqrtpiint dtildev_tildef_s\n\n  tilden_stildeu_s\n   = frac1sqrtpiint dtildev_tildev_tildef_s\n\n  tildep_s\n   = frac1sqrtpiint dtildev_left(tildev_\n      - tildeu_sright)^2tildef_s\n    = frac1sqrtpiint dtildev_tildev_^2tildef_s\n      - tilden_stildeu_s^2\n\n  tildeq_s\n   = frac1sqrtpiint dtildev_\n      left(tildev_-tildeu_sright)^3tildef_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  tildeq_s\n    = frac1sqrtpiint dtildev_tildev_^3tildef_s\n       - 3tildeu_sfrac1sqrtpiint dv_v_^2f_s\n       + 3u_s^2frac1sqrtpiint dv_v_f_s\n       - u_s^3frac1sqrtpiint dv_f_s \n\n    = frac1sqrtpiint dtildev_tildev_^3tildef_s\n       - 3tildeu_sleft(tildep_s+tilden_stildeu_s^2right)\n       + 3tildeu_s^2tilden_stildeu_s-tildeu_s^3tilden_s\nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  tildeq_s\n    = frac1sqrtpiint dtildev_tildev_^3tildef_s\n       - 3tildeu_stildep_s\n       - tilden_stildeu_s^3\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"we can take moments of the ion DKE to give ion moment equations (dropping tildes from here on)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial n_ipartial t+fracpartialleft(n_iu_iright)partial z\n   = -R_inleft(n_nn_i-n_in_nright)+R_mathrmionn_in_n\n      + int dv_parallel S_i\n\n   = R_mathrmionn_in_n + int dv_parallel S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartialleft(n_iu_iright)partial t + fracpartialleft(p_i\n  + n_iu_i^2right)partial z + frac12fracpartialphipartial zn_i\n  = -R_inleft(n_nn_iu_i - n_in_nu_nright)\n    + R_mathrmionn_in_nu_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  n_ifracpartial u_ipartial t + u_ifracpartial n_ipartial t\n  + fracpartial p_ipartial z\n  + u_ifracpartialleft(n_iu_iright)partial z\n  + n_iu_ifracpartial u_ipartial z\n  + frac12fracpartialphipartial zn_i\n   = -R_inleft(n_nn_iu_i - n_in_nu_nright)\n      + R_mathrmionn_in_nu_n \n\n  n_ifracpartial u_ipartial t\n  + u_ileft(R_mathrmionn_in_n + int dv_parallel S_iright)\n  + fracpartial p_ipartial z + n_iu_ifracpartial u_ipartial z\n  + frac12fracpartialphipartial zn_i\n   = -R_inleft(n_nn_iu_i - n_in_nu_nright)\n      + R_mathrmionn_in_nu_n \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial u_ipartial t + frac1n_ifracpartial p_ipartial z\n  + u_ifracpartial u_ipartial z + frac12fracpartialphipartial z\n  = -R_inn_nleft(u_i-u_nright)\n    + R_mathrmionn_in_nleft(u_n-u_iright)\n    - fracu_in_i int dv_parallel S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartialleft(p_i + n_iu_i^2right)partial t\n    + fracpartialleft(q_i + 3u_ip_i\n    + n_iu_i^3right)partial z + fracpartialphipartial zn_iu_i \n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n      - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n+n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial p_ipartial t\n  + frac1n_ifracpartialleft(n_iu_iright)^2partial t\n  - fracleft(n_iu_iright)^2n_i^2fracpartial n_ipartial t\n  + fracpartialleft(q_i + 3u_ip_i\n  + n_iu_i^3right)partial z + fracpartialphipartial zn_iu_i\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n                   - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_i \n\n  fracp_ipartial t + 2u_ifracpartial n_iu_ipartial t\n  - u_i^2fracpartial n_ipartial t + fracpartialleft(q_i\n  + 3u_ip_i + n_iu_i^3right)partial z\n  + fracpartialphipartial zn_iu_i\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n      - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_i \n\n  fracpartial p_ipartial t + 2u_ileft(-fracpartial p_ipartial z\n  - fracpartialleft(n_iu_i^2right)partial z\n  - frac12fracpartialphipartial zn_i\n  - R_inleft(n_nn_iu_i - n_in_nu_nright)\n  + R_mathrmionn_in_nu_nright) \n  -u_i^2left(-fracpartialleft(n_iu_iright)partial z\n  + R_mathrmionn_in_n + int dv_parallel S_iright)\n  + fracpartial q_ipartial z\n  + fracpartialleft(3u_ip_iright)partial z\n  + fracpartialleft(n_iu_i^3right)partial z\n  + fracpartialphipartial zn_iu_i\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n      - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_i \n\n  fracpartial p_ipartial t + u_ifracpartial p_ipartial z\n  + 3p_ifracpartial u_ipartial z + fracpartial q_ipartial z\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right) - n_ileft(p_n\n      + n_nu_n^2right) - 2u_ileft(n_nn_iu_i - n_in_nu_nright)right) \n       quad + R_mathrmionn_ileft(p_n + n_nu_n^2 + n_nu_i^2\n      - 2n_nu_iu_nright)\n      + int dv_parallel v_parallel^2 S_i + u_i^2 int dv_parallel S_i \n\n  fracpartial p_ipartial t + u_ifracpartial p_ipartial z\n  + 3p_ifracpartial u_ipartial z + fracpartial q_ipartial z\n   = -R_inleft(n_np_i - n_ip_n - n_in_nleft(u_i^2 + u_n^2\n      - 2u_iu_nright)right) + R_mathrmionn_ileft(p_n + n_nleft(u_n\n      - u_iright)^2right) \n       quad + int dv_parallel v_parallel^2 S_i + u_i^2 int dv_parallel S_i \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial p_ipartial t + u_ifracpartial p_ipartial z\n    + 3p_ifracpartial u_ipartial z + fracpartial q_ipartial z \n   = -R_inleft(n_np_i - n_ip_n\n      - n_in_nleft(u_i - u_nright)^2right)\n      + R_mathrmionn_ileft(p_n + n_nleft(u_n - u_iright)^2right) \n       quad + int dv_parallel v_parallel^2 S_i + u_i^2 int dv_parallel S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and of the neutral DKE to give neutral moment equations","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial n_npartial t + fracpartialleft(n_nu_nright)partial z\n   = -R_ileft(n_in_n - n_nn_iright) - R_mathrmionn_in_n\n      + int dv_parallel S_n \n\n   =-R_mathrmionn_in_n + int dv_parallel S_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartialleft(n_nu_nright)partial t\n  + fracpartialleft(p_n + n_nu_n^2right)partial z\n  = -R_inleft(n_in_nu_n - n_nn_iu_iright)\n    - R_mathrmionn_in_nu_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  n_nfracpartial u_npartial t + u_nfracpartial n_npartial t\n  + fracpartial p_npartial z\n  + u_nfracpartialleft(n_nu_nright)partial z\n  + n_nu_nfracpartial u_npartial z\n   = -R_inleft(n_in_nu_n - n_nn_iu_iright)\n      - R_mathrmionn_in_nu_n \n\n  n_nfracpartial u_npartial t\n  + u_nleft(-R_mathrmionn_in_n + int dv_parallel S_nright)\n  + fracpartial p_npartial z\n  + n_nu_sfracpartial u_npartial z\n   = -R_inleft(n_in_nu_n - n_nn_iu_iright)\n      - R_mathrmionn_in_nu_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial u_npartial t + frac1n_nfracpartial p_npartial z\n  + u_nfracpartial u_npartial z\n  = -R_inn_ileft(u_n - u_iright) - fracu_nn_n int dv_parallel S_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartialleft(p_n + n_nu_n^2right)partial t\n    + fracpartialleft(q_n + 3u_np_n\n    + n_nu_n^3right)partial z + q_nfracpartialphipartial zn_nu_n \n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right)right)\n      - R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial p_npartial t\n  + frac1n_nfracpartialleft(n_nu_nright)^2partial t\n  - fracleft(n_nu_nright)^2n_n^2fracpartial n_npartial t\n  + fracpartialleft(q_n + 3u_np_n + n_nu_n^3right)partial z\n  + q_nfracpartialphipartial zn_nu_n\n   =-R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right)right)\n      - R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_n \n\n  fracpartial p_npartial t + 2u_nfracpartial n_nu_npartial t\n  - u_n^2fracpartial n_npartial t + fracpartialleft(q_n\n  + 3u_np_n + n_nu_n^3right)partial z\n  + q_nfracpartialphipartial zn_nu_n\n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right)right) - R_mathrmionn_ileft(p_n\n      + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_n \n\n  fracpartial p_npartial t\n  + 2u_nleft(-fracpartial p_npartial z\n  - fracpartialleft(n_nu_n^2right)partial z\n  - fracq_n2fracpartialphipartial zn_n\n  - R_inleft(n_in_nu_n - n_nn_iu_iright)\n  - R_mathrmionn_in_nu_nright) \n  - u_n^2left(-fracpartialleft(n_nu_nright)partial z\n  - R_mathrmionn_in_n + int dv_parallel S_nright)\n  + fracpartial q_npartial z\n  + fracpartialleft(3u_np_nright)partial z\n  + fracpartialleft(n_nu_n^3right)partial z\n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n  + n_iu_i^2right)right)\n  - R_mathrmionn_ileft(p_n + n_nu_n^2right)\n  + int dv_parallel v_parallel^2 S_n \n\n  fracpartial p_npartial t + u_nfracpartial p_npartial z\n  + 3p_nfracpartial u_npartial z + fracpartial q_npartial z\n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right) - 2u_nleft(n_in_nu_n\n      - n_nn_iu_iright)right) - R_mathrmionn_ileft(p_n\n      + n_nu_n^2 + n_nu_n^2 - 2n_nu_nu_nright)\n      + int dv_parallel v_parallel^2 S_n + u_n^2int dv_parallel S_n \n\n  fracpartial p_npartial t + u_nfracpartial p_npartial z\n  + 3p_nfracpartial u_npartial z + fracpartial q_npartial z\n   = -R_inleft(n_ip_n - n_np_i - n_nn_ileft(u_n^2 + u_i^2\n      - 2u_nu_iright)right) - R_mathrmionn_ip_n\n      + int dv_parallel v_parallel^2 S_n + u_n^2int dv_parallel S_n \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial p_npartial t + u_nfracpartial p_npartial z\n    + 3p_nfracpartial u_npartial z + fracpartial q_npartial z \n   = -R_inleft(n_ip_n - n_np_i\n      - n_nn_ileft(u_n - u_iright)^2right) - R_mathrmionn_ip_n \n       quad + int dv_parallel v_parallel^2 S_n + u_n^2int dv_parallel S_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Kinetic-equation","page":"Moment kinetic equations","title":"Kinetic equation","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"For the moment-kinetic equation for the normalized distribution function","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ng_s(w_s) = fracv_mathrmthsn_sf_s(v_(w_s))\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"we transform to the normalized velocity coordinate","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nw_s = fracv_ - u_sv_mathrmths\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The derivatives transform as","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  leftfracpartial f_spartial tright_zv\n   rightarrowleftfracpartial f_spartial tright_zw\n               - frac1v_mathrmthsfracpartial u_spartial tleftfracpartial f_spartial w_sright_zt\n               - fracw_sv_mathrmthsfracpartial v_mathrmthspartial tleftfracpartial f_spartial w_sright_zt\n\n  leftfracpartial f_spartial zright_zv\n   rightarrowleftfracpartial f_spartial zright_tw\n               - frac1v_mathrmthsfracpartial u_spartial zleftfracpartial f_spartial w_sright_zt\n               - fracw_sv_mathrmthsfracpartial v_mathrmthspartial zleftfracpartial f_spartial w_sright_zwt\n\n  leftfracpartial f_spartial v_right_zv\n   rightarrowfrac1v_mathrmthsleftfracpartial f_spartial w_sright_zt\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"We use an energy equation that evolves p_s not v_mathrmths, so use","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  v_mathrmths^2  = 2fracp_sn_s \n\n  Rightarrow v_mathrmthsfracpartial v_mathrmthspartial t\n   = frac1n_sfracpartial p_spartial t\n      - fracp_sn_s^2fracpartial n_spartial t\n\n  v_mathrmthsfracpartial v_mathrmthspartial z\n   = frac1n_sfracpartial p_spartial z\n      - fracp_sn_s^2fracpartial n_spartial z\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"to convert the transformations above to","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  leftfracpartial f_spartial tright_zv\n   rightarrowleftfracpartial f_spartial tright_zw\n    - frac1v_mathrmthsfracpartial u_spartial tleftfracpartial f_spartial w_sright_zw\n    - fracw_sv_mathrmths^2left(frac1n_sfracpartial p_spartial t\n    - fracp_sn_s^2fracpartial n_spartial tright)leftfracpartial f_spartial w_sright_zw\n\n   = leftfracpartial f_spartial tright_zw\n      - frac1v_mathrmthsfracpartial u_spartial tleftfracpartial f_spartial w_sright_zw\n      - fracw_s2left(frac1p_sfracpartial p_spartial t\n      - frac1n_sfracpartial n_spartial tright)leftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial zright_zv\n   rightarrowleftfracpartial f_spartial zright_zw\n    - frac1v_mathrmthsfracpartial u_spartial zleftfracpartial f_spartial w_sright_zw\n    - fracw_sv_mathrmths^2left(frac1n_sfracpartial p_spartial z\n    - fracp_sn_s^2fracpartial n_spartial zright)leftfracpartial f_spartial w_sright_zw\n\n   = leftfracpartial f_spartial zright_zw\n      - frac1v_mathrmthsfracpartial u_spartial zleftfracpartial f_spartial w_sright_zw\n      - fracw_s2left(frac1p_sfracpartial p_spartial z\n      - frac1n_sfracpartial n_spartial zright)leftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial v_right_zv\n   rightarrowfrac1v_mathrmthsleftfracpartial f_spartial w_sright_zw\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Using these transformations gives the ion DKE in a form similar to (TN-04;55) (but writing out dotw_ in full here, and not using the moment equations for the moment)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_ipartial t\n    - frac1v_mathrmthifracpartial u_ipartial tfracpartial f_ipartial w_i\n    - fracw_i2left(frac1p_ifracpartial p_ipartial t\n    - frac1n_ifracpartial n_ipartial tright)fracpartial f_ipartial w_i \n   + left(v_mathrmthiw_i + u_iright)left(fracpartial f_ipartial z\n    - frac1v_mathrmthifracpartial u_ipartial zfracpartial f_ipartial w_i\n    - fracw_i2left(frac1p_ifracpartial p_ipartial z\n    - frac1n_ifracpartial n_ipartial zright)fracpartial f_ipartial w_iright) \n   - frac12v_mathrmthifracpartialphipartial zfracpartial f_ipartial w_i \n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n + S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial f_ipartial t + left(v_mathrmthiw_i\n  + u_iright)fracpartial f_ipartial z\n  - frac1v_mathrmthifracpartial u_ipartial tfracpartial f_ipartial w_i\n  - fracw_i2left(frac1p_ifracpartial p_ipartial t\n  - frac1n_ifracpartial n_ipartial tright)fracpartial f_ipartial w_i\n  + left(v_mathrmthiw_i\n  + u_iright)left(-frac1v_mathrmthifracpartial u_ipartial zfracpartial f_ipartial w_i\n  - fracw_i2left(frac1p_ifracpartial p_ipartial z\n  - frac1n_ifracpartial n_ipartial zright)fracpartial f_ipartial w_iright)\n  - frac12v_mathrmthifracpartialphipartial zfracpartial f_ipartial w_i\n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n + S_i \n\n  fracpartial f_ipartial t + left(v_mathrmthiw_i\n  + u_iright)fracpartial f_ipartial z\n  + left-frac1v_mathrmthifracpartial u_ipartial t\n  - fracw_i2left(frac1p_ifracpartial p_ipartial t\n  - frac1n_ifracpartial n_ipartial tright)\n  + left(v_mathrmthiw_i\n  + u_iright)left(-frac1v_mathrmthifracpartial u_ipartial z\n  - fracw_i2left(frac1p_ifracpartial p_ipartial z\n  - frac1n_ifracpartial n_ipartial zright)right)\n  - frac12v_mathrmthifracpartialphipartial zrightfracpartial f_ipartial w_i\n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n + S_i \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_ipartial t + left(v_mathrmthiw_i\n    + u_iright)fracpartial f_ipartial z \n   + left-frac1v_mathrmthileft(fracpartial u_ipartial t\n    + left(v_mathrmthiw_i + u_iright)fracpartial u_ipartial z\n    + frac12fracpartialphipartial zright)right \n   qquad - fracw_i2frac1p_ileft(fracpartial p_ipartial t\n          + left(v_mathrmthiw_i + u_iright)fracpartial p_ipartial zright) \n   qquad + fracw_i2frac1n_ileft(fracpartial n_ipartial t\n          + left(v_mathrmthiw_i\n          + leftu_iright)fracpartial n_ipartial zright)rightfracpartial f_ipartial w_i \n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n + S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and the neutral DKE","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_npartial t\n    - frac1v_mathrmthnfracpartial u_npartial tfracpartial f_npartial w_n\n    - fracw_n2left(frac1p_nfracpartial p_npartial t\n    - frac1n_nfracpartial n_npartial tright)fracpartial f_npartial w_n \n   + left(v_mathrmthnw_n + u_nright)left(fracpartial f_npartial z\n    - frac1v_mathrmthnfracpartial u_npartial zfracpartial f_npartial w_n\n    - fracw_n2left(frac1p_nfracpartial p_npartial z\n    - frac1n_nfracpartial n_npartial zright)fracpartial f_npartial w_nright) \n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n + S_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial f_npartial t + left(v_mathrmthnw_n\n  + u_nright)fracpartial f_npartial z\n  - frac1v_mathrmthnfracpartial u_npartial tfracpartial f_npartial w_n\n  - fracw_n2left(frac1p_nfracpartial p_npartial t\n  - frac1n_nfracpartial n_npartial tright)fracpartial f_npartial w_n\n  + left(v_mathrmthnw_n\n  + u_nright)left(-frac1v_mathrmthnfracpartial u_npartial zfracpartial f_npartial w_n\n  - fracw_n2left(frac1p_nfracpartial p_npartial z\n  - frac1n_nfracpartial n_npartial zright)fracpartial f_npartial w_nright)\n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n + S_n \n\n  fracpartial f_npartial t + left(v_mathrmthnw_n\n  + u_nright)fracpartial f_npartial z\n  + left-frac1v_mathrmthnfracpartial u_npartial t\n  - fracw_n2left(frac1p_nfracpartial p_npartial t\n  - frac1n_nfracpartial n_npartial tright) + left(v_mathrmthnw_n\n  + u_nright)left(-frac1v_mathrmthnfracpartial u_npartial z\n  - fracw_n2left(frac1p_nfracpartial p_npartial z\n  - frac1n_nfracpartial n_npartial zright)right)rightfracpartial f_npartial w_n\n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n + S_n \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_npartial t + left(v_mathrmthnw_n\n    + u_nright)fracpartial f_npartial z \n   + left-frac1v_mathrmthnleft(fracpartial u_npartial t\n    + left(v_mathrmthnw_n+u_nright)fracpartial u_npartial zright)right \n   qquad - fracw_n2frac1p_nleft(fracpartial p_npartial t\n           + left(v_mathrmthnw_n + u_nright)fracpartial p_npartial zright) \n   qquad + leftfracw_n2frac1n_nleft(fracpartial n_npartial t\n           + left(v_mathrmthnw_n\n           + u_nright)fracpartial n_npartial zright)rightfracpartial f_npartial w_n \n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n + S_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"We also normalise f and write the DKEs for","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  g_s  =fracv_mathrmthsn_sf_s \n\n  Rightarrowfracpartial f_spartial t\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n  + fracg_sv_mathrmthsfracpartial n_spartial t\n  - fracn_sg_sv_mathrmths^2fracpartial v_mathrmthspartial t \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial f_spartial t\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n      + fracg_sv_mathrmthsfracpartial n_spartial t\n      - fracn_sg_sv_mathrmths^3left(frac1n_sfracpartial p_spartial t\n      - fracp_sn_s^2fracpartial n_spartial tright) \n\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n      + fracg_sv_mathrmthsfracpartial n_spartial t\n      - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial t\n      + fracg_s2v_mathrmthsfracpartial n_spartial t \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial f_spartial t\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n      + frac3g_s2v_mathrmthsfracpartial n_spartial t\n      - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial t \n\n  fracpartial f_spartial z\n   = fracn_sv_mathrmthsfracpartial g_spartial z\n      + frac3g_s2v_mathrmthsfracpartial n_spartial z\n      - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial z \n\n  fracpartial f_spartial w_s\n   = fracn_sv_mathrmthsfracpartial g_spartial w_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"For brevity, do the following manipulations for g_s rather than for ions and neutrals separately by using q_i=1, q_n=0 and with the +'ve sign for the ion DKE and -'ve sign for the neutral DKE.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracn_sv_mathrmthsfracpartial g_spartial t\n  + frac3g_s2v_mathrmthsfracpartial n_spartial t\n  - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial t \n   + fracn_sv_mathrmths left(v_mathrmthsw_s + u_sright)fracpartial g_spartial z\n  + frac3 g_s2 v_mathrmths left(v_mathrmthsw_s + u_sright) fracpartial n_spartial z\n  - fracg_s n_s2 v_mathrmths p_parallels left(v_mathrmthsw_s + u_sright) fracpartial p_parallelspartial z \n   + left-frac1v_mathrmthsleft(fracpartial u_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial u_spartial z\n  + fracq_s2fracpartialphipartial zright)right \n   qquad - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright) \n   qquad + leftfracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracn_sv_mathrmthsfracpartial g_spartial w_s \n   = -R_ssleft(n_sfracn_sv_mathrmthsg_s\n      - n_sfracn_sv_mathrmthsg_sright)\n      pm R_mathrmionn_ifracn_nv_mathrmthng_n\n      + S_s \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial g_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t\n  + frac3 g_s2 n_s left(v_mathrmthsw_s + u_sright) fracpartial n_spartial z\n  - fracg_s2 p_parallels left(v_mathrmthsw_s + u_sright) fracpartial p_parallelspartial z \n   + left-frac1v_mathrmthsleft(fracpartial u_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial u_spartial z\n  + fracq_s2fracpartialphipartial zright)\n  - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright)\n  + fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s \n\n  Rightarrow  fracpartial g_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial g_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t\n  + frac3 g_s2 n_s left(v_mathrmthsw_s + u_sright) fracpartial n_spartial z\n  - fracg_s2 p_parallels left(v_mathrmthsw_s + u_sright) fracpartial p_parallelspartial z \n   + left-frac1v_mathrmthsleft(fracn_sn_sfracpartial u_spartial t\n  + fracn_sn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial u_spartial z\n  + fracu_sn_sleft(fracpartial npartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial npartial zright)\n  + fracq_s2fracpartialphipartial zright)\n  + fracu_sn_sv_mathrmthsleft(fracpartial npartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial npartial zright)\n  - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright)\n  + fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial g_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t\n  + frac3 g_s2 n_s left(v_mathrmthsw_s + u_sright) fracpartial n_spartial z\n  - fracg_s2 p_parallels left(v_mathrmthsw_s + u_sright) fracpartial p_parallelspartial z \n   + left-frac1n_sv_mathrmthsleft(fracpartial n_su_spartial t\n  + left(v_mathrmthsw_s + u_sright)left(n_sfracpartial u_spartial z\n  + u_sfracpartial n_spartial zright)\n  + fracq_s2n_sfracpartialphipartial zright)right \n   qquad + fracu_sn_sv_mathrmthsleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial n_spartial zright)\n  - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright) \n   qquad left+ fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"So then if we use the moment equations we can rewrite the DKE as","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial g_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial g_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t\n  + frac3 g_s2 n_s left(v_mathrmthsw_s + u_sright) fracpartial n_spartial z\n  - fracg_s2 p_parallels left(v_mathrmthsw_s + u_sright) fracpartial p_parallelspartial z \n   + left-frac1n_sv_mathrmthsleft(fracpartial n_su_spartial t\n  + u_sleft(n_sfracpartial u_spartial z\n  + u_sfracpartial n_spartial zright)\n  - frac12n_sE_\n  + v_mathrmthsw_sleft(n_sfracpartial u_spartial z\n  + u_sfracpartial n_spartial zright)right)right \n   qquad + fracu_sn_sv_mathrmthsleft(fracpartial n_spartial t\n  + u_sfracpartial n_spartial z\n  + v_mathrmthsw_sfracpartial n_spartial zright) \n   qquad-fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + u_sfracpartial p_spartial z\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   qquadleft + fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + u_sfracpartial n_spartial z\n  + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  Rightarrow  fracpartial g_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial g_spartial z\n  + frac3g_s2n_sleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  - cancelu_sfracpartial n_spartial z\n  - n_sfracpartial u_spartial z\n  + left(v_mathrmthsw_s + cancelu_sright) fracpartial n_spartial z right) \n   -fracg_s2p_sleft(-cancelu_sfracpartial p_spartial z\n  - fracpartial q_spartial z\n  - 3p_sfracpartial u_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n - u_sright)^2right)\n  + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + left(v_mathrmthsw_s + cancelu_sright) fracpartial p_parallelspartial z right) \n   + left-frac1n_sv_mathrmthsleft(-underbracecanceln_su_sfracpartial u_spartial z_A\n  - fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)\n  pm R_mathrmionn_in_nu_n\n  + v_mathrmthsw_sleft(underbracecanceln_sfracpartial u_spartial z_B\n  + underbracecancelu_sfracpartial n_spartial z_Cright)right)right \n   quad + fracu_sn_sv_mathrmthsleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  - underbracecanceln_sfracpartial u_spartial z_A\n  + underbracecancelv_mathrmthsw_sfracpartial n_spartial z_Cright) \n   quad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - underbracecancel3p_sfracpartial u_spartial z_B\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n\n  - u_sright)^2right) + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   quadleft + fracw_s2frac1n_sleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  - underbracecanceln_sfracpartial u_spartial z_B\n  + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s \n\n  Rightarrow  fracpartial g_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial g_spartial z\n  + frac3g_s2n_sleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  + v_mathrmths w_parallels fracpartial n_spartial z - n_sfracpartial u_spartial zright) \n   -fracg_s2p_sleft(v_mathrmths w_parallelsfracpartial p_spartial z\n  - fracpartial q_spartial z - 3p_sfracpartial u_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n - u_sright)^2right)\n  + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_sright) \n   + left-frac1n_sv_mathrmthsleft(-fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)pm R_mathrmionn_in_nu_nright)right \n   quad + fracu_sn_sv_mathrmthsleft(pm R_mathrmionn_in_n + int dv_parallel S_sright) \n   quad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n\n  - u_sright)^2right) + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   quadleft + fracw_s2frac1n_sleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s\n\n  Rightarrow  fracpartial g_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial g_spartial z\n  + g_sleft(pmfrac32R_mathrmionn_ifracn_nn_s\n  + frac32n_sint dv_parallel S_s\n  + frac3 v_mathrmths w_parallels2n_sfracpartial n_spartial zright) \n   + g_sleft(-fracv_mathrmths w_parallels2p_sfracpartial p_spartial z\n  + frac12p_sfracpartial q_spartial z\n  + frac12p_sR_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right)\n  mpfrac12R_mathrmionfracn_ip_sleft(p_n\n  + n_nleft(u_n - u_sright)^2right)\n  - frac12p_parallelsint dv_parallel v_parallel^2 S_s - fracu_s^22p_parallelsint dv_parallel S_sright) \n   + left-frac1n_sv_mathrmthsleft(-fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)\n  pm R_mathrmionn_in_nleft(u_n - u_sright) - u_sint dv_parallel S_sright)right \n   quad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right)\n  + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   quadmpfracw_s2R_mathrmionn_ileft(fracp_np_s\n  - fracn_nn_s + fracn_np_sleft(u_n - u_sright)^2right) \n   quadleft + fracw_s2frac1n_sleft(int dv_parallel S_s + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n + fracv_mathrmthsn_s S_s\nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and finally using","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  -w_parallelsfracpartial v_mathrmthspartial z\n   =-fracv_mathrmths w_parallelsv_mathrmthsfracpartial v_mathrmthspartial z \n   =-v_mathrmths w_parallelssqrtfracn_sp_sfracpartialpartial zsqrtfracp_sn_s \n   = fracv_mathrmths w_parallels2left(-frac1p_sfracpartial p_spartial z\n      + frac1n_sfracpartial n_spartial zright)\nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"gives","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial g_spartial z\n  + left(pmfrac32R_mathrmionn_ifracn_nn_s\n  + frac32n_s int dv_parallel S_s\n  + fracv_mathrmths w_parallelsn_sfracpartial n_spartial zright)g_s \n   + left(-w_parallelsfracpartial v_mathrmthspartial z\n  + frac12p_sfracpartial q_spartial zright \n   qquad + frac12p_sR_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right) \n   qquad leftmpfrac12R_mathrmionfracn_ip_sleft(p_n\n  + n_nleft(u_n - u_sright)^2right)\n  - frac12p_parallelsint dv_parallel v_parallel^2 S_s - fracu_s^22p_parallelsint dv_parallel S_sright)g_s \n   + left-frac1n_sv_mathrmthsleft(-fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)\n  pm R_mathrmionn_in_nleft(u_n - u_sright) - u_sint dv_parallel S_sright)right \n   qquad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right)\n  + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   qquadmpfracw_s2R_mathrmionn_ileft(fracp_np_s\n  - fracn_nn_s + fracn_np_sleft(u_n - u_sright)^2right) \n   qquadleft + fracw_parallels2frac1n_sint dv_parallel S_s\n  + fracw_s^22fracv_mathrmthsn_sfracpartial n_spartial zrightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n + fracv_mathrmthsn_s S_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Writing out the final result fully for ions","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial g_ipartial t\n  + left(v_mathrmthiw_i + u_iright)fracpartial g_ipartial z\n  + left(frac32R_mathrmionn_n + frac32n_iint dv_parallel S_i\n  + fracv_mathrmthi w_parallelin_ifracpartial n_ipartial zright)g_i \n   + left(-w_parallelifracpartial v_mathrmthipartial z\n  + frac12p_ifracpartial q_ipartial zright \n   qquad + frac12p_iR_inleft(n_np_i - n_ip_n\n  - n_in_nleft(u_i - u_nright)^2right) \n   qquad left - frac12R_mathrmionfracn_ip_ileft(p_n\n  + n_nleft(u_n - u_iright)^2right)\n  - frac12p_paralleliint dv_parallel v_parallel^2 S_i - fracu_i^22p_paralleliint dv_parallel S_iright)g_i \n   + left-frac1n_iv_mathrmthileft(-fracpartial p_ipartial z\n  + R_inn_in_nleft(u_n - u_iright)\n  + R_mathrmionn_in_nleft(u_n - u_iright) - u_iint dv_parallel S_iright)right \n   qquad-fracw_i2frac1p_ileft(-fracpartial q_ipartial z\n  - R_inleft(n_np_i - n_ip_n\n  - n_in_nleft(u_i - u_nright)^2right)\n  + int dv_parallel v_parallel^2 S_i + u_i^2 int dv_parallel S_i\n  + v_mathrmthiw_ifracpartial p_ipartial zright) \n   qquad - fracw_i2R_mathrmionn_ileft(fracp_np_i\n  - fracn_nn_i + fracn_np_ileft(u_n - u_iright)^2right) \n   qquadleft + fracw_paralleli2 frac1n_iint dv_parallel S_i\n  + fracw_i^22fracv_mathrmthin_ifracpartial n_ipartial zrightfracpartial g_ipartial w_i \n   = -R_inn_nleft(g_i - fracv_mathrmthiv_mathrmthng_nright)\n      + R_mathrmionv_mathrmthifracn_nv_mathrmthng_n + fracv_mathrmthin_i S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and for neutrals where several of the ionization terms cancel","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_npartial t\n  + left(v_mathrmthnw_n + u_nright)fracpartial f_npartial z\n  + left(-frac32R_mathrmionn_i + frac32n_nint dv_parallel S_n\n  + fracv_mathrmthn w_parallelnn_nfracpartial n_npartial zright)g_n \n   + left(-w_parallelnfracpartial v_mathrmthnpartial z\n  + frac12p_nfracpartial q_npartial zright \n   qquad left + frac12p_nR_inleft(n_ip_n - n_np_i\n  - n_nn_ileft(u_n - u_iright)^2right)\n  + frac12R_mathrmionn_i\n  - frac12p_parallelnint dv_parallel v_parallel^2 S_n - fracu_n^22p_parallelnint dv_parallel S_nright)g_n \n   + left-frac1n_nv_mathrmthnleft(-fracpartial p_npartial z\n  + R_inn_nn_ileft(u_i - u_nright) - u_nint dv_parallel S_nright)right \n   qquad-fracw_n2frac1p_nleft(-fracpartial q_npartial z\n  - R_inleft(n_ip_n - n_np_i\n  - n_nn_ileft(u_n - u_iright)^2right)\n  + int dv_parallel v_parallel^2 S_n + u_n^2int dv_parallel S_n\n  + v_mathrmthnw_nfracpartial p_npartial zright) \n   qquadleft + fracw_paralleln2frac1n_nint dv_parallel S_n\n  + fracw_n^22fracv_mathrmthnn_nfracpartial n_npartial zrightfracpartial g_npartial w_n \n   = -R_inn_ileft(g_n - fracv_mathrmthnv_mathrmthig_iright)\n      - R_mathrmionn_ig_n + fracv_mathrmthnn_n S_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"zz_ionization/#ionization","page":"ionization","title":"ionization","text":"","category":"section"},{"location":"zz_ionization/#moment_kinetics.ionization","page":"ionization","title":"moment_kinetics.ionization","text":"\n\n\n\n","category":"module"},{"location":"zz_moment_kinetics_input/#moment_kinetics_input","page":"moment_kinetics_input","title":"moment_kinetics_input","text":"","category":"section"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input","text":"\n\n\n\n","category":"module"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_coordinate_input-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_coordinate_input","text":"Check input for a coordinate\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input-NTuple{13, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input","text":"check various input options to ensure they are all valid/consistent\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input_initialization-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input_initialization","text":"\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input_time_advance-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input_time_advance","text":"\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.mk_input","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.mk_input","text":"Process user-supplied inputs\n\nsave_inputs_to_txt should be true when actually running a simulation, but defaults to false for other situations (e.g. when post-processing).\n\nignore_MPI should be false when actually running a simulation, but defaults to true for other situations (e.g. when post-processing).\n\n\n\n\n\n","category":"function"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.read_input_file-Tuple{String}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.read_input_file","text":"Read input from a TOML file\n\n\n\n\n\n","category":"method"},{"location":"developing/#Developing","page":"Developing","title":"Developing","text":"","category":"section"},{"location":"developing/#Dependencies","page":"Developing","title":"Dependencies","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"If you need to add a dependency, start the REPL with the moment_kinetics package activated (see above), enter pkg> mode (press ]) and then to add, for example, the FFTW.jl package enter","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"(moment_kinetics) pkg> add FFTW","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"This should take care of adding the package (FFTW) to the Project.toml and Manifest.toml files.","category":"page"},{"location":"developing/#Revise.jl","page":"Developing","title":"Revise.jl","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"When working on the code, one way to avoid waiting for everything to recompile frequently is to load the Revise.jl package","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> using Revise","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Revise.jl will recompile each edited function/method as needed, so it is possible to keep a REPL session open and avoid long recompilation. moment_kinetics can be run fairly conveniently from the REPL","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> using moment_kinetics\njulia> run_moment_kinetics(input)","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"where input is a Dict() containing any non-default options desired. Input can also be loaded from a TOML file passing the filaname as a String to the second argument, e.g.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> run_moment_kinetics(\"input.toml\")","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It might be convenient to add using Revise to your startup.jl file (~/julia/config/startup.jl) so it's always loaded.","category":"page"},{"location":"developing/#Input-options-and-defaults","page":"Developing","title":"Input options and defaults","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"The input is read from a .toml file. It is also written to the output HDF5 (or NetCDF) file, after all defaults are applied, both as a TOML-formatted String and as a tree of HDF5 variables.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"warning: Warning\nNeither TOML nor HDF5 have a 'null' type, so there is no convenient way to store Julia's nothing when writing to TOML or HDF5.  Therefore nothing should not be used as a default for any input option. If the code should use nothing as a default for some setting, that is fine, but must be done after the input is read, and not stored in the input_dict.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"warning: Parallel I/O consistency\nTo ensure consistency between all MPI ranks in the order of reads and/or writes when using Parallel I/O, all dictionary types used to store options must be either OrderedDict or SortedDict, so that their order of entries is deterministic (which is not the case for Dict, which instead optimises for look-up speed). This should mostly be taken care of by using moment_kinetics's OptionsDict type (which is an alias for OrderedDict{String,Any}). We also need to sort the input after it is read by TOML, which is taken care of by moment_kinetics.input_structs.convert_to_sorted_nested_OptionsDict. See also Parallel I/O.","category":"page"},{"location":"developing/#Array-types","page":"Developing","title":"Array types","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"Most arrays in moment_kinetics are declared using a custom array type moment_kinetics.type_definitions.MPISharedArray. Most of the time this type is just an alias for Array, and so it needs the same template parameters (see Julia's Array documentation) - the data type and the number of dimensions, e.g. MPISharedArray{mk_float,3}. Although these arrays use shared memory, Julia does not know about this. We use MPI.Win_allocate_shared() to allocate the shared memory, then wrap it in an Array in moment_kinetics.communication.allocate_shared.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The reason for using the alias, is that when the shared-memory debugging mode is activated, we instead create arrays using a type DebugMPISharedArray, which allows us to track some debugging information along with the array, see Shared memory debugging, and make MPISharedArray an alias for DebugMPISharedArray instead. The reason for the alias is that if we declared our structs with just Array type, then when debugging is activated we would not be able to store DebugMPISharedArray instances in those structs, and if we declared the structs with AbstractArray, they would not be concretely typed, which could impact performance by creating code that is not 'type stable' (i.e. all concrete types are known at compile time).","category":"page"},{"location":"developing/#Timings","page":"Developing","title":"Timings","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"Checking the timings of different parts of the code can be useful to check that performance problems are not introduced. Excessive allocations can also be a sign of type instability (or other problems) that could impact performance. To monitor these things, moment_kinetics uses a TimerOutput object moment_kinetics.timer_utils.global_timer.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The timings and allocation counts from the rank-0 MPI process are printed to the terminal at the end of a run. The same information is also saved to the output file as a string for quick reference - one way to view this is","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"$ h5dump -d /timing_data/global_timer_string my_output_file.moments.h5","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"More detailed timing information is saved for each MPI rank into subgroups rank<i> of the timing_data group in the output file. This information can be plotted using makie_post_processing.timing_data. The plots contain many curves. Filtering out the ones you are not interested in (using the include_patterns, exclude_patterns, and/or ranks arguments) can help, but it still may be useful to have interactive plots which show the label and MPI rank when you hover over a curve. For example","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> using makie_post_processing, GLMakie\njulia> ri = get_run_info(\"runs/my_example_run/\")\njulia> timing_data(ri; interactive_figs=:times);","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Here using GLMakie selects the Makie backend that provides interactive plots, and the interactive_figs argument specifies that timing_data() should make an interactive plot (in this case for the execution times).","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Lower level timing data, for example timing MPI and linear-algebra calls, can be enabled by activating 'debug timing'. This can be done by re-defining the function moment_kinetics.timer_utils.timeit_debug_enabled to return true - not the most user-friendly interface (!) but this feature is probably only needed while developing/profiling/debugging.","category":"page"},{"location":"developing/#Parallelization","page":"Developing","title":"Parallelization","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"The code is parallelized at the moment using MPI and shared-memory arrays. Arrays representing the pdf, moments, etc. are shared between all processes. Using shared memory means, for example, we can take derivatives along one dimension while parallelising the other for any dimension without having to communicate to re-distribute the arrays. Using shared memory instead of (in future as well as) distributed memory parallelism has the advantage that it is easier to split up the points within each element between processors, giving a finer-grained parallelism which should let the code use larger numbers of processors efficiently.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It is possible to use a REPL workflow with parallel code:","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Recommended option is to use tmpi. This utility (it's a bash script that uses tmux) starts an mpi program with each process in a separate pane in a single terminal, and mirrors input to all processes simultaneously (which is normally what you want, there are also commands to 'zoom in' on a single process).\nAnother 'low-tech' possibilty is to use something like mpirun -np 4 xterm -e julia --project, but that will start each process in a separate xterm and you would have to enter commands separately in each one. Occasionally useful for debugging when nothing else is available.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"There is no restriction on the number of processes or number of grid points, although load-balancing may be affected - if there are only very few points per process, and a small fraction of processes have an extra grid point (e.g. splitting 5 points over 4 processes, so 3 process have 1 point but 1 process has 2 points), many processes will spend time waiting for the few with an extra point.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Parallelism is implemented through macros that get the local ranges of points that each process should handle. The inner-most level of nested loops is typically not parallelized, to allow efficient FFTs for derivatives, etc. A loop over one (possibly parallelized) dimension can be written as, for example,","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s is begin\n    f[is] = ...\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"These macros can be nested as needed for relatively complex loops","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s is begin\n    some_setup(is)\n    @loop_z iz begin\n        @views do_something(f[:,iz,is])\n    end\n    @loop_z iz begin\n        @views do_something_else(f[:,iz,is])\n    end\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Simpler nested loops can (optionally) be written more compactly","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s_z_vpa is iz ivpa begin\n    f[ivpa,iz,is] = ...\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Which dimensions are actually parallelized by these macros is controlled by the 'region' that the code is currently in, as set by the @begin_<dims>_region() macros, where <dims> are the dimensions that will be parallelized in the following region. For example, after calling @begin_s_z_region() loops over species and z will be divided up over the processes in a 'block' (currently there is only one block, which contains the whole grid and all the processes being used, as we have not yet implemented distributed-memory parallelism). Every process will loop over all points in the remaining dimensions if the loop macros for those dimensions are called.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The recommended place to put @begin_*_region() calls is at the beginning of a function whose contents should use loops parallelised according to the settings for that region.\nEach @begin_*_region() function checks if the region it would set is already active, and if so returns immediately (doing nothing). This means that @begin_*_region() can (and should) be used to mark a block of code as belonging to that region, and if moment_kinetics is already in that region type, the call will have essentially zero cost.\nIn some places it may be necessary to change the region type half way through a function, etc. This is fine.\nWhen choosing which region type to select, note that all 'parallelised dimensions' must be looped over for each operation (otherwise some points may be written more than once), unless some special handling is used (e.g. species dimension s is parallelised, but a conditional like if 1 in loop_ranges[].s is wrapped around code to be executed so that only processes which should handle the point at s=1 do anything). It may be more optimal in some places to choose region types that do not parallelise all possible dimensions, to reduce the number of synchronisations that are needed.\nAs a matter of style, it is recommended to place @begin_*_region() calls within functions where the loops are (or at most one level above), so that it is not necessary to search back along the execution path of the code to find the most recent @begin_*_region() call, and therefore know what region type is active.\nIn a region after @begin_serial_region(), the rank 0 process in each block will loop over all points in every dimension, and all other ranks will not loop over any.\nInside serial regions, the macro @serial_region can also be used to wrap blocks of code so that they only run on rank 0 of the block. This is useful for example to allow the use of array-broadcast expressions during initialization where performance is not critical.\nTo help show how these macros work, a script is provided that print a set of examples where the loop macros are expanded. It can be run from the Julia REPL\n$ julia --project\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.7.0 (2021-11-30)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> include(\"util/print-macros.jl\")\nor on the command line\n$ julia --project util/print-macros.jl","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The ranges used are stored in a LoopRanges struct in the Ref variable loop_ranges (which is exported by the looping module). The range for each dimension is stored in a member with the same name as the dimension, e.g. loop_ranges[].s for the species. Occasionally it is useful to access the range directly. There are different LoopRanges instances for different parallelization patterns - the instance stored in loop_ranges is updated when begin_*_region() is called. It is possible to find out the current region type (i.e. which dimensions are being parallelized) by looking at loop_ranges[].parallel_dims.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"note: Note\nThe square brackets [] after loop_ranges[] are needed because loop_ranges is a reference to a LoopRanges object Ref{LoopRanges} (a bit like a pointer) - it allows loop_ranges to be a const variable, so its type is always known at compile time, but the actual LoopRanges can be set/modified at run-time.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It is also possible to run a block of code in serial (on just the rank-0 member of each block of processes) by wrapping it in a @serial_region macro. This is mostly useful for initialization or file I/O where performance is not critical. For example","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@serial_region begin\n    # Do some initialization\n    f .= 0.0\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Internally, when the @begin_*_region() macros need to change the region type (i.e. the requested region is not already active), they call _block_synchronize(), which calls MPI.Barrier(). They also switch over the LoopRanges struct contained in looping.loop_ranges as noted above. For optimization, the _block_synchronize() call can be skipped - when it is correct to do so - by passing the argument no_synchronize=true (or some more complicated conditional expression if synchronization is necessary when using some options but not for others).","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"If for some reason it is necessary to synchronize explicitly, not by using an @begin_*_region() call, use the @_block_synchronize() macro. This calls _block_synchronize(), but when debugging can also pass in some information (a hash of the file an line number) about the calling site that is used for consistency checking.","category":"page"},{"location":"developing/#Collision-operator-and-anysv-region","page":"Developing","title":"Collision operator and anysv region","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"The Fokker-Planck collision operator requires a special approach to shared-memory parallelisation. There is an outer loop over spatial points. Inside that outer loop there are operations that can benefit from parallelisation over (possibly species and) v_perp, or over v_parallel, or over both v_perp and v_parallel, as well as some that do not parallelise over velocity space at all. To deal with this, it is beneficial to parallelise the outer loop over species and spatial dimensions as much as possible, and then within that allow changes between different ways of parallelizing over velocity space.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The mechanism introduced to allow the type of parallelization just described is the 'anysv' (read any-s-v) region. Before the outer loop of the collision operator @begin_r_z_anysv_region() is used to start the 'anysv' parallelization. Then within the @loop_r_z ir iz begin... the functions @begin_anysv_region() (for no parallelization over velocity space), @begin_anysv_s_vperp_region(), @begin_anysv_s_vpa_region(), @begin_anysv_s_vperp_vpa_region(), @begin_anysv_vperp_region(), @begin_anysv_vpa_region() and @begin_anysv_vperp_vpa_region() can be used to parallelize over species and neither velocity space dimension, either velocity space dimension individually, or over both velocity space dimensions together. This is possible because 'subblocks' of processes are defined. Each subblock shares the same range of spatial indices, which stay the same throughout the @begin_r_z_anysv_region() section, and are not shared with any other subblock of processes. Because the subblock has an independent set of spatial-indices, when changing the species- and velocity-space parallelization only the processes in the sub-block need to be synchronized which is done by moment_kinetics.communication._anysv_subblock_synchronize, which is called when necessary within the @begin_anysv*_region() functions (the whole shared-memory block does not need to be synchronized at once, as would be done by moment_kinetics.communication._block_synchronize). The processes that share an anysv subblock are all part of the comm_anysv_subblock[] communicator (which is a subset of the processes in the full block, whose communicator is comm_block[]).","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"See also notes on debugging the 'anysv' parallelisation: Collision operator and 'anysv' region.","category":"page"},{"location":"developing/#Bounds-checking","page":"Developing","title":"Bounds checking","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"For best performance (i.e. 'production' runs), it is important that bounds checks not be included on array accesses. It should be possible to do this by running julia with the flag --check-bounds=no, but this flag has negative effects on the core Julia code and compiler, and works less well in Julia versions 1.10 and 1.11. As a workaround/alternative, the @loop_* macros described in the previous section wrap the contained code with an @inbounds macro (which disables bounds checks within the block, but the effect of @inbounds does not propagate down into functions called within the block). If performance-critical code that you write is within an @loop, then you do not need to do anything. However if it is not within an @loop, then you should add @inbounds begin ... end around any performance critical code. You can see examples of this being done in moment_kinetics.fokker_planck_calculus.","category":"page"},{"location":"developing/#parallel_io_section","page":"Developing","title":"Parallel I/O","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"The code provides an option to use parallel I/O, which allows all output to be written to a single output file even when using distributed-MPI parallelism - this is the default option when the linked HDF5 library is compiled with parallel-I/O support.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"There are a few things to be aware of to ensure parallel I/O works correctly:","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Some operations have to be called simultaneously on all the MPI ranks that have the output file open. Roughly, these are any operations that change the 'metadata' of the file, for example opening/closing files, creating variables, extending dimensions of variables, changing attributes of variables. Reading or writing the data from a variable does not have to be done collectively - actually when we write data we ensure that every rank that is writing writes a non-overlapping slice of the array to avoid contention that could slow down the I/O (because one rank has to wait for another) and to avoid slight inconsistencies because it is uncertain which rank writes the data last. For more details see the HDF5.jl documentation and the HDF5 documentation.\nOne important subtlety is that the Dict type does not guarantee a deterministic order of entries. When you iterate over a Dict, you can get the results in a different order at different times or on different MPI ranks. If we iterated over a Dict to create variables to write to an output file, or to read from a file, then different MPI ranks might (sometimes) get the variables in a different order, causing errors. We therefore use either OrderedDict or SortedDict types for anything that might be written to or read from an HDF5 file.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"If the collective operations are not done perfectly consistently, the errors can be extremely non-obvious. The inconsistent operations may appear to execute correctly, for example because the same number of variables are created, and the metadata may only actually be written from the rank-0 process, but the inconsistency may cause errors later. [JTO, 3/11/2024: my best guess as to the reason for this is that it puts HDF5's 'metadata cache' in inconsistent states on different ranks, and this means that at some later time the ranks will cycle some metadata out of the cache in different orders, and then some ranks will be able to get the metadata from the cache, while others have to read it from the file. The reading from the file requires some collective MPI call, which is only called from some ranks and not others, causing the code to hang.]","category":"page"},{"location":"developing/#Package-structure","page":"Developing","title":"Package structure","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"The structure of the packages in the moment_kinetics repo is set up so that some features, which depend on 'heavy' external packages (such as Makie, Plots, and Symbolics, which take a long time to precompile and load) can be optional.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The structure is set up by the machines/machine_setup.sh script, which prompts the user for input to decide which optional components to include (as well as some settings related to batch job submission on HPC clusters). machine_setup.sh calls several other scripts to do the setup (written as far as possible in Julia). The structure of these scripts is explained in machine_setup notes.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The intention is that a top-level 'project' (defined by a Project.toml file, which is created and populated by machines/machine_setup.sh) is set up in the top-level directory of the repository. The moment_kinetics package itself (which is in the moment_kinetics/ subdirectory, defined by its own Project.toml file which is tracked by git), and optionally other post-processing packages, are added to this top-level project using Pkg.develop().","category":"page"},{"location":"developing/#Optional-dependencies","page":"Developing","title":"Optional dependencies","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"Some capabilities that require optional dependencies are provided using 'package extensions' (a new feature of Julia in v1.9.0).","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The way we use package extensions is a bit of a hack. Extensions are intended to be activated when an optional dependency (called a 'weakdep' by Julia) is loaded, e.g. using moment_kinetics, NCDatasets. This usage pattern is not the most convenient for the way we use moment_kinetics where we would rather just load moment_kinetics and then specify for example binary_format = \"netcdf\" in the input TOML file. To work around this, the optional dependencies are loaded automatically if they are installed (by calling Base.requires() in the __init__() function of an appropriate sub-module). This is not the way package extensions were intended to be used, and it may be a bit fragile - at the time of writing in January 2024 there would be an error on precompilation if the optional dependencies were added in one order, which went away when the order was reversed. If this causes problems, we might need to consider an alternative, for example adding the optional dependencies to the startup.jl file, instead of trying to auto-load them from within the moment_kinetics package.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The optional capabilities at the moment are:","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Method of manufactured solutions (MMS) testing - this requires the Symbolics package which is heavy and has a large number of dependencies. It is convenient not to require Symbolics when MMS capability is not being used. The functionality is provided by the manufactured_solns_ext extension. The extension also requires the IfElse package, which is not needed elsewhere in moment_kinetics and so is included as a 'weakdep' although IfElse is not a heavy dependency.\nNetCDF output - this requires the NCDatasets package. Although not as heavy as Symbolics or the plotting packages, NetCDF output is not required and not used by default, so it does not hurt to make the dependency optional. As a bonus, importing NCDatasets can sometimes cause linking errors when a local or system installation of HDF5 (i.e. one not provided by the Julia package manager) is used, as NCDatasets (sometimes?) seems to try to link a different version of the library. These errors can be avoided by not enabling NetCDF outut (when HDF5 output is preferred), or allowing Julia to use the HDF5 library provided by its package manager (when NetCDF is preferred, although this would mean that parallel I/O functionality is not available).","category":"page"},{"location":"developing/#Post-processing-packages","page":"Developing","title":"Post processing packages","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"Post processing functionality is provided by separate packages (makie_post_processing and plots_post_processing) rather than by extensions. Extensions are not allowed to define new modules, functions, etc. within the main package, they can only add new methods (i.e. new implementations of the function for a different number of arguments, or different types of the arguments) to functions already defined in the main package. For post-processing, we want to add a lot of new functions, so to use extensions instead of separate packages we would need to define all the function names in the main package, and then separately the implementations in the extension, which would be inconvenient and harder to maintain.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"There are two suggested ways of setting up the post-processing packages:","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"For interactive use/development on a local machine, one or both post-processing packages can be added to the top-level project using Pkg.develop(). This is convenient as there is only one project to deal with. Both simulations and post-processing are run using\n$ bin/julia --project -O3 <...>\nFor optimized use on an HPC cluster it is better to set up a separate project for the post-processing package(s). This allows different optimization flags to be used for running simulations (-O3 --check-bounds=no) and for post-processing (-O3). [Note, in particular Makie.jl can have performance problems if run with --check-bounds=no, see here.] Simulations should be run with\n$ bin/julia --project -O3 --check-bounds=no <...>\nand post-processing with\n$ bin/julia --project=makie_post_processing -O3 <...>\nor\n$ bin/julia --project=plots_post_processing -O3 <...>\nThis option can also be used on a local machine, if you want to optimise your simulation runs as much as possible by using the --check-bounds=no flag. To do this answer y to the prompt \"Would you like to set up separate packages for post processing...\" from machines/machine_setup.sh.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"To support option 2, the post-processing packages are located in sub-sub-directories (makie_post_processing/makie_post_processing/ and plots_post_processing/plots_post_processing/), so that the separate projects can be created in the sub-directories (makie_post_processing/ and plots_post_processing). moment_kinetics and the other dependencies must also be added to the separate projects (the machine_setup.sh script takes care of this).","category":"page"},{"location":"parameter_scans/#Parameter-scans","page":"Parameter scans","title":"Parameter scans","text":"","category":"section"},{"location":"parameter_scans/#Running-a-scan","page":"Parameter scans","title":"Running a scan","text":"","category":"section"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"Parameter scans can be run using the run_parameter_scan.jl script. To run from the REPL","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"$ julia -p 8 --project -O3\njulia> include(\"run_parameter_scan.jl\")\njulia> run_parameter_scan(\"path/to/an/input/file.toml\")","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"or to run a single scan from the command line","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"$ julia -p 8 --project -O3 run_parameter_scan.jl path/to/an/input/file.toml","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"The -p 8 argument passed to julia in these examples is optional. It indicates that julia should use 8 processes for parallelism. In this case we are not using MPI - each run in the scan is run in serial, but up to 8 (in this example) runs from the scan can be performed simultaneously (using the @distributed macro).","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"The runs can use MPI - in this case call julia using mpirun, etc. as usual but do not pass the -p argument. Mixing MPI and @distributed would cause oversubscription and slow everything down. The runs will run one after the other, and each run will be MPI parallelised.","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"The inputs (see moment_kinetics.parameter_scans.get_scan_inputs) can be passed to the function in a Dict, or read from a TOML file.","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"run_parameter_scan can also be passed a directory (either as an argument to the function or from the command line), in which case it will perform a run for every input file contained in that directory.","category":"page"},{"location":"parameter_scans/#Post-processing-a-scan","page":"Parameter scans","title":"Post processing a scan","text":"","category":"section"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"makie_post_processing.makie_post_process can be called for each run in a scan. For example to post process the scan in runs/scan_example from the REPL","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"$ julia -p 8 --project -O3\njulia> include(\"post_process_parameter_scan.jl\")\njulia> post_process_parameter_scan(\"runs/scan_example/\")","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"or to from the command line","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"$ julia -p 8 --project -O3 post_process_parameter_scan.jl runs/scan_example/","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"Again the -p 8 argument passed to julia in these examples is optional. It indicates that julia should use 8 processes for parallelism. Each run in the scan is post-processed in serial, but up to 8 (in this example) runs from the scan can be post-processed simultaneously (using the @distributed macro).","category":"page"},{"location":"parameter_scans/#API","page":"Parameter scans","title":"API","text":"","category":"section"},{"location":"parameter_scans/#moment_kinetics.parameter_scans.generate_scan_input_files","page":"Parameter scans","title":"moment_kinetics.parameter_scans.generate_scan_input_files","text":"generate_scan_input_files(filename::AbstractString, dirname=nothing)\n\nRead inputs for a scan from a TOML file and call generate_scan_input_files(scan_input::AbstractDict, dirname::AbstractString).\n\nBy default, dirname will be set to filename with the .toml extension removed.\n\n\n\n\n\n","category":"function"},{"location":"parameter_scans/#moment_kinetics.parameter_scans.generate_scan_input_files-Tuple{AbstractDict, AbstractString}","page":"Parameter scans","title":"moment_kinetics.parameter_scans.generate_scan_input_files","text":"generate_scan_input_files(scan_input::AbstractDict, dirname::AbstractString)\n\nGenerate individual input files for each run in the scan specified by scan_input, saving the generated files in dirname\n\nInputs are generated by calling get_scan_inputs(scan_inputs::AbstractDict).\n\n\n\n\n\n","category":"method"},{"location":"parameter_scans/#moment_kinetics.parameter_scans.get_scan_inputs-Tuple{AbstractDict}","page":"Parameter scans","title":"moment_kinetics.parameter_scans.get_scan_inputs","text":"get_scan_inputs(scan_inputs::AbstractDict)\n\nMake a set of inputs for a parameter scan.\n\nscan_inputs is like a Dict of inputs for run_moment_kinetics, except that any value may be an array instead of a scalar. The values passed as arrays will be combined as follows.\n\nA special, extra, setting combine_outer can be passed, with the names of options to combine using an 'outer product'\n\nBy default, inputs are combined with an 'inner product', i.e. inputs a,b,c are combined as (a[1],b[1],c[1]), (a[2],b[2],c[2]), etc. Any inputs named in 'combine_outer' are instead combined with an 'outer product', i.e. an entry is created for every value of those inputs combined with every combination of the other inputs.\n\nReturns a Vector{OrderedDict} whose entries are the input for a single run in the parameter scan.\n\n\n\n\n\n","category":"method"},{"location":"parameter_scans/#moment_kinetics.parameter_scans.get_scan_inputs-Tuple{AbstractString}","page":"Parameter scans","title":"moment_kinetics.parameter_scans.get_scan_inputs","text":"get_scan_inputs(file_or_dir::AbstractString)\n\nIf file_or_dir is a file, read input from it using TOML , and call get_scan_inputs(scan_inputs::AbstractDict).\n\nIf file_or_dir is a directory, read input from all the .toml files in the directory, returning the inputs as a Vector{OrderedDict}.\n\n\n\n\n\n","category":"method"},{"location":"parameter_scans/#moment_kinetics.parameter_scans.get_scan_inputs-Tuple{}","page":"Parameter scans","title":"moment_kinetics.parameter_scans.get_scan_inputs","text":"get_scan_inputs()\n\nGet input file name from command line options, and call get_scan_inputs(filename::AbstractString)\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics","page":"moment_kinetics","title":"moment_kinetics","text":"","category":"section"},{"location":"zz_moment_kinetics/#moment_kinetics.moment_kinetics","page":"moment_kinetics","title":"moment_kinetics.moment_kinetics","text":"\n\n\n\n","category":"module"},{"location":"zz_moment_kinetics/#moment_kinetics.check_so_newer_than_code","page":"moment_kinetics","title":"moment_kinetics.check_so_newer_than_code","text":"check_so_newer_than_code(so_filename=nothing)\n\nUtility function that checks if so_filename is newer than the source code in moment_kinetics/src. If it is, prints an error message and returns false; otherwise returns true.\n\nIf so_filename is nothing, use the name of the system image of the current julia session for so_filename.\n\nIf so_filename is \"makie_postproc.so\", also checks against the source code in makie_post_processing/makie_post_processing/src/.\n\nIf so_filename is \"plots_postproc.so\", also checks against the source code in plots_post_processing/plots_post_processing/src/.\n\n\n\n\n\n","category":"function"},{"location":"zz_moment_kinetics/#moment_kinetics.cleanup_moment_kinetics!-Tuple{Any, Any, Any}","page":"moment_kinetics","title":"moment_kinetics.cleanup_moment_kinetics!","text":"Clean up after a run\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{OrderedCollections.OrderedDict{String, Any}}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"main function that contains all of the content of the program\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{String}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload which takes a filename and loads input\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload which gets the input file name from command line arguments\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.setup_moment_kinetics-Tuple{AbstractDict}","page":"moment_kinetics","title":"moment_kinetics.setup_moment_kinetics","text":"Perform all the initialization steps for a run.\n\nIf backup_filename is nothing, set up for a regular run; if a filename is passed, reload data from time index given by restart_time_index for a restart.\n\ndebug_loop_type and debug_loop_parallel_dims are used to force specific set ups for parallel loop ranges, and are only used by the tests in debug_test/.\n\n\n\n\n\n","category":"method"},{"location":"wall_boundary_conditions/#Wall-boundary-conditions-with-moment-constraints","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"","category":"section"},{"location":"wall_boundary_conditions/#Ions","page":"Wall boundary conditions with moment constraints","title":"Ions","text":"","category":"section"},{"location":"wall_boundary_conditions/#Boundary-conditions","page":"Wall boundary conditions with moment constraints","title":"Boundary conditions","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"The sheath-edge boundary conditions for the ions is that no ions leave from the sheath edge. So at the lower boundary z=-L_z2","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  f(z=-L2v_parallel0) = 0\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and at the upper boundary z=L_z2","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  f(z=L2v_parallel0) = 0\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Moment-constraints","page":"Wall boundary conditions with moment constraints","title":"Moment constraints","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"At the sheath-entrance boundary, the constraints need to be enforced slightly differently to how they are done in the bulk of the domain (see Constraints on normalized distribution function). For compatibility with the boundary condition, the corrections which are added to impose the constraints should go to zero at v_parallel=0. Note that the constraints are imposed after the boundary condition is applied by setting f(v_parallel0)=0 on the lower sheath boundary or f(v_parallel0)=0 on the upper sheath boundary.","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"The form of the correction that we choose is","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\ntildeg_s = Ahatg_s + Bw_parallel fracv_parallel1+v_parallelhatg_s + Cw_parallel^2 fracv_parallel1+v_parallelhatg_s\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"We have the same set of constraints","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s  =1\n  frac1sqrtpiint dw_w_tildeg_s  =0\n  frac1sqrtpiint dw_w_^2tildeg_s  =frac12\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Defining the integrals","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  I_n=frac1sqrtpiint dw_w_^nhatg_s\n  J_n=frac1sqrtpiint dw_w_^nfracv_parallel1+v_parallelhatg_s\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"We can write the constraints as","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s=1  =frac1sqrtpiint dw_left(Ahatg_s+Bw_fracv_parallel1+v_parallelhatg_s+Cw_^2fracv_parallel1+v_parallelhatg_sright) \n  =AI_0+BJ_1+CJ_2\n  frac1sqrtpiint dw_w_tildeg_s=0  =frac1sqrtpiint dw_left(Aw_hatg_s+Bw_^2fracv_parallel1+v_parallelhatg_s+Cw_^3fracv_parallel1+v_parallelhatg_sright) \n  =AI_1+BJ_2+CJ_3\n  frac1sqrtpiint dw_w_^2tildeg_s=frac12  =frac1sqrtpiint dw_left(Aw_^2hatg_s+Bw_^3fracv_parallel1+v_parallelhatg_s+Cw_^4fracv_parallel1+v_parallelhatg_sright) \n  =AI_2+BJ_3+CJ_4\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and solving these simultaneous equations","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracleft( frac12 - A I_2 - B J_3 right)J_4  \n  B = -fracA I_1 + C J_3J_2 \n    = -fracI_1J_2 A - fracJ_3J_2 left( frac12J_4 - fracI_2J_4 A - fracJ_3J_4 B right) \n  left( 1 - fracJ_3^2J_2 J_4 right) B = -fracJ_32 J_2 J_4 + left( fracI_2 J_3J_2 J_4 - fracI_1J_2 right) A \n  B = fracleft( fracI_2 J_3J_2 J_4 - fracI_1J_2 right) A - fracJ_32 J_2 J_4left( 1 - fracJ_3^2J_2 J_4 right) \n  = fracleft( I_2 J_3 - I_1 J_4 right) A - fracJ_32J_2 J_4 - J_3^2 \n  1 = A I_0 + B J_1 + C J_2 \n  = A I_0 + B J_1 + fracJ_2J_4left( frac12 - A I_2 - B J_3 right) \n  1 - fracJ_22 J_4 = left( I_0 - fracI_2 J_2J_4 right) A + left( J_1 - fracJ_2 J_3J_4 right) B \n  1 - fracJ_22 J_4 = left( I_0 - fracI_2 J_2J_4 right) A - fracleft( J_1 - fracJ_2 J_3J_4 right) J_32left( J_2 J_4 - J_3^2 right) + fracleft( J_1 - fracJ_2 J_3J_4 right)left( I_2 J_3 - I_1 J_4 right)left( J_2 J_4 - J_3^2 right) A \n  left( 1 - fracJ_22J_4 right) left( J_2 J_4 - J_3^2 right) = left( J_2 J_4 - J_3^2 right) left( I_0 - fracI_2 J_2J_4 right) A - fracleft( J_1 - fracJ_2 J_3J_4 right) J_32 + left( J_1 - fracJ_2 J_3J_4 right) left( I_2 J_3 - I_1 J_4 right) A \n  left( 1 - fracJ_22 J_4 right)left( J_2 J_4 - J_3^2 right) + fracleft( J_1 - fracJ_2 J_3J_4 right) J_32 = left left( J_2 J_4 - J_3^2 right)left( I_0 - fracI_2 J_2J_4 right) + left( J_1 - fracJ_2 J_3J_4 right)left( I_2 J_3 - I_1 J_4 right) right A \n  J_2 J_4 - fracJ_2^22 - J_3^2 + cancelfracJ_2 J_3^22 J_4 + fracJ_1 J_32 - cancelfracJ_2 J_3^22 J_4 = left I_0 J_2 J_4 - I_2 J_2^2 - I_0 J_3^2 + cancelfracI_2 J_2 J_3^2J_4 + I_2 J_1 J_3 - I_1 J_1 J_4 - cancelfracI_2 J_2 J_3^2J_4 + I_1 J_2 J_3 right A \n  J_2 J_4 - fracJ_2^22 + J_3left( fracJ_12 - J_3 right) = left I_0left( J_2 J_4 - J_3^2 right) + I_1left( J_2 J_3 - J_1 J_4 right) + I_2left( J_1 J_3 - J_2^2 right) right A \n  A =fracJ_2 J_4 - fracJ_2^22 + J_3left( fracJ_12 - J_3 right)I_0left( J_2 J_4 - J_3^2 right) + I_1 left( J_2 J_3 - J_1 J_4 right) + I_2left( J_1 J_3 - J_2^2 right)\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"</details>","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracfrac12 - A I_2 - B J_3J_4  \n  B = fracfrac12 J_3 + A (I_1 J_4 - I_2 J_3)J_3^2 - J_2 J_4 \n  A = fracJ_3^2 - J_2 J_4 + frac12 (J_2^2 - J_1 J_3)I_0 (J_3^2 - J_2 J_4) + I_1 (J_1 J_4 - J_2 J_3) + I_2 (J_2^2 - J_1 J_3)\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Evolving-u_\\parallel","page":"Wall boundary conditions with moment constraints","title":"Evolving u_parallel","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When evolving only u_parallel and n separately, we only need two constraints. This corresponds to C=0 so that","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  1 = A I_0 + B J_1 \n  0 = A I_1 + B J_2 \n  B = -fracA I_1J_2 \n  A I_0 = 1 - B J_1 = 1 + fracA I_1 J_1J_2 \n  A = frac1I_0 - fracI_1 J_1J_2\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Evolving-n","page":"Wall boundary conditions with moment constraints","title":"Evolving n","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When only evolving n separately, the constraint is the same as in the bulk of the domain","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  1 = AI_0 \n  A = frac1I_0\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Neutrals","page":"Wall boundary conditions with moment constraints","title":"Neutrals","text":"","category":"section"},{"location":"wall_boundary_conditions/#Boundary-conditions-2","page":"Wall boundary conditions with moment constraints","title":"Boundary conditions","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Ions and neutrals that reach the wall are both recycled as neutrals. The neutrals are emitted from the wall with a 'Knudsen cosine' distribution characterised by a specified temperature T_mathrmwall (see Excalibur report TN-05). The Knudsen distribution is given – here assuming that the magnetic field is perpendicular to the wall (so that v_parallel is the velocity normal to the wall) – by","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"f_Kw(v_zetav_rv_z) = frac34pi left(fracm_iT_mathrmwallright)^2 fracv_zsqrtv_zeta^2 + v_r^2 + v_z^2 expleft( -fracm_i(v_zeta^2 + v_r^2 + v_z^2)2T_mathrmwall right)","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Note that f_Kw is normalised so that it has unit flux int d^3vv_z f_Kw(v_zetav_rv_z) = 1.","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"The boundary condition for the neutrals at the lower target is then (for the neutrals leaving whe wall)","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"f_n(rz=-fracL_z2v_zetav_rv_z0) = Gamma_mathrmlower(r) f_Kw(v_zetav_rv_z)","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and at the upper target","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"f_n(rz=fracL_z2v_zetav_rv_z0) = Gamma_mathrmupper(r) f_Kw(v_zetav_rv_z)","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"A 'recycling fraction' is included, defined so that a fraction 0 leq R_mathrmrecycle leq 1 of the ions hitting the wall are recycled as neutrals, while the whole flux of neutrals hitting the wall is always recycled. (Recycling the 100% of the neutral flux means that the net flux of neutrals - hitting the wall plus recycled - is R_mathrmrecycle times the ion flux, which makes applying boundary conditions in the moment-kinetic approach simpler, see the next section.) This results in","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  Gamma_mathrmlower(r) = R_mathrmrecycle fracB_zB 2pi int_0^infty dv_perp int_-infty^0 dv_parallel v_parallel f_i(r-L2v_perpv_parallel) \n                           quad + int dv_zetadv_r int_-infty^0 dv_z v_z f_n(r-L2v_zetav_rv_z) \n  Gamma_mathrmupper(r) = R_mathrmrecycle fracB_zB 2pi int_0^infty dv_perp int_0^infty dv_parallel v_parallel f_i(rL2v_perpv_parallel) \n                           quad + int dv_zetadv_r int_0^infty dv_z v_z f_n(rL2v_zetav_rv_z)\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"For 1D1V, we 'marginalise' – i.e. integrate over v_perp, assuming that v_parallel=v_z (i.e. the magnetic field is perpendicular to the wall so B_zB = 1) – (see Excalibur report TN-08) which gives","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  f_Kw1V(v_parallel) = int dv_zeta dv_r f_Kw(v_zetav_rv_parallel) = 2pi int dv_perpv_perp f_Kw(v_perpv_parallel) \n                         = 3sqrtpi left(fracm_i2T_mathrmwallright)^32v_parallelmathrmerfcleft(sqrtfracm_i2T_mathrmwallv_parallelright)\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Moment-constraints-2","page":"Wall boundary conditions with moment constraints","title":"Moment constraints","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When using the moment kinetic approach, we first need to apply a boundary condition to the moments so that the net flux of neutrals leaving the wall matches the recycling fraction R_mathrmrecycle times the flux of ions reaching the wall","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  u_paralleln(z=pm L2) = -R_mathrmrecycle fracn_i(z=pm L2) u_paralleli(z=pm L2)n_n(z=pm L2)\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Having enforced the boundary condition on the flux, we need to impose that the outgoing neutrals have the shape of a Knudsen cosine distribution, and ensure that the constraints (Constraints on normalized distribution function) are satisfied. To impose three constraints we need three free parameters. Taking as before the updated, incoming part of the neutral distribution function before moment corrections to be","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  hatg_mathrmin(w_parallel) =\n    begincases\n      H(-w_parallel v_mathrmthn - u_paralleln)hatg(zw_parallel)  textat  z = -L2 \n      H(w_parallel v_mathrmthn + u_paralleln)hatg(zw_parallel)  textat  z = +L2\n    endcases\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and the shape for the Knudsen distribution to be","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  hatg_Kw(w_parallel) =\n    begincases\n      H(w_parallel v_mathrmthn + u_paralleln)f_Kw1V(w_parallel v_mathrmthn + u_paralleln)  textat  z = -L2 \n      H(-w_parallel v_mathrmthn - u_paralleln)f_Kw1V(w_parallel v_mathrmthn + u_paralleln)  textat  z = +L2\n    endcases\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"we define the final updated distribution function to be","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  tildeg_n(w_parallel) = N_mathrmout hatg_Kw + N_mathrmin hatg_mathrmin + C w_parallel hatg_mathrmin\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"(note that if we chose to use v_parallel = w_parallel v_mathrmthn + u_paralleln instead of w_parallel in the final term with the C coefficient, this is just a shift by a constant and scale by another constant, so would have the same form, just with different (but equivalent) values of the N_mathrmin and C coefficients).","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Defining the integrals","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  I_n = int dw_parallel w_parallel^n hatg_mathrmin(w_parallel)\n  K_n = int dw_parallel w_parallel^n hatg_Kw(w_parallel)\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"the constraints are","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dw_tildeg_n=1  =frac1sqrtpiint dw_left(N_mathrmout hatg_Kw + N_mathrmin hatg_mathrmin + C w_parallel hatg_mathrminright) \n  = N_mathrmout K_0 + N_mathrmin I_0 + C I_1 \n  frac1sqrtpiint dw_w_tildeg_n=0  =frac1sqrtpiint dw_left(N_mathrmout w_ hatg_Kw + N_mathrmin w_ hatg_mathrmin + C w_parallel^2 hatg_mathrminright) \n  = N_mathrmout K_1 + N_mathrmin I_1 + C I_2 \n  frac1sqrtpiint dw_w_^2tildeg_n=frac12  =frac1sqrtpiint dw_left(N_mathrmout w_^2 hatg_Kw + N_mathrmin w_^2 hatg_mathrmin + C w_parallel^3 hatg_mathrminright) \n  = N_mathrmout K_2 + N_mathrmin I_2 + C I_3\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"which can be solved to find","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracleft(frac12 - N_mathrmout K_2 - N_mathrmin I_2right)I_3 \n  N_mathrmout = fracleft(-N_mathrmin I_1 - C I_2 right)K_1 \n                 = -fracN_mathrmin I_1K_1 - fracI_2 left(frac12 - N_mathrmout K_2 - N_mathrmin I_2right)K_1 I_3 \n  N_mathrmout K_1 I_3 = -N_mathrmin I_1 I_3 - I_2 left(frac12 - N_mathrmout K_2 - N_mathrmin I_2right) \n  N_mathrmout = -fracleft(N_mathrmin left(I_1 I_3 - I_2^2right) + frac12 I_2right)left(K_1 I_3 - K_2 I_2right) \n  N_mathrmin = fracleft(1 - N_mathrmout K_0 - C I_1right)I_0 \n                = fracleft(1 - N_mathrmout K_0right)I_0 - fracC I_1I_0 \n                = fracleft(1 - N_mathrmout K_0right)I_0 - fracI_1 left(frac12 - N_mathrmout K_2 - N_mathrmin I_2right)I_0 I_3 \n  N_mathrmin I_0 I_3 = left(1 - N_mathrmout K_0right)I_3 - I_1 left(frac12 - N_mathrmout K_2 - N_mathrmin I_2right) \n  N_mathrmin left(I_0 I_3 - I_1 I_2right) = I_3 - frac12 I_1 - N_mathrmout left(K_0 I_3 - I_1 K_2right) \n  N_mathrmin left(I_0 I_3 - I_1 I_2right) = I_3 - frac12 I_1 + left(K_0 I_3 - I_1 K_2right) fracleft(N_mathrmin left(I_1 I_3 - I_2^2right) + frac12 I_2right)left(K_1 I_3 - K_2 I_2right) \n  N_mathrmin left(I_0 I_3 - I_1 I_2right) left(K_1 I_3 - K_2 I_2right) = left(I_3 - frac12 I_1right) left(K_1 I_3 - K_2 I_2right) + left(K_0 I_3 - I_1 K_2right) left(N_mathrmin left(I_1 I_3 - I_2^2right) + frac12 I_2right) \n  N_mathrmin left( left(I_0 I_3 - I_1 I_2right) left(K_1 I_3 - K_2 I_2right) - left(K_0 I_3 - I_1 K_2right) left(I_1 I_3 - I_2^2right) right) = left(I_3 - frac12 I_1right) left(K_1 I_3 - K_2 I_2right) + left(K_0 I_3 - I_1 K_2right) frac12 I_2 \n  N_mathrmin left( K_0 I_3 left(I_2^2 - I_1 I_3right) + K_1 I_3 left(I_0 I_3 - I_1 I_2right) + K_2 left(cancelI_1 I_2^2 - I_0 I_2 I_3 + I_1^2 I_3 - cancelI_1 I_2^2right)right) = frac12 K_0 I_2 I_3 + K_1 I_3 left(I_3 - frac12 I_1right) + K_2 left(cancelfrac12 I_1 I_2 - I_2 I_3 - cancelfrac12 I_1 I_2 right) \n  N_mathrmin left( K_0 left(I_2^2 - I_1 I_3right) + K_1 left(I_0 I_3 - I_1 I_2right) + K_2 left(I_1^2 - I_0 I_2right)right) = frac12 K_0 I_2 + K_1 left(I_3 - frac12 I_1right) - K_2 I_2 \n  N_mathrmin = fracleft(frac12 K_0 I_2 + K_1 left(I_3 - frac12 I_1right) - K_2 I_2right)left( K_0 left(I_2^2 - I_1 I_3right) + K_1 left(I_0 I_3 - I_1 I_2right) + K_2 left(I_1^2 - I_0 I_2right)right) \nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"</details>","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracleft(frac12 - N_mathrmout K_2 - N_mathrmin I_2right)I_3 \n  N_mathrmout = -fracleft(N_mathrmin left(I_1 I_3 - I_2^2right) + frac12 I_2right)left(K_1 I_3 - K_2 I_2right) \n  N_mathrmin = fracleft(frac12 K_0 I_2 + K_1 left(I_3 - frac12 I_1right) - K_2 I_2right)left( K_0 left(I_2^2 - I_1 I_3right) + K_1 left(I_0 I_3 - I_1 I_2right) + K_2 left(I_1^2 - I_0 I_2right)right)\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Evolving-u_\\parallel-2","page":"Wall boundary conditions with moment constraints","title":"Evolving u_parallel","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When evolving only u_parallel and n separately, we only need two constraints. This corresponds to C=0 so that","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  N_mathrmout = -fracI_1K_1 N_mathrmin \n  N_mathrmin = frac1I_0 - fracK_0 I_1K_1\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Evolving-n-2","page":"Wall boundary conditions with moment constraints","title":"Evolving n","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When only evolving n separately, we still have C=0, but N_mathrmin and N_mathrmout must be adjusted to impose the density-moment constraint and the flux boundary condition.","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dv_tildeg_n=1 = frac1sqrtpiint dv_left(N_mathrmout hatg_Kw + N_mathrmin hatg_mathrminright) \n  = N_mathrmout K_0 + N_mathrmin I_0 \n  frac1sqrtpiint dv_v_tildeg_n = u_n = frac1sqrtpiint dv_left(N_mathrmout v_ hatg_Kw + N_mathrmin v_ hatg_mathrmin right) \n  = N_mathrmout K_1 + N_mathrmin I_1\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"where u_n is calculated from the ion flux as above, which can be solved to give","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  N_mathrmout = fracleft(u_n - N_mathrmin I_1right)K_1 \n  1 = N_mathrmin I_0 + fracK_0 left(u_n - N_mathrmin I_1right)K_1 \n  Rightarrow N_mathrmin = fracleft(1 - fracK_0 u_nK_1right)left(I_0 - fracK_0 I_1K_1right)\nendalign","category":"page"},{"location":"zz_vperp_advection/#vperp_advection","page":"vperp_advection","title":"vperp_advection","text":"","category":"section"},{"location":"zz_vperp_advection/#moment_kinetics.vperp_advection.update_speed_vperp_n_evolution!-NTuple{9, Any}","page":"vperp_advection","title":"moment_kinetics.vperp_advection.update_speed_vperp_n_evolution!","text":"update vperp advection speed when n is evolved separately\n\n\n\n\n\n","category":"method"},{"location":"zz_vperp_advection/#moment_kinetics.vperp_advection.update_speed_vperp_n_u_evolution!-NTuple{9, Any}","page":"vperp_advection","title":"moment_kinetics.vperp_advection.update_speed_vperp_n_u_evolution!","text":"update vperp advection speed when n, u are evolved separately\n\n\n\n\n\n","category":"method"},{"location":"zz_vperp_advection/#moment_kinetics.vperp_advection.update_speed_vperp_n_u_p_evolution!-NTuple{10, Any}","page":"vperp_advection","title":"moment_kinetics.vperp_advection.update_speed_vperp_n_u_p_evolution!","text":"update vperp advection speed when n, u, p are evolved separately\n\n\n\n\n\n","category":"method"},{"location":"zz_fourier/#fourier","page":"fourier","title":"fourier","text":"","category":"section"},{"location":"zz_fourier/#moment_kinetics.fourier","page":"fourier","title":"moment_kinetics.fourier","text":"\n\n\n\n","category":"module"},{"location":"zz_fourier/#moment_kinetics.fourier.fourier_base_info","page":"fourier","title":"moment_kinetics.fourier.fourier_base_info","text":"Fourier pseudospectral discretization\n\n\n\n\n\n","category":"type"},{"location":"zz_fourier/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Any, moment_kinetics.fourier.fourier_info}","page":"fourier","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, ff, adv_fac, spectral::fourier_info)\n\nFourier transform f to get spectral coefficients and use them to calculate f'.\n\nNote: Fourier derivative does not make use of upwinding information.\n\n\n\n\n\n","category":"method"},{"location":"zz_fourier/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, moment_kinetics.fourier.fourier_info}","page":"fourier","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, ff, fourier::fourier_info)\n\nFourier transform f to get spectral coefficients and use them to calculate f'.\n\n\n\n\n\n","category":"method"},{"location":"zz_fourier/#moment_kinetics.fourier.setup_fourier_pseudospectral-Tuple{Any, Any}","page":"fourier","title":"moment_kinetics.fourier.setup_fourier_pseudospectral","text":"create arrays needed for explicit Fourier pseudospectral treatment and create the plans for the forward and backward fast Fourier transforms\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#fokker_planck_test","page":"fokker_planck_test","title":"fokker_planck_test","text":"","category":"section"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test","text":"Module for including functions used  in testing the implementation of the  the full-F Fokker-Planck collision operator.\n\n\n\n\n\n","category":"module"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.Cflux_vpa_Maxwellian_inputs-Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.Cflux_vpa_Maxwellian_inputs","text":"Calculates the collisional flux Gamma_ given Maxwellian input F_s and F_s^prime. The input Maxwellians are specified through their moments.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.Cflux_vperp_Maxwellian_inputs-Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.Cflux_vperp_Maxwellian_inputs","text":"Calculates the collisional flux Gamma_perp given Maxwellian input F_s and F_s^prime. The input Maxwellians are specified through their moments.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.Cssp_Maxwellian_inputs-Tuple{Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.Cssp_Maxwellian_inputs","text":"Calculates the fully expanded form of the collision operator C_s s^primeF_sF_s^prime given Maxwellian input F_s and F_s^prime. The input Maxwellians are specified through their moments.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.Cssp_fully_expanded_form-NTuple{17, Any}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.Cssp_fully_expanded_form","text":"Function calculating the fully expanded form of the collision operator taking as arguments the derivatives of F_s, G_s^prime and H_s^prime. This function is designed to be used at the  lowest level of a coordinate loop, with derivatives and integrals all previously calculated.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.F_Beam-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.F_Beam","text":"Function computing $ F_{\\rm Beam} $.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.F_Maxwellian-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.F_Maxwellian","text":"Function computing $ F_{\\rm Maxwellian} $.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.G_Maxwellian-NTuple{7, Any}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.G_Maxwellian","text":"Function computing G, defined by \n\nnabla^4 G = -frac8sqrtpi F \n\nwith \n\nF = c_rm ref^3 F_rm Maxwellian  n_rm ref\n\nthe normalised Maxwellian.  See Plasma Confinement, R. D. Hazeltine & J. D. Meiss, 2003, Dover Publications, pg 184, Chpt 5.2, Eqn (5.49).\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.H_Maxwellian-NTuple{7, Any}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.H_Maxwellian","text":"Function computing H, defined by \n\nnabla^2 H = -frac4sqrtpi F \n\nwith \n\nF = c_rm ref^3 F_rm Maxwellian  n_rm ref\n\nthe normalised Maxwellian.  See Plasma Confinement, R. D. Hazeltine & J. D. Meiss, 2003, Dover Publications, pg 184, Chpt 5.2, Eqn (5.49).\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.calculate_collisional_fluxes-NTuple{10, Any}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.calculate_collisional_fluxes","text":"Calculates the collisional fluxes given input F_s and G_s^prime, H_s^prime.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.d2Fdvpa2_Maxwellian-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.d2Fdvpa2_Maxwellian","text":"Function computing\n\nfracpartial^2 Fpartial v_^2\n\nfor $ F = F_{\\rm Maxwellian}$.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.d2Fdvperp2_Maxwellian-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.d2Fdvperp2_Maxwellian","text":"Function computing\n\nfracpartial^2 Fpartial v_perp^2\n\nfor $ F = F_{\\rm Maxwellian}$.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.d2Fdvperpdvpa_Maxwellian-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.d2Fdvperpdvpa_Maxwellian","text":"Function computing\n\nfracpartial^2 Fpartial v_perp partial v_\n\nfor $ F = F_{\\rm Maxwellian}$.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.d2Gdvpa2_Maxwellian-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.d2Gdvpa2_Maxwellian","text":"Function computing \n\nfracpartial^2 G  partial v_^2\n\nfor Maxwellian input. See G_Maxwellian().\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.d2Gdvperp2_Maxwellian-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.d2Gdvperp2_Maxwellian","text":"Function computing\n\nfracpartial^2 Gpartial v_perp^2\n\nfor Maxwellian input. See G_Maxwellian().\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.d2Gdvperpdvpa_Maxwellian-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.d2Gdvperpdvpa_Maxwellian","text":"Function computing\n\nfracpartial^2 Gpartial v_perp partial v_\n\nfor Maxwellian input. See G_Maxwellian().\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.dFdvpa_Maxwellian-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.dFdvpa_Maxwellian","text":"Function computing \n\nfracpartial Fpartial v_\n\nfor $ F = F_{\\rm Maxwellian}$.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.dFdvperp_Maxwellian-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.dFdvperp_Maxwellian","text":"Function computing\n\nfracpartial Fpartial v_perp\n\nfor $ F = F_{\\rm Maxwellian}$.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.dGdvperp_Maxwellian-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.dGdvperp_Maxwellian","text":"Function computing\n\nfracpartial Gpartial v_perp\n\nfor Maxwellian input. See G_Maxwellian().\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.dHdvpa_Maxwellian-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.dHdvpa_Maxwellian","text":"Function computing\n\nfracpartial Hpartial v_\n\nfor Maxwellian input. See H_Maxwellian().\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.dHdvperp_Maxwellian-Tuple{Float64, Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.dHdvperp_Maxwellian","text":"Function computing\n\nfracpartial Hpartial v_perp\n\nfor Maxwellian input. See H_Maxwellian().\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.eta_func-Tuple{Float64, Float64, Vararg{Any, 4}}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.eta_func","text":"Function computing the normalised speed variable \n\neta = fracsqrt(v_ - u_)^2 + v_perp^2v_rm th\n\nwith v_rm th = sqrt2 p  n m the thermal speed, and p the pressure,  n the density and m the mass.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.print_test_data-NTuple{4, Any}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.print_test_data","text":"Function to print the maximum error rm MAX(f_rm numerical-f_rm exact).\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.print_test_data-NTuple{7, Any}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.print_test_data","text":"Function to print the maximum error rm MAX(f_rm numerical-f_rm exact) and the L_2 norm of the error \n\nsqrtint (f - f_rm exact)^2 v_perp d v_perp d v_int v_perp d v_perp d v_\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.save_fkpl_error_data-NTuple{31, Any}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.save_fkpl_error_data","text":"Utility function that saves error data to a HDF5 file for later use.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.save_fkpl_integration_error_data-NTuple{17, Any}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.save_fkpl_integration_error_data","text":"Utility function that saves error data to a HDF5 file for later use.\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_r_advection/#neutral_r_advection","page":"neutral_r_advection","title":"neutral_r_advection","text":"","category":"section"},{"location":"zz_neutral_r_advection/#moment_kinetics.neutral_r_advection","page":"neutral_r_advection","title":"moment_kinetics.neutral_r_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_neutral_r_advection/#moment_kinetics.neutral_r_advection.neutral_advection_r!-NTuple{13, Any}","page":"neutral_r_advection","title":"moment_kinetics.neutral_r_advection.neutral_advection_r!","text":"do a single stage time advance in r (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_r_advection/#moment_kinetics.neutral_r_advection.update_speed_neutral_r!-NTuple{6, Any}","page":"neutral_r_advection","title":"moment_kinetics.neutral_r_advection.update_speed_neutral_r!","text":"calculate the advection speed in the r-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#utils","page":"utils","title":"utils","text":"","category":"section"},{"location":"zz_utils/#moment_kinetics.utils","page":"utils","title":"moment_kinetics.utils","text":"Utility functions\n\n\n\n\n\n","category":"module"},{"location":"zz_utils/#moment_kinetics.utils.enum_from_string-Tuple{Any, Any}","page":"utils","title":"moment_kinetics.utils.enum_from_string","text":"enum_from_string(enum_type, name)\n\nGet an the value of enum_type, whose name is given by the String (or Symbol) name.\n\nReturns nothing if the name is not found.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_CFL","page":"utils","title":"moment_kinetics.utils.get_CFL","text":"get_CFL!(CFL, speed, coord)\n\nCalculate the CFL factor 'speed/(grid spacing)' (with no prefactor) corresponding to advection speed speed for advection. Note that moment_kinetics is set up so that dimension in which advection happens is the first dimension of speed - coord is the coordinate corresponding to this dimension.\n\nThe result is written in CFL. This function is only intended to be used in post-processing.\n\n\n\n\n\n","category":"function"},{"location":"zz_utils/#moment_kinetics.utils.get_backup_filename-Tuple{Any}","page":"utils","title":"moment_kinetics.utils.get_backup_filename","text":"Append a number to the filename, to get a new, non-existing filename to backup the file to.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_default_restart_filename-Tuple{Any, Any}","page":"utils","title":"moment_kinetics.utils.get_default_restart_filename","text":"get_default_restart_filename(io_input, prefix; error_if_no_file_found=true)\n\nGet the default name for the file to restart from, using the input from io_input.\n\nprefix gives the type of file to open, e.g. \"moments\", \"dfns\", or \"initial_electron\".\n\nIf no matching file is found, raise an error unless error_if_no_file_found=false is passed, in which case no error is raised and instead the function returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_minimum_CFL_neutral_vz-Tuple{AbstractArray{T, 5} where T, Any}","page":"utils","title":"moment_kinetics.utils.get_minimum_CFL_neutral_vz","text":"get_minimum_CFL_neutral_vz(speed, vz)\n\nCalculate the minimum (over a shared-memory block) of the CFL factor 'speed/(grid spacing)' (with no prefactor) corresponding to advection speed speed for advection of neutrals in the vz direction.\n\nReduces the result over the shared-memory block (handling distributed parallelism is left to the calling site). The result is only to be used on rank-0 of the shared-memory block.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_minimum_CFL_neutral_z-Tuple{AbstractArray{T, 5} where T, Any}","page":"utils","title":"moment_kinetics.utils.get_minimum_CFL_neutral_z","text":"get_minimum_CFL_neutral_z(speed, z)\n\nCalculate the minimum (over a shared-memory block) of the CFL factor 'speed/(grid spacing)' (with no prefactor) corresponding to advection speed speed for advection of neutrals in the z direction.\n\nReduces the result over the shared-memory block (handling distributed parallelism is left to the calling site). The result is only to be used on rank-0 of the shared-memory block.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_minimum_CFL_r-Tuple{AbstractArray{T, 4} where T, Any}","page":"utils","title":"moment_kinetics.utils.get_minimum_CFL_r","text":"get_minimum_CFL_r(speed, r)\n\nCalculate the minimum (over a shared-memory block) of the CFL factor 'speed/(grid spacing)' (with no prefactor) corresponding to advection speed speed for advection in the r direction.\n\nReduces the result over the shared-memory block (handling distributed parallelism is left to the calling site). The result is only to be used on rank-0 of the shared-memory block.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_minimum_CFL_vpa-Tuple{AbstractArray{T, 4} where T, Any}","page":"utils","title":"moment_kinetics.utils.get_minimum_CFL_vpa","text":"get_minimum_CFL_vpa(speed, vpa)\n\nCalculate the minimum (over a shared-memory block) of the CFL factor 'speed/(grid spacing)' (with no prefactor) corresponding to advection speed speed for advection in the vpa direction.\n\nReduces the result over the shared-memory block (handling distributed parallelism is left to the calling site). The result is only to be used on rank-0 of the shared-memory block.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_minimum_CFL_vperp-Tuple{AbstractArray{T, 4} where T, Any}","page":"utils","title":"moment_kinetics.utils.get_minimum_CFL_vperp","text":"get_minimum_CFL_vperp(speed, vperp)\n\nCalculate the minimum (over a shared-memory block) of the CFL factor 'speed/(grid spacing)' (with no prefactor) corresponding to advection speed speed for advection in the vperp direction.\n\nReduces the result over the shared-memory block (handling distributed parallelism is left to the calling site). The result is only to be used on rank-0 of the shared-memory block.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_minimum_CFL_z-Tuple{AbstractArray{T, 4} where T, Any}","page":"utils","title":"moment_kinetics.utils.get_minimum_CFL_z","text":"get_minimum_CFL_z(speed, z)\n\nCalculate the minimum (over a shared-memory block) of the CFL factor 'speed/(grid spacing)' (with no prefactor) corresponding to advection speed speed for advection in the z direction.\n\nReduces the result over the shared-memory block (handling distributed parallelism is left to the calling site). The result is only to be used on rank-0 of the shared-memory block.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_prefix_iblock_and_move_existing_file-Tuple{Any, Any}","page":"utils","title":"moment_kinetics.utils.get_prefix_iblock_and_move_existing_file","text":"get_prefix_iblock_and_move_existing_file(restart_filename, output_dir)\n\nMove restart_filename to a backup location (if it is in output_dir), returning a prefix and block-index (which might be nothing) which can be used to open the file for reloading variables.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_unnormalized_parameters","page":"utils","title":"moment_kinetics.utils.get_unnormalized_parameters","text":"get_unnormalized_parameters(input::AbstractDict)\nget_unnormalized_parameters(input_filename::String)\n\nGet many parameters for the simulation setup given by input or in the file input_filename, in SI units and eV, returned as an OrderedDict.\n\n\n\n\n\n","category":"function"},{"location":"zz_utils/#moment_kinetics.utils.merge_dict_with_kwargs!-Tuple{Any}","page":"utils","title":"moment_kinetics.utils.merge_dict_with_kwargs!","text":"Dict merge function for named keyword arguments for case when input AbstractDict is a mixed AbstractDict of AbstractDicts and non-AbstractDict float/int/string entries, and the keyword arguments are also a mix of AbstractDicts and non-AbstractDicts\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.print_unnormalized_parameters-Tuple","page":"utils","title":"moment_kinetics.utils.print_unnormalized_parameters","text":"print_unnormalized_parameters(input)\n\nPrint many parameters for the simulation setup given by input (an AbstractDict of parameters or a String giving a filename), in SI units and eV.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.recursive_merge","page":"utils","title":"moment_kinetics.utils.recursive_merge","text":"recursive_merge(a, b)\n\nMerge two AbstractDicts a and b. Any elements that are AbstractDicts are also merged (rather than just replacing with the entry in b).\n\n\n\n\n\n","category":"function"},{"location":"zz_utils/#moment_kinetics.utils.to_hours-Tuple{T} where T<:Dates.TimePeriod","page":"utils","title":"moment_kinetics.utils.to_hours","text":"to_hours(x::T) where {T<:TimePeriod}\n\nConvert a time period x to seconds\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.to_minutes-Tuple{T} where T<:Dates.TimePeriod","page":"utils","title":"moment_kinetics.utils.to_minutes","text":"to_minutes(x::T) where {T<:TimePeriod}\n\nConvert a time period x to seconds\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.to_seconds-Tuple{T} where T<:Dates.TimePeriod","page":"utils","title":"moment_kinetics.utils.to_seconds","text":"to_seconds(x::T) where {T<:TimePeriod}\n\nConvert a time period x to seconds\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The full documentation is online at https://mabarnes.github.io/moment_kinetics.","category":"page"},{"location":"getting_started/#Setup","page":"Getting started","title":"Setup","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"First clone this git repository, e.g. (to clone it into a directory with the default name moment_kinetics)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ git clone git@github.com:mabarnes/moment_kinetics","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The command above assumes that you have an account on Github.com, and that account has ssh keys set up. If that is not the case you can clone using https instead","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ git clone https://github.com/mabarnes/moment_kinetics","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When using https some things (e.g. pushing to the remote repository) may require you to use 2-factor authentication, see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"warning: Warning\nDo not download the zip-file from the Github.com page. This gives you the source code files but does not create a git repository. We get some version information from git when running the code, so without the git repository you will not be able to run a simulation.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you have already installed Julia, ensure that the Julia version is >=  1.9.0 by doing  $ julia --version  at command line. The setup script in step 2 can also download a Julia  binary if you have not already installed Julia.\nIf you are running on a desktop/laptop (rather than an HPC cluster) ensure  that you have an MPI implementation installed (using whatever the usual way  of installing software is on your system). It should not matter which MPI  implementation - openmpi is often a good choice if you have no reason to  prefer a particular one. Check that the MPI compiler wrapper mpicc is  available, e.g.  $ mpicc --version  should run without an error.\nRun the setup script  $ machines/machine_setup.sh  This script will prompt you for various options. The default choices should  be sensible in most cases. On a laptop/desktop the 'name of machine to set  up' will be 'generic-pc' and will set up for interactive use. On supported  clusters, 'name of machine' will be the name of the cluster. On other  clusters 'generic-batch' can be used, but requires some manual setup (see  machines/generic-batch-template/README.md).\nFor more information, see  machine_setup notes.\nIf you want or need to set up 'by hand' without using  machines/machine_setup.sh, see  Manual setup.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Some other notes that might sometimes be useful:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To speed up running scripts or the first call of run_moment_kinetics in a   REPL session, it is possible to compile a 'system image'   (moment_kinetics.so). By running   $ julia --project -O3 precompile.jl   and then start Julia by running for example   $ julia --project -O3 -Jmoment_kinetics.so   this significantly decreases the load time but prevents code changes from   taking effect when moment_kinetics.so is used until you repeat the   compilation of the system image. Note that this also prevents the Revise   package from updating moment_kinetics when you edit the code during and   interactive session.\nSystem images are created by default on HPC clusters, and are required to   use the provided jobscript-*.template submission scripts (used by   submit-run.sh and submit-restart.sh). This is to try and minimise the   compilation that has to be replicated on all the (possibly thousands of)   processes in a parallel run. After changing source code, you should run   $ precompile-submit.sh   (to re-compile the moment_kinetics.so system image).\nIn the course of development, it is sometimes helpful to upgrade the Julia   version. Upgrading the version of Julia or upgrading packages may require a   fresh installation of moment_kinetics. To make a fresh install with the   latest package versions you should be able to just run   julia   pkg> update   (to enter 'Package mode' enter ']' at the julia> prompt). It might   sometimes necessary or helpful to instead remove (or rename) the   Manifest.jl file in the main directory, and re-run the setup from step 2)   above. It can sometimes be necessary to remove or rename the .julia/   directory (located by default in your home directory) to force all the   dependencies to be rebuilt.\nWhen using the Plots-based post-processing library, one may have to set an   environment variable to avoid error messages from the Qt library. If you   execute the command   $ julia --project run_post_processing.jl runs/your_run_dir/   and see the error message   qt.qpa.xcb: could not connect to display   qt.qpa.plugin: Could not load the Qt platform plugin \"xcb\" in \"\" even though it was found.   This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.   this can be suppressed by setting   export QT_QPA_PLATFORM=offscreen   in your .bashrc or .bash_profile files.","category":"page"},{"location":"getting_started/#Run-a-simulation","page":"Getting started","title":"Run a simulation","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To run julia with optimization, type","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project run_moment_kinetics.jl input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Note that the middle character in -O3 is a capital letter 'O', not a zero. (On HPC clusters, or if you selected the \"set up separate packages for post processing\" option from machines/machine_setup.sh, you should use -O3 --check-bounds=no instead of just -O3, and the same in the Restarting section.)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Options are specified in a TOML file, e.g. input.toml here. The defaults are specified in moment_kinetics_input.jl.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To run in parallel, just put mpirun -np <n> in front of the call you would normally use, with <n> the number of processes to use.\nIt may be more convenient when running moment_kinetics more than once to work from the Julia REPL, e.g.   $ julia -O3 --project   julia> using moment_kinetics   julia> run_moment_kinetics(\"input.toml\")   where input is the name of a TOML file containing the desired options. It   is also possible to pass a Dict() containing any non-default options   desired, which might sometimes be useful in tests or scripts   julia> run_moment_kinetics(input)   Especially when developing the code, a lot of compilation time can be saved   by using Revise.jl, and   re-running a test case in the REPL (without restarting julia) - this is   enabled by default when setting up using machines/machine_setup.sh for   'generic-pc'.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"On an HPC cluster, you can submit a simulation (using the input file input.toml) to the batch queue using the convenience script","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-run.sh input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"See the help text","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-run.sh -h","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"for various command line options to change parameters (e.g. number of nodes, etc.).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you need to rebuild the system images moment_kinetics.so and makie_postproc.so or plots_postproc.so because you have updated the code since they were built, it may be convenient to use","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-precompile-and-run.sh input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"which will submit jobs for compilation, to run the simulation, and to do post processing. The simulation job will wait for the compilation job creating moment_kinetics.so to finish before starting. The post processing job will wait for the compilation job creating makie_postproc.so or plots_postproc.so to finish before starting.","category":"page"},{"location":"getting_started/#Stopping-a-run","page":"Getting started","title":"Stopping a run","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When running in the REPL (especially with MPI) interrupting a run using Ctrl-C can mess things up, and require you to restart Julia. There is also a chance that you might interrupt while writing the output files and corrupt them. To avoid these problems, you can stop the run cleanly (including writing the distribution functions at the last time point, so that it is possible to restart the run from where you stopped it), by creating an empty file called stop in the run directory. For example, if the name of your run is 'my_example'","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ touch runs/my_example/stop","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"moment_kinetics checks for this file when it is going to write output, and if it is present writes all output and then returns cleanly. The 'stop file' is deleted when a run is (re-)started, if present, so you do not have to manually delete it before (re-)starting the run again.","category":"page"},{"location":"getting_started/#Restarting","page":"Getting started","title":"Restarting","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To restart a simulation using input.toml from the last time point in the existing run directory,","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project run_moment_kinetics --restart input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"or to restart from a specific output file - either from the same run or (if the settings are compatible, see below) a different one - here runs/example/example.dfns.h5","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project run_moment_kinetics input.toml runs/example/example.dfns.h5","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The output file must include distribution functions. When not using parallel I/O there will be multiple output files from different MPI ranks - any one of these can be passed.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To do the same from the Julia REPL","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project\njulia> run_moment_kinetics(\"input.toml\", restart=true)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"or","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> run_moment_kinetics(\"input.toml\", restart=\"runs/example/example.dfns.h5\")","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When calling the run_moment_kinetics() function you can also choose a particular time index to restart from, e.g.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> run_moment_kinetics(\"input.toml\", restart=\"runs/example/example.dfns.h5\", restart_time_index=42)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"On an HPC cluster, you can submit a restart (using the input file input.toml) to the batch queue using the convenience script","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-restart.sh input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"or to restart from a particular output file","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-restart.sh -r runs/example/example.dfns.h5 input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"See the help text","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-restart.sh -h","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"for various other command line options to change parameters (e.g. number of nodes, etc.).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you need to rebuild the system images moment_kinetics.so and makie_postproc.so or plots_postproc.so because you have updated the code since they were built, it may be convenient to use","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-precompile-and-restart.sh [-r runs/example/example.dfns.h5] input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"which will submit jobs for compilation, to restart the simulation, and to do post processing. The simulation job will wait for the compilation job creating moment_kinetics.so to finish before starting. The post processing job will wait for the compilation job creating makie_postproc.so or plots_postproc.so to finish before starting.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"It is possible to restart a run from another output file with different resolution settings or different moment-kinetic options. This is done by interpolating variables from the old run onto the new grid.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When interpolating in spatial dimensions it is not recommended to change the length of the domain.\nFor velocity space dimensions, changing the size of the domain should be OK. Points outside the original domain will be filled with propto exp(-v^2) decreasing values.\nWhen changing from 1D (no r-dimension) to 2D (with r-dimension), the interpolated values will be constant in r.\nWhen changing from 1V to 2V or 3V, the interpolated values will be proportional to exp(-v_j^2) in the new dimension(s).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When running in parallel, both the old and the new grids must be compatible with the distributed-MPI parallelisation. When not using Parallel I/O, the distributed-MPI domain decomposition must be identical in the old and new runs (as each block only reads from a single file).","category":"page"},{"location":"getting_started/#Post-processing-with-makie_post_processing","page":"Getting started","title":"Post-processing with makie_post_processing","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The default post-processing module, written to be a bit more generic and flexible than the original Plots-based one, and able to be used interactively, is provided in makie_post_processing, see Post processing.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"On an HPC cluster, when you call ./submit-run.sh or ./submit-restart.sh, a job will (by default) be submitted to run makie_post_processing.makie_post_process or plots_post_processing.analyze_and_plot_data (depending on which you have set up, or on whether you pass the -o argument when both are set up) on the output after the run is finished. You can skip this by passing the -a argument to ./submit-run.sh or ./submit-restart.sh.","category":"page"},{"location":"getting_started/#Original,-Plots-based-post-processing-quickstart","page":"Getting started","title":"Original, Plots-based post processing quickstart","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This post-processing functionality is now disabled by default, but you can enable it by entering y at the \"Would you like to set up plots_post_processing?\" prompt in machines/machine_setup.sh.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To make plots and calculate frequencies/growth rates, run","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia --project -O3 run_post_processing.jl runs/<directory to process>","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"passing the directory to process as a command line argument. Input options for post-processing can be specified in post_processing_input.jl. Note that even when running interactively, it is necessary to restart Julia after modifying post_processing_input.jl.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Post processing can be done for several directories at once using","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia --project -O3 post_processing_driver.jl runs/<directory1> runs/<directory2> ...","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"passing the directories to process as command line arguments. Optionally pass a number as the first argument to parallelise post processing of different directories.","category":"page"},{"location":"getting_started/#Parallel-I/O","page":"Getting started","title":"Parallel I/O","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To enable parallel I/O, HDF5.jl needs to be configured to use an HDF5 library which has MPI enabled and is compiled using the same MPI as you run Julia with. To ensure this happens, machines/machine_setup.sh will download the HDF5 source code and compile a local copy of the library under machines/artifacts, unless you enter n at the \"Do you want to download, and compile a local version of HDF5\" prompt (except on known HPC clusters where an MPI-enabled HDF5 is provided by a module - this is currently true on ARCHER2 - where the module-provided HDF5 is used).","category":"page"},{"location":"getting_started/#Running-parameter-scans","page":"Getting started","title":"Running parameter scans","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Parameter scans (see Parameter scans) can be performed by running","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project run_parameter_scan.jl path/to/scan/input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If running a scan, it can be parallelised by passing the -p argument to julia, e.g. to run on 8 processes","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -p 8 -O3 --project run_parameter_scan.jl path/to/scan/input.toml","category":"page"},{"location":"getting_started/#Tests","page":"Getting started","title":"Tests","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"There is a test suite in the test/ subdirectory. It can be run in a few ways:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Execute some or all of the tests as a script. For example in the terminal run   $ julia -O3 --project moment_kinetics/test/runtests.jl   or in the REPL run   julia> include(\"moment_kinetics/test/runtests.jl\")   Individual test files can also be used instead of runtests.jl, which runs all the tests.\nYou can also run the tests using Pkg. Either using pkg> mode   $ julia -O3 --project   julia> <press ']' to enter pkg mode>   (moment_kinetics) pkg> test moment_kinetics   using Pkg in the REPL   $ julia -O3 --project   julia> import Pkg   julia> Pkg.test(\"moment_kinetics\")   or run on the command line   julia -O3 --project -e \"import Pkg; Pkg.test(\"moment_kinetics\")`   The downside of this method is that it will cause NCDatasets to be   installed if you did not install it already, which might sometimes cause   linking errors (related to the HDF5 library, see Optional   dependencies).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"By default the test suite should run fairly quickly (in a few minutes). To do so, it skips many cases. To run more comprehensive tests, you can activate the --long option:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In the REPL, run   julia> push!(ARGS, \"--long\")   before running the tests.\nRunning from the terminal, pass as a command line argument, e.g.   $ julia -O3 --project --long moment_kinetics/test/runtests.jl\nUsing test_args argument   julia> Pkg.test(\"moment_kinetics\"; test_args=[\"--long\"])   Note the semicolon is necessary.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To get more output on what tests were successful, an option --verbose (or -v) can be passed in a similar way to --long (if any tests fail, the output is printed by default).","category":"page"},{"location":"getting_started/#Manufactured-Solutions-Tests","page":"Getting started","title":"Manufactured Solutions Tests","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In addition to the test suite in the test/ subdirectory, the moment_kinetics project utilises the method of manufactured solutions to test more complicated models in 1D1V,  and 2D2V or 2D3V (for neutral particles). To run these tests we run a normal moment_kinetics simulation, making use of the manufacted solutions test TOML options. We describe how to use  the existing tests below. To set up moment_kinetics to use the manufactured solutions features,  take the following steps:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Install moment_kinetics using the setup instructions above (Setup),  using the plots_post_processing project and make sure that the Symbolics package is installed, e.g., if following the manual setup instructions (Manual setup), these commands would be   $ julia -O3 --project   julia> ]   develop ./moment_kinetics   develop ./plots_post_processing/plots_post_processing   add Symbolics   if you will run the tests with MPI, make sure that MPI is also installed at this step.\nSelect an input file representing the desired test. For example, we can pick from the list  MMS input TOML list.\nRun the input file using the usual command.   julia> using moment_kinetics   julia> run_moment_kinetics(\"runs/your_MMS_test_input.toml\")\nUse the post processing module to test the error norms for the simulation of interest.   julia> using plots_post_processing   julia> analyze_and_plot_data(\"runs/your_MMS_test_input\") This will print out a series of numbers to the terminal which represent the error norms for each field and distribution function compared to the exact analytical solution, at  each time step in the simulation. This error data can be computed for different resolutions.\nFinally, to partially automate this last step when a resolution scan is performed, we provide functions for generating plots of the error data versus resolutions in the file plot_MMS_sequence.jl in the plots_post_processing project. This can be accessed by using the run_MMS_test.jl  script from the command line\n$ julia -O3 --project run_MMS_test.kl\nor by using the underlying functions in the REPL\nimport plots_post_processing\nusing plots_post_processing.plot_MMS_sequence\nrun_mms_test()\nNote that currently the lists of files used as input for the plotting functions are hardcoded for the purposes of self-documenting the tests – these lists could be made input parameters to improve these scripts.","category":"page"},{"location":"machine_setup_notes/#machine_setup-notes","page":"machine_setup notes","title":"machine_setup notes","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"The machines subdirectory provides scripts to set up Julia and moment_kinetics to run on laptops/desktops or on clusters. If the cluster is not one of the currently supported machines, then some additional manual setup is required.","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"Currently supported:","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"\"generic-pc\" - A generic personal computer (i.e. laptop or desktop machine). Set up for interactive use, rather than for submitting jobs to a batch queue.\n\"generic-batch\" - A generic cluster using a batch queue. Requires some manual setup first, see machines/generic-batch-template/README.md.\n\"archer\" - the UK supercomputer ARCHER2\n\"marconi\" - the EUROfusion supercomputer Marconi","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"The usage is described in Getting started. This page contains some extra technical information.","category":"page"},{"location":"machine_setup_notes/#Notes-on-some-prompts-from-the-script","page":"machine_setup notes","title":"Notes on some prompts from the script","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"You will be prompted to enter a location for your .julia directory. If you are installing on a personal computer or on a cluster which allows access to your home directory from compute nodes, it is fine to leave this as the default. If not (e.g. on ARCHER2), you need to set a path which is accessible from the compute nodes.  If you want to create a completely self-contained install (e.g. for reproducibility or for debugging some dependency conflicts), you might want to put .julia within the moment_kinetics directory (i.e. enter .julia at the prompt).","category":"page"},{"location":"machine_setup_notes/#Defaults-for-prompts","page":"machine_setup notes","title":"Defaults for prompts","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"The default value for each of the settings that the user is prompted for interactively are first taken from some sensible, machine-specific defaults. When machines/machine_setup.sh is run, the values chosen by the user are saved in the [moment_kinetics] section of LocalPreferences.toml, and these values are used as the defaults next time machines/machine_setup.sh is run, in order to make it easier to re-run the setup, e.g. because some dependencies need updating, or to change just one or a few settings.","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"A few settings (which are needed before Julia can be started for the first time) are saved into hidden files (.julia_default.txt, .this_machine_name.txt, and .julia_directory_default.txt) instead of into LocalPreferences.toml, to avoid needing to parse a TOML file using bash.","category":"page"},{"location":"machine_setup_notes/#bin/julia","page":"machine_setup notes","title":"bin/julia","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"A symlink or script is created at bin/julia to call the chosen julia executable. On HPC systems we create a file julia.env which must be source'd (to load the right modules, etc.) before julia can be used - in this case julia.env can be used to set up any environment variables, etc. so a symlink is sufficient. On laptops/desktops that will be used interactively, it is inconvenient to have to remember to source julia.env, especially if you have multiple instances of moment_kinetics, so instead the necessary setup (of the JULIA_DEPOT_PATH environment variable, if needed, and a Python venv if the Plots-based post processing is enabled) is done by making bin/julia a   small bash script, which does that setup and then calls the chosen julia   executable, passing through to it any command line arguments.","category":"page"},{"location":"machine_setup_notes/#julia.env","page":"machine_setup notes","title":"julia.env","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"A julia.env file is used on HPC systems to set up the environment (modules and environment variables). On laptop/desktop systems this would be inconvenient (especially if there are multiple instances of moment_kinetics) so a julia.env is not used for these.","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"The julia.env is created from a template julia.env which is located in the subdirectory of machines/ for the specific machine being set up.","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"If you need to run julia interactively (for moment_kinetics) on a machine that uses julia.env, either run source julia.env in each terminal session where you want to use moment_kinetics, or add it to your .bashrc (if this does not conflict with any other projects).","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"warning: Warning\nNote that julia.env runs module purge to remove any already loaded modules (to get a clean environment). It is therefore very likely to interfere with other projects.","category":"page"},{"location":"machine_setup_notes/#Setup-of-post-processing-packages","page":"machine_setup notes","title":"Setup of post processing packages","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"See Post processing packages.","category":"page"},{"location":"machine_setup_notes/#Use-of-system-images","page":"machine_setup notes","title":"Use of system images","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"On HPC clusters, creating system images moment_kinetics.so and for post processing makie_postproc.so and/or plots_postproc.so is required. This is to avoid (as far as practical) wasting CPU hours doing identical compilation in large parallel jobs. If you wanted to remove this requirement for some reason (although this is not recommended), you would need to go to the subdirectory of machines/ for the machine you are working on, and edit the jobscript-run.template, jobscript-restart.template, jobscript-postprocess.template, and jobscript-postprocess-plotsjl.template files to remove the -J*.so argument.  If you do do this, please do not commit those changes and merge them to the master branch of moment_kinetics.","category":"page"},{"location":"machine_setup_notes/#Operations-done-by-machines/machine_setup.sh","page":"machine_setup notes","title":"Operations done by machines/machine_setup.sh","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"The convenience script machine_setup.sh is provide because the actual setup happens in multiple stages, with Julia being restarted in between (as this is required on some machines), and because the script is able to download Julia if Julia is not already installed.","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"The steps done by machines/machine_setp.sh are:","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"Get the name of the 'machine' ('generic-pc', 'archer', etc.) so that machine-dependent setup can be done and machine-specific defaults can be used. ()\nDownload a Julia executable, or prompt the user for the location of one (defaulting to any julia found in $PATH).\nGet the location of the .julia directory to be used by (this copy of) moment_kinetics. At this point we have enough setup to start using julia. Export JULIA_DEPOT_PATH so that this is used any time julia is run in the rest of the script.\nRun machines/shared/machine_setup.jl. This script (whose functions are documented in API documentation):\nprompts the user for most of the settings (and saves them to LocalPreferences.toml from where they can be accessed by other scripts later and used as defaults if machines/machine_setup is re-run)\ncreates the julia.env file (from the template for the given machine) on HPC systems\ncreates the bin/julia symlink or script (see bin/julia)\ncreates a link to the compile_dependencies.sh script for the machine (if there is one).\ninstalls the Revise package and adds using Revise to the startup.jl file (on laptop/desktop systems, and if the user did not de-select this).\nIt is necessary to restart julia after this script has been run, so that we can first source julia.env (if it exists) or use the script at bin/julia in order to use the environment settings in them.\nIf julia.env exists, run source julia.env to load modules, etc.\nSet the optimization flags that will be used for running simulations or for running post processing. These need to be set the same as will be used eventually so that precompilation of dependencies and packages that happens while running machines/machine_setup.sh does not need to be overwritten (due to different optimization flags) later, as this would be a waste of time (although it should work fine).\nAdd various dependencies to the top-level project, by calling machines/shared/add_dependencies_to_project.jl. This will set up MPI and HDF5 to link to the correct libraries. julia needs to be restarted after the setup of MPI and HDF5 is done, which is why this is a separate script from the following one (this separation also allows add_dependencies_to_project.jl to be re-used in makie_post_processing_setup.jl and plots_post_processing_setup.jl if these are to be set up as separate projects from the top-level one).\nComplete the setup by running machines/shared/machine_setup_stage_two.jl, which creates a Python venv with matplotlib installed (if plots_post_processing is enabled), creates symlinks at the top level to scripts to submit batch jobs (if setting up for an HPC cluster), and submits a job to compile a system image for moment_kinetics (if setting up for an HPC cluster, and if the user did not de-select this).\nSet up makie_post_processing (if enabled) by running machines/shared/makie_post_processing_setup.jl and/or plots_post_processing (if enabled) by running machines/shared/plots_post_processing_setup.jl. These scripts also submit jobs to create system images for makie_post_processing or plots_post_processing (if setting up for an HPC cluster, and if the user did not de-select this).\nPrint a message indicating which optimization flags to use for running simulations or for post-processing.","category":"page"},{"location":"machine_setup_notes/#machine_setup_api_documentation","page":"machine_setup notes","title":"API documentation","text":"","category":"section"},{"location":"machine_setup_notes/#moment_kinetics.machine_setup","page":"machine_setup notes","title":"moment_kinetics.machine_setup","text":"Functions to help setting up on known machines\n\n\n\n\n\n","category":"module"},{"location":"machine_setup_notes/#moment_kinetics.machine_setup.get_setting","page":"machine_setup notes","title":"moment_kinetics.machine_setup.get_setting","text":"get_setting(setting_name, message, machine, local_defaults,\n            possible_values=nothing)\n\nPrompt the user to set a setting called setting_name after printing message. Default value is read from local_defaults if it exists there (which it will do if it has been set before, as then it is stored in LocalPreferences.toml), or from sensible defaults in the machine section of default_settings otherwise.\n\n\n\n\n\n","category":"function"},{"location":"machine_setup_notes/#moment_kinetics.machine_setup.get_user_input-Tuple{Any, Any}","page":"machine_setup notes","title":"moment_kinetics.machine_setup.get_user_input","text":"get_user_input(possible_values, default_value)\n\nPrompt for user input. If the user enters nothing, return default_value. Check that the entered value is one of possible_values, if not prompt again.\n\n\n\n\n\n","category":"method"},{"location":"machine_setup_notes/#moment_kinetics.machine_setup.machine_setup_moment_kinetics-Tuple{String}","page":"machine_setup notes","title":"moment_kinetics.machine_setup.machine_setup_moment_kinetics","text":"machine_setup_moment_kinetics(machine::String; ; no_force_exit::Bool=false,\n                              interactive::Bool=true)\n\nDo setup for a known machine, prompting the user for various settings (with defaults set to sensible values - if the script has been run before, the defaults are the previously used values):\n\nOn clusters that use a module system, provide julia.env at the top level of the moment_kinetics repo.\nCall\nsource julia.env\nto get the correct modules for running moment_kinetics, either on the command line (to get them for the current session) or in your .bashrc (to get them by default). Note that this calls module purge so will remove any currently loaded modules when it is run.\nMakes a symlink to, or a bash script that calls, the Julia executable used to run this command at bin/julia under the moment_kinetics repo, so that setup and job submission scripts can use a known relative path.\nnote: Note\nIf you change the Julia executable, e.g. to update to a new verison, you will need to either replace the symlink <moment_kinetics>/bin/julia or edit the bash script at <moment_kinetics>/bin/julia by hand, or re-run this function using the new executable.\n\nUsually it is necessary for Julia to be restarted after running this function to run Julia with the correct JULIA_DEPOT_PATH, etc. so the function will force Julia to exit. If for some reason this is not desired (e.g. when debugging), pass no_force_exit=true.\n\nThe interactive argument exists so that when this function is called from another script, terminal output with instructions for the next step can be disabled.\n\nCurrently supported machines:\n\n\"generic-pc\" - A generic personal computer (i.e. laptop or desktop machine).. Set up   for interactive use, rather than for submitting jobs to a batch queue.\n\"generic-batch\" - A generic cluster using a batch queue. Requires some manual setup   first, see machines/generic-batch-template/README.md.\n\"archer\" - the UK supercomputer ARCHER2\n\"marconi\" - the EUROfusion supercomputer   Marconi\n\nnote: Note\nThe settings created by this function are saved in LocalPreferences.toml. It might sometimes be useful to edit these by hand (e.g.  the account setting if this needs to be changed.): it is fine to do this.\n\n\n\n\n\n","category":"method"},{"location":"zz_collision_frequencies/#collision_frequencies","page":"collision_frequencies","title":"collision_frequencies","text":"","category":"section"},{"location":"zz_collision_frequencies/#moment_kinetics.collision_frequencies.get_collision_frequency_ee-Tuple{Any, Any, Any}","page":"collision_frequencies","title":"moment_kinetics.collision_frequencies.get_collision_frequency_ee","text":"get_collision_frequency_ee(collisions, n, vthe)\n\nCalculate the electron-electron collision frequency, depending on the settings/parameters in collisions, for the given density n and electron thermal speed vthe.\n\nn and vthe may be scalars or arrays, but should have shapes that can be broadcasted together.\n\n\n\n\n\n","category":"method"},{"location":"zz_collision_frequencies/#moment_kinetics.collision_frequencies.get_collision_frequency_ei-Tuple{Any, Any, Any}","page":"collision_frequencies","title":"moment_kinetics.collision_frequencies.get_collision_frequency_ei","text":"get_collision_frequency_ei(collisions, n, vthe)\n\nCalculate the electron-electron collision frequency, depending on the settings/parameters in collisions, for the given density n and electron thermal speed vthe.\n\nn and vthe may be scalars or arrays, but should have shapes that can be broadcasted together.\n\n\n\n\n\n","category":"method"},{"location":"zz_collision_frequencies/#moment_kinetics.collision_frequencies.get_collision_frequency_ii-Tuple{Any, Any, Any}","page":"collision_frequencies","title":"moment_kinetics.collision_frequencies.get_collision_frequency_ii","text":"get_collision_frequency_ii(collisions, n, vth)\n\nCalculate the ion-ion collision frequency, depending on the settings/parameters in collisions, for the given density n and thermal speed vth.\n\nn and vth may be scalars or arrays, but should have shapes that can be broadcasted together.\n\n\n\n\n\n","category":"method"}]
}
