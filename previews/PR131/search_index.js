var documenterSearchIndex = {"docs":
[{"location":"zz_scan_input/#scan_input","page":"scan_input","title":"scan_input","text":"","category":"section"},{"location":"zz_scan_input/","page":"scan_input","title":"scan_input","text":"Modules = [moment_kinetics.scan_input]","category":"page"},{"location":"zz_scan_input/#moment_kinetics.scan_input.base_name","page":"scan_input","title":"moment_kinetics.scan_input.base_name","text":"\n\n\n\n","category":"constant"},{"location":"zz_scan_input/#moment_kinetics.scan_input.combine_outer","page":"scan_input","title":"moment_kinetics.scan_input.combine_outer","text":"By default, inputs are combined with an 'inner product', i.e. inputs a,b,c are combined as (a[1],b[1],c[1]), (a[2],b[2],c[2]), etc. Any inputs named in 'combine_outer' are instead combined with an 'outer product', i.e. an entry is created for every value of those inputs combined with every combination of the other inputs.\n\n\n\n\n\n","category":"constant"},{"location":"zz_scan_input/#moment_kinetics.scan_input.mk_name-Tuple{Any}","page":"scan_input","title":"moment_kinetics.scan_input.mk_name","text":"\n\n\n\n","category":"method"},{"location":"zz_scan_input/#moment_kinetics.scan_input.mk_scan_inputs-Tuple{}","page":"scan_input","title":"moment_kinetics.scan_input.mk_scan_inputs","text":"\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_structs/#moment_kinetics_structs","page":"moment_kinetics_structs","title":"moment_kinetics_structs","text":"","category":"section"},{"location":"zz_moment_kinetics_structs/","page":"moment_kinetics_structs","title":"moment_kinetics_structs","text":"Modules = [moment_kinetics.moment_kinetics_structs]","category":"page"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs","text":"structs used within moment_kinetics that should be defined early to avoid dependency cycles when they are used by several other modules.\n\n\n\n\n\n","category":"module"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.discretization_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.discretization_info","text":"discretization_info for one dimension\n\nAll the specific discretizations in moment_kinetics are subtypes of this type.\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.em_fields_struct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.em_fields_struct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.null_spatial_dimension_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.null_spatial_dimension_info","text":"Type representing a spatial dimension with only one grid point\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.null_velocity_dimension_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.null_velocity_dimension_info","text":"Type representing a velocity space dimension with only one grid point\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.scratch_pdf","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.scratch_pdf","text":"\n\n\n\n","category":"type"},{"location":"shared_memory_debugging/#Shared-memory-debugging","page":"Shared memory debugging","title":"Shared memory debugging","text":"","category":"section"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"This debug_test directory contains scripts for running a set of short runs, intended to be used with the --debug flag to check for bugs (e.g. race conditions). The output is not checked - the intention is just to catch errors raised by the debugging checks.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The inputs only have 3 time-steps, and very few grid points, because the debug checks are very slow. The actual output is not important, so it does not matter that the runs are badly under-resolved.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"It may be necessary to use the --compiled-modules=no flag to Julia for changes to the --debug setting to be picked up correctly. This setting means that all precompilation is redone each time Julia is started, which can be slow. An alternative workaround is to hard-code the moment_kinetics.debugging._debug_level variable in debugging.jl to the desired value.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"To run the debug tests, call (from the top-level moment_kinetics directory) something like","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"julia --project --check-bounds=yes --compiled-modules=no debug_test/runtests.jl --debug 99","category":"page"},{"location":"shared_memory_debugging/#Finding-race-conditions","page":"Shared memory debugging","title":"Finding race conditions","text":"","category":"section"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The code is parallelized using MPI with shared memory arrays. 'Race conditions' can occur if a shared array is accessed incorrectly. All the processes sharing an array can be synchronized, ensuring they pass through the following code block with a consistent state, by using the _block_synchronize() function (which calls MPI.Barrier() to synchronize the processes). Race conditions occur if between consecutive calls to _block_synchronize() any array is:","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"written by 2 or more processes at the same position\nwritten by one process at a certain position, and read by one or more other processes at the same position.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"If a race condition occurs, it can result in errors in the results. These are sometimes small, but often show inconsistent results between runs (because results erroneously depend on the execution order on different processes). They are undefined behaviour though, and so can also cause anything up to segfaults.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The provided debugging routines can help to pin down where either of these errors happen.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The @debug_shared_array macro (activated at --debug 2 or higher) counts all reads and writes to shared arrays by each process, and checks at each _block_synchronize() call whether either pattern has occurred since the previous _block_synchronize(). If they have and in addition @debug_track_array_allocate_location is active (--debug 3 or higher), then the array for which the error occured is identified by printing a stack-trace of the location where it was allocated, and the stack-trace for the exception shows the location of the _block_synchronize() call where the error occured.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"@debug_block_synchronize (activated at --debug 4)checks that all processes called _block_synchronize() from the same place - i.e. the same line in the code, checked by comparing stack traces.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"@debug_detect_redundant_block_synchronize (activated at --debug 5) aims to find any unnecessary calls to _block_synchronize(). These calls can be somewhat expensive (for large numbers of processes at least), so it is good to minimise the number. When this mode is active, at each _block_synchronize() a check is made whether there would be a race-condition error if the previous _block_synchronize() call was removed. If there would not be, then the previous call was unnecessary and could be removed. The tricky part is that whether it was necessary or not could depend on the options being used... Detecting redundant block_synchronize() calls requires that all dimensions that could be split over processes are actually split over processes, which demands a large number of processes are used. The @debug_detect_redundant_block_synchronize flag, when activated, modifies the splitting algorithm to force every dimension to be split if possible, and raise an error if not.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"Suggested debugging strategy for race conditions is:","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"Look at the loop types and ensure that there is an appropriate begin_*_region() call before each new loop type.\nRun debug_test/runtests.jl with @debug_shared_array activated, but not @debug_detect_redundant_block_synchronize. It will be faster to first run without @debug_track_array_allocate_location to find failing tests, then with @debug_track_array_allocate_location to help identify the cause of the failure. Usually a failure should indicate where there is a missing begin_*_region() call. There may be places though where synchronization is required even though the type of loop macros used does not change (for example when phi is calculated contributions from all charged species need to be summed, resulting in an unusual pattern of array accesses); in this case _block_synchronize() can be called directly.\nThe function debug_check_shared_memory() can be inserted between begin_*_region() calls when debugging to narrow down the location where the incorrect array access occured. It is defined when @debug_shared_array is active, and can be imported with using ..communication: debug_check_shared_memory(). The function runs the same error checks as are added by @debug_shared_array in _block_synchronize().\nThe tests in debug_test/ check for correctness by looping over the dimensions and forcing each to be split over separate processes in turn. This allows the correctness checks to be run using only 2 processes, which would not be possible if all dimensions had to be split at the same time.\n[This final level of checking only looks for minor optimizations rather than finding bugs, so it is much less important than the checks above.] Run debug_test/debug_redundant_synchronization/runtests.jl with @debug_detect_redundant_block_synchronize activated. This should show if any call to _block_synchronize() (including the ones inside begin_*_region() calls) was 'unnecessary' - i.e. there would be no incorrect array accesses if it was removed. This test needs to be run on a suitable combination of grid sizes and numbers of processes so that all dimensions are split across multiple processes to avoid false positives.  Any redundant calls which appear in all tests can be deleted.  Redundant calls that appear in only some tests (unless they are in some code block that is just not called in all the other tests) should preferably be moved inside a conditional block, so that they are called only when necessary, if a suitable one exists. If there is no conditional block that the call can be moved to, it may sometimes be necessary to just test one or more options before calling, e.g.\nmoments.evolve_upar && _block_synchronize()\nThe checks for redundant _block_synchronize() calls have been separated from the correctness checks so that the correctness checks can be run in the CI using only 2 processes, while the redundancy checks can be run manually on a machine with enough memory and cpu cores.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"You can find out what loop type is currently active by looking at loop_ranges[].parallel_dims. This variable is a Tuple containing Symbols for each dimension currently being parallelized.","category":"page"},{"location":"zz_analysis/#analysis","page":"analysis","title":"analysis","text":"","category":"section"},{"location":"zz_analysis/","page":"analysis","title":"analysis","text":"Modules = [moment_kinetics.analysis]","category":"page"},{"location":"zz_analysis/#moment_kinetics.analysis","page":"analysis","title":"moment_kinetics.analysis","text":"\n\n\n\n","category":"module"},{"location":"zz_analysis/#moment_kinetics.analysis.analyze_2D_instability-NTuple{7, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_2D_instability","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.analyze_fields_data-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_fields_data","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.analyze_moments_data-NTuple{8, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_moments_data","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.analyze_pdf_data-NTuple{7, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.check_Chodura_condition","page":"analysis","title":"moment_kinetics.analysis.check_Chodura_condition","text":"Check the (kinetic) Chodura condition\n\nChodura condition is: ∫d^3v F/vpa^2 ≤ mi ne/Te\n\nReturn a tuple (whose first entry is the result for the lower boundary and second for the upper) of the ratio which is 1 if the Chodura condition is satisfied (with equality): Te/(mi ne) * ∫d^3v F/vpa^2\n\nCurrently only evaluates condition for the first species: is=1\n\n2D2V\n\nIn normalised form (normalised variables suffixed with 'N'): vpa = cref vpaN vperp = cref vperpN ne = nref neN Te = Tref TeN F = FN nref / cref^3 pi^3/2 cref = sqrt(2 Tref / mi)\n\ncref^3 ∫d^3vN FN nref / cref^3 pi^3/2 cref^2 vpaN^2 ≤ mi nref neN / Tref TeN nref / (pi^3/2 cref^2) * ∫d^3vN FN / vpaN^2 ≤ mi nref neN / Tref TeN mi nref / (pi^3/2 2 Tref) * ∫d^3vN FN / vpaN^2 ≤ mi nref neN / Tref TeN 1 / (2 pi^3/2) * ∫d^3vN FN / vpaN^2 ≤ neN / TeN 1 / (2 pi^3/2) * ∫d^3vN FN / vpaN^2 ≤ neN / TeN TeN / (2 neN pi^3/2) * ∫d^3vN FN / vpaN^2 ≤ 1\n\nNote that integrate_over_vspace() includes the 1/pi^3/2 factor already.\n\n1D1V\n\nThe 1D1V code evolves the marginalised distribution function f = ∫d^2vperp F so the Chodura condition becomes ∫dvpa f/vpa^2 ≤ mi ne/Te\n\nIn normalised form (normalised variables suffixed with 'N'): vpa = cref vpaN ne = nref neN Te = Tref TeN f = fN nref / cref sqrt(pi) cref = sqrt(2 Tref / mi)\n\ncref ∫dvpaN fN nref / cref sqrt(pi) cref^2 vpaN^2 ≤ mi nref neN / Tref TeN nref / (sqrt(pi) cref^2) * ∫dvpaN fN / vpaN^2 ≤ mi nref neN / Tref TeN mi nref / (sqrt(pi) 2 Tref) * ∫dvpaN fN / vpaN^2 ≤ mi nref neN / Tref TeN 1 / (2 sqrt(pi)) * ∫dvpaN fN / vpaN^2 ≤ neN / TeN 1 / (2 sqrt(pi)) * ∫dvpaN fN / vpaN^2 ≤ neN / TeN TeN / (2 neN sqrt(pi)) * ∫dvpaN fN / vpaN^2 ≤ 1\n\nNote that integrate_over_vspace() includes the 1/sqrt(pi) factor already.\n\nIf ir0 is passed, only load the data for as single r-point (to save memory).\n\n\n\n\n\n","category":"function"},{"location":"zz_analysis/#moment_kinetics.analysis.field_line_average-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.field_line_average","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_Fourier_modes_1D-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, moment_kinetics.coordinates.coordinate, Any, Any}} where T","page":"analysis","title":"moment_kinetics.analysis.get_Fourier_modes_1D","text":"Get 1D Fourier transform (in r) of nonuniformdata\n\nFirst interpolates to uniform grid, then uses FFT.\n\nIf zind is not given, find the zind where mode seems to be growing most strongly.\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_Fourier_modes_2D-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, moment_kinetics.coordinates.coordinate, Any, moment_kinetics.coordinates.coordinate, Any}} where T","page":"analysis","title":"moment_kinetics.analysis.get_Fourier_modes_2D","text":"Get 2D Fourier transform (in r and z) of nonuniformdata\n\nFirst interpolates to uniform grid, then uses FFT\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_r_perturbation-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T","page":"analysis","title":"moment_kinetics.analysis.get_r_perturbation","text":"Return (v - mean(v, dims=2))\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.steady_state_residuals-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.steady_state_residuals","text":"steady_state_residuals(variable, variable_at_previous_time, dt;\n                       epsilon=0.0001, use_mpi=false)\n\nCalculate how close a variable is to steady state.\n\nCalculates several quantities. Define the 'squared absolute residual' r_mathrmabs(t)^2 for a quantity a(tx) as\n\nr_mathrmabs(t)^2 = left( a(tx) - a(t - delta tx) right)\n\nand the 'squared relative residual' r_mathrmrel(t)^2\n\nr_mathrmrel(t)^2 = left( fraca(tx) - a(t - delta tx)delta t left a(tx) + epsilon max_x(a(tx)) right right)\n\nwhere x stands for any spatial and velocity coordinates, and the offset epsilon max_x(a(tx)) is used to avoid points where a(tx) happens to be very close to zero from dominating the result in the 'squared relative residual', with max_x being the maximum over the x coordinate(s). Returns an OrderedDict containing: the maximum 'absolute residual' max_xleft( sqrtr_mathrmabs(t)^2 right) (\"RMS absolute residual\"); the root-mean-square (RMS) 'absolute residual' left sqrtr_mathrmabs(t)^2 right_x (\"max absolute residual\"); the maximum 'relative residual' max_xleft( sqrtr_mathrmrel(t)^2 right) (\"RMS relative residual\"); the root-mean-square (RMS) 'relative residual' left sqrtr_mathrmrel(t)^2 right_x (\"max relative residual\").\n\nvariable gives the value of a(tx) at the current time, variable_at_previous_time the value a(t - delta t x) at a previous time and dt gives the difference in times delta t. All three can be arrays with a time dimension of the same length, or have no time dimension.\n\nBy default runs in serial, but if use_mpi=true is passed, assume MPI has been initialised, and that variable has r and z dimensions but no species dimension, and use @loop_* macros. In this case the result is returned only on global rank 0. When using distributed-memory MPI, this routine will double-count the points on block boundaries.\n\nIf only_max_abs=true is passed, then only calculate the 'maxium absolute residual'. In this case the OrderedDict returned will have only one entry, for \"max absolute residual\".\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.steady_state_square_residuals-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.steady_state_square_residuals","text":"steady_state_square_residuals(variable, variable_at_previous_time, dt;\n                              variable_max=nothing, epsilon=1.0e-4,\n                              use_mpi=false, only_max_abs=false)\n\nUsed to calculate the mean square residual for steady_state_residuals.\n\nUseful to define this separately as it can be called on (equally-sized) chunks of the variable and then combined appropriately. If this is done, the global maximum of abs.(variable) should be passed to variable_max.\n\nSee steady_state_residuals for documenation of the other arguments. The return values of steady_state_residuals are the square-root of the return values of this function.\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#post_processing","page":"post_processing","title":"post_processing","text":"","category":"section"},{"location":"zz_post_processing/","page":"post_processing","title":"post_processing","text":"Modules = [moment_kinetics.post_processing]","category":"page"},{"location":"zz_post_processing/#moment_kinetics.post_processing","page":"post_processing","title":"moment_kinetics.post_processing","text":"\n\n\n\n","category":"module"},{"location":"zz_post_processing/#moment_kinetics.post_processing.allocate_global_zr_fields-Tuple{Any, Any, Any}","page":"post_processing","title":"moment_kinetics.post_processing.allocate_global_zr_fields","text":"functions to allocate arrays that are used at run-time to postprocess data that is stored in the netcdf files\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.analyze_and_plot_data-Tuple","page":"post_processing","title":"moment_kinetics.post_processing.analyze_and_plot_data","text":"analyze_and_plot_data(prefix...; run_index=nothing)\n\nMake some plots for the simulation at prefix. If more than one argument is passed to prefix, plot all the simulations together.\n\nThe strings passed to prefix should be either a directory (which contains run output) or the prefix of output files, like <directory>/<prefix> where the output files are <directory>/<prefix>.moments.h5 and <directory>/<prefix>.dfns.h5.\n\nIf a single value is passed for prefix the plots/movies are created in the same directory as the run, and given names based on the name of the run. If multiple values are passed, the plots/movies are given names beginning with compare_ and are created in the comparison_plots/ subdirectory.\n\nBy default plots output from all restarts in a directory. To select a single run, pass the run_index argument - the value corresponds to the _<i> suffix given to output files when restarting. run_index can be an integer (which is applied to all directories in prefix...), or a tuple of integers (which should have the same length as the number of directories passed to prefix...). Use run_index=-1 to get the most recent run (which does not have a _<i> suffix). Note that run_index is only used when a directory (rather than the prefix of a specific output file) is passed to prefix...\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.calculate_and_write_frequencies-NTuple{9, Any}","page":"post_processing","title":"moment_kinetics.post_processing.calculate_and_write_frequencies","text":"\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.calculate_differences-Tuple","page":"post_processing","title":"moment_kinetics.post_processing.calculate_differences","text":"Find the maximum difference, as a function of time, between two or more outputs for each variable.\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.compare_fields_symbolic_test-NTuple{13, Any}","page":"post_processing","title":"moment_kinetics.post_processing.compare_fields_symbolic_test","text":"\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.draw_v_parallel_zero!-Tuple{Plots.Plot, AbstractVector, Any, Any, Bool, Bool}","page":"post_processing","title":"moment_kinetics.post_processing.draw_v_parallel_zero!","text":"Add a thin, red, dashed line showing vparallel=(vth*wparallel+upar)=0 to a 2d plot with axes (z,vpa).\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.fit_cosine","page":"post_processing","title":"moment_kinetics.post_processing.fit_cosine","text":"Fit a cosine to a 1d array\n\nFit function is Acos(2πn(z + δ)/L)\n\nThe domain z is taken to be periodic, with the first and last points identified, so L=z[end]-z[begin]\n\nArguments\n\nz : Array     1d array with positions of the grid points - should have the same length as data data : Array     1d array of the data to be fit amplitudeguess : Float     Initial guess for the amplitude (the value from the previous time point might be a     good choice) offsetguess : Float     Initial guess for the offset (the value from the previous time point might be a good     choice) n : Int, default 1     The periodicity used for the fit\n\nReturns\n\namplitude : Float     The amplitude A of the cosine fit offset : Float     The offset δ of the cosine fit error : Float     The RMS of the difference between data and the fit\n\n\n\n\n\n","category":"function"},{"location":"zz_post_processing/#moment_kinetics.post_processing.fit_delta_phi_mode-Tuple{Any, Any, Any}","page":"post_processing","title":"moment_kinetics.post_processing.fit_delta_phi_mode","text":"Fit delta_phi to get the frequency and growth rate.\n\nNote, expect the input to be a standing wave (as simulations are initialised with just a density perturbation), so need to extract both frequency and growth rate from the time-variation of the amplitude.\n\nThe function assumes that if the amplitude does not cross zero, then the mode is non-oscillatory and so fits just an exponential, not exp*cos. The simulation used as input should be long enough to contain at least ~1 period of oscillation if the mode is oscillatory or the fit will not work.\n\nArguments\n\nz : Array{mkfloat, 1}     1d array of the grid point positions t : Array{mkfloat, 1}     1d array of the time points deltaphi : Array{mkfloat, 2}     2d array of the values of delta_phi(z, t)\n\nReturns\n\nphifitresult struct whose fields are:     growthrate : mkfloat         Fitted growth rate of the mode     amplitude0 : mkfloat         Fitted amplitude at t=0     frequency : mkfloat         Fitted frequency of the mode     offset0 : mkfloat         Fitted offset at t=0     amplitudefiterror : mkfloat         RMS error in fit to ln(amplitude) - i.e. ln(A)     offsetfiterror : mkfloat         RMS error in fit to offset - i.e. δ     cosinefiterror : mkfloat         Maximum of the RMS errors of the cosine fits at each time point     amplitude : Array{mkfloat, 1}         Values of amplitude from which growthrate fit was calculated     offset : Array{mk_float, 1}         Values of offset from which frequency fit was calculated\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.get_tuple_of_return_values-Tuple{Any, Vararg{Any}}","page":"post_processing","title":"moment_kinetics.post_processing.get_tuple_of_return_values","text":"get_tuple_of_return_values(func, arg_tuples...)\n\nSuppose func(args...) returns a tuple of return values, then get_tuple_of_return_values(func, arg_tuples...) returns a tuple (with an entry for each return value of func) of tuples (one for each argument in each of arg_tuples...) of return values.\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.get_unnormalised_f_coords_2d-NTuple{9, Any}","page":"post_processing","title":"moment_kinetics.post_processing.get_unnormalised_f_coords_2d","text":"Get the unnormalised distribution function and unnormalised ('lab space') coordinates.\n\nInputs should depend only on z and vpa.\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.get_unnormalised_f_dzdt_1d-NTuple{8, Any}","page":"post_processing","title":"moment_kinetics.post_processing.get_unnormalised_f_dzdt_1d","text":"Get the unnormalised distribution function and unnormalised ('lab space') dzdt coordinate at a point in space.\n\nInputs should depend only on vpa.\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.init_postprocessing_options-NTuple{10, Any}","page":"post_processing","title":"moment_kinetics.post_processing.init_postprocessing_options","text":"\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.moving_average-Tuple{AbstractVector, Int64}","page":"post_processing","title":"moment_kinetics.post_processing.moving_average","text":"Calculate a moving average\n\nresult[i] = mean(v[i-n:i+n])\n\nExcept near the ends of the array where indices outside the range of v are skipped.\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.plot_1D_1V_diagnostics-NTuple{47, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_1D_1V_diagnostics","text":"\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.plot_charged_pdf-NTuple{21, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_charged_pdf","text":"plots various slices of the ion pdf (1d and 2d, stills and animations)\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.plot_dfns-NTuple{21, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_dfns","text":"\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.plot_fields-NTuple{11, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_fields","text":"\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.plot_moments-NTuple{25, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_moments","text":"\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.plot_neutral_pdf-NTuple{23, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_neutral_pdf","text":"plots various slices of the neutral pdf (1d and 2d, stills and animations)\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.plot_unnormalised_f2d-Tuple{Any, Any, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_unnormalised_f2d","text":"Make a 2d plot of an unnormalised f on unnormalised coordinates, as returned from getunnormalisedf_coords()\n\nNote this function requires using the PyPlot backend to support 2d coordinates being passed to heatmap().\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.read_distributed_zr_data!-Union{Tuple{N}, Tuple{Array{Float64, N}, String, Tuple, String, Tuple, Int64, Int64, Int64}} where N","page":"post_processing","title":"moment_kinetics.post_processing.read_distributed_zr_data!","text":"Read data which is a function of (z,r,t) or (z,r,species,t)\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.read_distributed_zwallr_data!-Union{Tuple{N}, Tuple{Array{Float64, N}, String, Tuple, String, Tuple, Int64, Int64, String}} where N","page":"post_processing","title":"moment_kinetics.post_processing.read_distributed_zwallr_data!","text":"Read data which is a function of (r,t) or (r,species,t) and associated to one of the wall boundaries\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.trygif-Tuple{Any, Any}","page":"post_processing","title":"moment_kinetics.post_processing.trygif","text":"Call gif, but catch the exception if there is an error\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing/#moment_kinetics.post_processing.trysavefig-Tuple{Any}","page":"post_processing","title":"moment_kinetics.post_processing.trysavefig","text":"Call savefig, but catch the exception if there is an error\n\n\n\n\n\n","category":"method"},{"location":"zz_quadrature/#quadrature","page":"quadrature","title":"quadrature","text":"","category":"section"},{"location":"zz_quadrature/","page":"quadrature","title":"quadrature","text":"Modules = [moment_kinetics.quadrature]","category":"page"},{"location":"zz_quadrature/#moment_kinetics.quadrature","page":"quadrature","title":"moment_kinetics.quadrature","text":"\n\n\n\n","category":"module"},{"location":"zz_quadrature/#moment_kinetics.quadrature.composite_simpson_weights-Tuple{Any}","page":"quadrature","title":"moment_kinetics.quadrature.composite_simpson_weights","text":"compositesimpsonweights creates, computes, and returns an array for the 1D integration weights associated with each grid point using composite Simpson's rule\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#input_structs","page":"input_structs","title":"input_structs","text":"","category":"section"},{"location":"zz_input_structs/","page":"input_structs","title":"input_structs","text":"Modules = [moment_kinetics.input_structs]","category":"page"},{"location":"zz_input_structs/#moment_kinetics.input_structs","page":"input_structs","title":"moment_kinetics.input_structs","text":"\n\n\n\n","category":"module"},{"location":"zz_input_structs/#moment_kinetics.input_structs.advance_info","page":"input_structs","title":"moment_kinetics.input_structs.advance_info","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.advection_input","page":"input_structs","title":"moment_kinetics.input_structs.advection_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.advection_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.advection_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.collisions_input","page":"input_structs","title":"moment_kinetics.input_structs.collisions_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.drive_input","page":"input_structs","title":"moment_kinetics.input_structs.drive_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.drive_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.drive_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.electron_physics_type","page":"input_structs","title":"moment_kinetics.input_structs.electron_physics_type","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.evolve_moments_options","page":"input_structs","title":"moment_kinetics.input_structs.evolve_moments_options","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.geometry_input","page":"input_structs","title":"moment_kinetics.input_structs.geometry_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.grid_input","page":"input_structs","title":"moment_kinetics.input_structs.grid_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.grid_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.grid_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.initial_condition_input","page":"input_structs","title":"moment_kinetics.input_structs.initial_condition_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.initial_condition_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.initial_condition_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.io_input","page":"input_structs","title":"moment_kinetics.input_structs.io_input","text":"Settings and input for setting up file I/O\n\n\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.pp_input","page":"input_structs","title":"moment_kinetics.input_structs.pp_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.species_composition","page":"input_structs","title":"moment_kinetics.input_structs.species_composition","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.species_parameters","page":"input_structs","title":"moment_kinetics.input_structs.species_parameters","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.species_parameters_mutable","page":"input_structs","title":"moment_kinetics.input_structs.species_parameters_mutable","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.time_input","page":"input_structs","title":"moment_kinetics.input_structs.time_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#Base.get-Tuple{Dict, Any, Enum}","page":"input_structs","title":"Base.get","text":"Utility method for converting a string to an Enum when getting from a Dict, based on the type of the default value\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#moment_kinetics.input_structs.Dict_to_NamedTuple-Tuple{Any}","page":"input_structs","title":"moment_kinetics.input_structs.Dict_to_NamedTuple","text":"Convert a Dict whose keys are String or Symbol to a NamedTuple\n\nUseful as NamedTuple is immutable, so option values cannot be accidentally changed.\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#moment_kinetics.input_structs.set_defaults_and_check_section!-Tuple{AbstractDict, Any}","page":"input_structs","title":"moment_kinetics.input_structs.set_defaults_and_check_section!","text":"Set the defaults for options in a section, and check that there are not any unexpected options (i.e. options that have no default).\n\nModifies the options[section_name]::Dict by adding defaults for any values that are not already present.\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#moment_kinetics.input_structs.set_defaults_and_check_top_level!-Tuple{AbstractDict}","page":"input_structs","title":"moment_kinetics.input_structs.set_defaults_and_check_top_level!","text":"Set the defaults for options in the top level of the input, and check that there are not any unexpected options (i.e. options that have no default).\n\nModifies the options[section_name]::Dict by adding defaults for any values that are not already present.\n\nIgnores any sections, as these will be checked separately.\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#array_allocation","page":"array_allocation","title":"array_allocation","text":"","category":"section"},{"location":"zz_array_allocation/","page":"array_allocation","title":"array_allocation","text":"Modules = [moment_kinetics.array_allocation]","category":"page"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation","page":"array_allocation","title":"moment_kinetics.array_allocation","text":"\n\n\n\n","category":"module"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_bool-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_bool","text":"allocate array with dimensions given by dims and entries of type Bool\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_complex-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_complex","text":"allocate 1d array with dimensions given by dims and entries of type Complex{mk_float}\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_float-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_float","text":"allocate array with dimensions given by dims and entries of type mk_float\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_int-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_int","text":"allocate 1d array with dimensions given by dims and entries of type mk_int\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_shared_bool-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_bool","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_shared_complex-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_complex","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_shared_float-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_float","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_shared_int-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_int","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#vpa_advection","page":"vpa_advection","title":"vpa_advection","text":"","category":"section"},{"location":"zz_vpa_advection/","page":"vpa_advection","title":"vpa_advection","text":"Modules = [moment_kinetics.vpa_advection]","category":"page"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection","page":"vpa_advection","title":"moment_kinetics.vpa_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_constant!-NTuple{5, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_constant!","text":"update the advection speed dvpa/dt = constant\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_default!-NTuple{12, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_default!","text":"\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_linear-NTuple{5, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_linear","text":"update the advection speed dvpa/dt = const*(vpa + L/2)\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_n_p_evolution!-NTuple{10, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_n_p_evolution!","text":"update the advection speed in the parallel velocity coordinate for the case where density and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized velocity vpahat = vpa/vth\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_n_u_evolution!-NTuple{9, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_n_u_evolution!","text":"update the advection speed in the parallel velocity coordinate for the case where density and flow are evolved independently from the pdf; in this case, the parallel velocity coordinate is the peculiar velocity wpa = vpa-upar\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_n_u_p_evolution!-NTuple{9, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_n_u_p_evolution!","text":"update the advection speed in the parallel velocity coordinate for the case where density, flow and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized peculiar velocity wpahat = (vpa - upar)/vth\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_vpa!-NTuple{13, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_vpa!","text":"calculate the advection speed in the vpa-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.vpa_advection!-NTuple{16, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.vpa_advection!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#interpolation","page":"interpolation","title":"interpolation","text":"","category":"section"},{"location":"zz_interpolation/","page":"interpolation","title":"interpolation","text":"Modules = [moment_kinetics.interpolation]","category":"page"},{"location":"zz_interpolation/#moment_kinetics.interpolation","page":"interpolation","title":"moment_kinetics.interpolation","text":"Interpolation routines intended for post-processing.\n\nNote these are not guaranteed to be highly optimized!\n\n\n\n\n\n","category":"module"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_1d!","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_1d!","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nArguments\n\nresult : Array{mkfloat, 1}     Array to be overwritten with the result of the interpolation newgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies spectral : discretization_info     struct containing information for discretization, whose type determines which method     is used.\n\n\n\n\n\n","category":"function"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_1d-Tuple{Any, Vararg{Any}}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_1d","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nThis version allocates a new array for the result, which is returned.\n\nArguments\n\nnewgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies spectral : Bool or chebyshevinfo     struct containing information for discretization, whose type determines which method     is used.\n\nReturns\n\nresult : Array     Array with the values of f interpolated to the points in new_grid.\n\n\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa!-Tuple{AbstractVector{Float64}, Any, AbstractVector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa!-Tuple{Array{Float64, 3}, Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa-Tuple{Any, AbstractVector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa-Tuple{Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Array{Float64, 3}, Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Matrix{Float64}, Any, Matrix{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Vector{Float64}, Any, Vector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Matrix{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Vector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#initial_conditions","page":"initial_conditions","title":"initial_conditions","text":"","category":"section"},{"location":"zz_initial_conditions/","page":"initial_conditions","title":"initial_conditions","text":"Modules = [moment_kinetics.initial_conditions]","category":"page"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions","page":"initial_conditions","title":"moment_kinetics.initial_conditions","text":"\n\n\n\n","category":"module"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.pdf_substruct","page":"initial_conditions","title":"moment_kinetics.initial_conditions.pdf_substruct","text":"\n\n\n\n","category":"type"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.allocate_pdf_and_moments-NTuple{12, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.allocate_pdf_and_moments","text":"Creates the structs for the pdf and the velocity-space moments\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.convert_full_f_charged_to_normalised!-NTuple{11, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.convert_full_f_charged_to_normalised!","text":"Take the full charged-particle distribution function, calculate the moments, then normalise and shift to the moment-kinetic grid.\n\nUses input value of f and modifies in place to the normalised distribution functions. Input density, upar, ppar, and vth are not used, the values are overwritten with the moments of f.\n\nInputs/outputs depend on z, vperp, and vpa (should be inside loops over species, r)\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.convert_full_f_neutral_to_normalised!-NTuple{12, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.convert_full_f_neutral_to_normalised!","text":"Take the full neutral-particle distribution function, calculate the moments, then normalise and shift to the moment-kinetic grid.\n\nUses input value of f and modifies in place to the normalised distribution functions. Input density, upar, ppar, and vth are not used, the values are overwritten with the moments of f.\n\nInputs/outputs depend on z, vzeta, vr and vz (should be inside loops over species, r)\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.create_boundary_distributions-NTuple{7, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.create_boundary_distributions","text":"Allocate arrays for distributions to be applied as boundary conditions to the pdf at various boundaries. Also initialise the Knudsen cosine distribution here so it can be used when initialising the neutral pdf.\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.create_pdf-NTuple{8, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.create_pdf","text":"Allocate arrays for pdfs\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.enforce_boundary_conditions!-NTuple{20, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_boundary_conditions!","text":"enforce boundary conditions in vpa and z on the evolved pdf; also enforce boundary conditions in z on all separately evolved velocity space moments of the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.enforce_initial_tapered_zero_incoming!-Tuple{Any, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_initial_tapered_zero_incoming!","text":"Set up an initial condition that tries to be smoothly compatible with the sheath boundary condition for ions, by setting f(±(v_parallel-u0)<0) where u0=0 at the sheath boundaries and for z<0 increases linearly to u0=vpa.L at z=0, while for z>0 increases from u0=-vpa.L at z=0 to zero at the z=z.L/2 sheath.\n\nTo be applied to 'full-f' distribution function on vparallel grid (not wparallel grid).\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.enforce_neutral_boundary_conditions!-NTuple{25, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_neutral_boundary_conditions!","text":"enforce boundary conditions on neutral particle distribution function\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.enforce_neutral_wall_bc!-NTuple{17, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_neutral_wall_bc!","text":"enforce the wall boundary condition on neutrals; i.e., the incoming flux of neutrals equals the sum of the ion/neutral outgoing fluxes\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.enforce_neutral_z_boundary_condition!-NTuple{16, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_neutral_z_boundary_condition!","text":"enforce boundary conditions on neutral particle f in z\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.enforce_r_boundary_condition!-Union{Tuple{T}, Tuple{AbstractArray{Float64, 5}, Any, String, T, Any, Any, Any, Any, Any, AbstractArray{Float64, 4}, AbstractArray{Float64, 4}, AbstractArray{Float64, 4}, AbstractArray{Float64, 4}, AbstractArray{Float64, 5}, Bool}} where T","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_r_boundary_condition!","text":"enforce boundary conditions on f in r\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.enforce_v_boundary_condition_local!-NTuple{4, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_v_boundary_condition_local!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.enforce_vpa_boundary_condition!-NTuple{4, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_vpa_boundary_condition!","text":"impose the prescribed vpa boundary condition on f at every z grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.enforce_z_boundary_condition!-Tuple{Any, Any, Any, Any, Any, String, Any, Any, Any, Any, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_z_boundary_condition!","text":"enforce boundary conditions on charged particle f in z\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.enforce_z_boundary_condition_moments!-Tuple{Any, Any, String}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_z_boundary_condition_moments!","text":"enforce the z boundary condition on the evolved velocity space moments of f\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.enforce_zero_incoming_bc!-NTuple{4, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_zero_incoming_bc!","text":"enforce a zero incoming BC in z for given species pdf at each radial location\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_charged_pdf_over_density!-NTuple{15, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_charged_pdf_over_density!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_density!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_density!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_neutral_pdf_over_density!-NTuple{19, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_neutral_pdf_over_density!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_pdf_and_moments!-NTuple{17, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_pdf_and_moments!","text":"creates the normalised pdf and the velocity-space moments and populates them with a self-consistent initial condition\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_upar!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_upar!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_uz!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_uz!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_vth!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_vth!","text":"for now the only initialisation option for the temperature is constant in z returns vth0 = sqrt(2Ts/ms) / sqrt(2Te/ms) = sqrt(Ts/Te)\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.initialize_pdf!-NTuple{14, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.initialize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.vpagrid_to_dzdt-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.vpagrid_to_dzdt","text":"create an array of dz/dt values corresponding to the given vpagrid values\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing","page":"makie_post_processing","title":"makie_post_processing","text":"","category":"section"},{"location":"zz_makie_post_processing/","page":"makie_post_processing","title":"makie_post_processing","text":"Modules = [moment_kinetics.makie_post_processing]","category":"page"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing","text":"Post processing functions using Makie.jl\n\nOptions are read by default from a file post_processing_input.toml, if it exists.\n\nThe plots can be generated from the command line by running\n\njulia --project run_makie_post_processing.jl dir1 [dir2 [dir3 ...]]\n\n\n\n\n\n","category":"module"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.input_dict","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.input_dict","text":"Global dict containing settings for makiepostprocessing. Can be re-loaded at any time to change settings.\n\nIs an OrderedDict so the order of sections is nicer if input_dict is written out as a TOML file.\n\n\n\n\n\n","category":"constant"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.input_dict_dfns","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.input_dict_dfns","text":"Global dict containing settings for makiepostprocessing for files with distribution function output. Can be re-loaded at any time to change settings.\n\nIs an OrderedDict so the order of sections is nicer if input_dict_dfns is written out as a TOML file.\n\n\n\n\n\n","category":"constant"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.Chodura_condition_plots","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.Chodura_condition_plots","text":"Chodura_condition_plots(run_info::Tuple; plot_prefix)\nChodura_condition_plots(run_info; plot_prefix=nothing, axes=nothing)\n\nPlot the criterion from the Chodura condition at the sheath boundaries.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where line plots from the different runs are overlayed on the same axis, and heatmap plots are displayed in a horizontal row.\n\nSettings are read from the [Chodura_condition] section of the input.\n\nWhen run_info is a Tuple, plot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf. When run_info is not a Tuple, plot_prefix is optional - plots will be saved only if it is passed.\n\nWhen run_info is not a Tuple, a Vector of Axis objects can be passed to axes, and each plot will be added to one of axes.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing._MMS_pdf_plots-NTuple{10, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing._MMS_pdf_plots","text":"_MMS_pdf_plots(run_info, input, variable_name, plot_prefix, field_label,\n               field_sym_label, norm_label, plot_dims, animate_dims)\n\nUtility function for making plots to avoid duplicated code in compare_charged_pdf_symbolic_test and compare_neutral_pdf_symbolic_test.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\ninput is a NamedTuple of settings to use.\n\nvariable_name is the name of the variable being plotted.\n\nplot_prefix gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nfield_label is the label for the computed variable that will be used in plots/animations, field_sym_label is the label for the manufactured solution, and norm_label is the label for the error.\n\nplot_dims are the dimensions of the variable, and animate_dims are the same but omitting :t.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing._get_steady_state_residual_fig_axes-Tuple{Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing._get_steady_state_residual_fig_axes","text":" _get_steady_state_residual_fig_axes(n_runs)\n\nUtility method to avoid code duplication when creating the figaxes OrderedDict for calculatesteadystateresidual.\n\nn_runs sets the number of axes to create in each entry.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_1d-Tuple{Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_1d","text":"animate_1d(xcoord, data; frame_index=nothing, ax=nothing, fig=nothing,\n           xlabel=nothing, ylabel=nothing, title=nothing, yscale=nothing,\n           transform=identity, outfile=nothing, ylims=nothing, kwargs...)\n\nMake a 1d animation of data vs xcoord.\n\nxlabel, ylabel and title can be passed to set axis labels and title for the (sub-)plot.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nIf ax is passed, the animation will be added to that existing Axis, otherwise a new Figure and Axis will be created. If ax is passed, you should also pass an Observable{mk_int} to frame_index so that the data for this animation can be updated when frame_index is changed.\n\nIf outfile is passed the animation will be saved to a file with that name. The suffix determines the file type. If ax is passed at the same time as outfile then the Figure containing ax must also be passed (to the fig argument) so that the animation can be saved.\n\nOther kwargs are passed to Makie's lines!() function.\n\nIf ax is not passed, returns the Figure, otherwise returns the object returned by lines!().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_2d-Tuple{Any, Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_2d","text":"animate_2d(xcoord, ycoord, data; frame_index=nothing, ax=nothing, fig=nothing,\n           colorbar_place=nothing, xlabel=nothing, ylabel=nothing, title=nothing,\n           outfile=nothing, colormap=\"reverse_deep\", colorscale=nothing,\n           transform=identity, kwargs...)\n\nMake a 2d animation of data vs xcoord and ycoord.\n\nxlabel, ylabel and title can be passed to set axis labels and title for the (sub-)plot.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nIf ax is passed, the animation will be added to that existing Axis, otherwise a new Figure and Axis will be created. If ax is passed, you should also pass an Observable{mk_int} to frame_index so that the data for this animation can be updated when frame_index is changed.\n\nIf outfile is passed the animation will be saved to a file with that name. The suffix determines the file type. If ax is passed at the same time as outfile then the Figure containing ax must also be passed (to the fig argument) so that the animation can be saved.\n\ncolormap is included explicitly because we do some special handling so that extra Makie functionality can be specified by a prefix to the colormap string, rather than the standard Makie mechanism of creating a struct that modifies the colormap. For example Reverse(\"deep\") can be passed as \"reverse_deep\". This is useful so that these extra colormaps can be specified in an input file, but is not needed for interactive use.\n\nWhen xcoord and ycoord are both one-dimensional, uses Makie's heatmap!() function for the plot. If either or both of xcoord and ycoord are two-dimensional, instead uses irregular_heatmap!.\n\nOther kwargs are passed to Makie's heatmap!() function.\n\nIf ax is not passed, returns the Figure, otherwise returns the object returned by heatmap!().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_f_unnorm_vs_vpa","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_f_unnorm_vs_vpa","text":"animate_f_unnorm_vs_vpa(run_info; input=nothing, neutral=false, is=1, iz=nothing,\n                        fig=nothing, ax=nothing, frame_index=nothing,\n                        outfile=nothing, yscale=identity, transform=identity,\n                        kwargs...)\n\nPlot an unnormalized distribution function against v_parallel at a fixed z.\n\nThis function is only needed for moment-kinetic runs. These are currently only supported for the 1D1V case.\n\nThe information for the runs to animate is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where plots from the different runs are overlayed on the same axis.\n\nBy default animates the ion distribution function. If neutrals=true is passed, animates the neutral distribution function instead.\n\nis selects which species to analyse.\n\nit and iz specify the indices of the time- and z-points to choose. By default they are taken from input.\n\nIf input is not passed, it is taken from input_dict_dfns[\"f\"].\n\nThe data needed will be loaded from file.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen run_info is not a Tuple, an Axis can be passed to ax to have the plot added to ax. When ax is passed, if outfile is passed to save the plot, then the Figure containing ax must be passed to fig.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nAny extra kwargs are passed to plot_1d (which is used to create the plot, as we have to handle time-varying coordinates so cannot use animate_1d).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_f_unnorm_vs_vpa_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_f_unnorm_vs_vpa_z","text":"animate_f_unnorm_vs_vpa_z(run_info; input=nothing, neutral=false, is=1,\n                          fig=nothing, ax=nothing, frame_index=nothing,\n                          outfile=nothing, yscale=identity, transform=identity,\n                          kwargs...)\n\nAnimate an unnormalized distribution function against v_parallel and z.\n\nThis function is only needed for moment-kinetic runs. These are currently only supported for the 1D1V case.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where plots from the different runs are displayed in a horizontal row.\n\nBy default animates the ion distribution function. If neutrals=true is passed, animates the neutral distribution function instead.\n\nis selects which species to analyse.\n\nIf input is not passed, it is taken from input_dict_dfns[\"f\"].\n\nThe data needed will be loaded from file.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen run_info is not a Tuple, an Axis can be passed to ax to have the animation created in ax. When ax is passed, if outfile is passed to save the animation, then the Figure containing ax must be passed to fig.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nAny extra kwargs are passed to plot_2d (which is used to create the plot, as we have to handle time-varying coordinates so cannot use animate_2d).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_r","text":"function animatevsr(runinfo::Tuple, varname; is=1, data=nothing,                      input=nothing, outfile=nothing, yscale=nothing,                      transform=identity, ylims=nothing, it=nothing, ir=nothing,                      iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                      ivr=nothing, ivz=nothing, kwargs...) function animatevsr(runinfo, varname; is=1, data=nothing,                      input=nothing, frame_index=nothing, ax=nothing,                      fig=nothing, outfile=nothing, yscale=nothing,                      transform=identity, ylims=nothing, it=nothing, ir=nothing,                      iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                      ivr=nothing, ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vpa","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vpa","text":"function animatevsvpa(runinfo::Tuple, varname; is=1, data=nothing,                        input=nothing, outfile=nothing, yscale=nothing,                        transform=identity, ylims=nothing, it=nothing, ir=nothing,                        iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                        ivr=nothing, ivz=nothing, kwargs...) function animatevsvpa(runinfo, varname; is=1, data=nothing,                        input=nothing, frame_index=nothing, ax=nothing,                        fig=nothing, outfile=nothing, yscale=nothing,                        transform=identity, ylims=nothing, it=nothing, ir=nothing,                        iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                        ivr=nothing, ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vpa.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vpa_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vpa_r","text":"function animatevsvpar(runinfo::Tuple, varname; is=1, data=nothing,                          input=nothing, outfile=nothing, colorscale=identity,                          transform=identity, it=nothing, ir=nothing, iz=nothing,                          ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                          ivz=nothing, kwargs...) function animatevsvpar(runinfo, varname; is=1, data=nothing,                          input=nothing, frameindex=nothing, ax=nothing,                          fig=nothing, colorbarplace=colorbar_place,                          title=nothing, outfile=nothing, colorscale=identity,                          transform=identity, it=nothing, ir=nothing, iz=nothing,                          ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                          ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vpa.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vpa_vperp","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vpa_vperp","text":"function animatevsvpavperp(runinfo::Tuple, varname; is=1, data=nothing,                              input=nothing, outfile=nothing, colorscale=identity,                              transform=identity, it=nothing, ir=nothing, iz=nothing,                              ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                              ivz=nothing, kwargs...) function animatevsvpavperp(runinfo, varname; is=1, data=nothing,                              input=nothing, frameindex=nothing, ax=nothing,                              fig=nothing, colorbarplace=colorbar_place,                              title=nothing, outfile=nothing, colorscale=identity,                              transform=identity, it=nothing, ir=nothing, iz=nothing,                              ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                              ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vperp and vpa.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vpa_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vpa_z","text":"function animatevsvpaz(runinfo::Tuple, varname; is=1, data=nothing,                          input=nothing, outfile=nothing, colorscale=identity,                          transform=identity, it=nothing, ir=nothing, iz=nothing,                          ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                          ivz=nothing, kwargs...) function animatevsvpaz(runinfo, varname; is=1, data=nothing,                          input=nothing, frameindex=nothing, ax=nothing,                          fig=nothing, colorbarplace=colorbar_place,                          title=nothing, outfile=nothing, colorscale=identity,                          transform=identity, it=nothing, ir=nothing, iz=nothing,                          ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                          ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vpa.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vperp","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vperp","text":"function animatevsvperp(runinfo::Tuple, varname; is=1, data=nothing,                          input=nothing, outfile=nothing, yscale=nothing,                          transform=identity, ylims=nothing, it=nothing, ir=nothing,                          iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                          ivr=nothing, ivz=nothing, kwargs...) function animatevsvperp(runinfo, varname; is=1, data=nothing,                          input=nothing, frame_index=nothing, ax=nothing,                          fig=nothing, outfile=nothing, yscale=nothing,                          transform=identity, ylims=nothing, it=nothing, ir=nothing,                          iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                          ivr=nothing, ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vperp.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vperp_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vperp_r","text":"function animatevsvperpr(runinfo::Tuple, varname; is=1, data=nothing,                            input=nothing, outfile=nothing, colorscale=identity,                            transform=identity, it=nothing, ir=nothing, iz=nothing,                            ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                            ivz=nothing, kwargs...) function animatevsvperpr(runinfo, varname; is=1, data=nothing,                            input=nothing, frameindex=nothing, ax=nothing,                            fig=nothing, colorbarplace=colorbar_place,                            title=nothing, outfile=nothing, colorscale=identity,                            transform=identity, it=nothing, ir=nothing, iz=nothing,                            ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                            ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vperp.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vperp_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vperp_z","text":"function animatevsvperpz(runinfo::Tuple, varname; is=1, data=nothing,                            input=nothing, outfile=nothing, colorscale=identity,                            transform=identity, it=nothing, ir=nothing, iz=nothing,                            ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                            ivz=nothing, kwargs...) function animatevsvperpz(runinfo, varname; is=1, data=nothing,                            input=nothing, frameindex=nothing, ax=nothing,                            fig=nothing, colorbarplace=colorbar_place,                            title=nothing, outfile=nothing, colorscale=identity,                            transform=identity, it=nothing, ir=nothing, iz=nothing,                            ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                            ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vperp.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vr","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vr","text":"function animatevsvr(runinfo::Tuple, varname; is=1, data=nothing,                       input=nothing, outfile=nothing, yscale=nothing,                       transform=identity, ylims=nothing, it=nothing, ir=nothing,                       iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                       ivr=nothing, ivz=nothing, kwargs...) function animatevsvr(runinfo, varname; is=1, data=nothing,                       input=nothing, frame_index=nothing, ax=nothing,                       fig=nothing, outfile=nothing, yscale=nothing,                       transform=identity, ylims=nothing, it=nothing, ir=nothing,                       iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                       ivr=nothing, ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vr.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vr_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vr_r","text":"function animatevsvrr(runinfo::Tuple, varname; is=1, data=nothing,                         input=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...) function animatevsvrr(runinfo, varname; is=1, data=nothing,                         input=nothing, frameindex=nothing, ax=nothing,                         fig=nothing, colorbarplace=colorbar_place,                         title=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vr.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vr_vzeta","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vr_vzeta","text":"function animatevsvrvzeta(runinfo::Tuple, varname; is=1, data=nothing,                             input=nothing, outfile=nothing, colorscale=identity,                             transform=identity, it=nothing, ir=nothing, iz=nothing,                             ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                             ivz=nothing, kwargs...) function animatevsvrvzeta(runinfo, varname; is=1, data=nothing,                             input=nothing, frameindex=nothing, ax=nothing,                             fig=nothing, colorbarplace=colorbar_place,                             title=nothing, outfile=nothing, colorscale=identity,                             transform=identity, it=nothing, ir=nothing, iz=nothing,                             ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                             ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta and vr.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vr_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vr_z","text":"function animatevsvrz(runinfo::Tuple, varname; is=1, data=nothing,                         input=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...) function animatevsvrz(runinfo, varname; is=1, data=nothing,                         input=nothing, frameindex=nothing, ax=nothing,                         fig=nothing, colorbarplace=colorbar_place,                         title=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vr.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vz","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vz","text":"function animatevsvz(runinfo::Tuple, varname; is=1, data=nothing,                       input=nothing, outfile=nothing, yscale=nothing,                       transform=identity, ylims=nothing, it=nothing, ir=nothing,                       iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                       ivr=nothing, ivz=nothing, kwargs...) function animatevsvz(runinfo, varname; is=1, data=nothing,                       input=nothing, frame_index=nothing, ax=nothing,                       fig=nothing, outfile=nothing, yscale=nothing,                       transform=identity, ylims=nothing, it=nothing, ir=nothing,                       iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                       ivr=nothing, ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vz.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vz_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vz_r","text":"function animatevsvzr(runinfo::Tuple, varname; is=1, data=nothing,                         input=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...) function animatevsvzr(runinfo, varname; is=1, data=nothing,                         input=nothing, frameindex=nothing, ax=nothing,                         fig=nothing, colorbarplace=colorbar_place,                         title=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vz.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vz_vr","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vz_vr","text":"function animatevsvzvr(runinfo::Tuple, varname; is=1, data=nothing,                          input=nothing, outfile=nothing, colorscale=identity,                          transform=identity, it=nothing, ir=nothing, iz=nothing,                          ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                          ivz=nothing, kwargs...) function animatevsvzvr(runinfo, varname; is=1, data=nothing,                          input=nothing, frameindex=nothing, ax=nothing,                          fig=nothing, colorbarplace=colorbar_place,                          title=nothing, outfile=nothing, colorscale=identity,                          transform=identity, it=nothing, ir=nothing, iz=nothing,                          ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                          ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vr and vz.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vz_vzeta","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vz_vzeta","text":"function animatevsvzvzeta(runinfo::Tuple, varname; is=1, data=nothing,                             input=nothing, outfile=nothing, colorscale=identity,                             transform=identity, it=nothing, ir=nothing, iz=nothing,                             ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                             ivz=nothing, kwargs...) function animatevsvzvzeta(runinfo, varname; is=1, data=nothing,                             input=nothing, frameindex=nothing, ax=nothing,                             fig=nothing, colorbarplace=colorbar_place,                             title=nothing, outfile=nothing, colorscale=identity,                             transform=identity, it=nothing, ir=nothing, iz=nothing,                             ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                             ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta and vz.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vz_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vz_z","text":"function animatevsvzz(runinfo::Tuple, varname; is=1, data=nothing,                         input=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...) function animatevsvzz(runinfo, varname; is=1, data=nothing,                         input=nothing, frameindex=nothing, ax=nothing,                         fig=nothing, colorbarplace=colorbar_place,                         title=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vz.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vzeta","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vzeta","text":"function animatevsvzeta(runinfo::Tuple, varname; is=1, data=nothing,                          input=nothing, outfile=nothing, yscale=nothing,                          transform=identity, ylims=nothing, it=nothing, ir=nothing,                          iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                          ivr=nothing, ivz=nothing, kwargs...) function animatevsvzeta(runinfo, varname; is=1, data=nothing,                          input=nothing, frame_index=nothing, ax=nothing,                          fig=nothing, outfile=nothing, yscale=nothing,                          transform=identity, ylims=nothing, it=nothing, ir=nothing,                          iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                          ivr=nothing, ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vzeta_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vzeta_r","text":"function animatevsvzetar(runinfo::Tuple, varname; is=1, data=nothing,                            input=nothing, outfile=nothing, colorscale=identity,                            transform=identity, it=nothing, ir=nothing, iz=nothing,                            ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                            ivz=nothing, kwargs...) function animatevsvzetar(runinfo, varname; is=1, data=nothing,                            input=nothing, frameindex=nothing, ax=nothing,                            fig=nothing, colorbarplace=colorbar_place,                            title=nothing, outfile=nothing, colorscale=identity,                            transform=identity, it=nothing, ir=nothing, iz=nothing,                            ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                            ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vzeta.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_vzeta_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_vzeta_z","text":"function animatevsvzetaz(runinfo::Tuple, varname; is=1, data=nothing,                            input=nothing, outfile=nothing, colorscale=identity,                            transform=identity, it=nothing, ir=nothing, iz=nothing,                            ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                            ivz=nothing, kwargs...) function animatevsvzetaz(runinfo, varname; is=1, data=nothing,                            input=nothing, frameindex=nothing, ax=nothing,                            fig=nothing, colorbarplace=colorbar_place,                            title=nothing, outfile=nothing, colorscale=identity,                            transform=identity, it=nothing, ir=nothing, iz=nothing,                            ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                            ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vzeta.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_z","text":"function animatevsz(runinfo::Tuple, varname; is=1, data=nothing,                      input=nothing, outfile=nothing, yscale=nothing,                      transform=identity, ylims=nothing, it=nothing, ir=nothing,                      iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                      ivr=nothing, ivz=nothing, kwargs...) function animatevsz(runinfo, varname; is=1, data=nothing,                      input=nothing, frame_index=nothing, ax=nothing,                      fig=nothing, outfile=nothing, yscale=nothing,                      transform=identity, ylims=nothing, it=nothing, ir=nothing,                      iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,                      ivr=nothing, ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.animate_vs_z_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.animate_vs_z_r","text":"function animatevszr(runinfo::Tuple, varname; is=1, data=nothing,                        input=nothing, outfile=nothing, colorscale=identity,                        transform=identity, it=nothing, ir=nothing, iz=nothing,                        ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                        ivz=nothing, kwargs...) function animatevszr(runinfo, varname; is=1, data=nothing,                        input=nothing, frameindex=nothing, ax=nothing,                        fig=nothing, colorbarplace=colorbar_place,                        title=nothing, outfile=nothing, colorscale=identity,                        transform=identity, it=nothing, ir=nothing, iz=nothing,                        ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                        ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and z.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.calculate_steady_state_residual","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.calculate_steady_state_residual","text":"calculatesteadystateresidual(runinfo, variablename; is=1, data=nothing,                                 plotprefix=nothing, figaxes=nothing, irun=1)\n\nCalculate and plot the 'residuals' for variable_name.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where plots from the different runs are displayed in a horizontal row.\n\nIf the variable has a species dimension, is selects which species to analyse.\n\nBy default the variable will be loaded from file. If the data has already been loaded, it can be passed to data instead. data should be a Tuple of the same length as run_info if run_info is a Tuple.\n\nIf plot_prefix is passed, it gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf.\n\nfig_axes can be passed an OrderedDict of Tuples as returned by _get_steady_state_residual_fig_axes - each tuple contains the Figure fig and Axis or Tuple{Axis} ax to which to add the plot corresponding to its key. If run_info is a Tuple, ax for each entry must be a Tuple of the same length.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.clear_Dict!-Tuple{AbstractDict}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.clear_Dict!","text":"clear_Dict!(d::AbstractDict)\n\nRemove all entries from an AbstractDict, leaving it empty\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.compare_charged_pdf_symbolic_test-Tuple{Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.compare_charged_pdf_symbolic_test","text":"compare_charged_pdf_symbolic_test(run_info, plot_prefix; io=nothing,\n                                  input=nothing)\n\nCompare the computed and manufactured solutions for the ion distribution function.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nIf io is passed then error norms will be written to that file.\n\ninput is a NamedTuple of settings to use. If not given it will be read from the [manufactured_solns] section of [input_dict_dfns][@ref].\n\nNote: when calculating error norms, data is loaded only for 1 time point and for an r-z chunk that is the same size as computed by 1 block of the simulation at run time. This should prevent excessive memory requirements for this function.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.compare_moment_symbolic_test-NTuple{6, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.compare_moment_symbolic_test","text":"compare_moment_symbolic_test(run_info, plot_prefix, field_label, field_sym_label,\n                             norm_label, variable_name; io=nothing)\n\nCompare the computed and manufactured solutions for a field or moment variable variable_name.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nfield_label is the label that will be used for the name of the computed variable in plots, field_sym_label is the label for the manufactured solution, and norm_label is the label for the error (the difference between the computed and manufactured solutions).\n\nIf io is passed then error norms will be written to that file.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.compare_neutral_pdf_symbolic_test-Tuple{Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.compare_neutral_pdf_symbolic_test","text":"compare_neutral_pdf_symbolic_test(run_info, plot_prefix; io=nothing,\n                                  input=nothing)\n\nCompare the computed and manufactured solutions for the neutral distribution function.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nIf io is passed then error norms will be written to that file.\n\ninput is a NamedTuple of settings to use. If not given it will be read from the [manufactured_solns] section of [input_dict_dfns][@ref].\n\nNote: when calculating error norms, data is loaded only for 1 time point and for an r-z chunk that is the same size as computed by 1 block of the simulation at run time. This should prevent excessive memory requirements for this function.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.convert_to_OrderedDicts!-Tuple{AbstractDict}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.convert_to_OrderedDicts!","text":"convert_to_OrderedDicts!(d::AbstractDict)\n\nRecursively convert an AbstractDict to OrderedDict.\n\nAny nested AbstractDicts are also converted to OrderedDict.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.curvilinear_grid_mesh-NTuple{4, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.curvilinear_grid_mesh","text":"curvilinear_grid_mesh(xs, ys, zs, colors)\n\nTesselates the grid defined by xs and ys in order to form a mesh with per-face coloring given by colors.\n\nThe grid defined by xs and ys must have dimensions (nx, ny) == size(colors) .+ 1, as is the case for heatmap/image.\n\nCode from: https://github.com/MakieOrg/Makie.jl/issues/742#issuecomment-1415809653\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.generate_example_input_Dict-Tuple{}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.generate_example_input_Dict","text":"generate_example_input_Dict()\n\nCreate a Dict containing all the makie-post-processing options with default values\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.generate_example_input_file","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.generate_example_input_file","text":"generate_example_input_file(filename::String=post_processing_input.toml;\n                            overwrite::Bool=false)\n\nCreate an example makie-post-processing input file.\n\nEvery option is commented out, but filled with the default value.\n\nPass filename to choose the name of the example file (defaults to the default input file name used by makie_post_process()).\n\nPass overwrite=true to overwrite any existing file at filename.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.get_1d_ax","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.get_1d_ax","text":"get_1d_ax(n=nothing; title=nothing, subtitles=nothing, yscale=nothing,\n          get_legend_place=nothing, kwargs...)\n\nCreate a new Figure fig and Axis ax intended for 1d plots.\n\ntitle gives an overall title to the Figure.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10.\n\nBy default creates a single Axis, and returns (fig, ax). If a number of axes n is passed, then ax is a Vector{Axis} of length n (even if n is 1). The axes are created in a horizontal row, and the width of the figure is increased in proportion to n.\n\nget_legend_place can be set to one of (:left, :right, :above, :below) to create a GridPosition for a legend in the corresponding place relative to each Axis. If get_legend_place is set, (fig, ax, legend_place) is returned where legend_place is a GridPosition (if n=nothing) or a Tuple of n GridPositions.\n\nWhen n is passed, subtitles can be passed a Tuple of length n which will be used to set a subtitle for each Axis in ax.\n\nExtra kwargs are passed to the Axis() constructor.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.get_2d_ax","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.get_2d_ax","text":"get_2d_ax(n=nothing; title=nothing, subtitles=nothing, kwargs...)\n\nCreate a new Figure fig and Axis ax intended for 2d plots.\n\ntitle gives an overall title to the Figure.\n\nBy default creates a single Axis, and returns (fig, ax, colorbar_place), where colorbar_place is a location in the grid layout that can be passed to Colorbar() located immediately to the right of ax. If a number of axes n is passed, then ax is a Vector{Axis} and colorbar_place is a Vector{GridPosition} of length n (even if n is 1). The axes are created in a horizontal row, and the width of the figure is increased in proportion to n.\n\nWhen n is passed, subtitles can be passed a Tuple of length n which will be used to set a subtitle for each Axis in ax.\n\nExtra kwargs are passed to the Axis() constructor.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.get_dimension_slice_indices-Tuple","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.get_dimension_slice_indices","text":"getdimensionsliceindices(keepdims...; input, it=nothing, is=nothing,                             ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,                             ivzeta=nothing, ivr=nothing, ivz=nothing)\n\nGet indices for dimensions to slice\n\nThe indices are taken from input, unless they are passed as keyword arguments\n\nThe dimensions in keep_dims are not given a slice (those are the dimensions we want in the variable after slicing).\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.get_run_info","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.get_run_info","text":"get_run_info(run_dir, restart_index=nothing; itime_min=1, itime_max=-1,\n             itime_skip=1, dfns=false)\n\nGet file handles and other info for a single run\n\nrun_dir is the directory to read output from.\n\nBy default load data from moments files, pass dfns=true to load from distribution functions files.\n\nrestart_index specifies which restart to read if there are multiple restarts. The default (nothing) reads all restarts and concatenates them. An integer value reads the restart with that index - -1 indicates the latest restart (which does not have an index).\n\nThe itime_min, itime_max and itime_skip options can be used to select only a slice of time points when loading data. In makie_post_process these options are read from the input (if they are set) before get_run_info() is called, so that the run_info returned can be passed to setup_makie_post_processing_input!, to be used for defaults for the remaining options.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.get_variable","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.get_variable","text":"get_variable(run_info::Tuple, variable_name; kwargs...)\nget_variable(run_info, variable_name; kwargs...)\n\nGet an array (or Tuple of arrays, if run_info is a Tuple) of the data for variable_name from run_info.\n\nSome derived variables need to be calculated from the saved output, not just loaded from file (with postproc_load_variable). This function takes care of that calculation, and handles the case where run_info is a Tuple (which postproc_load_data does not handle).\n\nkwargs... are passed through to postproc_load_variable().\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.get_variable_symbol-Tuple{Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.get_variable_symbol","text":"get_variable_symbol(variable_name)\n\nGet a symbol corresponding to a variable_name\n\nFor example get_variable_symbol(\"phi\") returns \"ϕ\".\n\nIf the symbol has not been defined, just return variable_name.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.grid_points_to_faces","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.grid_points_to_faces","text":"grid_points_to_faces(coord::AbstractVector)\ngrid_points_to_faces(coord::Observable{T} where T <: AbstractVector)\ngrid_points_to_faces(coord::AbstractMatrix)\ngrid_points_to_faces(coord::Observable{T} where T <: AbstractMatrix)\n\nTurn grid points in coord into 'cell faces'.\n\nReturns faces, which has a length one greater than coord. The first and last values of faces are the first and last values of coord. The intermediate values are the mid points between grid points.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.instability2D_plots","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.instability2D_plots","text":"instability2D_plots(run_info::Tuple, variable_name; plot_prefix, zind=nothing)\ninstability2D_plots(run_info, variable_name; plot_prefix, zind=nothing,\n                    axes_and_observables=nothing)\n\nMake plots of variable_name for analysis of 2D instability.\n\nThe information for the runs to analyse and plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, make plots comparing the runs, shown in a horizontal row..\n\nSettings are read from the [instability2D] section of the input.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nWhen run_info is not a Tuple, axes_and_observables can be passed to add plots and animations to existing figures, although this is not very convenient - see the use of this argument when called from the run_info::Tuple method.\n\nIf zind is not passed, it is calculated as the z-index where the mode seems to have the maximum growth rate for this variable. Returns zind.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.irregular_heatmap!-NTuple{4, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.irregular_heatmap!","text":"irregular_heatmap!(ax, xs, ys, zs; kwargs...)\n\nPlot a heatmap onto the Axis ax where xs and ys are allowed to define irregularly spaced, 2d grids.  zs gives the value in each cell of the grid.\n\nThe grid defined by xs and ys must have dimensions (nx, ny) == size(zs) .+ 1, as is the case for heatmap/image.\n\nxs be an array of size (nx,ny) or a vector of size (nx).\n\nys be an array of size (nx,ny) or a vector of size (ny).\n\nkwargs are passed to Makie's mesh() function.\n\nCode adapted from: https://github.com/MakieOrg/Makie.jl/issues/742#issuecomment-1415809653\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.irregular_heatmap-Tuple{Any, Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.irregular_heatmap","text":"irregular_heatmap(xs, ys, zs; kwargs...)\n\nPlot a heatmap where xs and ys are allowed to define irregularly spaced, 2d grids. zs gives the value in each cell of the grid.\n\nThe grid defined by xs and ys must have dimensions (nx, ny) == size(zs) .+ 1, as is the case for heatmap/image.\n\nxs be an array of size (nx,ny) or a vector of size (nx).\n\nys be an array of size (nx,ny) or a vector of size (ny).\n\nkwargs are passed to Makie's mesh() function.\n\nCode adapted from: https://github.com/MakieOrg/Makie.jl/issues/742#issuecomment-1415809653\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.makie_post_process-Tuple","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.makie_post_process","text":"makie_post_process(run_dir...;\n                   input_file::String=default_input_file_name,\n                   restart_index::Union{Nothing,mk_int,Tuple}=nothing,\n                   plot_prefix::Union{Nothing,AbstractString}=nothing)\n\nRun post processing with input read from a TOML file\n\nrun_dir... is the path to the directory to plot from. If more than one run_dir is given, plots comparing the runs in run_dir....\n\nrestart_index specifies which restart to read if there are multiple restarts. The default (nothing) reads all restarts and concatenates them. An integer value reads the restart with that index - -1 indicates the latest restart (which does not have an index). A tuple with the same length as run_dir can also be passed to give a different restart_index for each run.\n\nplot_prefix can be specified to give the prefix (directory and first part of file name) to use when saving plots/animations. By default the run directory and run name are used if there is only one run, and \"comparisonplots/compare\" is used if there are multiple runs.\n\nIf input_file does not exist, prints warning and uses default options.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.makie_post_process-Tuple{Union{String, Tuple}, AbstractDict{String, Any}}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.makie_post_process","text":"makie_post_process(run_dir::Union{String,Tuple},\n                   new_input_dict::Dict{String,Any};\n                   restart_index::Union{Nothing,mk_int,Tuple}=nothing,\n                   plot_prefix::Union{Nothing,AbstractString}=nothing)\n\nRun post prossing, with (non-default) input given in a Dict\n\nrun_dir is the path to an output directory, or (to make comparison plots) a tuple of paths to output directories.\n\ninput_dict is a dictionary containing settings for the post-processing.\n\nrestart_index specifies which restart to read if there are multiple restarts. The default (nothing) reads all restarts and concatenates them. An integer value reads the restart with that index - -1 indicates the latest restart (which does not have an index). A tuple with the same length as run_dir can also be passed to give a different restart_index for each run.\n\nplot_prefix can be specified to give the prefix (directory and first part of file name) to use when saving plots/animations. By default the run directory and run name are used if there is only one run, and \"comparisonplots/compare\" is used if there are multiple runs.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.manufactured_solutions_analysis","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.manufactured_solutions_analysis","text":"manufactured_solutions_analysis(run_info; plot_prefix)\nmanufactured_solutions_analysis(run_info::Tuple; plot_prefix)\n\nCompare computed and manufactured solutions for field and moment variables for a 'method of manufactured solutions' (MMS) test.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nSettings are read from the [manufactured_solns] section of the input.\n\nWhile a Tuple of run_info can be passed for compatibility with makie_post_process(), at present comparison of multiple runs is not supported - passing a Tuple of length greater than one will result in an error.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.manufactured_solutions_analysis_dfns","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.manufactured_solutions_analysis_dfns","text":"manufactured_solutions_analysis_dfns(run_info; plot_prefix)\nmanufactured_solutions_analysis_dfns(run_info::Tuple; plot_prefix)\n\nCompare computed and manufactured solutions for distribution function variables for a 'method of manufactured solutions' (MMS) test.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nSettings are read from the [manufactured_solns] section of the input.\n\nWhile a Tuple of run_info can be passed for compatibility with makie_post_process(), at present comparison of multiple runs is not supported - passing a Tuple of length greater than one will result in an error.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.manufactured_solutions_get_field_and_field_sym-Tuple{Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.manufactured_solutions_get_field_and_field_sym","text":" manufactured_solutions_get_field_and_field_sym(run_info, variable_name;\n     it=nothing, ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n     ivr=nothing, ivz=nothing)\n\nGet the data variable for variable_name from the output, and calculate the manufactured solution variable_sym.\n\nThe information for the runs to analyse and plot is passed in run_info (as returned by get_run_info).\n\nit, ir, iz, ivperp, ivpa, ivzeta, ivr, ivz can be used to select a subset of the grid by passing an integer or range for any dimension.\n\nReturns variable, variable_sym.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.parse_colormap-Tuple{Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.parse_colormap","text":"parse_colormap(colormap)\n\nParse a colormap option\n\nAllows us to have a string option which can be set in the input file and still use Reverse, etc. conveniently.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_1d-Tuple{Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_1d","text":"plot_1d(xcoord, data; ax=nothing, xlabel=nothing, ylabel=nothing, title=nothing,\n        yscale=nothing, transform=identity, kwargs...)\n\nMake a 1d plot of data vs xcoord.\n\nxlabel, ylabel and title can be passed to set axis labels and title for the (sub-)plot.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nIf ax is passed, the plot will be added to that existing Axis, otherwise a new Figure and Axis will be created.\n\nOther kwargs are passed to Makie's lines!() function.\n\nIf ax is not passed, returns the Figure, otherwise returns the object returned by lines!().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_2d-Tuple{Any, Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_2d","text":"plot_2d(xcoord, ycoord, data; ax=nothing, colorbar_place=nothing, xlabel=nothing,\n        ylabel=nothing, title=nothing, colormap=\"reverse_deep\",\n        colorscale=nothing, transform=identity, kwargs...)\n\nMake a 2d plot of data vs xcoord and ycoord.\n\nxlabel, ylabel and title can be passed to set axis labels and title for the (sub-)plot.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nIf ax is passed, the plot will be added to that existing Axis, otherwise a new Figure and Axis will be created.\n\ncolormap is included explicitly because we do some special handling so that extra Makie functionality can be specified by a prefix to the colormap string, rather than the standard Makie mechanism of creating a struct that modifies the colormap. For example Reverse(\"deep\") can be passed as \"reverse_deep\". This is useful so that these extra colormaps can be specified in an input file, but is not needed for interactive use.\n\nWhen xcoord and ycoord are both one-dimensional, uses Makie's heatmap!() function for the plot. If either or both of xcoord and ycoord are two-dimensional, instead uses irregular_heatmap!.\n\nOther kwargs are passed to Makie's heatmap!() function.\n\nIf ax is not passed, returns the Figure, otherwise returns the object returned by heatmap!().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_charged_pdf_2D_at_wall-Tuple{Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_charged_pdf_2D_at_wall","text":"plot_charged_pdf_2D_at_wall(run_info; plot_prefix)\n\nMake plots/animations of the charged particle distribution function at wall boundaries.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where line plots/animations from the different runs are overlayed on the same axis, and heatmap plots/animations are displayed in a horizontal row.\n\nSettings are read from the [wall_pdf] section of the input.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf. When run_info is not a Tuple, plot_prefix is optional - plots/animations will be saved only if it is passed.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_f_unnorm_vs_vpa","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_f_unnorm_vs_vpa","text":"plot_f_unnorm_vs_vpa(run_info; input=nothing, neutral=false, it=nothing, is=1,\n                     iz=nothing, fig=nothing, ax=nothing, outfile=nothing,\n                     yscale=identity, transform=identity, kwargs...)\n\nPlot an unnormalized distribution function against v_parallel at a fixed z.\n\nThis function is only needed for moment-kinetic runs. These are currently only supported for the 1D1V case.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where plots from the different runs are overlayed on the same axis.\n\nBy default plots the ion distribution function. If neutrals=true is passed, plots the neutral distribution function instead.\n\nis selects which species to analyse.\n\nit and iz specify the indices of the time- and z-points to choose. By default they are taken from input.\n\nIf input is not passed, it is taken from input_dict_dfns[\"f\"].\n\nThe data needed will be loaded from file.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nWhen run_info is not a Tuple, an Axis can be passed to ax to have the plot added to ax. When ax is passed, if outfile is passed to save the plot, then the Figure containing ax must be passed to fig.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nAny extra kwargs are passed to plot_1d.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_f_unnorm_vs_vpa_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_f_unnorm_vs_vpa_z","text":"plot_f_unnorm_vs_vpa_z(run_info; input=nothing, neutral=false, it=nothing, is=1,\n                       fig=nothing, ax=nothing, outfile=nothing, yscale=identity,\n                       transform=identity, kwargs...)\n\nPlot unnormalized distribution function against v_parallel and z.\n\nThis function is only needed for moment-kinetic runs. These are currently only supported for the 1D1V case.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where plots from the different runs are displayed in a horizontal row.\n\nBy default plots the ion distribution function. If neutrals=true is passed, plots the neutral distribution function instead.\n\nis selects which species to analyse.\n\nit specifies the time-index to choose. By default it is taken from input.\n\nIf input is not passed, it is taken from input_dict_dfns[\"f\"].\n\nThe data needed will be loaded from file.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nWhen run_info is not a Tuple, an Axis can be passed to ax to have the plot created in ax. When ax is passed, if outfile is passed to save the plot, then the Figure containing ax must be passed to fig.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nAny extra kwargs are passed to plot_2d.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_neutral_pdf_2D_at_wall-Tuple{Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_neutral_pdf_2D_at_wall","text":"plot_neutral_pdf_2D_at_wall(run_info; plot_prefix)\n\nMake plots/animations of the neutral particle distribution function at wall boundaries.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where line plots/animations from the different runs are overlayed on the same axis, and heatmap plots/animations are displayed in a horizontal row.\n\nSettings are read from the [wall_pdf_neutral] section of the input.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf. When run_info is not a Tuple, plot_prefix is optional - plots/animations will be saved only if it is passed.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_r","text":"function plotvsr(runinfo::Tuple, varname; is=1, data=nothing,                   input=nothing, outfile=nothing, yscale=nothing,                   transform=identity, it=nothing, ir=nothing, iz=nothing,                   ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                   ivz=nothing, kwargs...) function plotvsr(runinfo, varname; is=1, data=nothing,                   input=nothing, ax=nothing, label=nothing,                   outfile=nothing, yscale=nothing, transform=identity,                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                   kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs r.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_r_t","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_r_t","text":"function plotvsrt(runinfo::Tuple, varname; is=1, data=nothing,                     input=nothing, outfile=nothing, colorscale=identity,                     transform=identity, it=nothing, ir=nothing, iz=nothing,                     ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                     ivz=nothing, kwargs...) function plotvsrt(runinfo, varname; is=1, data=nothing,                     input=nothing, ax=nothing,                     colorbar_place=nothing, title=nothing,                     outfile=nothing, colorscale=identity, transform=identity,                     it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                     ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                     kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and r.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_t","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_t","text":"function plotvst(runinfo::Tuple, varname; is=1, data=nothing,                   input=nothing, outfile=nothing, yscale=nothing,                   transform=identity, it=nothing, ir=nothing, iz=nothing,                   ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                   ivz=nothing, kwargs...) function plotvst(runinfo, varname; is=1, data=nothing,                   input=nothing, ax=nothing, label=nothing,                   outfile=nothing, yscale=nothing, transform=identity,                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                   kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs t.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vpa","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vpa","text":"function plotvsvpa(runinfo::Tuple, varname; is=1, data=nothing,                     input=nothing, outfile=nothing, yscale=nothing,                     transform=identity, it=nothing, ir=nothing, iz=nothing,                     ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                     ivz=nothing, kwargs...) function plotvsvpa(runinfo, varname; is=1, data=nothing,                     input=nothing, ax=nothing, label=nothing,                     outfile=nothing, yscale=nothing, transform=identity,                     it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                     ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                     kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vpa.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vpa_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vpa_r","text":"function plotvsvpar(runinfo::Tuple, varname; is=1, data=nothing,                       input=nothing, outfile=nothing, colorscale=identity,                       transform=identity, it=nothing, ir=nothing, iz=nothing,                       ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                       ivz=nothing, kwargs...) function plotvsvpar(runinfo, varname; is=1, data=nothing,                       input=nothing, ax=nothing,                       colorbar_place=nothing, title=nothing,                       outfile=nothing, colorscale=identity, transform=identity,                       it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                       ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                       kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vpa.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vpa_t","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vpa_t","text":"function plotvsvpat(runinfo::Tuple, varname; is=1, data=nothing,                       input=nothing, outfile=nothing, colorscale=identity,                       transform=identity, it=nothing, ir=nothing, iz=nothing,                       ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                       ivz=nothing, kwargs...) function plotvsvpat(runinfo, varname; is=1, data=nothing,                       input=nothing, ax=nothing,                       colorbar_place=nothing, title=nothing,                       outfile=nothing, colorscale=identity, transform=identity,                       it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                       ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                       kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vpa.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vpa_vperp","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vpa_vperp","text":"function plotvsvpavperp(runinfo::Tuple, varname; is=1, data=nothing,                           input=nothing, outfile=nothing, colorscale=identity,                           transform=identity, it=nothing, ir=nothing, iz=nothing,                           ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                           ivz=nothing, kwargs...) function plotvsvpavperp(runinfo, varname; is=1, data=nothing,                           input=nothing, ax=nothing,                           colorbar_place=nothing, title=nothing,                           outfile=nothing, colorscale=identity, transform=identity,                           it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                           ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                           kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs vperp and vpa.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vpa_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vpa_z","text":"function plotvsvpaz(runinfo::Tuple, varname; is=1, data=nothing,                       input=nothing, outfile=nothing, colorscale=identity,                       transform=identity, it=nothing, ir=nothing, iz=nothing,                       ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                       ivz=nothing, kwargs...) function plotvsvpaz(runinfo, varname; is=1, data=nothing,                       input=nothing, ax=nothing,                       colorbar_place=nothing, title=nothing,                       outfile=nothing, colorscale=identity, transform=identity,                       it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                       ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                       kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vpa.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vperp","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vperp","text":"function plotvsvperp(runinfo::Tuple, varname; is=1, data=nothing,                       input=nothing, outfile=nothing, yscale=nothing,                       transform=identity, it=nothing, ir=nothing, iz=nothing,                       ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                       ivz=nothing, kwargs...) function plotvsvperp(runinfo, varname; is=1, data=nothing,                       input=nothing, ax=nothing, label=nothing,                       outfile=nothing, yscale=nothing, transform=identity,                       it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                       ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                       kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vperp.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vperp_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vperp_r","text":"function plotvsvperpr(runinfo::Tuple, varname; is=1, data=nothing,                         input=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...) function plotvsvperpr(runinfo, varname; is=1, data=nothing,                         input=nothing, ax=nothing,                         colorbar_place=nothing, title=nothing,                         outfile=nothing, colorscale=identity, transform=identity,                         it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                         ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                         kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vperp.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vperp_t","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vperp_t","text":"function plotvsvperpt(runinfo::Tuple, varname; is=1, data=nothing,                         input=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...) function plotvsvperpt(runinfo, varname; is=1, data=nothing,                         input=nothing, ax=nothing,                         colorbar_place=nothing, title=nothing,                         outfile=nothing, colorscale=identity, transform=identity,                         it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                         ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                         kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vperp.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vperp_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vperp_z","text":"function plotvsvperpz(runinfo::Tuple, varname; is=1, data=nothing,                         input=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...) function plotvsvperpz(runinfo, varname; is=1, data=nothing,                         input=nothing, ax=nothing,                         colorbar_place=nothing, title=nothing,                         outfile=nothing, colorscale=identity, transform=identity,                         it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                         ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                         kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vperp.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vr","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vr","text":"function plotvsvr(runinfo::Tuple, varname; is=1, data=nothing,                    input=nothing, outfile=nothing, yscale=nothing,                    transform=identity, it=nothing, ir=nothing, iz=nothing,                    ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                    ivz=nothing, kwargs...) function plotvsvr(runinfo, varname; is=1, data=nothing,                    input=nothing, ax=nothing, label=nothing,                    outfile=nothing, yscale=nothing, transform=identity,                    it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                    ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                    kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vr.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vr_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vr_r","text":"function plotvsvrr(runinfo::Tuple, varname; is=1, data=nothing,                      input=nothing, outfile=nothing, colorscale=identity,                      transform=identity, it=nothing, ir=nothing, iz=nothing,                      ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                      ivz=nothing, kwargs...) function plotvsvrr(runinfo, varname; is=1, data=nothing,                      input=nothing, ax=nothing,                      colorbar_place=nothing, title=nothing,                      outfile=nothing, colorscale=identity, transform=identity,                      it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                      ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                      kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vr.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vr_t","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vr_t","text":"function plotvsvrt(runinfo::Tuple, varname; is=1, data=nothing,                      input=nothing, outfile=nothing, colorscale=identity,                      transform=identity, it=nothing, ir=nothing, iz=nothing,                      ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                      ivz=nothing, kwargs...) function plotvsvrt(runinfo, varname; is=1, data=nothing,                      input=nothing, ax=nothing,                      colorbar_place=nothing, title=nothing,                      outfile=nothing, colorscale=identity, transform=identity,                      it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                      ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                      kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vr.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vr_vzeta","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vr_vzeta","text":"function plotvsvrvzeta(runinfo::Tuple, varname; is=1, data=nothing,                          input=nothing, outfile=nothing, colorscale=identity,                          transform=identity, it=nothing, ir=nothing, iz=nothing,                          ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                          ivz=nothing, kwargs...) function plotvsvrvzeta(runinfo, varname; is=1, data=nothing,                          input=nothing, ax=nothing,                          colorbar_place=nothing, title=nothing,                          outfile=nothing, colorscale=identity, transform=identity,                          it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                          ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                          kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta and vr.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vr_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vr_z","text":"function plotvsvrz(runinfo::Tuple, varname; is=1, data=nothing,                      input=nothing, outfile=nothing, colorscale=identity,                      transform=identity, it=nothing, ir=nothing, iz=nothing,                      ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                      ivz=nothing, kwargs...) function plotvsvrz(runinfo, varname; is=1, data=nothing,                      input=nothing, ax=nothing,                      colorbar_place=nothing, title=nothing,                      outfile=nothing, colorscale=identity, transform=identity,                      it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                      ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                      kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vr.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vz","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vz","text":"function plotvsvz(runinfo::Tuple, varname; is=1, data=nothing,                    input=nothing, outfile=nothing, yscale=nothing,                    transform=identity, it=nothing, ir=nothing, iz=nothing,                    ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                    ivz=nothing, kwargs...) function plotvsvz(runinfo, varname; is=1, data=nothing,                    input=nothing, ax=nothing, label=nothing,                    outfile=nothing, yscale=nothing, transform=identity,                    it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                    ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                    kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vz.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vz_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vz_r","text":"function plotvsvzr(runinfo::Tuple, varname; is=1, data=nothing,                      input=nothing, outfile=nothing, colorscale=identity,                      transform=identity, it=nothing, ir=nothing, iz=nothing,                      ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                      ivz=nothing, kwargs...) function plotvsvzr(runinfo, varname; is=1, data=nothing,                      input=nothing, ax=nothing,                      colorbar_place=nothing, title=nothing,                      outfile=nothing, colorscale=identity, transform=identity,                      it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                      ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                      kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vz.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vz_t","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vz_t","text":"function plotvsvzt(runinfo::Tuple, varname; is=1, data=nothing,                      input=nothing, outfile=nothing, colorscale=identity,                      transform=identity, it=nothing, ir=nothing, iz=nothing,                      ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                      ivz=nothing, kwargs...) function plotvsvzt(runinfo, varname; is=1, data=nothing,                      input=nothing, ax=nothing,                      colorbar_place=nothing, title=nothing,                      outfile=nothing, colorscale=identity, transform=identity,                      it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                      ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                      kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vz.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vz_vr","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vz_vr","text":"function plotvsvzvr(runinfo::Tuple, varname; is=1, data=nothing,                       input=nothing, outfile=nothing, colorscale=identity,                       transform=identity, it=nothing, ir=nothing, iz=nothing,                       ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                       ivz=nothing, kwargs...) function plotvsvzvr(runinfo, varname; is=1, data=nothing,                       input=nothing, ax=nothing,                       colorbar_place=nothing, title=nothing,                       outfile=nothing, colorscale=identity, transform=identity,                       it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                       ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                       kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs vr and vz.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vz_vzeta","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vz_vzeta","text":"function plotvsvzvzeta(runinfo::Tuple, varname; is=1, data=nothing,                          input=nothing, outfile=nothing, colorscale=identity,                          transform=identity, it=nothing, ir=nothing, iz=nothing,                          ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                          ivz=nothing, kwargs...) function plotvsvzvzeta(runinfo, varname; is=1, data=nothing,                          input=nothing, ax=nothing,                          colorbar_place=nothing, title=nothing,                          outfile=nothing, colorscale=identity, transform=identity,                          it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                          ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                          kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta and vz.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vz_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vz_z","text":"function plotvsvzz(runinfo::Tuple, varname; is=1, data=nothing,                      input=nothing, outfile=nothing, colorscale=identity,                      transform=identity, it=nothing, ir=nothing, iz=nothing,                      ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                      ivz=nothing, kwargs...) function plotvsvzz(runinfo, varname; is=1, data=nothing,                      input=nothing, ax=nothing,                      colorbar_place=nothing, title=nothing,                      outfile=nothing, colorscale=identity, transform=identity,                      it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                      ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                      kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vz.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vzeta","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vzeta","text":"function plotvsvzeta(runinfo::Tuple, varname; is=1, data=nothing,                       input=nothing, outfile=nothing, yscale=nothing,                       transform=identity, it=nothing, ir=nothing, iz=nothing,                       ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                       ivz=nothing, kwargs...) function plotvsvzeta(runinfo, varname; is=1, data=nothing,                       input=nothing, ax=nothing, label=nothing,                       outfile=nothing, yscale=nothing, transform=identity,                       it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                       ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                       kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vzeta.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vzeta_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vzeta_r","text":"function plotvsvzetar(runinfo::Tuple, varname; is=1, data=nothing,                         input=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...) function plotvsvzetar(runinfo, varname; is=1, data=nothing,                         input=nothing, ax=nothing,                         colorbar_place=nothing, title=nothing,                         outfile=nothing, colorscale=identity, transform=identity,                         it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                         ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                         kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vzeta.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vzeta_t","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vzeta_t","text":"function plotvsvzetat(runinfo::Tuple, varname; is=1, data=nothing,                         input=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...) function plotvsvzetat(runinfo, varname; is=1, data=nothing,                         input=nothing, ax=nothing,                         colorbar_place=nothing, title=nothing,                         outfile=nothing, colorscale=identity, transform=identity,                         it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                         ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                         kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vzeta.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_vzeta_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_vzeta_z","text":"function plotvsvzetaz(runinfo::Tuple, varname; is=1, data=nothing,                         input=nothing, outfile=nothing, colorscale=identity,                         transform=identity, it=nothing, ir=nothing, iz=nothing,                         ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                         ivz=nothing, kwargs...) function plotvsvzetaz(runinfo, varname; is=1, data=nothing,                         input=nothing, ax=nothing,                         colorbar_place=nothing, title=nothing,                         outfile=nothing, colorscale=identity, transform=identity,                         it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                         ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                         kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vzeta.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_z","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_z","text":"function plotvsz(runinfo::Tuple, varname; is=1, data=nothing,                   input=nothing, outfile=nothing, yscale=nothing,                   transform=identity, it=nothing, ir=nothing, iz=nothing,                   ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                   ivz=nothing, kwargs...) function plotvsz(runinfo, varname; is=1, data=nothing,                   input=nothing, ax=nothing, label=nothing,                   outfile=nothing, yscale=nothing, transform=identity,                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                   kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs z.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_z_r","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_z_r","text":"function plotvszr(runinfo::Tuple, varname; is=1, data=nothing,                     input=nothing, outfile=nothing, colorscale=identity,                     transform=identity, it=nothing, ir=nothing, iz=nothing,                     ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                     ivz=nothing, kwargs...) function plotvszr(runinfo, varname; is=1, data=nothing,                     input=nothing, ax=nothing,                     colorbar_place=nothing, title=nothing,                     outfile=nothing, colorscale=identity, transform=identity,                     it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                     ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                     kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and z.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plot_vs_z_t","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plot_vs_z_t","text":"function plotvszt(runinfo::Tuple, varname; is=1, data=nothing,                     input=nothing, outfile=nothing, colorscale=identity,                     transform=identity, it=nothing, ir=nothing, iz=nothing,                     ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,                     ivz=nothing, kwargs...) function plotvszt(runinfo, varname; is=1, data=nothing,                     input=nothing, ax=nothing,                     colorbar_place=nothing, title=nothing,                     outfile=nothing, colorscale=identity, transform=identity,                     it=nothing, ir=nothing, iz=nothing, ivperp=nothing,                     ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,                     kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and z.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plots_for_dfn_variable-Tuple{Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plots_for_dfn_variable","text":"plots_for_dfn_variable(run_info, variable_name; plot_prefix, is_1D=false,\n                       is_1V=false)\n\nMake plots for the distribution function variable variable_name.\n\nWhich plots to make are determined by the settings in the section of the input whose heading is the variable name.\n\nrun_info is the information returned by get_run_info(). The dfns=true keyword argument must have been passed to get_run_info() so that output files containing the distribution functions are being read.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nis_1D and/or is_1V can be passed to allow the function to skip some plots that do not make sense for 1D or 1V simulations (regardless of the settings).\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.plots_for_variable-Tuple{Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.plots_for_variable","text":"plots_for_variable(run_info, variable_name; plot_prefix, is_1D=false,\n                   is_1V=false, steady_state_residual_fig_axes=nothing)\n\nMake plots for the EM field or moment variable variable_name.\n\nWhich plots to make are determined by the settings in the section of the input whose heading is the variable name.\n\nrun_info is the information returned by get_run_info.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nis_1D and/or is_1V can be passed to allow the function to skip some plots that do not make sense for 1D or 1V simulations (regardless of the settings).\n\nsteady_state_residual_fig_axes contains the figure, axes and legend places for steady state residual plots.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.positive_or_nan-Tuple{Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.positive_or_nan","text":"positive_or_nan(x; epsilon=0)\n\nIf the argument x is zero or negative, replace it with NaN, otherwise return x.\n\nepsilon can be passed if the number should be forced to be above some value (typically we would assume epsilon is small and positive, but nothing about this function forces it to be).\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.postproc_load_variable-Tuple{Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.postproc_load_variable","text":"postproc_load_variable(run_info, variable_name; it=nothing, is=nothing,\n                       ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n                       ivzeta=nothing, ivr=nothing, ivz=nothing)\n\nLoad a variable\n\nrun_info is the information about a run returned by get_run_info.\n\nvariable_name is the name of the variable to load.\n\nThe keyword arguments it, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be set to an integer or a range (e.g. 3:8 or 3:2:8) to select subsets of the data. Only the data for the subset requested will be loaded from the output file (mostly - when loading fields or moments from runs which used parallel_io = false, the full array will be loaded and then sliced).\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.println_to_stdout_and_file-Tuple{Any, Vararg{Any}}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.println_to_stdout_and_file","text":"println_to_stdout_and_file(io, stuff...)\n\nPrint stuff both to stdout and to a file io.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.put_legend_above-Tuple{Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.put_legend_above","text":"putlegendabove(fig, ax; kwargs...)\n\nAdd a legend corresponding to the plot in ax to fig on the left of a new row at the top of the figure layout.\n\nAdditional kwargs are passed to the Legend() constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.put_legend_below-Tuple{Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.put_legend_below","text":"putlegendbelow(fig, ax; kwargs...)\n\nAdd a legend corresponding to the plot in ax to fig on the left of a new row at the bottom of the figure layout.\n\nAdditional kwargs are passed to the Legend() constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.put_legend_left-Tuple{Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.put_legend_left","text":"putlegendleft(fig, ax; kwargs...)\n\nAdd a legend corresponding to the plot in ax to fig on the bottom of a new column at the left of the figure layout.\n\nAdditional kwargs are passed to the Legend() constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.put_legend_right-Tuple{Any, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.put_legend_right","text":"putlegendright(fig, ax; kwargs...)\n\nAdd a legend corresponding to the plot in ax to fig on the bottom of a new column at the right of the figure layout.\n\nAdditional kwargs are passed to the Legend() constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.save_animation-NTuple{4, Any}","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.save_animation","text":"save_animation(fig, frame_index, nt, outfile)\n\nAnimate fig and save the result in outfile.\n\nframe_index is the Observable{mk_int} that updates the data used to make fig to a new time point. nt is the total number of time points to create.\n\nThe suffix of outfile determines the file type.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.select_slice","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.select_slice","text":"select_slice(variable::AbstractArray, dims::Symbol...; input=nothing, it=nothing,\n             is=1, ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n             ivzeta=nothing, ivr=nothing, ivz=nothing)\n\nReturns a slice of variable that includes only the dimensions given in dims..., e.g.\n\nselect_slice(variable, :t, :r)\n\nto get a two dimensional slice with t- and r-dimensions.\n\nAny other dimensions present in variable have a single point selected. By default this point is set by the options in input (which must be a NamedTuple) (or the final point for time or the size of the dimension divided by 3 if input is not given). These defaults can be overridden using the keyword arguments it, is, ir, iz, ivperp, ivpa, ivzeta, ivr, ivz. Ranges can also be passed to these keyword arguments for the 'kept dimensions' in dims to select a subset of those dimensions.\n\nThis function only recognises what the dimensions of variable are by the number of dimensions in the array. It assumes that either the variable has already been sliced to the correct dimensions (if ndims(variable) == length(dims) it just returns variable) or that variable has the full number of dimensions it could have (i.e. 'field' variables have 3 dimensions, 'moment' variables 4, 'ion distribution function' variables 6 and 'neutral distribution function' variables 7).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.setup_makie_post_processing_input!","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.setup_makie_post_processing_input!","text":"setup_makie_post_processing_input!(new_input_dict::AbstractDict{String,Any};\n                                   run_info_moments=nothing,\n                                   run_info_dfns=nothing)\n\nPass input_file to read the input from an input file other than post_processing_input.toml. You can also pass a Dict{String,Any} of options.\n\nSet up input, storing in the global input_dict and input_dict_dfns to be used in the various plotting and analysis functions.\n\nThe run_info that you are using (as returned by get_run_info) should be passed to run_info_moments (if it contains only the moments), or run_info_dfns (if it also contains the distributions functions), or both (if you have loaded both sets of output). This allows default values to be set based on the grid sizes and number of time points read from the output files.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#moment_kinetics.makie_post_processing.sound_wave_plots","page":"makie_post_processing","title":"moment_kinetics.makie_post_processing.sound_wave_plots","text":"sound_wave_plots(run_info::Tuple; plot_prefix)\nsound_wave_plots(run_info; outfile=nothing, ax=nothing, phi=nothing)\n\nCalculate decay rate and frequency for the damped 'sound wave' in a 1D1V simulation in a periodic box. Plot the mode amplitude vs. time along with the fitted decay rate.\n\nThe information for the runs to analyse and plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where line plots from the different runs are overlayed on the same axis.\n\nSettings are read from the [sound_wave] section of the input.\n\nWhen run_info is a Tuple, plot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf. When run_info is not a Tuple, outfile can be passed, to save the plot to outfile.\n\nWhen run_info is not a Tuple, ax can be passed to add the plot to an existing Axis.\n\nWhen run_info is not a Tuple, the array containing data for phi can be passed to phi - by default this data is loaded from the output file.\n\n\n\n\n\n","category":"function"},{"location":"zz_z_advection/#z_advection","page":"z_advection","title":"z_advection","text":"","category":"section"},{"location":"zz_z_advection/","page":"z_advection","title":"z_advection","text":"Modules = [moment_kinetics.z_advection]","category":"page"},{"location":"zz_z_advection/#moment_kinetics.z_advection","page":"z_advection","title":"moment_kinetics.z_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_z_advection/#moment_kinetics.z_advection.adjust_advection_speed!-NTuple{5, Any}","page":"z_advection","title":"moment_kinetics.z_advection.adjust_advection_speed!","text":"\n\n\n\n","category":"method"},{"location":"zz_z_advection/#moment_kinetics.z_advection.unnormalize_pdf!-NTuple{6, Any}","page":"z_advection","title":"moment_kinetics.z_advection.unnormalize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"zz_z_advection/#moment_kinetics.z_advection.update_speed_z!-NTuple{12, Any}","page":"z_advection","title":"moment_kinetics.z_advection.update_speed_z!","text":"calculate the advection speed in the z-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_z_advection/#moment_kinetics.z_advection.z_advection!-NTuple{15, Any}","page":"z_advection","title":"moment_kinetics.z_advection.z_advection!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"zz_derivatives/#derivatives","page":"derivatives","title":"derivatives","text":"","category":"section"},{"location":"zz_derivatives/","page":"derivatives","title":"derivatives","text":"Modules = [moment_kinetics.derivatives]","category":"page"},{"location":"zz_derivatives/#moment_kinetics.derivatives","page":"derivatives","title":"moment_kinetics.derivatives","text":"This module contains all the necessary derivatives needed to carry out distributed memory differential operations on the arrays in moment kinetics. We provide separate derivative functions for each (i) distributed dimension and (ii) array shape. We do not need to provide derivatives for non-distributed dimensions as these can by handled by the derivative! function from calculus.jl\n\n\n\n\n\n","category":"module"},{"location":"zz_calculus/#calculus","page":"calculus","title":"calculus","text":"","category":"section"},{"location":"zz_calculus/","page":"calculus","title":"calculus","text":"Modules = [moment_kinetics.calculus]","category":"page"},{"location":"zz_calculus/#moment_kinetics.calculus","page":"calculus","title":"moment_kinetics.calculus","text":"\n\n\n\n","category":"module"},{"location":"zz_calculus/#moment_kinetics.calculus.derivative!-NTuple{4, Any}","page":"calculus","title":"moment_kinetics.calculus.derivative!","text":"derivative!(df, f, coord, spectral)\n\nNon-upwinding derivative.\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.derivative!-Tuple{Any, Any, Any, Any, moment_kinetics.moment_kinetics_structs.discretization_info}","page":"calculus","title":"moment_kinetics.calculus.derivative!","text":"derivative!(df, f, coord, adv_fac, spectral)\n\nUpwinding derivative.\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.derivative_elements_to_full_grid!-Tuple{Any, Any, Any, AbstractVector{Float64}}","page":"calculus","title":"moment_kinetics.calculus.derivative_elements_to_full_grid!","text":"\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.derivative_elements_to_full_grid!-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.derivative_elements_to_full_grid!","text":"\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.elements_to_full_grid_interior_pts!-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.elements_to_full_grid_interior_pts!","text":"maps the derivative at points away from element boundaries from the grid/element representation to the full grid representation\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.elementwise_derivative!","page":"calculus","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, adv_fac, spectral)\nelementwise_derivative!(coord, f, spectral)\n\nGeneric function for element-by-element derivatives\n\nFirst signature, with adv_fac, calculates an upwind derivative, the second signature calculates a derivative without upwinding information.\n\nResult is stored in coord.scratch_2d.\n\n\n\n\n\n","category":"function"},{"location":"zz_calculus/#moment_kinetics.calculus.elementwise_second_derivative!","page":"calculus","title":"moment_kinetics.calculus.elementwise_second_derivative!","text":"elementwise_second_derivative!(coord, f, spectral)\n\nGeneric function for element-by-element second derivatives.\n\nNote: no upwinding versions of second deriatives.\n\nResult is stored in coord.scratch_2d.\n\n\n\n\n\n","category":"function"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-NTuple{10, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the 3D integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-NTuple{4, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand multiplied by v^n, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-NTuple{7, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the 2D integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand multiplied by v, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-Tuple{Any, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.reconcile_element_boundaries_upwind!-Tuple{Any, Any, Any, AbstractVector{Float64}}","page":"calculus","title":"moment_kinetics.calculus.reconcile_element_boundaries_upwind!","text":"if at the boundary point within the element, must carefully choose which value of df to use; this is because df is multi-valued at the overlapping point at the boundary between neighboring elements. here we choose to use the value of df from the upwind element.\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#numerical_dissipation","page":"numerical_dissipation","title":"numerical_dissipation","text":"","category":"section"},{"location":"zz_numerical_dissipation/","page":"numerical_dissipation","title":"numerical_dissipation","text":"Modules = [moment_kinetics.numerical_dissipation]","category":"page"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation","text":"\n\n\n\n","category":"module"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.force_minimum_pdf_value!-Tuple{Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.force_minimum_pdf_value!","text":"force_minimum_pdf_value!(f, num_diss_paras::numerical_dissipation_parameters)\n\nSet a minimum value for the pdf-sized array f. Any points less than the minimum are set to the minimum. By default, no minimum is applied. The minimum value can be set by\n\n[numerical_dissipation]\nforce_minimum_pdf_value = 0.0\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.force_minimum_pdf_value_neutral!-Tuple{Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.force_minimum_pdf_value_neutral!","text":"force_minimum_pdf_value_neutral!(f, num_diss_paras::numerical_dissipation_parameters)\n\nSet a minimum value for the neutral-pdf-sized array f. Any points less than the minimum are set to the minimum. By default, no minimum is applied. The minimum value can be set by\n\n[numerical_dissipation]\nforce_minimum_pdf_value = 0.0\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.r_dissipation!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.r_dissipation!","text":"Add diffusion in the r direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nr_dissipation_coefficient = 0.1\n\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.r_dissipation_neutral!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.r_dissipation_neutral!","text":"Add diffusion in the r direction to suppress oscillations for neutrals\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nr_dissipation_coefficient = 0.1\n\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_boundary_buffer_decay!-Tuple{Any, Any, Any, Any, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_boundary_buffer_decay!","text":"Suppress the distribution function by damping towards a Maxwellian in the last element before the vpa boundaries, to avoid numerical instabilities there.\n\nDisabled by default.\n\nThe damping rate is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nvpa_boundary_buffer_damping_rate = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_boundary_buffer_diffusion!-Tuple{Any, Any, Any, Any, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_boundary_buffer_diffusion!","text":"Suppress the distribution function by applying diffusion in the last element before the vpa boundaries, to avoid numerical instabilities there.\n\nDisabled by default.\n\nThe maximum diffusion rate in the buffer is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nvpa_boundary_buffer_diffusion_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_boundary_force_decreasing!-Tuple{Any, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_boundary_force_decreasing!","text":"Try to suppress oscillations near the boundary by ensuring that every point in the final element is ≤ the innermost value. The distribution function should be decreasing near the boundaries, so this should be an OK thing to force.\n\nNote: not currently used.\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_dissipation!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_dissipation!","text":"Add diffusion in the vpa direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nvpa_dissipation_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vz_dissipation_neutral!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vz_dissipation_neutral!","text":"Add diffusion in the vz direction to suppress oscillations for neutrals\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nvz_dissipation_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.z_dissipation!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.z_dissipation!","text":"Add diffusion in the z direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nz_dissipation_coefficient = 0.1\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.z_dissipation_neutral!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.z_dissipation_neutral!","text":"Add diffusion in the z direction to suppress oscillations for neutrals\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nz_dissipation_coefficient = 0.1\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"input_options/#Input-Options","page":"Input Options","title":"Input Options","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"This page describes the input options that can be specified in .toml input files.  The input variable name is given first, followed by its default value and a brief description.","category":"page"},{"location":"input_options/#File-I/O","page":"Input Options","title":"File I/O","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"Option name Default value Description\nrun_name  prefix for all output files associated with this run, defaults to the name of the input .toml file\nbase_directory \"runs\" directory where the simulation data will be stored","category":"page"},{"location":"input_options/#Model-Options","page":"Input Options","title":"Model Options","text":"","category":"section"},{"location":"input_options/#Special-cases","page":"Input Options","title":"Special cases","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"Some options apply only for certain types of run, etc. These special cases are described in the following subsections.","category":"page"},{"location":"input_options/#Steady-state-runs","page":"Input Options","title":"Steady state runs","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"Option name Default value Description\nsteady_state_residual false Set to true to print out the maximum residual r(t) = fracleft n(t)-n(t-delta t)right delta t of the density for each species at each output step\nconverged_residual_value -1.0 If steady_state_residual = true and converged_residual_value is set to a positive value, then the simulation will be stopped if all the density residuals are less than converged_residual_value. Note the residuals are only calculated and checked at time steps where output for moment variables is written.","category":"page"},{"location":"zz_load_data/#load_data","page":"load_data","title":"load_data","text":"","category":"section"},{"location":"zz_load_data/","page":"load_data","title":"load_data","text":"Modules = [moment_kinetics.load_data]","category":"page"},{"location":"zz_load_data/#moment_kinetics.load_data","page":"load_data","title":"moment_kinetics.load_data","text":"\n\n\n\n","category":"module"},{"location":"zz_load_data/#moment_kinetics.load_data.load_block_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_block_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_charged_particle_moments_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_charged_particle_moments_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_coordinate_data-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.load_coordinate_data","text":"load_coordinate_data(fid, name; printout=false, irank=nothing, nrank=nothing)\n\nLoad data for the coordinate name from a file-handle fid.\n\nReturns (coord, spectral, chunk_size). coord is a coordinate object. spectral is the object used to implement the discretization in this coordinate. chunk_size is the size of chunks in this coordinate that was used when writing to the output file.\n\nIf printout is set to true a message will be printed when this function is called.\n\nIf irank and nrank are passed, then the coord and spectral objects returned will be set up for the parallelisation specified by irank and nrank, rather than the one implied by the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_distributed_charged_pdf_slice-Tuple{Tuple, Tuple, Any, Int64, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate}","page":"load_data","title":"moment_kinetics.load_data.load_distributed_charged_pdf_slice","text":"Read a slice of an ion distribution function\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\nThe slice to take is specified by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_distributed_neutral_pdf_slice-Tuple{Tuple, Tuple, Any, Int64, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate}","page":"load_data","title":"moment_kinetics.load_data.load_distributed_neutral_pdf_slice","text":"Read a slice of a neutral distribution function\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\nThe slice to take is specified by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_fields_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_fields_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_input-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_input","text":"Load saved input settings\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_mk_options-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_mk_options","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_neutral_pdf_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_neutral_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_pdf_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_rank_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_rank_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_slice-Tuple{}","page":"load_data","title":"moment_kinetics.load_data.load_slice","text":"Load a slice of a single variable from a file\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_species_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_species_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_time_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_time_data","text":"If a tuple is given for fid, concatenate the \"time\" output from each file in the tuple\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_variable-Tuple{}","page":"load_data","title":"moment_kinetics.load_data.load_variable","text":"Load a single variable from a file\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.open_readonly_output_file-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.open_readonly_output_file","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.read_Dict_from_section-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.read_Dict_from_section","text":"read_Dict_from_section(file_or_group, section_name; ignore_subsections=false)\n\nRead information from section_name in file_or_group, returning a Dict.\n\nBy default, any subsections are included as nested Dicts. If ignore_subsections=true they are ignored.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.reload_evolving_fields!-NTuple{14, Any}","page":"load_data","title":"moment_kinetics.load_data.reload_evolving_fields!","text":"Reload pdf and moments from an existing output file.\n\n\n\n\n\n","category":"method"},{"location":"post_processing_notes/#Post-processing","page":"Post processing","title":"Post processing","text":"","category":"section"},{"location":"post_processing_notes/#How-to","page":"Post processing","title":"How to","text":"","category":"section"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"Post processing functionality is provided by the moment_kinetics.makie_post_processing module. To run the post processing, call moment_kinetics.makie_post_processing.makie_post_process e.g.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> using moment_kinetics.makie_post_process\njulia> makie_post_process(\"runs/example-run/\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"or","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> makie_post_process(\"runs/example-run1/\", \"runs/example-run2/\", \"runs/example-run3/\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"What this function does is controlled by the settings in an input file, by default post_processing_input.toml.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"To run from the command line","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia --project run_makie_post_processing.jl dir1 [dir2 [dir3 ...]]","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"If multiple directories are passed, comparison plots will be made. This usually means that for line plots and animations the output for all the runs will be drawn on the same plot. For heatmap plots, the runs will be plotted side by side.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"If there is output from several restarts of the same run in a directory, by default they will all be read and plotted. A single restart can be started by passing the restart_id argument to makie_post_process().","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"To see all the options that can be set, moment_kinetics.makie_post_processing.generate_example_input_file can be used to create an example file containing all the options with their default values. The options are all commented out when the file is created.","category":"page"},{"location":"post_processing_notes/#Interactive-use","page":"Post processing","title":"Interactive use","text":"","category":"section"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"The functions in moment_kinetics.makie_post_processing can be used interactively (or in standalone scripts). To do so, first get the 'info' for a run (file names, metadata, etc.) using moment_kinetics.makie_post_processing.get_run_info","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> using moment_kinetics.makie_post_processing\njulia> run_info = get_run_info(\"runs/example-run/\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"or to load from the distribution functions output file .dfns.h5","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> run_info_dfns = get_run_info(\"runs/example-run/\"; dfns=true)","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"You will usually want to set up the options (stored in moment_kinetics.makie_post_processing.input_dict and moment_kinetics.makie_post_processing.input_dict_dfns) with moment_kinetics.makie_post_processing.setup_makie_post_processing_input!()","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> setup_makie_post_processing_input!(\"my_input.toml\"; run_info_moments=run_info, run_info_dfns=run_info_dfns)","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"The run_info_moments and run_info_dfns arguments are used to set sensible defaults for various options - they are not required, and usually you will probably only pass one (run_info_dfns if you loaded distribution function output, and run_info_moments otherwise).","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"Then you can make 1d or 2d plots, e.g.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> fig1 = plot_vs_z(run_info, \"phi\")\njulia> fig2 = plot_vs_r_t(run_info, \"density\"; outfile=\"density_vs_r_t.pdf\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"using moment_kinetics.makie_post_processing.plot_vs_t, etc. for 1d and moment_kinetics.makie_post_processing.plot_vs_r_t, etc. for 2d plots. The outfile argument can be used to save the plot. You can also change the default values used to select from the other dimensions","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> plot_vs_z(run_info, \"phi\"; outfile=\"phi_vs_z.pdf\", it=42, ir=7)","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"You can make animations in a similar way","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> fig1 = animate_vs_z(run_info, \"phi\"; outfile=\"phi_vs_z.gif\", it=8:12, ir=1)\njulia> fig2 = animate_vs_z_r(run_info, \"density\"; outfile=\"density_vs_z_r.mp4\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"using moment_kinetics.makie_post_processing.animate_vs_r, etc. for 1d and moment_kinetics.makie_post_processing.animate_vs_z_r, etc.  for 2d animations. Note that outfile is required for animations.","category":"page"},{"location":"post_processing_notes/#API","page":"Post processing","title":"API","text":"","category":"section"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"See makie_post_processing.","category":"page"},{"location":"zz_chebyshev/#chebyshev","page":"chebyshev","title":"chebyshev","text":"","category":"section"},{"location":"zz_chebyshev/","page":"chebyshev","title":"chebyshev","text":"Modules = [moment_kinetics.chebyshev]","category":"page"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev","page":"chebyshev","title":"moment_kinetics.chebyshev","text":"\n\n\n\n","category":"module"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_info","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_info","text":"Chebyshev pseudospectral discretization\n\n\n\n\n\n","category":"type"},{"location":"zz_chebyshev/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Any, moment_kinetics.chebyshev.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, ff, adv_fac, spectral::chebyshev_info)\n\nChebyshev transform f to get Chebyshev spectral coefficients and use them to calculate f'.\n\nNote: Chebyshev derivative does not make use of upwinding information within each element.\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, moment_kinetics.chebyshev.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, ff, chebyshev::chebyshev_info)\n\nChebyshev transform f to get Chebyshev spectral coefficients and use them to calculate f'.\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_backward_transform!-NTuple{5, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_backward_transform!","text":"\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_derivative_single_element!-NTuple{7, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_derivative_single_element!","text":"\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_forward_transform!-NTuple{5, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_forward_transform!","text":"takes the real function ff on a Chebyshev grid in z (domain [-1, 1]), which corresponds to the domain [π, 2π] in variable theta = ArcCos(z). interested in functions of form f(z) = sumn cn Tn(z) using Tn(cos(theta)) = cos(ntheta) and z = cos(theta) gives f(z) = sumn cn cos(ntheta) thus a Chebyshev transform is equivalent to a discrete cosine transform doing this directly turns out to be slower than extending the domain from [0, 2pi] and using the fact that f(z) must be even (as cosines are all even) on this extended domain, can do a standard complex-to-complex fft fext is an array used to store f(theta) on the extended grid theta ∈ [0,2π) ff is f(theta) on the grid [π,2π] the Chebyshev coefficients of ff are calculated and stored in chebyf n is the number of grid points on the Chebyshev-Gauss-Lobatto grid transform is the plan for the complex-to-complex, in-place fft\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_interpolate_single_element!-NTuple{7, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_interpolate_single_element!","text":"\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_spectral_derivative!-Tuple{Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_spectral_derivative!","text":"use Chebyshev basis to compute the first derivative of f\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshevmoments-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshevmoments","text":"compute and return modified Chebyshev moments of the first kind: ∫dx Tᵢ(x) over range [-1,1]\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshevpoints-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshevpoints","text":"returns the Chebyshev-Gauss-Lobatto grid points on an n point grid\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.clenshaw_curtis_weights-NTuple{6, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.clenshaw_curtis_weights","text":"returns wgts array containing the integration weights associated with all grid points for Clenshaw-Curtis quadrature\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.scaled_chebyshev_grid-NTuple{7, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.scaled_chebyshev_grid","text":"initialize chebyshev grid scaled to interval [-boxlength/2, boxlength/2] we no longer pass the boxlength to this function, but instead pass precomputed arrays elementscale and element_shift that are needed to compute the grid.\n\nngrid – number of points per element (including boundary points) nelementlocal – number of elements in the local (distributed memory MPI) grid n – total number of points in the local grid (excluding duplicate points) elementscale – the scale factor in the transform from the coordinates                   where the element limits are -1, 1 to the coordinate where                  the limits are Aj = coord.grid[imin[j]-1] and Bj = coord.grid[imax[j]]                  elementscale = 0.5*(Bj - Aj) elementshift – the centre of the element in the extended grid coordinate                  element_shift = 0.5*(Aj + Bj) imin – the array of minimum indices of each element on the extended grid.         By convention, the duplicated points are not included, so for element index j > 1         the lower boundary point is actually imin[j] - 1 imax – the array of maximum indices of each element on the extended grid.\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.setup_chebyshev_pseudospectral-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.setup_chebyshev_pseudospectral","text":"create arrays needed for explicit Chebyshev pseudospectral treatment and create the plans for the forward and backward fast Fourier transforms\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.update_df_chebyshev!-Tuple{Any, Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.update_df_chebyshev!","text":"compute the Chebyshev spectral coefficients of the spatial derivative of f\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.update_fcheby!-Tuple{Any, Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.update_fcheby!","text":"Chebyshev transform f to get Chebyshev spectral coefficients\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.interpolation.interpolate_to_grid_1d!-Tuple{Any, Any, Any, Any, moment_kinetics.chebyshev.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.interpolation.interpolate_to_grid_1d!","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nArguments\n\nresult : Array{mkfloat, 1}     Array to be overwritten with the result of the interpolation newgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies chebyshev : chebyshev_info     struct containing information for Chebyshev transforms\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_constraints/#moment_kinetics","page":"moment_kinetics","title":"moment_kinetics","text":"","category":"section"},{"location":"zz_moment_constraints/","page":"moment_kinetics","title":"moment_kinetics","text":"Modules = [moment_kinetics.moment_constraints]","category":"page"},{"location":"zz_moment_constraints/#moment_kinetics.moment_constraints","page":"moment_kinetics","title":"moment_kinetics.moment_constraints","text":"Functions for enforcing integral constraints on the normalised distribution function. Ensures consistency of evolution split into moments and normalised distribution function.\n\n\n\n\n\n","category":"module"},{"location":"zz_moment_constraints/#moment_kinetics.moment_constraints.hard_force_moment_constraints!-Tuple{Any, Any, Any}","page":"moment_kinetics","title":"moment_kinetics.moment_constraints.hard_force_moment_constraints!","text":"hard_force_moment_constraints!(f, moments, vpa)\n\nForce the moment constraints needed for the system being evolved to be applied to f. Not guaranteed to be a small correction, if f does not approximately obey the constraints to start with, but can be useful at initialisation to ensure a consistent initial state, and when applying boundary conditions.\n\nNote this function assumes the input is given at a single spatial position.\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_constraints/#moment_kinetics.moment_constraints.hard_force_moment_constraints_neutral!-Tuple{Any, Any, Any}","page":"moment_kinetics","title":"moment_kinetics.moment_constraints.hard_force_moment_constraints_neutral!","text":"hard_force_moment_constraints_neutral!(f, moments, vz)\n\nForce the moment constraints needed for the system being evolved to be applied to f. Not guaranteed to be a small correction, if f does not approximately obey the constraints to start with, but can be useful at initialisation to ensure a consistent initial state, and when applying boundary conditions.\n\nNotes:\n\nthis function assumes the input is given at a single spatial position.\ncurrently only works with '1V' runs, where vz is the only velocity-space dimension\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#source_terms","page":"source_terms","title":"source_terms","text":"","category":"section"},{"location":"zz_source_terms/","page":"source_terms","title":"source_terms","text":"Modules = [moment_kinetics.source_terms]","category":"page"},{"location":"zz_source_terms/#moment_kinetics.source_terms","page":"source_terms","title":"moment_kinetics.source_terms","text":"\n\n\n\n","category":"module"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms!-NTuple{11, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms!","text":"calculate the source terms due to redefinition of the pdf to split off density, flow and/or pressure, and use them to update the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_evolve_density!-NTuple{10, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_density!","text":"\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_evolve_density_neutral!-NTuple{10, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_density_neutral!","text":"\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_collisions!-NTuple{13, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_collisions!","text":"update the evolved pdf to account for the charge exchange and ionization source terms in the kinetic equation arising due to the re-normalization of the pdf as g = f * vth / n\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_collisions_neutral!-NTuple{13, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_collisions_neutral!","text":"update the evolved pdf to account for the charge exchange and ionization source terms in the kinetic equation arising due to the re-normalization of the pdf as g = f * vth / n\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_no_collisions!-NTuple{13, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_no_collisions!","text":"update the evolved pdf to account for the collisionless source terms in the kinetic equation arising due to the re-normalization of the pdf as g = f * vth / n\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_no_collisions_neutral!-NTuple{13, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_no_collisions_neutral!","text":"update the evolved pdf to account for the collisionless source terms in the kinetic equation arising due to the re-normalization of the pdf as g = f * vth / n\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_manufactured!-NTuple{13, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_manufactured!","text":"advance the dfn with an arbitrary source function \n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_neutral!-NTuple{11, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_neutral!","text":"calculate the source terms due to redefinition of the pdf to split off density, flow and/or pressure, and use them to update the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_constants/#constants","page":"constants","title":"constants","text":"","category":"section"},{"location":"zz_constants/","page":"constants","title":"constants","text":"Modules = [moment_kinetics.constants]","category":"page"},{"location":"zz_constants/#moment_kinetics.constants","page":"constants","title":"moment_kinetics.constants","text":"Some physical constants\n\n\n\n\n\n","category":"module"},{"location":"zz_force_balance/#force_balance","page":"force_balance","title":"force_balance","text":"","category":"section"},{"location":"zz_force_balance/","page":"force_balance","title":"force_balance","text":"Modules = [moment_kinetics.force_balance]","category":"page"},{"location":"zz_force_balance/#moment_kinetics.force_balance","page":"force_balance","title":"moment_kinetics.force_balance","text":"\n\n\n\n","category":"module"},{"location":"zz_force_balance/#moment_kinetics.force_balance.force_balance!-NTuple{11, Any}","page":"force_balance","title":"moment_kinetics.force_balance.force_balance!","text":"use the force balance equation d(nu)/dt + d(ppar + nuparupar)/dz = -(dens/2)dphi/dz + Rdensi*densn(uparn-upari) to update the parallel particle flux densupar for each species\n\n\n\n\n\n","category":"method"},{"location":"zz_krook_collisions/#krook_collisions","page":"krook_collisions","title":"krook_collisions","text":"","category":"section"},{"location":"zz_krook_collisions/","page":"krook_collisions","title":"krook_collisions","text":"Modules = [moment_kinetics.krook_collisions]","category":"page"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions","page":"krook_collisions","title":"moment_kinetics.krook_collisions","text":"\n\n\n\n","category":"module"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions.get_collision_frequency-Tuple{Any, Any, Any}","page":"krook_collisions","title":"moment_kinetics.krook_collisions.get_collision_frequency","text":"get_collision_frequency(collisions, n, vth)\n\nCalculate the collision frequency, depending on the settings/parameters in collisions, for the given density n and thermal speed vth.\n\nn and vth may be scalars or arrays, but should have shapes that can be broadcasted together.\n\n\n\n\n\n","category":"method"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions.krook_collisions!-NTuple{8, Any}","page":"krook_collisions","title":"moment_kinetics.krook_collisions.krook_collisions!","text":"Add collision operator\n\nCurrently Krook collisions\n\n\n\n\n\n","category":"method"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions.setup_krook_collisions-Tuple{Any}","page":"krook_collisions","title":"moment_kinetics.krook_collisions.setup_krook_collisions","text":"Calculate normalized collision frequency at reference parameters for Coulomb collisions.\n\nCurrently valid only for hydrogenic ions (Z=1)\n\n\n\n\n\n","category":"method"},{"location":"zz_plot_MMS_sequence/#plot_MMS_sequence","page":"plot_MMS_sequence","title":"plot_MMS_sequence","text":"","category":"section"},{"location":"zz_plot_MMS_sequence/","page":"plot_MMS_sequence","title":"plot_MMS_sequence","text":"Modules = [moment_kinetics.plot_MMS_sequence]","category":"page"},{"location":"zz_plot_MMS_sequence/#moment_kinetics.plot_MMS_sequence","page":"plot_MMS_sequence","title":"moment_kinetics.plot_MMS_sequence","text":"\n\n\n\n","category":"module"},{"location":"zz_external_sources/#external_sources","page":"external_sources","title":"external_sources","text":"","category":"section"},{"location":"zz_external_sources/","page":"external_sources","title":"external_sources","text":"Modules = [moment_kinetics.external_sources]","category":"page"},{"location":"zz_external_sources/#moment_kinetics.external_sources","page":"external_sources","title":"moment_kinetics.external_sources","text":"Maxwellian source terms with spatially varying parameters representing external sources of particles and energy.\n\nNote there is no parallel momentum input from the external sources.\n\nThe sources can be controlled by a PI controller to set density to a target value or profile. Note that the PI controller should not be used with operator splitting - implementing it in a way that would be compatible with splitting is complicated because the source contributes to several terms.\n\n\n\n\n\n","category":"module"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_ion_source!-NTuple{7, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_ion_source!","text":"external_ion_source!(pdf, fvec, moments, ion_source_settings, vperp, vpa, dt)\n\nAdd external source term to the ion kinetic equation.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_ion_source_controller!-NTuple{4, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_ion_source_controller!","text":"external_ion_source_controller!(fvec_in, ion_moments, ion_source_settings, dt)\n\nCalculate the amplitude when using a PI controller for the density to set the external source amplitude.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_neutral_source!-NTuple{8, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_neutral_source!","text":"external_neutral_source!(pdf, fvec, moments, neutral_source_settings, vzeta, vr,\n                        vz, dt)\n\nAdd external source term to the neutral kinetic equation.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_neutral_source_controller!-NTuple{6, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_neutral_source_controller!","text":"external_neutral_source_controller!(fvec_in, neutral_moments,\n                                    neutral_source_settings, r, z, dt)\n\nCalculate the amplitude when using a PI controller for the density to set the external source amplitude.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.get_source_profile-NTuple{4, Any}","page":"external_sources","title":"moment_kinetics.external_sources.get_source_profile","text":"get_source_profile(profile_type, width, min_val, coord)\n\nCreate a profile of type profile_type with width width for coordinate coord.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.initialize_external_source_amplitude!-NTuple{6, Any}","page":"external_sources","title":"moment_kinetics.external_sources.initialize_external_source_amplitude!","text":"initialize_external_source_amplitude!(moments, external_source_settings, vperp,\n                                      vzeta, vr, n_neutral_species)\n\nInitialize the arrays moments.charged.external_source_amplitude and moments.neutral.external_source_amplitude, using the settings in external_source_settings\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.initialize_external_source_controller_integral!-Tuple{Any, Any, Any}","page":"external_sources","title":"moment_kinetics.external_sources.initialize_external_source_controller_integral!","text":"function initializeexternalsourcecontrollerintegral!(              moments, externalsourcesettings, nneutralspecies)\n\nInitialize the arrays moments.charged.external_source_controller_integral and moments.neutral.external_source_controller_integral, using the settings in external_source_settings\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.setup_external_sources!-Tuple{Any, Any, Any}","page":"external_sources","title":"moment_kinetics.external_sources.setup_external_sources!","text":"setup_external_sources!(input_dict, r, z)\n\nSet up parameters for the external sources using settings in input_dict.\n\nUpdates input_dict with defaults for unset parameters.\n\nr and z are the coordinates.coordinate objects for the r- and z-coordinates.\n\nReturns a NamedTuple (ion=ion_source_settings, neutral=neutral_source_settings) containing two NamedTuples of settings.\n\n\n\n\n\n","category":"method"},{"location":"zz_clenshaw_curtis/#clenshaw_curtis","page":"clenshaw_curtis","title":"clenshaw_curtis","text":"","category":"section"},{"location":"zz_clenshaw_curtis/","page":"clenshaw_curtis","title":"clenshaw_curtis","text":"Modules = [moment_kinetics.clenshaw_curtis]","category":"page"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis","text":"\n\n\n\n","category":"module"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis.chebyshevpoints-Tuple{Any}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.chebyshevpoints","text":"\n\n\n\n","category":"method"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis.clenshawcurtisnodes-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.clenshawcurtisnodes","text":"Compute nodes of the Clenshaw—Curtis quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis.clenshawcurtisweights-Tuple{}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.clenshawcurtisweights","text":"Compute weights of the Clenshaw—Curtis quadrature rule with modified Chebyshev moments of the first kind (μ)\n\n\n\n\n\n","category":"method"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis.plan_clenshawcurtis-Tuple{Any}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.plan_clenshawcurtis","text":"\n\n\n\n","category":"method"},{"location":"zz_reference_parameters/#reference_parameters","page":"reference_parameters","title":"reference_parameters","text":"","category":"section"},{"location":"zz_reference_parameters/","page":"reference_parameters","title":"reference_parameters","text":"Modules = [moment_kinetics.reference_parameters]","category":"page"},{"location":"zz_reference_parameters/#moment_kinetics.reference_parameters","page":"reference_parameters","title":"moment_kinetics.reference_parameters","text":"Reference parameters\n\nReference parameters are not needed or used by the main part of the code, but define the physical units of the simulation, and are needed for a few specific steps during setup (e.g. calculation of normalised collision frequency).\n\n\n\n\n\n","category":"module"},{"location":"zz_reference_parameters/#moment_kinetics.reference_parameters.setup_reference_parameters-Tuple{Any}","page":"reference_parameters","title":"moment_kinetics.reference_parameters.setup_reference_parameters","text":"\n\n\n\n","category":"method"},{"location":"zz_velocity_grid_transforms/#velocity_grid_transforms","page":"velocity_grid_transforms","title":"velocity_grid_transforms","text":"","category":"section"},{"location":"zz_velocity_grid_transforms/","page":"velocity_grid_transforms","title":"velocity_grid_transforms","text":"Modules = [moment_kinetics.velocity_grid_transforms]","category":"page"},{"location":"zz_velocity_grid_transforms/#moment_kinetics.velocity_grid_transforms","page":"velocity_grid_transforms","title":"moment_kinetics.velocity_grid_transforms","text":"\n\n\n\n","category":"module"},{"location":"zz_neutral_z_advection/#neutral_z_advection","page":"neutral_z_advection","title":"neutral_z_advection","text":"","category":"section"},{"location":"zz_neutral_z_advection/","page":"neutral_z_advection","title":"neutral_z_advection","text":"Modules = [moment_kinetics.neutral_z_advection]","category":"page"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection.adjust_advection_speed!-NTuple{5, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.adjust_advection_speed!","text":"\n\n\n\n","category":"method"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection.neutral_advection_z!-NTuple{14, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.neutral_advection_z!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection.unnormalize_pdf!-NTuple{6, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.unnormalize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection.update_speed_neutral_z!-NTuple{11, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.update_speed_neutral_z!","text":"calculate the advection speed in the z-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_manufactured_solns/#manufactured_solns","page":"manufactured_solns","title":"manufactured_solns","text":"","category":"section"},{"location":"zz_manufactured_solns/","page":"manufactured_solns","title":"manufactured_solns","text":"Modules = [moment_kinetics.manufactured_solns]","category":"page"},{"location":"zz_manufactured_solns/#moment_kinetics.manufactured_solns","page":"manufactured_solns","title":"moment_kinetics.manufactured_solns","text":"\n\n\n\n","category":"module"},{"location":"constraints_on_normalized_distribution_function/#Constraints-on-normalized-distribution-function","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Note: Equation references give the Excalibur/Neptune report number and equation number, e.g. (TN-04;1) is equation (1) from report TN-04.pdf.","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Constraints","page":"Constraints on normalized distribution function","title":"Constraints","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"The normalized particle distribution function that is evolved when using the moment-kinetic approach has to satisfy integral constraints related to particle number, momentum and energy conservation (TN-04;70-72)","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s  =1\n  frac1sqrtpiint dw_w_tildeg_s  =0\n  frac1sqrtpiint dw_w_^2tildeg_s  =frac12\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Old-algorithm","page":"Constraints on normalized distribution function","title":"Old algorithm","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"The algorithm described in TN-04 used the distribution function from the previous time step and also made use of a symmetrized distribution function tildeg_E(w_)=frac12left(tildeg(w_)+tildeg(-w_)right). These choices caused problems when in combination with the boundary conditions as: applying the boundary condition at the new timestep (with an updated tildeu_) to the old tildeg_s could mean that it no longer satisfied the moment constraints (e.g. if a grid point that was previously non-zero is now set to zero by the ion sheath boundary condition); the symmetrized tildeg_E will be non-zero at places where the boundary condition forces tildeg_s to be zero. It is possible to extend the algorithm to allow the constraints to be enforced using only the initial guess of the distribution function at the new timestep, as described below.","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Current-algorithm","page":"Constraints on normalized distribution function","title":"Current algorithm","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"After the time advance updates the distribution function, it will in general not obey the constraints, but the errors will be small, with the size depending on the accuracy of the spatial and temporal discretizations. We can take this updated value hatg_s as an initial guess, to be corrected to give the actual updated value tildeg_s, which does obey the constraints to machine precision.","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"We define the corrected distribution function as","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  tildeg_s=Ahatg_s+Bw_hatg_s+Cw_^2hatg_s\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"and define the moments of hatg_s","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  I_n=frac1sqrtpiint dw_w_^nhatg_s\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Then the moments of tildeg_s are","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s=1  =frac1sqrtpiint dw_left(Ahatg_s+Bw_hatg_s+Cw_^2hatg_sright)=AI_0+BI_1+CI_2\n  frac1sqrtpiint dw_w_tildeg_s=0  =frac1sqrtpiint dw_left(Aw_hatg_s+Bw_^2hatg_s+Cw_^3hatg_sright)=AI_1+BI_2+CI_3\n  frac1sqrtpiint dw_w_^2tildeg_s=frac12  =frac1sqrtpiint dw_left(Aw_^2hatg_s+Bw_^3hatg_s+Cw_^4hatg_sright)=AI_2+BI_3+CI_4\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Solving the simultaneous equations for A, B, C gives","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  C  =fracfrac12-AI_2-BI_3I_4\n  B  =fracleft(I_2I_3-I_1I_4right)A-fracI_32I_2I_4-I_3^2\n  A  =fracI_2I_4-fracI_2^22+I_3left(fracI_12-I_3right)I_0left(I_2I_4-I_3^2right)+I_1left(I_2I_3-I_1I_4right)+I_2left(I_1I_3-I_2^2right)\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Note that there is no guarantee that tildeg_s is geq0 even if hatg_sgeq0, although if the violations of the integral constraints are small, it should be true that Aapprox1 while B and C are small.","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Evolving-u_\\parallel","page":"Constraints on normalized distribution function","title":"Evolving u_parallel","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"When evolving fewer moments separately, the constraints become simpler. When evolving n and u_parallel, only the first two constraints are needed. This corresponds to C=0 so that","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  1 = AI_0 + BI_1 \n  0 = AI_1 + BI_2 \n  Rightarrow B = -fracAI_1I_2 \n  AI_0 = 1 - BI_1 = 1 + fracAI_1^2I_2 \n  A = frac1I_0 - I_1^2I_2\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Evolving-n","page":"Constraints on normalized distribution function","title":"Evolving n","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"When evolving only n separately, we only need one constraint and the correction is just a re-scaling. This corresponds to B=0C=0 so that","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  1 = AI_0 \n  A = frac1I_0\nendalign","category":"page"},{"location":"zz_command_line_options/#command_line_options","page":"command_line_options","title":"command_line_options","text":"","category":"section"},{"location":"zz_command_line_options/","page":"command_line_options","title":"command_line_options","text":"Modules = [moment_kinetics.command_line_options]","category":"page"},{"location":"zz_command_line_options/#moment_kinetics.command_line_options","page":"command_line_options","title":"moment_kinetics.command_line_options","text":"Parse command line arguments\n\nHave to include test options here too, because ArgParse errors on unrecognized options.\n\n\n\n\n\n","category":"module"},{"location":"zz_command_line_options/#moment_kinetics.command_line_options.get_options-Tuple{}","page":"command_line_options","title":"moment_kinetics.command_line_options.get_options","text":"\n\n\n\n","category":"method"},{"location":"zz_em_fields/#em_fields","page":"em_fields","title":"em_fields","text":"","category":"section"},{"location":"zz_em_fields/","page":"em_fields","title":"em_fields","text":"Modules = [moment_kinetics.em_fields]","category":"page"},{"location":"zz_em_fields/#moment_kinetics.em_fields","page":"em_fields","title":"moment_kinetics.em_fields","text":"\n\n\n\n","category":"module"},{"location":"zz_em_fields/#moment_kinetics.em_fields.setup_em_fields-NTuple{6, Any}","page":"em_fields","title":"moment_kinetics.em_fields.setup_em_fields","text":"\n\n\n\n","category":"method"},{"location":"zz_em_fields/#moment_kinetics.em_fields.update_phi!-NTuple{8, Any}","page":"em_fields","title":"moment_kinetics.em_fields.update_phi!","text":"update_phi updates the electrostatic potential, phi\n\n\n\n\n\n","category":"method"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for moment_kinetics.jl","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"getting_started.md\",\n         \"machine_setup.md\",\n         \"input_options.md\",\n         \"post_processing_notes.md\",\n         \"moment_kinetic_equations.md\",\n         \"moment_constraints_notes.md\",\n         \"boundary_conditions_notes.md\",\n         \"external_sources_notes.md\",\n         \"developing.md\",\n         \"debugging-hints.md\",\n        ]","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Order = [:module]","category":"page"},{"location":"zz_neutral_vz_advection/#neutral_vz_advection","page":"neutral_vz_advection","title":"neutral_vz_advection","text":"","category":"section"},{"location":"zz_neutral_vz_advection/","page":"neutral_vz_advection","title":"neutral_vz_advection","text":"Modules = [moment_kinetics.neutral_vz_advection]","category":"page"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.neutral_advection_vz!-NTuple{15, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.neutral_advection_vz!","text":"\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_constant_neutral!-NTuple{6, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_constant_neutral!","text":"update the advection speed dvpa/dt = constant\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_default_neutral!-NTuple{10, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_default_neutral!","text":"\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_linear_neutral-NTuple{6, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_linear_neutral","text":"update the advection speed dvpa/dt = const*(vpa + L/2)\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_n_p_evolution_neutral!-NTuple{10, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_n_p_evolution_neutral!","text":"update the advection speed in the parallel velocity coordinate for the case where density and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized velocity vpahat = vpa/vth\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_n_u_evolution_neutral!-NTuple{9, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_n_u_evolution_neutral!","text":"update the advection speed in the parallel velocity coordinate for the case where density and flow are evolved independently from the pdf; in this case, the parallel velocity coordinate is the peculiar velocity wpa = vpa-upar\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_n_u_p_evolution_neutral!-NTuple{9, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_n_u_p_evolution_neutral!","text":"update the advection speed (for the neutral distribution function) in the z-velocity coordinate for the case where density, flow and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized peculiar velocity wpahat = (vpa - upar)/vth\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_neutral_vz!-NTuple{12, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_neutral_vz!","text":"calculate the advection speed in the vz-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#advection","page":"advection","title":"advection","text":"","category":"section"},{"location":"zz_advection/","page":"advection","title":"advection","text":"Modules = [moment_kinetics.advection]","category":"page"},{"location":"zz_advection/#moment_kinetics.advection","page":"advection","title":"moment_kinetics.advection","text":"\n\n\n\n","category":"module"},{"location":"zz_advection/#moment_kinetics.advection.advection_info","page":"advection","title":"moment_kinetics.advection.advection_info","text":"structure containing the basic arrays associated with the advection terms appearing in the advection equation for each coordinate\n\n\n\n\n\n","category":"type"},{"location":"zz_advection/#moment_kinetics.advection.advance_f_local!-NTuple{9, Any}","page":"advection","title":"moment_kinetics.advection.advance_f_local!","text":"do all the work needed to update f(coord) at a single value of other coords\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.calculate_explicit_advection!-NTuple{4, Any}","page":"advection","title":"moment_kinetics.advection.calculate_explicit_advection!","text":"calculate the explicit advection terms on the rhs of the equation; i.e., -Δt⋅δv⋅f'\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.setup_advection-Tuple{Any, Vararg{Any}}","page":"advection","title":"moment_kinetics.advection.setup_advection","text":"create arrays needed to compute the advection term(s) for a 1D problem\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.setup_advection_per_species-Tuple","page":"advection","title":"moment_kinetics.advection.setup_advection_per_species","text":"create arrays needed to compute the advection term(s)\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.update_advection_factor!-NTuple{4, Any}","page":"advection","title":"moment_kinetics.advection.update_advection_factor!","text":"calculate the factor appearing in front of f' in the advection term at time level n in the frame moving with the approximate characteristic\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.update_f!-Tuple{Any, Any, Any}","page":"advection","title":"moment_kinetics.advection.update_f!","text":"\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.update_rhs!-NTuple{8, Any}","page":"advection","title":"moment_kinetics.advection.update_rhs!","text":"update the righthand side of the equation to account for 1d advection in this coordinate\n\n\n\n\n\n","category":"method"},{"location":"debugging-hints/#Debugging","page":"Debugging","title":"Debugging","text":"","category":"section"},{"location":"debugging-hints/#Shared-memory-parallelism","page":"Debugging","title":"Shared-memory parallelism","text":"","category":"section"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"For information on race conditions and debugging, see Shared memory debugging.","category":"page"},{"location":"debugging-hints/#Dumping-state-of-physics-variables","page":"Debugging","title":"Dumping state of physics variables","text":"","category":"section"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"There is a function moment_kinetics.file_io.debug_dump provided in the moment_kinetics.file_io module that can be inserted to save the distribution function, moments, etc. These can include a label so that if there are several 'dumps' within a timestep, they can be easily identified.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"To use, first import the function","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"using ..file_io: debug_dump","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"then insert calls at the point where you want to save the variables, e.g.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"debug_dump(f, density, upar, ppar, phi, t, istage=istage, label=\"foo\")","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"where f, density, upar, ppar, and phi are arrays and t is an mk_float. istage is an optional mk_int, and can be used to identify the stage in the ssp_rk!() function. label is optional and can be any string, intended to distinguish different calls to debug_dump().","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"There is an alternative method (implementation) of the function that takes moment_kinetics.moment_kinetics_structs.scratch_pdf and moment_kinetics.moment_kinetics_structs.em_fields_struct arguments. This can be convenient within the functions in moment_kinetics.time_advance, e.g.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"debug_dump(fvec_out, fields, t, istage=istage, label=\"bar\")","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"Any of the positional arguments can be replaced by nothing if they are not available in a certain place, or just not needed. If nothing is passed, then arrays filled with 0.0 are written into the output.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"The output is written into a NetCDF file debug_output.cdf in the current directory (the filename is currently hard-coded because that was simpler than adding more command line arguments, etc.).","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"For debugging, a script util/compare_debug_files.jl is provided to compare two output files, assumed to have similar structure (i.e. the same set of debug_dump() calls). An example workflow could be:","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"Checkout master branch.\nCreate new branch, git checkout -b newfeature.\nWork on newfeature...\nAt some point, a bug is introduced which breaks some test or example - i.e. changes its output. Commit the current state of the code.\nAdd debug_dump() calls before and after locations where the bug is likely to be.\nRun the broken case.\nmv debug_output.cdf debug_after.cdf, so the file does not get overwritten.\ngit stash to 'save' the debug_dump() statements.\ngit checkout a commit where the test/example was working.\ngit stash pop to add the debug_dump() statements on top of the working commit  (fingers crossed there are no merge conflicts).\nRun the test example again.\nmv debug_output.cdf debug_before.cdf\nRun the comparison script  julia util/compare_debug_files.jl debug_before.cdf debug_after.cdf\nThe script identifies the first point (by t, istage and label) where any  variable in the two output files has a maximum difference that is larger than some  very tight (1.e-14) absolute and relative tolerances, and reports which  variables were different and their maximum difference.","category":"page"},{"location":"zz_file_io/#file_io","page":"file_io","title":"file_io","text":"","category":"section"},{"location":"zz_file_io/","page":"file_io","title":"file_io","text":"Modules = [moment_kinetics.file_io]","category":"page"},{"location":"zz_file_io/#moment_kinetics.file_io","page":"file_io","title":"moment_kinetics.file_io","text":"\n\n\n\n","category":"module"},{"location":"zz_file_io/#moment_kinetics.file_io.debug_output_counter","page":"file_io","title":"moment_kinetics.file_io.debug_output_counter","text":"Global counter for calls to debug_dump\n\n\n\n\n\n","category":"constant"},{"location":"zz_file_io/#moment_kinetics.file_io.debug_output_file","page":"file_io","title":"moment_kinetics.file_io.debug_output_file","text":"An nc_info instance that may be initialised for writing debug output\n\nThis is a non-const module variable, so does cause type instability, but it is only used for debugging (from debug_dump()) so performance is not critical.\n\n\n\n\n\n","category":"constant"},{"location":"zz_file_io/#moment_kinetics.file_io.ascii_ios","page":"file_io","title":"moment_kinetics.file_io.ascii_ios","text":"structure containing the various input/output streams\n\n\n\n\n\n","category":"type"},{"location":"zz_file_io/#moment_kinetics.file_io.io_dfns_info","page":"file_io","title":"moment_kinetics.file_io.io_dfns_info","text":"structure containing the data/metadata needed for binary file i/o distribution function data only\n\n\n\n\n\n","category":"type"},{"location":"zz_file_io/#moment_kinetics.file_io.io_moments_info","page":"file_io","title":"moment_kinetics.file_io.io_moments_info","text":"structure containing the data/metadata needed for binary file i/o moments & fields only\n\n\n\n\n\n","category":"type"},{"location":"zz_file_io/#moment_kinetics.file_io.add_attribute!-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.add_attribute!","text":"Add an attribute to a file, group or variable\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.add_vspace_coordinates!-NTuple{7, Any}","page":"file_io","title":"moment_kinetics.file_io.add_vspace_coordinates!","text":"Add to coords group in output file information about vspace coordinate grids\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.append_to_dynamic_var-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.append_to_dynamic_var","text":"append_to_dynamic_var(io_var, data, t_idx, parallel_io, coords...)\n\nAppend data to the dynamic variable io_var. The time-index of the data being appended is t_idx. parallel_io indicates whether parallel I/O is being used. coords... is used to get the ranges to write from/to (needed for parallel I/O) - the entries in the coords tuple can be either coordinate instances or integers (for an integer n the range is 1:n).\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.create_dynamic_variable!-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.create_dynamic_variable!","text":"create_dynamic_variable!(file_or_group, name, type, coords::coordinate...;\n                         nspecies=1, description=nothing, units=nothing)\n\nCreate a time-evolving variable in file_or_group named name of type type. coords are the coordinates corresponding to the dimensions of the array, in the order of the array dimensions. The species dimension does not have a coordinate, so the number of species is passed as nspecies. A description and/or units can be added with the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.debug_dump","page":"file_io","title":"moment_kinetics.file_io.debug_dump","text":"debug_dump(ff, dens, upar, ppar, phi, t; istage=0, label=\"\")\ndebug_dump(fvec::scratch_pdf, fields::em_fields_struct, t; istage=0, label=\"\")\n\nDump variables into a NetCDF file for debugging\n\nIntended to be called more frequently than write_data_to_binary(), possibly several times within a timestep, so includes a label argument to identify the call site.\n\nWrites to a file called debug_output.h5 in the current directory.\n\nCan either be called directly with the arrays to be dumped (fist signature), or using scratch_pdf and em_fields_struct structs.\n\nnothing can be passed to any of the positional arguments (if they are unavailable at a certain point in the code, or just not interesting). t=nothing will set t to the value saved in the previous call (or 0.0 on the first call). Passing nothing to the other arguments will set that array to 0.0 for this call (need to write some value so all the arrays have the same length, with an entry for each call to debug_dump()).\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_dfn_variables!-NTuple{12, Any}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_dfn_variables!","text":"define dynamic (time-evolving) distribution function variables for writing to the output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_moment_variables!-Tuple{Any, Any, Any, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_moment_variables!","text":"define dynamic (time-evolving) moment variables for writing to the hdf5 file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_io_coordinate!-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.define_io_coordinate!","text":"define a sub-group for each code coordinate and write to output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_spatial_coordinates!-NTuple{4, Any}","page":"file_io","title":"moment_kinetics.file_io.define_spatial_coordinates!","text":"Define coords group for coordinate information in the output file and write information about spatial coordinate grids\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.finish_file_io-Tuple{Union{Nothing, moment_kinetics.file_io.ascii_ios}, Union{Nothing, Tuple, moment_kinetics.file_io.io_moments_info}, Union{Nothing, Tuple, moment_kinetics.file_io.io_dfns_info}}","page":"file_io","title":"moment_kinetics.file_io.finish_file_io","text":"close all opened output files\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.get_group-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.get_group","text":"Get a (sub-)group from a file or group\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.get_subgroup_keys-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.get_subgroup_keys","text":"Get names of all subgroups\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.get_variable_keys-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.get_variable_keys","text":"Get names of all variables\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.hdf5_get_dynamic_dim_sizes-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.hdf5_get_dynamic_dim_sizes","text":"given a tuple, fixed_coords, containing all dimensions except the time dimension, get the dimension sizes and chunk sizes\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.hdf5_get_fixed_dim_sizes-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.hdf5_get_fixed_dim_sizes","text":"Get sizes of fixed dimensions and chunks (i.e. everything but time) for I/O\n\ncoords should be a tuple whose elements are coordinate structs or integers (e.g. number of species).\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.input_option_error-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.input_option_error","text":"accepts an option name which has been identified as problematic and returns an appropriate error message\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.io_has_parallel-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.io_has_parallel","text":"io_has_parallel(Val(binary_format))\n\nTest if the backend supports parallel I/O.\n\nbinary_format should be one of the values of the binary_format_type enum\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.is_group-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.is_group","text":"Test if a member of a (sub-)group is a group\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.open_ascii_output_file-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.open_ascii_output_file","text":"opens an output file with the requested prefix and extension and returns the corresponding io stream (identifier)\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.open_output_file-NTuple{4, Any}","page":"file_io","title":"moment_kinetics.file_io.open_output_file","text":"Open an output file, selecting the backend based on io_option\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.reopen_dfns_io-Tuple{Any}","page":"file_io","title":"moment_kinetics.file_io.reopen_dfns_io","text":"Reopen an existing distribution-functions output file to append more data\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.reopen_moments_io-Tuple{Any}","page":"file_io","title":"moment_kinetics.file_io.reopen_moments_io","text":"Reopen an existing moments output file to append more data\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.reopen_output_file-Tuple{Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.reopen_output_file","text":"Re-open an existing output file, selecting the backend based on io_option\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.setup_dfns_io-NTuple{23, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_dfns_io","text":"setup file i/o for distribution function variables\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.setup_file_io-NTuple{19, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_file_io","text":"open the necessary output files\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.setup_moments_io-NTuple{17, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_moments_io","text":"setup file i/o for moment variables\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_Dict_to_section-Tuple{Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_Dict_to_section","text":"write_Dict_to_section(section_io, section_dict, parallel_io)\n\nWrite the contents of section_dict into the I/O group section_io.\n\nAny nested Dicts in section_dict are written to subsections.\n\nAll the keys in section_dict (and any nested Dicts) should be Strings.\n\nparallel_io is a Bool indicating whether parallel I/O is being used.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_boundary_distributions!-NTuple{10, Any}","page":"file_io","title":"moment_kinetics.file_io.write_boundary_distributions!","text":"Write the distributions that may be used for boundary conditions to the output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_data_to_ascii-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Union{Nothing, moment_kinetics.file_io.ascii_ios}}","page":"file_io","title":"moment_kinetics.file_io.write_data_to_ascii","text":"\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_dfns_data_to_binary-NTuple{17, Any}","page":"file_io","title":"moment_kinetics.file_io.write_dfns_data_to_binary","text":"write time-dependent distribution function data to the binary output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_f_ascii-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.write_f_ascii","text":"write the function f(z,vpa) at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_fields_ascii-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.write_fields_ascii","text":"write electrostatic potential at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_input!-Tuple{Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_input!","text":"Save info from the dict with input settings to the output file\n\nNote: assumes all keys in input_dict are strings.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_moments_charged_ascii-NTuple{6, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_charged_ascii","text":"write moments of the charged species distribution function f at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_moments_data_to_binary-NTuple{10, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_data_to_binary","text":"write time-dependent moments data to the binary output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_moments_neutral_ascii-NTuple{6, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_neutral_ascii","text":"write moments of the neutral species distribution function f_neutral at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_overview!-NTuple{8, Any}","page":"file_io","title":"moment_kinetics.file_io.write_overview!","text":"write some overview information for the simulation to the binary file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_provenance_tracking_info!-NTuple{6, Any}","page":"file_io","title":"moment_kinetics.file_io.write_provenance_tracking_info!","text":"Write provenance tracking information, to allow runs to be reproduced.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_single_value!-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.write_single_value!","text":"write_single_value!(file_or_group, name, value; description=nothing, units=nothing)\n\nWrite a single variable to a file or group. If a description or units are passed, add as attributes of the variable.\n\n\n\n\n\n","category":"method"},{"location":"zz_post_processing_input/#post_processing_input","page":"post_processing_input","title":"post_processing_input","text":"","category":"section"},{"location":"zz_post_processing_input/","page":"post_processing_input","title":"post_processing_input","text":"Modules = [moment_kinetics.post_processing_input]","category":"page"},{"location":"zz_post_processing_input/#moment_kinetics.post_processing_input","page":"post_processing_input","title":"moment_kinetics.post_processing_input","text":"\n\n\n\n","category":"module"},{"location":"zz_velocity_moments/#velocity_moments","page":"velocity_moments","title":"velocity_moments","text":"","category":"section"},{"location":"zz_velocity_moments/","page":"velocity_moments","title":"velocity_moments","text":"Modules = [moment_kinetics.velocity_moments]","category":"page"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments","page":"velocity_moments","title":"moment_kinetics.velocity_moments","text":"\n\n\n\n","category":"module"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.moments_charged_substruct","page":"velocity_moments","title":"moment_kinetics.velocity_moments.moments_charged_substruct","text":"\n\n\n\n","category":"type"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.moments_neutral_substruct","page":"velocity_moments","title":"moment_kinetics.velocity_moments.moments_neutral_substruct","text":"\n\n\n\n","category":"type"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.calculate_moment_derivatives!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_moment_derivatives!","text":"Pre-calculate spatial derivatives of the moments that will be needed for the time advance\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.calculate_moment_derivatives_neutral!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_moment_derivatives_neutral!","text":"Pre-calculate spatial derivatives of the neutral moments that will be needed for the time advance\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.create_moments_charged-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.create_moments_charged","text":"\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.get_pressure-Tuple{Float64, Float64}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.get_pressure","text":"compute the isotropic pressure from the already computed ppar and pperp\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.integrate_over_negative_vpa-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_negative_vpa","text":"computes the integral over vpa <= 0 of the integrand, using the input vpa_wgts this could be made more efficient for the case that dz/dt = vpa is time-independent, but it has been left general for the cases where, e.g., dz/dt = wpa*vth + upar varies in time\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.integrate_over_positive_vpa-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_positive_vpa","text":"computes the integral over vpa >= 0 of the integrand, using the input vpa_wgts this could be made more efficient for the case that dz/dt = vpa is time-independent, but it has been left general for the cases where, e.g., dz/dt = wpa*vth + upar varies in time\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.integrate_over_vspace-Tuple","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_vspace","text":"computes the integral over vpa of the integrand, using the input vpa_wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.reset_moments_status!-Tuple{Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.reset_moments_status!","text":"\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_chodura_integral_species!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_chodura_integral_species!","text":"compute the integral needed for the generalised Chodura condition\n\nIChodura = (Z^2 vBohm^2 / cref^2) * int ( f bz^2 / vz^2 + dfdr*rhostar/vz )  vBohm = sqrt(Z Te/mi)  with Z = 1 and mref = mi  cref = sqrt(2Ti/mi) and normalise to the local ion density, appropriate to assessing the  Chodura condition \n\nIChodura <= (Te/e)d ne / dphi |(sheath entrance) = ni\n\nto a single species plasma with Z = 1\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_density!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_density!","text":"NB: if this function is called and if dens_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_density_species!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_density_species!","text":"calculate the updated density (dens) for a given species; should only be called when evolvedensity = false, in which case the vpa coordinate is vpa/cs\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_moments!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_moments!","text":"calculate the updated density (dens) and parallel pressure (ppar) for all species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_moments_neutral!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_moments_neutral!","text":"update velocity moments of the evolved neutral pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_density!-NTuple{9, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_density!","text":"calculate the neutral density from the neutral pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_density_species!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_density_species!","text":"calculate the updated density (dens) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_pr_species!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_pr_species!","text":"calculate the updated pressure in the rr direction (pr) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_pz_species!-NTuple{11, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_pz_species!","text":"calculate the updated pressure in zz direction (pz) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_pzeta_species!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_pzeta_species!","text":"calculate the updated pressure in the zeta zeta direction (pzeta) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_qz_species!-NTuple{13, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_qz_species!","text":"calculate the updated heat flux zzz direction (qz) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_ur_species!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_ur_species!","text":"calculate the updated ur (mean velocity in r) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_uz_species!-NTuple{11, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_uz_species!","text":"calculate the updated uz (mean velocity in z) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_uzeta_species!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_uzeta_species!","text":"calculate the updated uzeta (mean velocity in zeta) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_ppar!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_ppar!","text":"NB: if this function is called and if ppar_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_ppar_species!-NTuple{10, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_ppar_species!","text":"calculate the updated energy density (or parallel pressure, ppar) for a given species; which of these is calculated depends on the definition of the vpa coordinate\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_pperp_species!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_pperp_species!","text":"calculate the updated perpendicular pressure (pperp) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_qpar!-NTuple{14, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_qpar!","text":"NB: the incoming pdf is the normalized pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_qpar_species!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_qpar_species!","text":"calculate the updated parallel heat flux (qpar) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_upar!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_upar!","text":"NB: if this function is called and if upar_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_upar_species!-NTuple{10, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_upar_species!","text":"calculate the updated parallel flow (upar) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#coordinates","page":"coordinates","title":"coordinates","text":"","category":"section"},{"location":"zz_coordinates/","page":"coordinates","title":"coordinates","text":"Modules = [moment_kinetics.coordinates]","category":"page"},{"location":"zz_coordinates/#moment_kinetics.coordinates","page":"coordinates","title":"moment_kinetics.coordinates","text":"\n\n\n\n","category":"module"},{"location":"zz_coordinates/#moment_kinetics.coordinates.coordinate","page":"coordinates","title":"moment_kinetics.coordinates.coordinate","text":"structure containing basic information related to coordinates\n\n\n\n\n\n","category":"type"},{"location":"zz_coordinates/#moment_kinetics.coordinates.define_coordinate","page":"coordinates","title":"moment_kinetics.coordinates.define_coordinate","text":"create arrays associated with a given coordinate, setup the coordinate grid, and populate the coordinate structure containing all of this information\n\n\n\n\n\n","category":"function"},{"location":"zz_coordinates/#moment_kinetics.coordinates.elemental_to_full_grid_map-Tuple{Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.elemental_to_full_grid_map","text":"returns imin and imax, which contain the minimum and maximum indices on the full grid for each element\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.equally_spaced_grid-NTuple{4, Any}","page":"coordinates","title":"moment_kinetics.coordinates.equally_spaced_grid","text":"setup an equally spaced grid with n_global grid points between [-L/2,L/2]\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.equally_spaced_grid_shifted-NTuple{4, Any}","page":"coordinates","title":"moment_kinetics.coordinates.equally_spaced_grid_shifted","text":"setup an equally spaced grid with n_global grid points between [0,L]\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.full_to_elemental_grid_map-Tuple{Any, Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.full_to_elemental_grid_map","text":"setup arrays containing a map from the unpacked grid point indices to the element index and the grid point index within each element\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.grid_spacing-Tuple{Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.grid_spacing","text":"given a set of grid point locations calculate and return the length associated with the cell between adjacent grid points\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.init_grid-NTuple{13, Any}","page":"coordinates","title":"moment_kinetics.coordinates.init_grid","text":"setup a grid with n_global grid points on the interval [-L/2,L/2]\n\n\n\n\n\n","category":"method"},{"location":"zz_type_definitions/#type_definitions","page":"type_definitions","title":"type_definitions","text":"","category":"section"},{"location":"zz_type_definitions/","page":"type_definitions","title":"type_definitions","text":"Modules = [moment_kinetics.type_definitions]","category":"page"},{"location":"zz_type_definitions/#moment_kinetics.type_definitions","page":"type_definitions","title":"moment_kinetics.type_definitions","text":"\n\n\n\n","category":"module"},{"location":"zz_type_definitions/#moment_kinetics.type_definitions.mk_float","page":"type_definitions","title":"moment_kinetics.type_definitions.mk_float","text":"\n\n\n\n","category":"type"},{"location":"zz_type_definitions/#moment_kinetics.type_definitions.mk_int","page":"type_definitions","title":"moment_kinetics.type_definitions.mk_int","text":"\n\n\n\n","category":"type"},{"location":"zz_communication/#communication","page":"communication","title":"communication","text":"","category":"section"},{"location":"zz_communication/","page":"communication","title":"communication","text":"Modules = [moment_kinetics.communication]","category":"page"},{"location":"zz_communication/#moment_kinetics.communication","page":"communication","title":"moment_kinetics.communication","text":"Communication functions and setup\n\nSplit the grid into 'blocks'. Each block can use shared memory (MPI shared memory arrays). At the moment only works with a single 'block' containing the whole grid - eventually add more MPI communication functions to communicate between blocks. A block should probably be a 'NUMA region' for maximum efficiency.\n\nNote: charge-exchange collisions loop over neutral species for each ion species. At the moment this loop is not parallelised (although it could be, by introducing some more loop ranges), as at the moment we only run with 1 ion species and 1 neutral species.\n\n\n\n\n\n","category":"module"},{"location":"zz_communication/#moment_kinetics.communication.block_rank","page":"communication","title":"moment_kinetics.communication.block_rank","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.block_size","page":"communication","title":"moment_kinetics.communication.block_size","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.comm_block","page":"communication","title":"moment_kinetics.communication.comm_block","text":"Communicator connecting a shared-memory region\n\nMust use a Ref{MPI.Comm} to allow a non-const MPI.Comm to be stored. Need to actually assign to this and not just copy a pointer into the .val member because otherwise the MPI.Comm object created by MPI.Comm_split() would be deleted, which probably makes MPI.jl delete the communicator.\n\n\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.comm_inter_block","page":"communication","title":"moment_kinetics.communication.comm_inter_block","text":"Communicator connecting the root processes of each shared memory block\n\nMust use a Ref{MPI.Comm} to allow a non-const MPI.Comm to be stored. Need to actually assign to this and not just copy a pointer into the .val member because otherwise the MPI.Comm object created by MPI.Comm_split() would be deleted, which probably makes MPI.jl delete the communicator.\n\n\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.comm_world","page":"communication","title":"moment_kinetics.communication.comm_world","text":"Can use a const MPI.Comm for comm_world and just copy the pointer from MPI.COMM_WORLD because MPI.COMM_WORLD is never deleted, so pointer stays valid.\n\n\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.global_Win_store","page":"communication","title":"moment_kinetics.communication.global_Win_store","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.global_rank","page":"communication","title":"moment_kinetics.communication.global_rank","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.global_size","page":"communication","title":"moment_kinetics.communication.global_size","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.iblock_index","page":"communication","title":"moment_kinetics.communication.iblock_index","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.n_blocks","page":"communication","title":"moment_kinetics.communication.n_blocks","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.MPISharedArray","page":"communication","title":"moment_kinetics.communication.MPISharedArray","text":"\n\n\n\n","category":"type"},{"location":"zz_communication/#moment_kinetics.communication.__init__-Tuple{}","page":"communication","title":"moment_kinetics.communication.__init__","text":"\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication._block_synchronize-Tuple{}","page":"communication","title":"moment_kinetics.communication._block_synchronize","text":"Call an MPI Barrier for all processors in a block.\n\nUsed to synchronise processors that are working on the same shared-memory array(s) between operations, to avoid race conditions. Should be (much) cheaper than a global MPI Barrier because it only requires communication within a single node.\n\nNote: some debugging code currently assumes that if blocksynchronize() is called on one block, it is called simultaneously on all blocks. It seems likely that this will always be true, but if it ever changes (i.e. different blocks doing totally different work), the debugging routines need to be updated.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.allocate_shared-Tuple{Any, Any}","page":"communication","title":"moment_kinetics.communication.allocate_shared","text":"Get a shared-memory array of mk_float (shared by all processes in a 'block')\n\nCreate a shared-memory array using MPI.Win_allocate_shared(). Pointer to the memory allocated is wrapped in a Julia array. Memory is not managed by the Julia array though. A reference to the MPI.Win needs to be freed - this is done by saving the MPI.Win into a Vector in the Communication module, which has all its entries freed by the finalize_comms!() function, which should be called when moment_kinetics is done running a simulation/test.\n\nArguments\n\ndims - mkint or Tuple{mkint}     Dimensions of the array to be created. Dimensions passed define the size of the     array which is being handled by the 'block' (rather than the global array, or a     subset for a single process).\n\nReturns\n\nArray{mk_float}\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.finalize_comms!-Tuple{}","page":"communication","title":"moment_kinetics.communication.finalize_comms!","text":"Clean up from communications\n\nDo any needed clean-up for MPI, etc. Does not call MPI.Finalize() - this is called anyway when Julia exits, and we do not want to call it explicitly so that multiple runs can be done in a single Julia session.\n\nFrees any shared-memory arrays.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.free_shared_arrays-Tuple{}","page":"communication","title":"moment_kinetics.communication.free_shared_arrays","text":"\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.initialize_comms!-Tuple{}","page":"communication","title":"moment_kinetics.communication.initialize_comms!","text":"Set up communications\n\nCheck that global variables are in the correct state (i.e. caches were emptied correctly if they were used before).\n\nAlso does some set up for debugging routines, if they are active.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.setup_distributed_memory_MPI-NTuple{4, Any}","page":"communication","title":"moment_kinetics.communication.setup_distributed_memory_MPI","text":"Function to take information from user about r z grids and  number of processes allocated to set up communicators notation definitions:     - block: group of processes that share data with shared memory     - z group: group of processes that need to communicate data for z derivatives     - r group: group of processes that need to communicate data for r derivatives\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#looping","page":"looping","title":"looping","text":"","category":"section"},{"location":"zz_looping/","page":"looping","title":"looping","text":"Modules = [moment_kinetics.looping]","category":"page"},{"location":"zz_looping/#moment_kinetics.looping","page":"looping","title":"moment_kinetics.looping","text":"Provides convenience macros for shared-memory-parallel loops\n\n\n\n\n\n","category":"module"},{"location":"zz_looping/#moment_kinetics.looping.loop_ranges","page":"looping","title":"moment_kinetics.looping.loop_ranges","text":"module variable that we can access by giving fully-qualified name in loop macros\n\n\n\n\n\n","category":"constant"},{"location":"zz_looping/#moment_kinetics.looping.loop_ranges_store","page":"looping","title":"moment_kinetics.looping.loop_ranges_store","text":"module variable used to store LoopRanges that are swapped into the loopranges variable in begin*_region() functions\n\n\n\n\n\n","category":"constant"},{"location":"zz_looping/#moment_kinetics.looping.LoopRanges","page":"looping","title":"moment_kinetics.looping.LoopRanges","text":"LoopRanges structs contain information on which points should be included on this process in loops over shared-memory arrays.\n\nMembers\n\nparalleldims::Tuple{Vararg{Symbol}}        Indicates which dimensions are (or might be) parallelized when using        this LoopRanges. Provided for information for developers, to make it        easier to tell (when using a Debugger, or printing debug informatino)        which LoopRanges instance is active in looping.loopranges at any point        in the code. rank0::Bool        Is this process the one with rank 0 in the 'block' which work in        parallel on shared memory arrays. <d>::UnitRange{mkint}        Loop ranges for each dimension <d> in looping.alldimensions.\n\n\n\n\n\n","category":"type"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_region","text":"Begin region in which (:r,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vpa_region","text":"Begin region in which (:r, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vperp_region","text":"Begin region in which (:r, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vperp_vpa_region","text":"Begin region in which (:r, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vr_region","text":"Begin region in which (:r, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vr_vz_region","text":"Begin region in which (:r, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vz_region","text":"Begin region in which (:r, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vzeta_region","text":"Begin region in which (:r, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vzeta_vr_region","text":"Begin region in which (:r, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vzeta_vr_vz_region","text":"Begin region in which (:r, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vzeta_vz_region","text":"Begin region in which (:r, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_region","text":"Begin region in which (:r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vpa_region","text":"Begin region in which (:r, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vperp_region","text":"Begin region in which (:r, :z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vperp_vpa_region","text":"Begin region in which (:r, :z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vr_region","text":"Begin region in which (:r, :z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vr_vz_region","text":"Begin region in which (:r, :z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vz_region","text":"Begin region in which (:r, :z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vzeta_region","text":"Begin region in which (:r, :z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vzeta_vr_region","text":"Begin region in which (:r, :z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vzeta_vr_vz_region","text":"Begin region in which (:r, :z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vzeta_vz_region","text":"Begin region in which (:r, :z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_region","text":"Begin region in which (:s, :r) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_vpa_region","text":"Begin region in which (:s, :r, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_vperp_region","text":"Begin region in which (:s, :r, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_vperp_vpa_region","text":"Begin region in which (:s, :r, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_region","text":"Begin region in which (:s, :r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_vpa_region","text":"Begin region in which (:s, :r, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_z_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_vperp_region","text":"Begin region in which (:s, :r, :z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_z_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_vperp_vpa_region","text":"Begin region in which (:s, :r, :z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_region","text":"Begin region in which (:s,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_vpa_region","text":"Begin region in which (:s, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_vperp_region","text":"Begin region in which (:s, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_vperp_vpa_region","text":"Begin region in which (:s, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_region","text":"Begin region in which (:s, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_vpa_region","text":"Begin region in which (:s, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_z_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_vperp_region","text":"Begin region in which (:s, :z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_z_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_vperp_vpa_region","text":"Begin region in which (:s, :z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_serial_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_serial_region","text":"Begin region in which only rank-0 in each group of processes operating on a shared-memory block operates on shared-memory arrays.\n\nReturns immediately if loopranges[] is already set for a serial region. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_region","text":"Begin region in which (:sn, :r) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vr_region","text":"Begin region in which (:sn, :r, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vr_vz_region","text":"Begin region in which (:sn, :r, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vz_region","text":"Begin region in which (:sn, :r, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vzeta_region","text":"Begin region in which (:sn, :r, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vzeta_vr_region","text":"Begin region in which (:sn, :r, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vzeta_vr_vz_region","text":"Begin region in which (:sn, :r, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vzeta_vz_region","text":"Begin region in which (:sn, :r, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_region","text":"Begin region in which (:sn, :r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vr_region","text":"Begin region in which (:sn, :r, :z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vr_vz_region","text":"Begin region in which (:sn, :r, :z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vz_region","text":"Begin region in which (:sn, :r, :z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vzeta_region","text":"Begin region in which (:sn, :r, :z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vzeta_vr_region","text":"Begin region in which (:sn, :r, :z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vzeta_vr_vz_region","text":"Begin region in which (:sn, :r, :z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vzeta_vz_region","text":"Begin region in which (:sn, :r, :z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_region","text":"Begin region in which (:sn,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vr_region","text":"Begin region in which (:sn, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vr_vz_region","text":"Begin region in which (:sn, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vz_region","text":"Begin region in which (:sn, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vzeta_region","text":"Begin region in which (:sn, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vzeta_vr_region","text":"Begin region in which (:sn, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vzeta_vr_vz_region","text":"Begin region in which (:sn, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vzeta_vz_region","text":"Begin region in which (:sn, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_region","text":"Begin region in which (:sn, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vr_region","text":"Begin region in which (:sn, :z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vr_vz_region","text":"Begin region in which (:sn, :z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vz_region","text":"Begin region in which (:sn, :z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vzeta_region","text":"Begin region in which (:sn, :z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vzeta_vr_region","text":"Begin region in which (:sn, :z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vzeta_vr_vz_region","text":"Begin region in which (:sn, :z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vzeta_vz_region","text":"Begin region in which (:sn, :z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vpa_region","text":"Begin region in which (:vpa,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vperp_region","text":"Begin region in which (:vperp,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vperp_vpa_region","text":"Begin region in which (:vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vr_region","text":"Begin region in which (:vr,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vr_vz_region","text":"Begin region in which (:vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vz_region","text":"Begin region in which (:vz,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vzeta_region","text":"Begin region in which (:vzeta,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vzeta_vr_region","text":"Begin region in which (:vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vzeta_vr_vz_region","text":"Begin region in which (:vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vzeta_vz_region","text":"Begin region in which (:vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_region","text":"Begin region in which (:z,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vpa_region","text":"Begin region in which (:z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vperp_region","text":"Begin region in which (:z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vperp_vpa_region","text":"Begin region in which (:z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vr_region","text":"Begin region in which (:z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vr_vz_region","text":"Begin region in which (:z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vz_region","text":"Begin region in which (:z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vzeta_region","text":"Begin region in which (:z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vzeta_vr_region","text":"Begin region in which (:z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vzeta_vr_vz_region","text":"Begin region in which (:z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vzeta_vz_region","text":"Begin region in which (:z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.debug_setup_loop_ranges_split_one_combination!-Tuple{Any, Any, Tuple{Vararg{Symbol, N}} where N, Vararg{Symbol}}","page":"looping","title":"moment_kinetics.looping.debug_setup_loop_ranges_split_one_combination!","text":"For debugging the shared-memory parallelism, create ranges where only the loops for a single combinations of variables (given by combination_to_split) are parallelised, and which dimensions are parallelised can be set with the dims_to_split... arguments.\n\nArguments\n\nKeyword arguments dim=n are required for each dim in all_dimensions where n is an integer giving the size of the dimension.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.dims_string-Tuple{Tuple}","page":"looping","title":"moment_kinetics.looping.dims_string","text":"Construct a string composed of the dimension names given in the Tuple dims, separated by underscores\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_best_ranges-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.get_best_ranges","text":"Find the ranges for loop variables that optimize load balance for a certain block_size\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_best_ranges_from_sizes-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.get_best_ranges_from_sizes","text":"\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_load_balance-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_load_balance","text":"Calculate the expected load balance\n\n'Load balance' is the ratio of the maximum and minimum numbers of points on any process.\n\nArguments\n\nnprocslist : Vector{mkint}     Number of processes for each dimension sizes : Vector{mk_int}     Size of each dimension\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_local_range-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.get_local_range","text":"Get local range of indices when splitting a loop over processes in a sub-block\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_splits-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_splits","text":"Find possible divisions of subblocksize into n factors\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.setup_loop_ranges!-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.setup_loop_ranges!","text":"Create ranges for loops with different combinations of variables\n\nArguments\n\nKeyword arguments dim=n are required for each dim in [:s, :r, :z, :vperp, :vpa, :sn, :vzeta, :vr, :vz] where n is an integer giving the size of the dimension.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r","text":"Loop over (:r,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vpa","text":"Loop over (:r, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vperp-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vperp","text":"Loop over (:r, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vperp_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vperp_vpa","text":"Loop over (:r, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vr","text":"Loop over (:r, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vr_vz","text":"Loop over (:r, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vz","text":"Loop over (:r, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vzeta-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta","text":"Loop over (:r, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vzeta_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta_vr","text":"Loop over (:r, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vzeta_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta_vr_vz","text":"Loop over (:r, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vzeta_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta_vz","text":"Loop over (:r, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z","text":"Loop over (:r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vpa","text":"Loop over (:r, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vperp-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vperp","text":"Loop over (:r, :z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vperp_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vperp_vpa","text":"Loop over (:r, :z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vr","text":"Loop over (:r, :z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vr_vz","text":"Loop over (:r, :z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vz","text":"Loop over (:r, :z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vzeta-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta","text":"Loop over (:r, :z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vzeta_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta_vr","text":"Loop over (:r, :z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vzeta_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta_vr_vz","text":"Loop over (:r, :z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vzeta_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta_vz","text":"Loop over (:r, :z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s","text":"Loop over (:s,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r","text":"Loop over (:s, :r) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vpa","text":"Loop over (:s, :r, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_vperp-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vperp","text":"Loop over (:s, :r, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_vperp_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vperp_vpa","text":"Loop over (:s, :r, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_z-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z","text":"Loop over (:s, :r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_z_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vpa","text":"Loop over (:s, :r, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_z_vperp-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vperp","text":"Loop over (:s, :r, :z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_z_vperp_vpa-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vperp_vpa","text":"Loop over (:s, :r, :z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vpa","text":"Loop over (:s, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_vperp-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vperp","text":"Loop over (:s, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_vperp_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vperp_vpa","text":"Loop over (:s, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z","text":"Loop over (:s, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_z_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vpa","text":"Loop over (:s, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_z_vperp-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vperp","text":"Loop over (:s, :z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_z_vperp_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vperp_vpa","text":"Loop over (:s, :z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn","text":"Loop over (:sn,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r","text":"Loop over (:sn, :r) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vr","text":"Loop over (:sn, :r, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vr_vz","text":"Loop over (:sn, :r, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vz","text":"Loop over (:sn, :r, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vzeta-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta","text":"Loop over (:sn, :r, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vzeta_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta_vr","text":"Loop over (:sn, :r, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vzeta_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta_vr_vz","text":"Loop over (:sn, :r, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vzeta_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta_vz","text":"Loop over (:sn, :r, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z","text":"Loop over (:sn, :r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vr","text":"Loop over (:sn, :r, :z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vr_vz","text":"Loop over (:sn, :r, :z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vz","text":"Loop over (:sn, :r, :z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta","text":"Loop over (:sn, :r, :z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta_vr-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta_vr","text":"Loop over (:sn, :r, :z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta_vr_vz-NTuple{7, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta_vr_vz","text":"Loop over (:sn, :r, :z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta_vz","text":"Loop over (:sn, :r, :z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vr","text":"Loop over (:sn, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vr_vz","text":"Loop over (:sn, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vz","text":"Loop over (:sn, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vzeta-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta","text":"Loop over (:sn, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vzeta_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta_vr","text":"Loop over (:sn, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vzeta_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta_vr_vz","text":"Loop over (:sn, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vzeta_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta_vz","text":"Loop over (:sn, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z","text":"Loop over (:sn, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vr","text":"Loop over (:sn, :z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vr_vz","text":"Loop over (:sn, :z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vz","text":"Loop over (:sn, :z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vzeta-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta","text":"Loop over (:sn, :z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vzeta_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta_vr","text":"Loop over (:sn, :z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vzeta_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta_vr_vz","text":"Loop over (:sn, :z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vzeta_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta_vz","text":"Loop over (:sn, :z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vpa-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vpa","text":"Loop over (:vpa,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vperp-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vperp","text":"Loop over (:vperp,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vperp_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vperp_vpa","text":"Loop over (:vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vr-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vr","text":"Loop over (:vr,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vr_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vr_vz","text":"Loop over (:vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vz-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vz","text":"Loop over (:vz,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vzeta-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta","text":"Loop over (:vzeta,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vzeta_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta_vr","text":"Loop over (:vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vzeta_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta_vr_vz","text":"Loop over (:vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vzeta_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta_vz","text":"Loop over (:vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z","text":"Loop over (:z,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vpa","text":"Loop over (:z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vperp-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vperp","text":"Loop over (:z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vperp_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vperp_vpa","text":"Loop over (:z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vr","text":"Loop over (:z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vr_vz","text":"Loop over (:z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vz","text":"Loop over (:z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vzeta-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta","text":"Loop over (:z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vzeta_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta_vr","text":"Loop over (:z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vzeta_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta_vr_vz","text":"Loop over (:z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vzeta_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta_vz","text":"Loop over (:z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@serial_region-Tuple{Any}","page":"looping","title":"moment_kinetics.looping.@serial_region","text":"Run a block of code on only rank-0 of each group of processes operating on a shared-memory block\n\n\n\n\n\n","category":"macro"},{"location":"zz_bgk/#bgk","page":"bgk","title":"bgk","text":"","category":"section"},{"location":"zz_bgk/","page":"bgk","title":"bgk","text":"Modules = [moment_kinetics.bgk]","category":"page"},{"location":"zz_bgk/#moment_kinetics.bgk","page":"bgk","title":"moment_kinetics.bgk","text":"\n\n\n\n","category":"module"},{"location":"zz_bgk/#moment_kinetics.bgk.allowed_wave_amplitude!-NTuple{5, Any}","page":"bgk","title":"moment_kinetics.bgk.allowed_wave_amplitude!","text":"\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.init_bgk_pdf!-NTuple{6, Any}","page":"bgk","title":"moment_kinetics.bgk.init_bgk_pdf!","text":"\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.passing_pdf!-NTuple{5, Any}","page":"bgk","title":"moment_kinetics.bgk.passing_pdf!","text":"inputs\n\npdf is the particle distribution function, with the passing part of phase space not filled in\nphi_max is the maximum value that e * phi / Te takes\ntau = Ti/Te is the ion-electron temperature ratio\nx = mvpa^2/2Te + ephi/Te is 1D array containing the total parallel energy (conserved)\n\noutput\n\npdf = particle distribution function; this function fills in the part of phase space where x > e*phi_max/T\n\n\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.setup_dummy_integrals-Tuple{}","page":"bgk","title":"moment_kinetics.bgk.setup_dummy_integrals","text":"\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.total_energy_grid-Tuple{Any, Any}","page":"bgk","title":"moment_kinetics.bgk.total_energy_grid","text":"inputs:\n\nvpa = parallel velocity normalized by vts = sqrt(2*Te/ms)\nphi = electrostatic potential normalized by Te/e\n\noutput: x = vpa^2 + phi is the total parallel energy\n\n\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.trapped_passing_boundary-Tuple{Any, Any}","page":"bgk","title":"moment_kinetics.bgk.trapped_passing_boundary","text":"\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.trapped_pdf!-NTuple{8, Any}","page":"bgk","title":"moment_kinetics.bgk.trapped_pdf!","text":"inputs\n\nphi_max is the maximum value that e * phi / Te takes\ntau = Ti/Te is the ion-electron temperature ratio\nx = vpa^2 + e*phi is a 2D array containing the total parallel energy on the (z,vpa) grid\ny = dummy coordinate for the necessary integrals in the function\nintegrand = dummy array used to hold integrands defined and integrated in this function\nwgts = integration weights associated with y integrals\n\noutput\n\npdf is the particle distribution function for all of phase space, with this function filling in only the part with x < e*phi_max/T\n\n\n\n\n\n","category":"method"},{"location":"zz_continuity/#continuity","page":"continuity","title":"continuity","text":"","category":"section"},{"location":"zz_continuity/","page":"continuity","title":"continuity","text":"Modules = [moment_kinetics.continuity]","category":"page"},{"location":"zz_continuity/#moment_kinetics.continuity","page":"continuity","title":"moment_kinetics.continuity","text":"\n\n\n\n","category":"module"},{"location":"zz_continuity/#moment_kinetics.continuity.continuity_equation!-NTuple{9, Any}","page":"continuity","title":"moment_kinetics.continuity.continuity_equation!","text":"use the continuity equation dn/dt + d(n*upar)/dz to update the density n for all charged species\n\n\n\n\n\n","category":"method"},{"location":"zz_continuity/#moment_kinetics.continuity.neutral_continuity_equation!-NTuple{9, Any}","page":"continuity","title":"moment_kinetics.continuity.neutral_continuity_equation!","text":"use the continuity equation dn/dt + d(n*upar)/dz to update the density n for all neutral species\n\n\n\n\n\n","category":"method"},{"location":"zz_debugging/#debugging","page":"debugging","title":"debugging","text":"","category":"section"},{"location":"zz_debugging/","page":"debugging","title":"debugging","text":"Modules = [moment_kinetics.debugging]","category":"page"},{"location":"zz_debugging/#moment_kinetics.debugging","page":"debugging","title":"moment_kinetics.debugging","text":"Define debugging levels that can be used to include extra debugging steps\n\nProvides a bunch of macros (see the macronames Vector) that can be used to surround code in other modules so that it only runs if the 'debug level' passed to the --debug or -d command line argument is high enough.\n\nAlso provides macro *_ifelse whose names are taken from macronames, which can be used to switch definitions, etc. For example, if debug_shared_array is in macronames, then\n\nconst MPISharedArray = @debug_shared_array_ifelse(DebugMPISharedArray, Array)\n\ncan be used to make the type represented by MPISharedArray depend on the debug level.\n\n\n\n\n\n","category":"module"},{"location":"zz_debugging/#moment_kinetics.debugging._debug_level","page":"debugging","title":"moment_kinetics.debugging._debug_level","text":"\n\n\n\n","category":"constant"},{"location":"zz_debugging/#moment_kinetics.debugging.macronames","page":"debugging","title":"moment_kinetics.debugging.macronames","text":"\n\n\n\n","category":"constant"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_block_synchronize-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_block_synchronize","text":"Check blocksynchronize() was called from the same place on every process.  Activated at _debug_level >= 4  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_block_synchronize_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_block_synchronize_ifelse","text":"Evaluate first expression if debugblocksynchronize is active, second expression if not  debugblocksynchronize is inactive (_debug_level = 0 < 4).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_detect_redundant_block_synchronize-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_detect_redundant_block_synchronize","text":"Check if any blocksynchronize() call could have been skipped without resulting in an error.  Activated at _debug_level >= 5  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_detect_redundant_block_synchronize_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_detect_redundant_block_synchronize_ifelse","text":"Evaluate first expression if debugdetectredundantblocksynchronize is active, second expression if not  debugdetectredundantblocksynchronize is inactive (_debug_level = 0 < 5).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_error_stop_all-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_error_stop_all","text":"Use MPI.Allgather to stop all processes following an error on any process.  Activated at _debug_level >= 1  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_error_stop_all_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_error_stop_all_ifelse","text":"Evaluate first expression if debugerrorstopall is active, second expression if not  debugerrorstopall is inactive (_debug_level = 0 < 1).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_initialize_NaN-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_initialize_NaN","text":"Initialize arrays with NaN.  Activated at _debug_level >= 1  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_initialize_NaN_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_initialize_NaN_ifelse","text":"Evaluate first expression if debuginitializeNaN is active, second expression if not  debuginitializeNaN is inactive (_debug_level = 0 < 1).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_shared_array-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array","text":"Check for incorrect reads/writes to shared-memory arrays  Activated at _debug_level >= 2  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_shared_array_allocate-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_allocate","text":"Check that allocateshared() was called from the same place on every process.  Activated at `debuglevel >= 4Currently inactive (debug_level = 0`).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_shared_array_allocate_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_allocate_ifelse","text":"Evaluate first expression if debugsharedarrayallocate is active, second expression if not  debugsharedarrayallocate is inactive (_debug_level = 0 < 4).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_shared_array_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_ifelse","text":"Evaluate first expression if debugsharedarray is active, second expression if not  debugsharedarray is inactive (_debug_level = 0 < 2).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_track_array_allocate_location-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_array_allocate_location","text":"Record where every array was allocated.  Activated at _debug_level >= 3  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_track_array_allocate_location_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_array_allocate_location_ifelse","text":"Evaluate first expression if debugtrackarrayallocatelocation is active, second expression if not  debugtrackarrayallocatelocation is inactive (_debug_level = 0 < 3).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_track_initialized-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_initialized","text":"Check that every array is initialized before being used.  Activated at _debug_level >= 3  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_track_initialized_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_initialized_ifelse","text":"Evaluate first expression if debugtrackinitialized is active, second expression if not  debugtrackinitialized is inactive (_debug_level = 0 < 3).\n\n\n\n\n\n","category":"macro"},{"location":"zz_time_advance/#time_advance","page":"time_advance","title":"time_advance","text":"","category":"section"},{"location":"zz_time_advance/","page":"time_advance","title":"time_advance","text":"Modules = [moment_kinetics.time_advance]","category":"page"},{"location":"zz_time_advance/#moment_kinetics.time_advance","page":"time_advance","title":"moment_kinetics.time_advance","text":"\n\n\n\n","category":"module"},{"location":"zz_time_advance/#moment_kinetics.time_advance.euler_time_advance!-NTuple{26, Any}","page":"time_advance","title":"moment_kinetics.time_advance.euler_time_advance!","text":"eulertimeadvance! advances the vector equation dfvec/dt = G[f] that includes the kinetic equation + any evolved moment equations using the forward Euler method: fvecout = fvecin + dt*fvecin, with fvecin an input and fvec_out the output\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.normalize_pdf!-Tuple{Any, Any, Any}","page":"time_advance","title":"moment_kinetics.time_advance.normalize_pdf!","text":"if evolving the density via continuity equation, redefine the normalised f → f/n if evolving the parallel pressure via energy equation, redefine f -> f * vth / n 'scratch' should be a (nz,nspecies) array\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.rk_update!-NTuple{22, Any}","page":"time_advance","title":"moment_kinetics.time_advance.rk_update!","text":"use information obtained from the Runge-Kutta stages to compute the updated pdf; for the quantities (density, upar, ppar, vth, qpar and phi) that are derived from the 'true', un-modified pdf, either: update them using info from Runge Kutta stages, if the quantities are evolved separately from the modified pdf; or update them by taking the appropriate velocity moment of the evolved pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.rk_update_evolved_moments!-NTuple{4, Any}","page":"time_advance","title":"moment_kinetics.time_advance.rk_update_evolved_moments!","text":"use Runge Kutta to update any charged-particle velocity moments evolved separately from the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.rk_update_evolved_moments_neutral!-NTuple{4, Any}","page":"time_advance","title":"moment_kinetics.time_advance.rk_update_evolved_moments_neutral!","text":"use Runge Kutta to update any neutral-particle velocity moments evolved separately from the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.setup_advance_flags-NTuple{14, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_advance_flags","text":"create the 'advance_info' struct to be used in later Euler advance to indicate which parts of the equations are to be advanced concurrently. if no splitting of operators, all terms advanced concurrently; else, will advance one term at a time.\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.setup_runge_kutta_coefficients-Tuple{Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_runge_kutta_coefficients","text":"given the number of Runge Kutta stages that are requested, returns the needed Runge Kutta coefficients; e.g., if f is the function to be updated, then f^{n+1}[stage+1] = rkcoef[1,stage]*f^{n} + rkcoef[2,stage]f^{n+1}[stage] + rk_coef[3,stage](f^{n}+dt*G[f^{n+1}[stage]]\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.setup_scratch_arrays-NTuple{4, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_scratch_arrays","text":"create an array of structs containing scratch arrays for the normalised pdf and low-order moments that may be evolved separately via fluid equations\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.setup_time_advance!-NTuple{27, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_time_advance!","text":"create arrays and do other work needed to setup the main time advance loop. this includes creating and populating structs for Chebyshev transforms, velocity space moments, EM fields, and advection terms\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.ssp_rk!-NTuple{26, Any}","page":"time_advance","title":"moment_kinetics.time_advance.ssp_rk!","text":"\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.time_advance!-NTuple{28, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance!","text":"solve ∂f/∂t + v(z,t)⋅∂f/∂z + dvpa/dt ⋅ ∂f/∂vpa= 0 define approximate characteristic velocity v₀(z)=vⁿ(z) and take time derivative along this characteristic df/dt + δv⋅∂f/∂z = 0, with δv(z,t)=v(z,t)-v₀(z) for prudent choice of v₀, expect δv≪v so that explicit time integrator can be used without severe CFL condition\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.time_advance_no_splitting!-NTuple{26, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance_no_splitting!","text":"\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.time_advance_split_operators!-NTuple{18, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance_split_operators!","text":"\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.update_derived_moments!-NTuple{7, Any}","page":"time_advance","title":"moment_kinetics.time_advance.update_derived_moments!","text":"update velocity moments that are calculable from the evolved charged pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.update_derived_moments_neutral!-NTuple{8, Any}","page":"time_advance","title":"moment_kinetics.time_advance.update_derived_moments_neutral!","text":"update velocity moments that are calculable from the evolved neutral pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.update_solution_vector!-NTuple{8, Any}","page":"time_advance","title":"moment_kinetics.time_advance.update_solution_vector!","text":"update the vector containing the pdf and any evolved moments of the pdf for use in the Runge-Kutta time advance\n\n\n\n\n\n","category":"method"},{"location":"zz_energy_equation/#energy_equation","page":"energy_equation","title":"energy_equation","text":"","category":"section"},{"location":"zz_energy_equation/","page":"energy_equation","title":"energy_equation","text":"Modules = [moment_kinetics.energy_equation]","category":"page"},{"location":"zz_energy_equation/#moment_kinetics.energy_equation","page":"energy_equation","title":"moment_kinetics.energy_equation","text":"\n\n\n\n","category":"module"},{"location":"zz_energy_equation/#moment_kinetics.energy_equation.energy_equation!-NTuple{9, Any}","page":"energy_equation","title":"moment_kinetics.energy_equation.energy_equation!","text":"evolve the parallel pressure by solving the energy equation\n\n\n\n\n\n","category":"method"},{"location":"zz_energy_equation/#moment_kinetics.energy_equation.neutral_energy_equation!-NTuple{9, Any}","page":"energy_equation","title":"moment_kinetics.energy_equation.neutral_energy_equation!","text":"evolve the neutral parallel pressure by solving the energy equation\n\n\n\n\n\n","category":"method"},{"location":"zz_charge_exchange/#charge_exchange","page":"charge_exchange","title":"charge_exchange","text":"","category":"section"},{"location":"zz_charge_exchange/","page":"charge_exchange","title":"charge_exchange","text":"Modules = [moment_kinetics.charge_exchange]","category":"page"},{"location":"zz_charge_exchange/#moment_kinetics.charge_exchange","page":"charge_exchange","title":"moment_kinetics.charge_exchange","text":"\n\n\n\n","category":"module"},{"location":"zz_charge_exchange/#moment_kinetics.charge_exchange.charge_exchange_collisions_1V!-NTuple{11, Any}","page":"charge_exchange","title":"moment_kinetics.charge_exchange.charge_exchange_collisions_1V!","text":"update the evolved pdf for each ion and electron species to account for charge exchange collisions between ions and neutrals\n\n\n\n\n\n","category":"method"},{"location":"zz_charge_exchange/#moment_kinetics.charge_exchange.charge_exchange_collisions_single_species!-NTuple{14, Any}","page":"charge_exchange","title":"moment_kinetics.charge_exchange.charge_exchange_collisions_single_species!","text":"update the evolved pdf for a single species to account for charge exchange collisions with a single species of the opposite type; e.g., ions with neutrals or neutrals with ions\n\n\n\n\n\n","category":"method"},{"location":"zz_plot_sequence/#plot_sequence","page":"plot_sequence","title":"plot_sequence","text":"","category":"section"},{"location":"zz_plot_sequence/","page":"plot_sequence","title":"plot_sequence","text":"Modules = [moment_kinetics.plot_sequence]","category":"page"},{"location":"zz_plot_sequence/#moment_kinetics.plot_sequence","page":"plot_sequence","title":"moment_kinetics.plot_sequence","text":"\n\n\n\n","category":"module"},{"location":"zz_finite_differences/#finite_differences","page":"finite_differences","title":"finite_differences","text":"","category":"section"},{"location":"zz_finite_differences/","page":"finite_differences","title":"finite_differences","text":"Modules = [moment_kinetics.finite_differences]","category":"page"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences","page":"finite_differences","title":"moment_kinetics.finite_differences","text":"\n\n\n\n","category":"module"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.finite_difference_info","page":"finite_differences","title":"moment_kinetics.finite_differences.finite_difference_info","text":"Finite difference discretization\n\n\n\n\n\n","category":"type"},{"location":"zz_finite_differences/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Any, moment_kinetics.finite_differences.finite_difference_info}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, adv_fac, not_spectral::finite_difference_info)\n\nCalculate the derivative of f using finite differences, with particular scheme specified by coord.fdoption; result stored in coord.scratch2d.\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, moment_kinetics.finite_differences.finite_difference_info}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, not_spectral::finite_difference_info)\n\nCalculate the derivative of f using 4th order centered finite differences; result stored in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.calculus.elementwise_second_derivative!-Tuple{Any, Any, moment_kinetics.finite_differences.finite_difference_info}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_second_derivative!","text":"elementwise_second_derivative!(coord, f, not_spectral::finite_difference_info)\n\nCalculate the second derivative of f using 2nd order centered finite differences; result stored in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.centered_fourth_order!-Tuple{Matrix{Float64}, Any, Any, Any, Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_fourth_order!","text":"take the derivative of input function f and return as df using fourth-order, centered differences. input/output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.centered_second_order!-Tuple{Matrix{Float64}, Any, Any, Any, Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_second_order!","text":"take the derivative of input function f and return as df using second-order, centered differences. input/output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.centered_second_order!-Tuple{Vector{Float64}, Any, Any, Any, Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_second_order!","text":"take the derivative of input function f and return as df using second-order, centered differences. input/output df is 1D array of size n (full grid)\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.derivative_finite_difference!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.derivative_finite_difference!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.derivative_finite_difference!-NTuple{8, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.derivative_finite_difference!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.fd_check_option-Tuple{Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.fd_check_option","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.second_derivative_finite_difference!-Tuple{Matrix{Float64}, Any, Any, Any, Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.second_derivative_finite_difference!","text":"Take the second derivative of input function f and return as df using second-order, centered differences. output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.upwind_first_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_first_order!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.upwind_second_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_second_order!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.upwind_third_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_third_order!","text":"\n\n\n\n","category":"method"},{"location":"external_sources_notes/#External-sources","page":"External sources","title":"External sources","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"Sometimes it is useful to have a source term for the plasma or neutrals (the S_i and S_n of Moment kinetic equations). The currently-implemented source term has the form of a Maxwellian with constant temperature and spatially-varying amplitude","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\nS_i = A_i(rz) expleft( -frac(v_perp^2 + v_parallel^2)T_mathrmsourcei right) \nS_n = A_n(rz) expleft( -frac(v_zeta^2 + v_r^2 + v_z^2)T_mathrmsourcen right)\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The sources are controlled by options in the [ion_source] and [neutral_source] sections of the input file. The source terms are enabled by setting active = true. The constant temperature is set with the source_T option (default is 1 for ions and T_mathrmwall for neutrals). The amplitude can be set or controlled in various ways depending on the controller_type setting, as explained in the following subsection.","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"Note that all the settings mentioned below have values given in normalised units (in the same way as the settings for initial profiles, etc.).","category":"page"},{"location":"external_sources_notes/#Amplitude","page":"External sources","title":"Amplitude","text":"","category":"section"},{"location":"external_sources_notes/#Fixed-amplitude-(default)","page":"External sources","title":"Fixed amplitude (default)","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"When controller_type = \"\" (the default), the amplitude of the source is fixed in time and controled by the profile options. The profile has the form","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"A(rz) = A_0 R(r) Z(z)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"where A_0 is given by the source_strength option. R(r) and Z(z) are controlled by the r_profile and z_profile options respectively. The available options for either are the same, so letting x stand for either of r or z, and X for the corresponding R or Z:","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"x_profile = \"constant\" (the default) means X(x)=1.\nx_profile = \"gaussian\" means   X(x) = (1 - X_mathrmmin) expleft( -left(fracxwright)^2 right) + X_mathrmmin   where X_mathrmmin is set by x_relative_minimum and w is set by   x_width.\nx_profile = \"parabolic\" means   P(x) = left( 1 - left(frac2xwright)^2 right),    X(x) = (1 - X_mathrmmin) H(P(x)) P(x) + X_mathrmmin   where X_mathrmmin is set by x_relative_minimum and w is set by   x_width. The effect of the step function H is to let the profile be a   quadratic in the range -w2  x  w2, but equal to a floor (by default   0, so that the source is just not allowed to become negative) outside that   range.","category":"page"},{"location":"external_sources_notes/#Midpoint-density-controller","page":"External sources","title":"Midpoint density controller","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"When controller_type = \"density_midpoint\" a PI controller (Wikipedia) is used to control the ion/neutral density. The 'midpoint' for the purposes of this controller is the point on the grid where r=0 and z=0 (there must be a grid point there).","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The spatial profile of the source (R(r) and Z(z)) is set in the same way as for the 'Fixed amplitude' source (see above), but now the prefactor changes with time","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"A(rz) = A_0(t) R(r) Z(z)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The prefactor A_0(t) is controlled to set the midpoint density to some value n(r=0z=0)rightarrow n_mathrmPI where n_mathrmPI is set by PI_density_target_amplitude. Specifically,","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\n  A_0(t) = mathttmaxleft(P(n_mathrmPI - n(r=0z=0)) + iota(t) 0right) \n  fracpartial iotapartial t = I(n_mathrmPI - n(r=0z=0))\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The 'proportional' coefficient P is set by PI_density_controller_P and the 'integral' coefficient I is set by PI_density_controller_I. The mathrmmax(ldots0) is to ensure that the 'source term' is never negative (i.e. a sink), to avoid the possibility of driving the system towards negative density.","category":"page"},{"location":"external_sources_notes/#Density-profile-controller","page":"External sources","title":"Density profile controller","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"When controller_type = \"density_profile\" a PI controller (Wikipedia) is used to control the ion/neutral density profile.","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The target profile is","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"n_mathrmPI(rz) = n_mathrmPI0 R(r) Z(z)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"where n_mathrmPI0 is set by PI_density_target_amplitude and R(r) and Z(z) are set as described in Fixed amplitude (default).","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The source amplitude A(rz) is controlled to set the density profile to n(rz)rightarrow n_mathrmPI(rz). Specifically,","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\n  A(rz) = mathttmaxleft(P(n_mathrmPI(rz) - n(rz)) + iota(trz) 0right) \n  fracpartial iota(trz)partial t = I(n_mathrmPI(rz) - n(rz))\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The 'proportional' coefficient P is set by PI_density_controller_P and the 'integral' coefficient I is set by PI_density_controller_I. The mathrmmax(ldots0) is to ensure that the 'source term' is never negative (i.e. a sink), to avoid the possibility of driving the system towards negative density.","category":"page"},{"location":"external_sources_notes/#Recycling","page":"External sources","title":"Recycling","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The source of neutrals can be set so that some fraction of the flux of ions to the walls is recycled into the volume of the domain as neutrals by using the controller_type = \"recycling\" option.","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The profile is set up whose spatial integral is 1","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"A(rz) = A_0 R(r) Z(z)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"where A_0 = leftint drdz R(r) Z(z)right^-1 and R(r) and Z(z) are set as described in Fixed amplitude (default). The source is","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"S_n(trz) = F(t) A(rz)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"where F(t) is the sum of the integrated ion flux to the lower and upper targets.","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"warning: Warning\nThe target flux calculated for this controller does not account for magnetic field lines that are not perpendicular to the wall, or for drifts to the target, so needs updating (within moment_kinetics.external_sources.external_neutral_source_controller!) to be used in 2D simulations.","category":"page"},{"location":"external_sources_notes/#API","page":"External sources","title":"API","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"See external_sources.","category":"page"},{"location":"zz_r_advection/#r_advection","page":"r_advection","title":"r_advection","text":"","category":"section"},{"location":"zz_r_advection/","page":"r_advection","title":"r_advection","text":"Modules = [moment_kinetics.r_advection]","category":"page"},{"location":"zz_r_advection/#moment_kinetics.r_advection","page":"r_advection","title":"moment_kinetics.r_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_r_advection/#moment_kinetics.r_advection.adjust_advection_speed!-NTuple{5, Any}","page":"r_advection","title":"moment_kinetics.r_advection.adjust_advection_speed!","text":"\n\n\n\n","category":"method"},{"location":"zz_r_advection/#moment_kinetics.r_advection.r_advection!-NTuple{14, Any}","page":"r_advection","title":"moment_kinetics.r_advection.r_advection!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"zz_r_advection/#moment_kinetics.r_advection.unnormalize_pdf!-NTuple{6, Any}","page":"r_advection","title":"moment_kinetics.r_advection.unnormalize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"zz_r_advection/#moment_kinetics.r_advection.update_speed_r!-NTuple{11, Any}","page":"r_advection","title":"moment_kinetics.r_advection.update_speed_r!","text":"calculate the advection speed in the r-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetic_equations/#Moment-kinetic-equations","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The following are partial notes on the derivation of the equations being solved by moment_kinetics. It would be useful to expand them with more details from the Excalibur/Neptune reports. Equation references give the report number and equation number, e.g. (TN-04;1) is equation (1) from report TN-04.pdf.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The drift kinetic equation (DKE), marginalised over v_perp, for ions is, adding ionization and a source term to the form in (TN-04;1),","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartial f_ipartial t\n  +v_fracpartial f_ipartial z\n  -fracemfracpartialphipartial zfracpartial f_ipartial v_\n  = -R_mathrminleft(n_nf_i-n_if_nright)+R_mathrmionn_if_n\n    + S_i\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and for neutrals, adding ionization and a source term to (TN-04;2)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartial f_npartial t\n  +v_fracpartial f_npartial z\n  = -R_mathrminleft(n_if_n-n_nf_iright)-R_mathrmionn_if_n\n    + S_n\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Using the normalizations (TN04;5-11)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  tildef_s  doteq f_sfracc_ssqrtpiN_e\n  tildet  doteq tfracc_sL_z\n  tildez  doteqfraczL_z\n  tildev_  doteqfracv_c_s\n  tilden_s  doteqfracn_sN_e\n  tildephi  doteqfracephiT_e\n  tildeR_mathrmin  doteq R_mathrminfracN_eL_zc_s\n  tildeR_mathrmion  doteq R_mathrmionfracN_eL_zc_s\n  tildeS_i = S_i fracc_ssqrtpiN_e fracL_zc_s = S_i fracL_zsqrtpiN_e\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"with c_sdoteqsqrt2T_em_s where L_z, N_e and T_e are constant reference parameters, the ion DKE is","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartialtildef_ipartialtildet\n  + tildev_fracpartialtildef_ipartialtildez\n  - frac12fracpartialtildephipartialtildez\n    fracpartialtildef_ipartialtildev_\n  = -tildeR_inleft(tilden_ntildef_i-tilden_itildef_nright)\n    + tildeR_mathrmiontilden_itildef_n\n    + tildeS_i\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and the neutral DKE is","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartialtildef_npartialtildet\n  + v_fracpartialtildef_npartialtildez\n  = -tildeR_inleft(tilden_itildef_n-tilden_ntildef_iright)\n    - tildeR_mathrmiontilden_itildef_n\n    + tildeS_n\nendequation","category":"page"},{"location":"moment_kinetic_equations/#Moment-equations","page":"Moment kinetic equations","title":"Moment equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Recalling the definitions (TN-04;15,29,63-66), but writing the integral in the energy equation over tildev_ instead of w_,","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  tilden_s\n   = frac1sqrtpiint dtildev_tildef_s\n\n  tilden_stildeu_s\n   = frac1sqrtpiint dtildev_tildev_tildef_s\n\n  tildep_s\n   = frac1sqrtpiint dtildev_left(tildev_\n      - tildeu_sright)^2tildef_s\n    = int dtildev_tildev_^2tildef_s\n      - tilden_stildeu_s^2\n\n  tildeq_s\n   = frac1sqrtpiint dtildev_\n      left(tildev_-tildeu_sright)^3tildef_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  tildeq_s\n    = frac1sqrtpiint dtildev_tildev_^3tildef_s\n       - 3tildeu_sfrac1sqrtpiint dv_v_^2f_s\n       + 3u_s^2frac1sqrtpiint dv_v_f_s\n       - u_s^3frac1sqrtpiint dv_f_s \n\n    = frac1sqrtpiint dtildev_tildev_^3tildef_s\n       - 3tildeu_sleft(tildep_s+tilden_stildeu_s^2right)\n       + 3tildeu_s^2tilden_stildeu_s-tildeu_s^3tilden_s\nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  tildeq_s\n    = frac1sqrtpiint dtildev_tildev_^3tildef_s\n       - 3tildeu_stildep_s\n       - tilden_stildeu_s^3\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"we can take moments of the ion DKE to give ion moment equations (dropping tildes from here on)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial n_ipartial t+fracpartialleft(n_iu_iright)partial z\n   = -R_inleft(n_nn_i-n_in_nright)+R_mathrmionn_in_n\n      + int dv_parallel S_i\n\n   = R_mathrmionn_in_n + int dv_parallel S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartialleft(n_iu_iright)partial t + fracpartialleft(p_i\n  + n_iu_i^2right)partial z + frac12fracpartialphipartial zn_i\n  = -R_inleft(n_nn_iu_i - n_in_nu_nright)\n    + R_mathrmionn_in_nu_n \nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  n_ifracpartial u_ipartial t + u_ifracpartial n_ipartial t\n  + fracpartial p_ipartial z\n  + u_ifracpartialleft(n_iu_iright)partial z\n  + n_iu_ifracpartial u_ipartial z\n  + frac12fracpartialphipartial zn_i\n   = -R_inleft(n_nn_iu_i - n_in_nu_nright)\n      + R_mathrmionn_in_nu_n \n\n  n_ifracpartial u_ipartial t\n  + u_ileft(R_mathrmionn_in_n + int dv_parallel S_iright)\n  + fracpartial p_ipartial z + n_iu_ifracpartial u_ipartial z\n  + frac12fracpartialphipartial zn_i\n   = -R_inleft(n_nn_iu_i - n_in_nu_nright)\n      + R_mathrmionn_in_nu_n \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartial u_ipartial t + frac1n_ifracpartial p_ipartial z\n  + u_ifracpartial u_ipartial z + frac12fracpartialphipartial z\n  = -R_inn_nleft(u_i-u_nright)\n    + R_mathrmionfracn_in_nn_sleft(u_n-u_iright)\n    - fracu_in_i int dv_parallel S_i\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartialleft(p_i + n_iu_i^2right)partial t\n    + fracpartialleft(q_i + 3u_ip_i\n    + n_iu_i^3right)partial z + fracpartialphipartial zn_iu_i \n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n      - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n+n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial p_ipartial t\n  + frac1n_ifracpartialleft(n_iu_iright)^2partial t\n  - fracleft(n_iu_iright)^2n_i^2fracpartial n_ipartial t\n  + fracpartialleft(q_i + 3u_ip_i\n  + n_iu_i^3right)partial z + fracpartialphipartial zn_iu_i\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n                   - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_i \n\n  fracp_ipartial t + 2u_ifracpartial n_iu_ipartial t\n  - u_i^2fracpartial n_ipartial t + fracpartialleft(q_i\n  + 3u_ip_i + n_iu_i^3right)partial z\n  + fracpartialphipartial zn_iu_i\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n      - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_i \n\n  fracpartial p_ipartial t + 2u_ileft(-fracpartial p_ipartial z\n  - fracpartialleft(n_iu_i^2right)partial z\n  - frac12fracpartialphipartial zn_i\n  - R_inleft(n_nn_iu_i - n_in_nu_nright)\n  + R_mathrmionn_in_nu_nright) \n  -u_i^2left(-fracpartialleft(n_iu_iright)partial z\n  + R_mathrmionn_in_n + int dv_parallel S_iright)\n  + fracpartial q_ipartial z\n  + fracpartialleft(3u_ip_iright)partial z\n  + fracpartialleft(n_iu_i^3right)partial z\n  + fracpartialphipartial zn_iu_i\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n      - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_i \n\n  fracpartial p_ipartial t + u_ifracpartial p_ipartial z\n  + 3p_ifracpartial u_ipartial z + fracpartial q_ipartial z\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right) - n_ileft(p_n\n      + n_nu_n^2right) - 2u_ileft(n_nn_iu_i - n_in_nu_nright)right) \n       quad + R_mathrmionn_ileft(p_n + n_nu_n^2 + n_nu_i^2\n      - 2n_nu_iu_nright)\n      + int dv_parallel v_parallel^2 S_i + u_i^2 int dv_parallel S_i \n\n  fracpartial p_ipartial t + u_ifracpartial p_ipartial z\n  + 3p_ifracpartial u_ipartial z + fracpartial q_ipartial z\n   = -R_inleft(n_np_i - n_ip_n - n_in_nleft(u_i^2 + u_n^2\n      - 2u_iu_nright)right) + R_mathrmionn_ileft(p_n + n_nleft(u_n\n      - u_iright)^2right) \n       quad + int dv_parallel v_parallel^2 S_i + u_i^2 int dv_parallel S_i \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial p_ipartial t + u_ifracpartial p_ipartial z\n    + 3p_ifracpartial u_ipartial z + fracpartial q_ipartial z \n   = -R_inleft(n_np_i - n_ip_n\n      - n_in_nleft(u_i - u_nright)^2right)\n      + R_mathrmionn_ileft(p_n + n_nleft(u_n - u_iright)^2right) \n       quad + int dv_parallel v_parallel^2 S_i + u_i^2 int dv_parallel S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and of the neutral DKE to give neutral moment equations","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial n_npartial t + fracpartialleft(n_nu_nright)partial z\n   = -R_ileft(n_in_n - n_nn_iright) - R_mathrmionn_in_n\n      + int dv_parallel S_n \n\n   =-R_mathrmionn_in_n + int dv_parallel S_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartialleft(n_nu_nright)partial t\n  + fracpartialleft(p_n + n_nu_n^2right)partial z\n  = -R_inleft(n_in_nu_n - n_nn_iu_iright)\n    - R_mathrmionn_in_nu_n \nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  n_nfracpartial u_npartial t + u_nfracpartial n_npartial t\n  + fracpartial p_npartial z\n  + u_nfracpartialleft(n_nu_nright)partial z\n  + n_nu_nfracpartial u_npartial z\n   = -R_inleft(n_in_nu_n - n_nn_iu_iright)\n      - R_mathrmionn_in_nu_n \n\n  n_nfracpartial u_npartial t\n  + u_nleft(-R_mathrmionn_in_n + int dv_parallel S_nright)\n  + fracpartial p_npartial z\n  + n_nu_sfracpartial u_npartial z\n   = -R_inleft(n_in_nu_n - n_nn_iu_iright)\n      - R_mathrmionn_in_nu_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartial u_npartial t + frac1n_nfracpartial p_npartial z\n  + u_nfracpartial u_npartial z\n  = -R_inn_ileft(u_n - u_iright) - fracu_nn_n int dv_parallel S_n\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartialleft(p_n + n_nu_n^2right)partial t\n    + fracpartialleft(q_n + 3u_np_n\n    + n_nu_n^3right)partial z + q_nfracpartialphipartial zn_nu_n \n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right)right)\n      - R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial p_npartial t\n  + frac1n_nfracpartialleft(n_nu_nright)^2partial t\n  - fracleft(n_nu_nright)^2n_n^2fracpartial n_npartial t\n  + fracpartialleft(q_n + 3u_np_n + n_nu_n^3right)partial z\n  + q_nfracpartialphipartial zn_nu_n\n   =-R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right)right)\n      - R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_n \n\n  fracpartial p_npartial t + 2u_nfracpartial n_nu_npartial t\n  - u_n^2fracpartial n_npartial t + fracpartialleft(q_n\n  + 3u_np_n + n_nu_n^3right)partial z\n  + q_nfracpartialphipartial zn_nu_n\n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right)right) - R_mathrmionn_ileft(p_n\n      + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_n \n\n  fracpartial p_npartial t\n  + 2u_nleft(-fracpartial p_npartial z\n  - fracpartialleft(n_nu_n^2right)partial z\n  - fracq_n2fracpartialphipartial zn_n\n  - R_inleft(n_in_nu_n - n_nn_iu_iright)\n  - R_mathrmionn_in_nu_nright) \n  - u_n^2left(-fracpartialleft(n_nu_nright)partial z\n  - R_mathrmionn_in_n + int dv_parallel S_nright)\n  + fracpartial q_npartial z\n  + fracpartialleft(3u_np_nright)partial z\n  + fracpartialleft(n_nu_n^3right)partial z\n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n  + n_iu_i^2right)right)\n  - R_mathrmionn_ileft(p_n + n_nu_n^2right)\n  + int dv_parallel v_parallel^2 S_n \n\n  fracpartial p_npartial t + u_nfracpartial p_npartial z\n  + 3p_nfracpartial u_npartial z + fracpartial q_npartial z\n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right) - 2u_nleft(n_in_nu_n\n      - n_nn_iu_iright)right) - R_mathrmionn_ileft(p_n\n      + n_nu_n^2 + n_nu_n^2 - 2n_nu_nu_nright)\n      + int dv_parallel v_parallel^2 S_n + u_n^2int dv_parallel S_n \n\n  fracpartial p_npartial t + u_nfracpartial p_npartial z\n  + 3p_nfracpartial u_npartial z + fracpartial q_npartial z\n   = -R_inleft(n_ip_n - n_np_i - n_nn_ileft(u_n^2 + u_i^2\n      - 2u_nu_iright)right) - R_mathrmionn_ip_n\n      + int dv_parallel v_parallel^2 S_n + u_n^2int dv_parallel S_n \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial p_npartial t + u_nfracpartial p_npartial z\n    + 3p_nfracpartial u_npartial z + fracpartial q_npartial z \n   = -R_inleft(n_ip_n - n_np_i\n      - n_nn_ileft(u_n - u_iright)^2right) - R_mathrmionn_ip_n \n       quad + int dv_parallel v_parallel^2 S_n + u_n^2int dv_parallel S_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Kinetic-equation","page":"Moment kinetic equations","title":"Kinetic equation","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"For the moment-kinetic equation for the normalized distribution function","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\ng_s(w_s)=fracv_mathrmthsn_sf_s(v_(w_s))\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"we transform to the normalized velocity coordinate","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\nw_s=fracv_ - u_sv_mathrmths\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The derivatives transform as","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  leftfracpartial f_spartial tright_zv\n   rightarrowleftfracpartial f_spartial tright_zw\n               - frac1v_mathrmthsfracpartial u_spartial tleftfracpartial f_spartial w_sright_zw\n               - fracw_sv_mathrmthsfracpartial v_mathrmthspartial tleftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial zright_zv\n   rightarrowleftfracpartial f_spartial zright_zw\n               - frac1v_mathrmthsfracpartial u_spartial zleftfracpartial f_spartial w_sright_zw\n               - fracw_sv_mathrmthsfracpartial v_mathrmthspartial zleftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial v_right_zv\n   rightarrowfrac1v_mathrmthsleftfracpartial f_spartial w_sright_zw\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"We use an energy equation that evolves p_s not v_mathrmths, so use","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  v_mathrmths^2  = 2fracp_sn_s \n\n  Rightarrow v_mathrmthsfracpartial v_mathrmthspartial t\n   = frac1n_sfracpartial p_spartial t\n      - fracp_sn_s^2fracpartial n_spartial t\n\n  v_mathrmthsfracpartial v_mathrmthspartial z\n   = frac1n_sfracpartial p_spartial z\n      - fracp_sn_s^2fracpartial n_spartial z\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"to convert the transformations above to","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  leftfracpartial f_spartial tright_zv\n   rightarrowleftfracpartial f_spartial tright_zw\n    - frac1v_mathrmthsfracpartial u_spartial tleftfracpartial f_spartial w_sright_zw\n    - fracw_sv_mathrmths^2left(frac1n_sfracpartial p_spartial t\n    - fracp_sn_s^2fracpartial n_spartial tright)leftfracpartial f_spartial w_sright_zw\n\n   = leftfracpartial f_spartial tright_zw\n      - frac1v_mathrmthsfracpartial u_spartial tleftfracpartial f_spartial w_sright_zw\n      - fracw_s2left(frac1p_sfracpartial p_spartial t\n      - frac1n_sfracpartial n_spartial tright)leftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial zright_zv\n   rightarrowleftfracpartial f_spartial zright_zw\n    - frac1v_mathrmthsfracpartial u_spartial zleftfracpartial f_spartial w_sright_zw\n    - fracw_sv_mathrmths^2left(frac1n_sfracpartial p_spartial z\n    - fracp_sn_s^2fracpartial n_spartial zright)leftfracpartial f_spartial w_sright_zw\n\n   = leftfracpartial f_spartial zright_zw\n      - frac1v_mathrmthsfracpartial u_spartial zleftfracpartial f_spartial w_sright_zw\n      - fracw_s2left(frac1p_sfracpartial p_spartial z\n      - frac1n_sfracpartial n_spartial zright)leftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial v_right_zv\n   rightarrowfrac1v_mathrmthsleftfracpartial f_spartial w_sright_zw\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Using these transformations gives the ion DKE in a form similar to (TN-04;55) (but writing out dotw_ in full here, and not using the moment equations for the moment)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_ipartial t\n    - frac1v_mathrmthifracpartial u_ipartial tfracpartial f_ipartial w_i\n    - fracw_i2left(frac1p_ifracpartial p_ipartial t\n    - frac1n_ifracpartial n_ipartial tright)fracpartial f_ipartial w_i \n   + left(v_mathrmthiw_i + u_iright)left(fracpartial f_ipartial z\n    - frac1v_mathrmthifracpartial u_ipartial zfracpartial f_ipartial w_i\n    - fracw_i2left(frac1p_ifracpartial p_ipartial z\n    - frac1n_ifracpartial n_ipartial zright)fracpartial f_ipartial w_iright) \n   - frac12v_mathrmthifracpartialphipartial zfracpartial f_ipartial w_i \n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n + S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial f_ipartial t + left(v_mathrmthiw_i\n  + u_iright)fracpartial f_ipartial z\n  - frac1v_mathrmthifracpartial u_ipartial tfracpartial f_ipartial w_i\n  - fracw_i2left(frac1p_ifracpartial p_ipartial t\n  - frac1n_ifracpartial n_ipartial tright)fracpartial f_ipartial w_i\n  + left(v_mathrmthiw_i\n  + u_iright)left(-frac1v_mathrmthifracpartial u_ipartial zfracpartial f_ipartial w_i\n  - fracw_i2left(frac1p_ifracpartial p_ipartial z\n  - frac1n_ifracpartial n_ipartial zright)fracpartial f_ipartial w_iright)\n  - frac12v_mathrmthifracpartialphipartial zfracpartial f_ipartial w_i\n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n + S_i \n\n  fracpartial f_ipartial t + left(v_mathrmthiw_i\n  + u_iright)fracpartial f_ipartial z\n  + left-frac1v_mathrmthifracpartial u_ipartial t\n  - fracw_i2left(frac1p_ifracpartial p_ipartial t\n  - frac1n_ifracpartial n_ipartial tright)\n  + left(v_mathrmthiw_i\n  + u_iright)left(-frac1v_mathrmthifracpartial u_ipartial z\n  - fracw_i2left(frac1p_ifracpartial p_ipartial z\n  - frac1n_ifracpartial n_ipartial zright)right)\n  - frac12v_mathrmthifracpartialphipartial zrightfracpartial f_ipartial w_i\n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n + S_i \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_ipartial t + left(v_mathrmthiw_i\n    + u_iright)fracpartial f_ipartial z \n   + left-frac1v_mathrmthileft(fracpartial u_ipartial t\n    + left(v_mathrmthiw_i + u_iright)fracpartial u_ipartial z\n    + frac12fracpartialphipartial zright)right \n   qquad - fracw_i2frac1p_ileft(fracpartial p_ipartial t\n          + left(v_mathrmthiw_i + u_iright)fracpartial p_ipartial zright) \n   qquad + fracw_i2frac1n_ileft(fracpartial n_ipartial t\n          + left(v_mathrmthiw_i\n          + leftu_iright)fracpartial n_ipartial zright)rightfracpartial f_ipartial w_i \n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n + S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and the neutral DKE","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_npartial t\n    - frac1v_mathrmthnfracpartial u_npartial tfracpartial f_npartial w_n\n    - fracw_n2left(frac1p_nfracpartial p_npartial t\n    - frac1n_nfracpartial n_npartial tright)fracpartial f_npartial w_n \n   + left(v_mathrmthnw_n + u_nright)left(fracpartial f_npartial z\n    - frac1v_mathrmthnfracpartial u_npartial zfracpartial f_npartial w_n\n    - fracw_n2left(frac1p_nfracpartial p_npartial z\n    - frac1n_nfracpartial n_npartial zright)fracpartial f_npartial w_nright) \n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n + S_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial f_npartial t + left(v_mathrmthnw_n\n  + u_nright)fracpartial f_npartial z\n  - frac1v_mathrmthnfracpartial u_npartial tfracpartial f_npartial w_n\n  - fracw_n2left(frac1p_nfracpartial p_npartial t\n  - frac1n_nfracpartial n_npartial tright)fracpartial f_npartial w_n\n  + left(v_mathrmthnw_n\n  + u_nright)left(-frac1v_mathrmthnfracpartial u_npartial zfracpartial f_npartial w_n\n  - fracw_n2left(frac1p_nfracpartial p_npartial z\n  - frac1n_nfracpartial n_npartial zright)fracpartial f_npartial w_nright)\n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n + S_n \n\n  fracpartial f_npartial t + left(v_mathrmthnw_n\n  + u_nright)fracpartial f_npartial z\n  + left-frac1v_mathrmthnfracpartial u_npartial t\n  - fracw_n2left(frac1p_nfracpartial p_npartial t\n  - frac1n_nfracpartial n_npartial tright) + left(v_mathrmthnw_n\n  + u_nright)left(-frac1v_mathrmthnfracpartial u_npartial z\n  - fracw_n2left(frac1p_nfracpartial p_npartial z\n  - frac1n_nfracpartial n_npartial zright)right)rightfracpartial f_npartial w_n\n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n + S_n \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_npartial t + left(v_mathrmthnw_n\n    + u_nright)fracpartial f_npartial z \n   + left-frac1v_mathrmthnleft(fracpartial u_npartial t\n    + left(v_mathrmthnw_n+u_nright)fracpartial u_npartial zright)right \n   qquad - fracw_n2frac1p_nleft(fracpartial p_npartial t\n           + left(v_mathrmthnw_n + u_nright)fracpartial p_npartial zright) \n   qquad + leftfracw_n2frac1n_nleft(fracpartial n_npartial t\n           + left(v_mathrmthnw_n\n           + u_nright)fracpartial n_npartial zright)rightfracpartial f_npartial w_n \n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n + S_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"We also normalise f and write the DKEs for","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  g_s  =fracv_mathrmthsn_sf_s \n\n  Rightarrowfracpartial f_spartial t\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n  + fracg_sv_mathrmthsfracpartial n_spartial t\n  - fracn_sg_sv_mathrmths^2fracpartial v_mathrmthspartial t \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial f_spartial t\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n      + fracg_sv_mathrmthsfracpartial n_spartial t\n      - fracn_sg_sv_mathrmths^3left(frac1n_sfracpartial p_spartial t\n      - fracp_sn_s^2fracpartial n_spartial tright) \n\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n      + fracg_sv_mathrmthsfracpartial n_spartial t\n      - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial t\n      + fracg_s2v_mathrmthsfracpartial n_spartial t \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial f_spartial t\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n      + frac3g_s2v_mathrmthsfracpartial n_spartial t\n      - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial t \n\n  fracpartial f_spartial w_s\n   = fracn_sv_mathrmthsfracpartial g_spartial w_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"For brevity, do the following manipulations for g_s rather than for ions and neutrals separately by using q_i=1, q_n=0 and with the +'ve sign for the ion DKE and -'ve sign for the neutral DKE.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracn_sv_mathrmthsfracpartial g_spartial t\n  + frac3g_s2v_mathrmthsfracpartial n_spartial t\n  - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial f_spartial z \n   + left-frac1v_mathrmthsleft(fracpartial u_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial u_spartial z\n  + fracq_s2fracpartialphipartial zright)right \n   qquad - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright) \n   qquad + leftfracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracn_sv_mathrmthsfracpartial g_spartial w_s \n   = -R_ssleft(n_sfracn_sv_mathrmthsg_s\n      - n_sfracn_sv_mathrmthsg_sright)\n      pm R_mathrmionn_ifracn_nv_mathrmthng_n\n      + S_s \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t \n   + left-frac1v_mathrmthsleft(fracpartial u_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial u_spartial z\n  + fracq_s2fracpartialphipartial zright)\n  - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright)\n  + fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s \n\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t \n   + left-frac1v_mathrmthsleft(fracn_sn_sfracpartial u_spartial t\n  + fracn_sn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial u_spartial z\n  + fracu_sn_sleft(fracpartial npartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial npartial zright)\n  + fracq_s2fracpartialphipartial zright)\n  + fracu_sn_sv_mathrmthsleft(fracpartial npartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial npartial zright)\n  - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright)\n  + fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t \n   + left-frac1n_sv_mathrmthsleft(fracpartial n_su_spartial t\n  + left(v_mathrmthsw_s + u_sright)left(n_sfracpartial u_spartial z\n  + u_sfracpartial n_spartial zright)\n  + fracq_s2n_sfracpartialphipartial zright)right \n   qquad + fracu_sn_sv_mathrmthsleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial n_spartial zright)\n  - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright) \n   qquad left+ fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"So then if we use the moment equations we can rewrite the DKE as","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t \n   + left-frac1n_sv_mathrmthsleft(fracpartial n_su_spartial t\n  + u_sleft(n_sfracpartial u_spartial z\n  + u_sfracpartial n_spartial zright)\n  - frac12n_sE_\n  + v_mathrmthsw_sleft(n_sfracpartial u_spartial z\n  + u_sfracpartial n_spartial zright)right)right \n   qquad + fracu_sn_sv_mathrmthsleft(fracpartial n_spartial t\n  + u_sfracpartial n_spartial z\n  + v_mathrmthsw_sfracpartial n_spartial zright) \n   qquad-fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + u_sfracpartial p_spartial z\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   qquadleft + fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + u_sfracpartial n_spartial z\n  + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  - u_sfracpartial n_spartial z\n  - n_sfracpartial u_spartial zright) \n   -fracg_s2p_sleft(-u_sfracpartial p_spartial z\n  - fracpartial q_spartial z\n  - 3p_sfracpartial u_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n - u_sright)^2right)\n  + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s right) \n   + left-frac1n_sv_mathrmthsleft(-underbracecanceln_su_sfracpartial u_spartial z_A\n  - fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)\n  pm R_mathrmionn_in_nu_n\n  + v_mathrmthsw_sleft(underbracecanceln_sfracpartial u_spartial z_B\n  + underbracecancelu_sfracpartial n_spartial z_Cright)right)right \n   quad + fracu_sn_sv_mathrmthsleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  - underbracecanceln_sfracpartial u_spartial z_A\n  + underbracecancelv_mathrmthsw_sfracpartial n_spartial z_Cright) \n   quad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - underbracecancel3p_sfracpartial u_spartial z_B\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n\n  - u_sright)^2right) + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   quadleft + fracw_s2frac1n_sleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  - underbracecanceln_sfracpartial u_spartial z_B\n  + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s \n\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  - u_sfracpartial n_spartial z - n_sfracpartial u_spartial zright) \n   -fracg_s2p_sleft(-u_sfracpartial p_spartial z\n  - fracpartial q_spartial z - 3p_sfracpartial u_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n - u_sright)^2right)\n  + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_sright) \n   + left-frac1n_sv_mathrmthsleft(-fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)pm R_mathrmionn_in_nu_nright)right \n   quad + fracu_sn_sv_mathrmthsleft(pm R_mathrmionn_in_n + int dv_parallel S_sright) \n   quad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n\n  - u_sright)^2right) + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   quadleft + fracw_s2frac1n_sleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s\n\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + g_sleft(pmfrac32R_mathrmionn_ifracn_nn_s\n  + frac32n_sint dv_parallel S_s\n  - frac3u_s2n_sfracpartial n_spartial zright) \n   + g_sleft(fracu_s2p_sfracpartial p_spartial z\n  + frac12p_sfracpartial q_spartial z\n  + frac12p_sR_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right)\n  mpfrac12R_mathrmionfracn_ip_sleft(p_n\n  + n_nleft(u_n - u_sright)^2right)\n  - frac12p_parallelsint dv_parallel v_parallel^2 S_s - fracu_s^22p_parallelsint dv_parallel S_sright) \n   + left-frac1n_sv_mathrmthsleft(-fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)\n  pm R_mathrmionn_in_nleft(u_n - u_sright) - u_sint dv_parallel S_sright)right \n   quad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right)\n  + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   quadmpfracw_s2R_mathrmionn_ileft(fracp_np_s\n  - fracn_nn_s + fracn_np_sleft(u_n - u_sright)^2right) \n   quadleft + fracw_s2frac1n_sleft(int dv_parallel S_s + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n + fracv_mathrmthsn_s S_s\nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and finally using","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracu_sv_mathrmthsfracpartial v_mathrmthspartial z\n   =u_ssqrtfracn_sp_sfracpartialpartial zsqrtfracp_sn_s \n   = fracu_s2left(frac1p_sfracpartial p_spartial z\n      - frac1n_sfracpartial n_spartial zright)\nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"gives","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + left(pmfrac32R_mathrmionn_ifracn_nn_s\n  + frac32n_s int dv_parallel S_s\n  - fracu_sn_sfracpartial n_spartial zright)g_s \n   + left(fracu_sv_mathrmthsfracpartial v_mathrmthspartial z\n  + frac12p_sfracpartial q_spartial zright \n   qquad + frac12p_sR_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right) \n   qquad leftmpfrac12R_mathrmionfracn_ip_sleft(p_n\n  + n_nleft(u_n - u_sright)^2right)\n  - frac12p_parallelsint dv_parallel v_parallel^2 S_s - fracu_s^22p_parallelsint dv_parallel S_sright)g_s \n   + left-frac1n_sv_mathrmthsleft(-fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)\n  pm R_mathrmionn_in_nleft(u_n - u_sright) - u_sint dv_parallel S_sright)right \n   qquad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right)\n  + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   qquadmpfracw_s2R_mathrmionn_ileft(fracp_np_s\n  - fracn_nn_s + fracn_np_sleft(u_n - u_sright)^2right) \n   qquadleft + fracw_parallels2frac1n_sint dv_parallel S_s\n  + fracw_s^22fracv_mathrmthsn_sfracpartial n_spartial zrightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n + fracv_mathrmthsn_s S_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Writing out the final result fully for ions","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial g_ipartial t\n  + fracv_mathrmthin_ileft(v_mathrmthiw_i\n  + u_iright)fracpartial f_ipartial z\n  + left(frac32R_mathrmionn_n + frac32n_iint dv_parallel S_i\n  - fracu_in_ifracpartial n_ipartial zright)g_i \n   + left(fracu_iv_mathrmthifracpartial v_mathrmthipartial z\n  + frac12p_ifracpartial q_ipartial zright \n   qquad + frac12p_iR_inleft(n_np_i - n_ip_n\n  - n_in_nleft(u_i - u_nright)^2right) \n   qquad left - frac12R_mathrmionfracn_ip_ileft(p_n\n  + n_nleft(u_n - u_iright)^2right)\n  - frac12p_paralleliint dv_parallel v_parallel^2 S_i - fracu_i^22p_paralleliint dv_parallel S_iright)g_i \n   + left-frac1n_iv_mathrmthileft(-fracpartial p_ipartial z\n  + R_inn_in_nleft(u_n - u_iright)\n  + R_mathrmionn_in_nleft(u_n - u_iright) - u_iint dv_parallel S_iright)right \n   qquad-fracw_i2frac1p_ileft(-fracpartial q_ipartial z\n  - R_inleft(n_np_i - n_ip_n\n  - n_in_nleft(u_i - u_nright)^2right)\n  + int dv_parallel v_parallel^2 S_i + u_i^2 int dv_parallel S_i\n  + v_mathrmthiw_ifracpartial p_ipartial zright) \n   qquad - fracw_i2R_mathrmionn_ileft(fracp_np_i\n  - fracn_nn_i + fracn_np_ileft(u_n - u_iright)^2right) \n   qquadleft + fracw_paralleli2 frac1n_iint dv_parallel S_i\n  + fracw_i^22fracv_mathrmthin_ifracpartial n_ipartial zrightfracpartial g_ipartial w_i \n   = -R_inn_nleft(g_i - fracv_mathrmthiv_mathrmthng_nright)\n      + R_mathrmionv_mathrmthifracn_nv_mathrmthng_n + fracv_mathrmthin_i S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and for neutrals where several of the ionization terms cancel","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_npartial t\n  + fracv_mathrmthnn_nleft(v_mathrmthnw_n\n  + u_nright)fracpartial f_npartial z\n  + left(-frac32R_mathrmionn_i + frac32n_nint dv_parallel S_n\n  - fracu_nn_nfracpartial n_npartial zright)g_n \n   + left(fracu_nv_mathrmthnfracpartial v_mathrmthnpartial z\n  + frac12p_nfracpartial q_npartial zright \n   qquad left + frac12p_nR_inleft(n_ip_n - n_np_i\n  - n_nn_ileft(u_n - u_iright)^2right)\n  + frac12R_mathrmionn_i\n  - frac12p_parallelnint dv_parallel v_parallel^2 S_n - fracu_n^22p_parallelnint dv_parallel S_nright)g_n \n   + left-frac1n_nv_mathrmthnleft(-fracpartial p_npartial z\n  + R_inn_nn_ileft(u_i - u_nright) - u_nint dv_parallel S_nright)right \n   qquad-fracw_n2frac1p_nleft(-fracpartial q_npartial z\n  - R_inleft(n_ip_n - n_np_i\n  - n_nn_ileft(u_n - u_iright)^2right)\n  + int dv_parallel S_n + u_n^2int dv_parallel v_parallel^2 S_n\n  + v_mathrmthnw_nfracpartial p_npartial zright) \n   qquadleft + fracw_paralleln2frac1n_nint dv_parallel S_n\n  + fracw_n^22fracv_mathrmthnn_nfracpartial n_npartial zrightfracpartial g_npartial w_n \n   = -R_inn_ileft(g_n - fracv_mathrmthnv_mathrmthig_iright)\n      - R_mathrmionn_ig_n + fracv_mathrmthnn_n S_n\nendalign","category":"page"},{"location":"zz_ionization/#ionization","page":"ionization","title":"ionization","text":"","category":"section"},{"location":"zz_ionization/","page":"ionization","title":"ionization","text":"Modules = [moment_kinetics.ionization]","category":"page"},{"location":"zz_ionization/#moment_kinetics.ionization","page":"ionization","title":"moment_kinetics.ionization","text":"\n\n\n\n","category":"module"},{"location":"zz_moment_kinetics_input/#moment_kinetics_input","page":"moment_kinetics_input","title":"moment_kinetics_input","text":"","category":"section"},{"location":"zz_moment_kinetics_input/","page":"moment_kinetics_input","title":"moment_kinetics_input","text":"Modules = [moment_kinetics.moment_kinetics_input]","category":"page"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input","text":"\n\n\n\n","category":"module"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_coordinate_input-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_coordinate_input","text":"Check input for a coordinate\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input-NTuple{12, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input","text":"check various input options to ensure they are all valid/consistent\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input_initialization-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input_initialization","text":"\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input_time_advance-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input_time_advance","text":"\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.get_default_rhostar-Tuple{Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.get_default_rhostar","text":"function get_default_rhostar(reference_params)\n\nCalculate the normalised ion gyroradius at reference parameters\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.load_defaults-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.load_defaults","text":"\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.mk_input","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.mk_input","text":"Process user-supplied inputs\n\nsave_inputs_to_txt should be true when actually running a simulation, but defaults to false for other situations (e.g. when post-processing).\n\nignore_MPI should be false when actually running a simulation, but defaults to true for other situations (e.g. when post-processing).\n\n\n\n\n\n","category":"function"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.read_input_file-Tuple{String}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.read_input_file","text":"Read input from a TOML file\n\n\n\n\n\n","category":"method"},{"location":"developing/#Developing","page":"Developing","title":"Developing","text":"","category":"section"},{"location":"developing/#Dependencies","page":"Developing","title":"Dependencies","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"If you need to add a dependency, start the REPL with the moment_kinetics package activated (see above), enter pkg> mode (press ]) and then to add, for example, the FFTW.jl package enter","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"(moment_kinetics) pkg> add FFTW","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"This should take care of adding the package (FFTW) to the Project.toml and Manifest.toml files.","category":"page"},{"location":"developing/#Revise.jl","page":"Developing","title":"Revise.jl","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"When working on the code, one way to avoid waiting for everything to recompile frequently is to load the Revise.jl package","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> using Revise","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Revise.jl will recompile each edited function/method as needed, so it is possible to keep a REPL session open and avoid long recompilation. moment_kinetics can be run fairly conveniently from the REPL","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> using moment_kinetics\njulia> run_moment_kinetics(input)","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"where input is a Dict() containing any non-default options desired. Input can also be loaded from a TOML file passing the filaname as a String to the second argument, e.g.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> run_moment_kinetics(\"input.toml\")","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It might be convenient to add using Revise to your startup.jl file (~/julia/config/startup.jl) so it's always loaded.","category":"page"},{"location":"developing/#Parallelization","page":"Developing","title":"Parallelization","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"The code is parallelized at the moment using MPI and shared-memory arrays. Arrays representing the pdf, moments, etc. are shared between all processes. Using shared memory means, for example, we can take derivatives along one dimension while parallelising the other for any dimension without having to communicate to re-distribute the arrays. Using shared memory instead of (in future as well as) distributed memory parallelism has the advantage that it is easier to split up the points within each element between processors, giving a finer-grained parallelism which should let the code use larger numbers of processors efficiently.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It is possible to use a REPL workflow with parallel code:","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Recommended option is to use tmpi. This utility (it's a bash script that uses tmux) starts an mpi program with each process in a separate pane in a single terminal, and mirrors input to all processes simultaneously (which is normally what you want, there are also commands to 'zoom in' on a single process).\nAnother 'low-tech' possibilty is to use something like mpirun -np 4 xterm -e julia --project, but that will start each process in a separate xterm and you would have to enter commands separately in each one. Occasionally useful for debugging when nothing else is available.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"There is no restriction on the number of processes or number of grid points, although load-balancing may be affected - if there are only very few points per process, and a small fraction of processes have an extra grid point (e.g. splitting 5 points over 4 processes, so 3 process have 1 point but 1 process has 2 points), many processes will spend time waiting for the few with an extra point.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Parallelism is implemented through macros that get the local ranges of points that each process should handle. The inner-most level of nested loops is typically not parallelized, to allow efficient FFTs for derivatives, etc. A loop over one (possibly parallelized) dimension can be written as, for example,","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s is begin\n    f[is] = ...\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"These macros can be nested as needed for relatively complex loops","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s is begin\n    some_setup(is)\n    @loop_z iz begin\n        @views do_something(f[:,iz,is])\n    end\n    @loop_z iz begin\n        @views do_something_else(f[:,iz,is])\n    end\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Simpler nested loops can (optionally) be written more compactly","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s_z_vpa is iz ivpa begin\n    f[ivpa,iz,is] = ...\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Which dimensions are actually parallelized by these macros is controlled by the 'region' that the code is currently in, as set by the begin_<dims>_region() functions, where <dims> are the dimensions that will be parallelized in the following region. For example, after calling begin_s_z_region() loops over species and z will be divided up over the processes in a 'block' (currently there is only one block, which contains the whole grid and all the processes being used, as we have not yet implemented distributed-memory parallelism). Every process will loop over all points in the remaining dimensions if the loop macros for those dimensions are called.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The recommended place to put begin_*_region() calls is at the beginning of a function whose contents should use loops parallelised according to the settings for that region.\nEach begin_*_region() function checks if the region it would set is already active, and if so returns immediately (doing nothing). This means that begin_*_region() can (and should) be used to mark a block of code as belonging to that region, and if moment_kinetics is already in that region type, the call will have essentially zero cost.\nIn some places it may be necessary to change the region type half way through a function, etc. This is fine.\nWhen choosing which region type to select, note that all 'parallelised dimensions' must be looped over for each operation (otherwise some points may be written more than once), unless some special handling is used (e.g. species dimension s is parallelised, but a conditional like if 1 in loop_ranges[].s is wrapped around code to be executed so that only processes which should handle the point at s=1 do anything). It may be more optimal in some places to choose region types that do not parallelise all possible dimensions, to reduce the number of synchronisations that are needed.\nAs a matter of style, it is recommended to place begin_*_region() calls within functions where the loops are (or at most one level above), so that it is not necessary to search back along the execution path of the code to find the most recent begin_*_region() call, and therefore know what region type is active.\nIn a region after begin_serial_region(), the rank 0 process in each block will loop over all points in every dimension, and all other ranks will not loop over any.\nInside serial regions, the macro @serial_region can also be used to wrap blocks of code so that they only run on rank 0 of the block. This is useful for example to allow the use of array-broadcast expressions during initialization where performance is not critical.\nTo help show how these macros work, a script is provided that print a set of examples where the loop macros are expanded. It can be run from the Julia REPL\n$ julia --project\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.7.0 (2021-11-30)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> include(\"util/print-macros.jl\")\nor on the command line\n$ julia --project util/print-macros.jl","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The ranges used are stored in a LoopRanges struct in the Ref variable loop_ranges (which is exported by the looping module). The range for each dimension is stored in a member with the same name as the dimension, e.g. loop_ranges[].s for the species. Occasionally it is useful to access the range directly. There are different LoopRanges instances for different parallelization patterns - the instance stored in loop_ranges is updated when begin_*_region() is called. It is possible to find out the current region type (i.e. which dimensions are being parallelized) by looking at loop_ranges[].parallel_dims.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"note: Note\nThe square brackets [] after loop_ranges[] are needed because loop_ranges is a reference to a LoopRanges object Ref{LoopRanges} (a bit like a pointer) - it allows loop_ranges to be a const variable, so its type is always known at compile time, but the actual LoopRanges can be set/modified at run-time.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It is also possible to run a block of code in serial (on just the rank-0 member of each block of processes) by wrapping it in a @serial_region macro. This is mostly useful for initialization or file I/O where performance is not critical. For example","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@serial_region begin\n    # Do some initialization\n    f .= 0.0\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Internally, when the begin_*_region() functions need to change the region type (i.e. the requested region is not already active), they call _block_synchronize(), which calls MPI.Barrier(). They also switch over the LoopRanges struct contained in looping.loop_ranges as noted above. For optimization, the _block_synchronize() call can be skipped - when it is correct to do so - by passing the argument no_synchronize=true (or some more complicated conditional expression if synchronization is necessary when using some options but not for others).","category":"page"},{"location":"setup_for_moment_kinetics/#Setup-for-moment_kinetics-on-known-clusters","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"","category":"section"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"This subdirectory provides scripts to set up Julia and moment_kinetics to run on some known clusters.","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"Currently supported:","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"\"archer\" (ARCHER2)\n\"marconi\" (the EUROfusion supercomputer   Marconi)","category":"page"},{"location":"setup_for_moment_kinetics/#Quickstart","page":"Setup for moment_kinetics on known clusters","title":"Quickstart","text":"","category":"section"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"From the top-level of the moment_kinetics repo, run","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"$ machines/machine_setup.sh [<path-to-Julia-executable>]","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"If you omit the <path-to-Julia-executable> argument, you will be prompted to enter it, with a default taken from your $PATH. If there is no julia in your $PATH you will be asked if you want the script to download Julia for you, or you can force the download by passing the -d flag (and do not pass a <path-to-Julia-executable>).","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"The script will prompt you for several settings, with sensible defaults (where possible). Note that some settings are needed on all machines - if a setting is not needed it will be ignored.","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"You will be prompted to enter a location for your .julia directory. If you are installing on a cluster which allows access to your home directory from compute nodes, it is fine to leave this as the default. If not (e.g. on ARCHER2), you need to set a path which is accessible from the compute nodes. If you want to create a completely self-contained install (e.g. for reproducibility or for debugging some dependency conflicts), you might want to put .julia within the moment_kinetics directory (e.g. enter . at the prompt).","category":"page"},{"location":"setup_for_moment_kinetics/#After-editing-source-code","page":"Setup for moment_kinetics on known clusters","title":"After editing source code","text":"","category":"section"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"If you use the precompiled moment_kinetics.so system image, you need to recompile it after editing source code (otherwise simulations will continue to use the old source code).","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"To do this, run","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"$ ./precompile-submit.sh","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"and wait for the resulting job to complete.","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"This step is required if you use the sumbit-run.sh or submit-restart.sh scripts, as these both use the moment_kinetics.so system image.","category":"page"},{"location":"setup_for_moment_kinetics/#Running-and-restarting-simulations","page":"Setup for moment_kinetics on known clusters","title":"Running and restarting simulations","text":"","category":"section"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"Convenience scripts are provided to submit jobs running and post-processing a simulation run or restart.","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"$ ./submit-run.sh <path to input file>.toml","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"will submit a job to run a simulation using that input file and (by default) a linked job that will run the post-processing routines (in the serial queue) when the run finishes.","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"Similarly","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"$ ./submit-restart.sh <path to input file>.toml","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"will submit a job to run and post-process a restart using input file. The simulation will restart from the last time point of the previous run (run_moment_kinetics.jl supports more flexibility, but for now you would need to write your own submission script to pass the options needed for that).","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"Default parameters for the runs (number of nodes, time limit, etc.) were set up by machines/machine_setup.sh are stored in LocalPreferences.toml (which can be edited to change them). The parameters can be altered for a particular job (and you can disable the post-processing job) using command line flags described by the help text","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"$ ./submit-run.sh -h","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"or","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"$ ./submit-restart.sh -h","category":"page"},{"location":"setup_for_moment_kinetics/#Advanced-usage","page":"Setup for moment_kinetics on known clusters","title":"Advanced usage","text":"","category":"section"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"The convenience script machine_setup.sh is provide because the actual setup happens in multiple stages, with Julia being restarted in between (as this is required on some machines):","category":"page"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"Start Julia (using the Julia executable you want to use in the end for simulations) from the top level of the moment_kinetics repo, but not requiring the --project flag; run include(\"machines/shared/machine_setup.jl\"); call the moment_kinetics.machine_setup_moment_kinetics function with appropriate settings as arguments (see the docstring).\nThis function requires no packages outside the base Julia system image (because on some machines it is desirable not to have to install any packages before setting JULIA_DEPOT_PATH, which can be done by this function).\nIt saves some settings into LocalPreferences.toml; makes a symlink at bin/julia to the Julia executable being used; saves environment setup  into the julia.env file (which can include setting the  JULIA_DEPOT_PATH environment variable to ensure the .julia  directory is accessible on compute nodes); and if necessary symlinks a  machine-specific file from  machines/shared/machine_setup_stage_two.jl.\nUsually Julia needs to be restarted after running this function, so it will call exit() to stop Julia. This can be avoided by passing the no_force_exit=true argument if that is useful.\nRun source julia.env in each terminal session where you want to use moment_kinetics, or add it to your .bashrc (if this does not conflict with any other projects).\nNote that julia.env runs module purge to remove any already loaded modules (to get a clean environment). It is therefore very likely to interfere with other projects.\nIf it is necessary to run a second stage of setup, for example after Julia is restarted with a special JULIA_DEPOT_PATH, start Julia again, this time with the --project flag. A symlink has been created, so you can use\n$ bin/julia --project\nand run include(\"machines/shared/machine_setup_stage_two.jl\").\nThis script sets up MPI and HDF5.\nIt exits Julia when it is finished, as Julia must be restarted when MPIPreferences settings are changed.\nIf you want to build a precompiled system image (to speed up startup of simulation runs), run\n$ precompile-submit.sh\nwhich will submit a serial or debug job that runs precompile.jl to create the moment_kinetics.so image.\nThis is required if using the submit-run.sh script, unless you edit the jobscript templates in the appropriate subdirectory machines/<your-machine>.","category":"page"},{"location":"setup_for_moment_kinetics/#API-documentation","page":"Setup for moment_kinetics on known clusters","title":"API documentation","text":"","category":"section"},{"location":"setup_for_moment_kinetics/","page":"Setup for moment_kinetics on known clusters","title":"Setup for moment_kinetics on known clusters","text":"Modules = [moment_kinetics.machine_setup]","category":"page"},{"location":"setup_for_moment_kinetics/#moment_kinetics.machine_setup","page":"Setup for moment_kinetics on known clusters","title":"moment_kinetics.machine_setup","text":"Functions to help setting up on known machines\n\n\n\n\n\n","category":"module"},{"location":"setup_for_moment_kinetics/#moment_kinetics.machine_setup.machine_setup_moment_kinetics-NTuple{9, String}","page":"Setup for moment_kinetics on known clusters","title":"moment_kinetics.machine_setup.machine_setup_moment_kinetics","text":"machine_setup_moment_kinetics(machine::String,\n                              account::String,\n                              julia_directory::String,\n                              default_run_time::String,\n                              default_nodes::String,\n                              default_postproc_time::String,\n                              default_postproc_memory::String,\n                              default_partition::String;\n                              default_qos::String;\n                              no_force_exit::Bool=false,\n                              interactive::Bool=true)\n\nDo setup for a known machine:\n\nOn clusters that use a module system, provide julia.env at the top level of the moment_kinetics repo.\nCall\nsource julia.env\nto get the correct modules for running moment_kinetics, either on the command line (to get them for the current session) or in your .bashrc (to get them by default). Note that this calls module purge so will remove any currently loaded modules when it is run.\nRun setup commands for MPI and HDF5 which ensure the correct, system-provided libraries are used.\nMakes a symlink to the Julia exeutable used to run this command at bin/julia under the moment_kinetics repo, so that setup and job submission scripts can use a known relative path.\nnote: Note\nIf you change the Julia executable, e.g. to update to a new verison, you will need to either replace the symlink <moment_kinetics>/bin/julia by hand, or re-run this function using the new executable.\n\njulia_directory gives the location of the directory (usually called .julia) where Julia installs files, saves settings, etc. julia_directory must be passed if this directory should be in a non-default location (i.e. not $HOME/.julia/). The value is used to set JULIA_DEPOT_PATH in the julia.env file, so that this setting is propagated to the environment on the compute nodes.\n\nUsually it is necessary for Julia to be restarted after running this function to ensure the correct MPI is linked, etc. so the function will force Julia to exit. If for some reason this is not desired (e.g. when debugging), pass no_force_exit=true.\n\nThe interactive argument exists so that when this function is called from another script, terminal output with instructions for the next step can be disabled.\n\nThe remaining arguments can be used to change the default settings for jobs submitted using the provided submit-run.sh script. These settings are read by the scripts from LocalPreferences.toml and the values can safely be edited in that file without re-running this function (if you want to). The arguments are:\n\ndefault_run_time is the maximum run time for the simulation, in the format expected by sbatch --time, e.g. \"24:00:00\" for 24 hours, 0 minutes, 0 seconds.\ndefault_nodes is the default number of nodes to use for a simulation run. Note that post-processing always runs in serial (using a serial or debug queue if available).\ndefault_postproc_time is the maximum run time for the post-processing job, in the format expected by sbatch --time, e.g. \"1:00:00\" for 1 hours, 0 minutes, 0 seconds.\ndefault_postproc_memory is the memory requested for the post-processing job, in the format expected by sbatch --mem, e.g. \"64G\" for 64GB.\ndefault_partition is the default 'partition' passed to sbatch --partition. See your cluster's documentation for possible values. The default will be the standard queue, which charges towards the budget of your allocation. You might sometimes want, for example, to change this to a debug queue if one is available.\ndefault_qos is the default 'quality of service' passed to sbatch --qos. See your cluster's documentation for possible values. The default will be the standard queue, which charges towards the budget of your allocation. You might want, for example, to change this to a free, low-priority queue if one is available.\n\nCurrently supported machines:\n\n\"archer\" - the UK supercomputer ARCHER2\n\"marconi\" - the EUROfusion supercomputer   Marconi\n\nnote: Note\nThe settings created by this function are saved in LocalPreferences.toml (using the Preferences.jl package). It might sometimes be useful to edit these by hand (e.g. the account setting if this needs to be changed.): it is fine to do this.\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics","page":"moment_kinetics","title":"moment_kinetics","text":"","category":"section"},{"location":"zz_moment_kinetics/","page":"moment_kinetics","title":"moment_kinetics","text":"Modules = [moment_kinetics.moment_kinetics]","category":"page"},{"location":"zz_moment_kinetics/#moment_kinetics.moment_kinetics","page":"moment_kinetics","title":"moment_kinetics.moment_kinetics","text":"\n\n\n\n","category":"module"},{"location":"zz_moment_kinetics/#moment_kinetics.cleanup_moment_kinetics!-Tuple{Any, Any, Any}","page":"moment_kinetics","title":"moment_kinetics.cleanup_moment_kinetics!","text":"Clean up after a run\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.get_backup_filename-Tuple{Any}","page":"moment_kinetics","title":"moment_kinetics.get_backup_filename","text":"Append a number to the filename, to get a new, non-existing filename to backup the file to.\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.run_moment_kinetics","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"main function that contains all of the content of the program\n\n\n\n\n\n","category":"function"},{"location":"zz_moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{Any}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload with no TimerOutput arguments\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{TimerOutputs.TimerOutput, String}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload which takes a filename and loads input\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload which gets the input file name from command line arguments\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.setup_moment_kinetics-Tuple{Dict}","page":"moment_kinetics","title":"moment_kinetics.setup_moment_kinetics","text":"Perform all the initialization steps for a run.\n\nIf backup_filename is nothing, set up for a regular run; if a filename is passed, reload data from time index given by restart_time_index for a restart.\n\ndebug_loop_type and debug_loop_parallel_dims are used to force specific set ups for parallel loop ranges, and are only used by the tests in debug_test/.\n\n\n\n\n\n","category":"method"},{"location":"wall_boundary_conditions/#Wall-boundary-conditions-with-moment-constraints","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"","category":"section"},{"location":"wall_boundary_conditions/#Ions","page":"Wall boundary conditions with moment constraints","title":"Ions","text":"","category":"section"},{"location":"wall_boundary_conditions/#Boundary-conditions","page":"Wall boundary conditions with moment constraints","title":"Boundary conditions","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"The sheath-edge boundary conditions for the ions is that no ions leave from the sheath edge. So at the lower boundary z=-L_z2","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  f(z=-L2v_parallel0) = 0\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and at the upper boundary z=L_z/2","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  f(z=L2v_parallel0) = 0\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Moment-constraints","page":"Wall boundary conditions with moment constraints","title":"Moment constraints","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"At the sheath-entrance boundary, the constraints need to be enforced slightly differently to how they are done in the bulk of the domain (see Constraints on normalized distribution function). For compatibility with the boundary condition, the corrections which are added to impose the constraints should go to zero at v_parallel=0. Note that the constraints are imposed after the boundary condition is applied by setting f(v_parallel0)=0 on the lower sheath boundary or f(v_parallel0)=0 on the upper sheath boundary.","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"The form of the correction that we choose is","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\ntildeg_s = Ahatg_s + Bw_parallel fracv_parallel1+v_parallelhatg_s + Cw_parallel^2 fracv_parallel1+v_parallelhatg_s\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"We have the same set of constraints","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s  =1\n  frac1sqrtpiint dw_w_tildeg_s  =0\n  frac1sqrtpiint dw_w_^2tildeg_s  =frac12\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Defining the integrals","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  I_n=frac1sqrtpiint dw_w_^nhatg_s\n  J_n=frac1sqrtpiint dw_w_^nfracv_parallel1+v_parallelhatg_s\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"We can write the constraints as","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s=1  =frac1sqrtpiint dw_left(Ahatg_s+Bw_fracv_parallel1+v_parallelhatg_s+Cw_^2fracv_parallel1+v_parallelhatg_sright) \n  =AI_0+BJ_1+CJ_2\n  frac1sqrtpiint dw_w_tildeg_s=0  =frac1sqrtpiint dw_left(Aw_hatg_s+Bw_^2fracv_parallel1+v_parallelhatg_s+Cw_^3fracv_parallel1+v_parallelhatg_sright) \n  =AI_1+BJ_2+CJ_3\n  frac1sqrtpiint dw_w_^2tildeg_s=frac12  =frac1sqrtpiint dw_left(Aw_^2hatg_s+Bw_^3fracv_parallel1+v_parallelhatg_s+Cw_^4fracv_parallel1+v_parallelhatg_sright) \n  =AI_2+BJ_3+CJ_4\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and solving these simultaneous equations","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracleft( frac12 - A I_2 - B J_3 right)J_4  \n  B = -fracA I_1 + C J_3J_2 \n    = -fracI_1J_2 A - fracJ_3J_2 left( frac12J_4 - fracI_2J_4 A - fracJ_3J_4 B right) \n  left( 1 - fracJ_3^2J_2 J_4 right) B = -fracJ_32 J_2 J_4 + left( fracI_2 J_3J_2 J_4 - fracI_1J_2 right) A \n  B = fracleft( fracI_2 J_3J_2 J_4 - fracI_1J_2 right) A - fracJ_32 J_2 J_4left( 1 - fracJ_3^2J_2 J_4 right) \n  = fracleft( I_2 J_3 - I_1 J_4 right) A - fracJ_32J_2 J_4 - J_3^2 \n  1 = A I_0 + B J_1 + C J_2 \n  = A I_0 + B J_1 + fracJ_2J_4left( frac12 - A I_2 - B J_3 right) \n  1 - fracJ_22 J_4 = left( I_0 - fracI_2 J_2J_4 right) A + left( J_1 - fracJ_2 J_3J_4 right) B \n  1 - fracJ_22 J_4 = left( I_0 - fracI_2 J_2J_4 right) A - fracleft( J_1 - fracJ_2 J_3J_4 right) J_32left( J_2 J_4 - J_3^2 right) + fracleft( J_1 - fracJ_2 J_3J_4 right)left( I_2 J_3 - I_1 J_4 right)left( J_2 J_4 - J_3^2 right) A \n  left( 1 - fracJ_22J_4 right) left( J_2 J_4 - J_3^2 right) = left( J_2 J_4 - J_3^2 right) left( I_0 - fracI_2 J_2J_4 right) A - fracleft( J_1 - fracJ_2 J_3J_4 right) J_32 + left( J_1 - fracJ_2 J_3J_4 right) left( I_2 J_3 - I_1 J_4 right) A \n  left( 1 - fracJ_22 J_4 right)left( J_2 J_4 - J_3^2 right) + fracleft( J_1 - fracJ_2 J_3J_4 right) J_32 = left left( J_2 J_4 - J_3^2 right)left( I_0 - fracI_2 J_2J_4 right) + left( J_1 - fracJ_2 J_3J_4 right)left( I_2 J_3 - I_1 J_4 right) right A \n  J_2 J_4 - fracJ_2^22 - J_3^2 + cancelfracJ_2 J_3^22 J_4 + fracJ_1 J_32 - cancelfracJ_2 J_3^22 J_4 = left I_0 J_2 J_4 - I_2 J_2^2 - I_0 J_3^2 + cancelfracI_2 J_2 J_3^2J_4 + I_2 J_1 J_3 - I_1 J_1 J_4 - cancelfracI_2 J_2 J_3^2J_4 + I_1 J_2 J_3 right A \n  J_2 J_4 - fracJ_2^22 + J_3left( fracJ_12 - J_3 right) = left I_0left( J_2 J_4 - J_3^2 right) + I_1left( J_2 J_3 - J_1 J_4 right) + I_2left( J_1 J_3 - J_2^2 right) right A \n  A =fracJ_2 J_4 - fracJ_2^22 + J_3left( fracJ_12 - J_3 right)I_0left( J_2 J_4 - J_3^2 right) + I_1 left( J_2 J_3 - J_1 J_4 right) + I_2left( J_1 J_3 - J_2^2 right)\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"</details>","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracfrac12 - A I_2 - B J_3J_4  \n  B = fracfrac12 J_3 + A (I_1 J_4 - I_2 J_3)J_3^2 - J_2 J_4 \n  A = fracJ_3^2 - J_2 J_4 + frac12 (J_2^2 - J_1 J_3)I_0 (J_3^2 - J_2 J_4) + I_1 (J_1 J_4 - J_2 J_3) + I_2 (J_2^2 - J_1 J_3)\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Evolving-u_\\parallel","page":"Wall boundary conditions with moment constraints","title":"Evolving u_parallel","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When evolving only u_parallel and n separately, we only need two constraints. This corresponds to C=0 so that","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  1 = A I_0 + B J_1 \n  0 = A I_1 + B J_2 \n  B = -fracA I_1J_2 \n  A I_0 = 1 - B J_1 = 1 + fracA I_1 J_1J_2 \n  A = frac1I_0 - fracI_1 J_1J_2\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Evolving-n","page":"Wall boundary conditions with moment constraints","title":"Evolving n","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When only evolving n separately, the constraint is the same as in the bulk of the domain","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  1 = AI_0 \n  A = frac1I_0\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Neutrals","page":"Wall boundary conditions with moment constraints","title":"Neutrals","text":"","category":"section"},{"location":"wall_boundary_conditions/#Boundary-conditions-2","page":"Wall boundary conditions with moment constraints","title":"Boundary conditions","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Ions and neutrals that reach the wall are both recycled as neutrals. The neutrals are emitted from the wall with a 'Knudsen cosine' distribution characterised by a specified temperature T_mathrmwall (see Excalibur report TN-05). The Knudsen distribution is given – here assuming that the magnetic field is perpendicular to the wall (so that v_parallel is the velocity normal to the wall) – by","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"f_Kw(v_zetav_rv_z) = frac34pi left(fracm_iT_mathrmwallright)^2 fracv_zsqrtv_zeta^2 + v_r^2 + v_z^2 expleft( -fracm_i(v_zeta^2 + v_r^2 + v_z^2)2T_mathrmwall right)","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Note that f_Kw is normalised so that it has unit flux int d^3vv_z f_Kw(v_zetav_rv_z) = 1.","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"The boundary condition for the neutrals at the lower target is then (for the neutrals leaving whe wall)","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"f_n(rz=-fracL_z2v_zetav_rv_z0) = Gamma_mathrmlower(r) f_Kw(v_zetav_rv_z)","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and at the upper target","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"f_n(rz=fracL_z2v_zetav_rv_z0) = Gamma_mathrmupper(r) f_Kw(v_zetav_rv_z)","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"A 'recycling fraction' is included, defined so that a fraction 0 leq R_mathrmrecycle leq 1 of the ions hitting the wall are recycled as neutrals, while the whole flux of neutrals hitting the wall is always recycled. (Recycling the 100% of the neutral flux means that the net flux of neutrals - hitting the wall plus recycled - is R_mathrmrecycle times the ion flux, which makes applying boundary conditions in the moment-kinetic approach simpler, see the next section.) This results in","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  Gamma_mathrmlower(r) = R_mathrmrecycle fracB_zB 2pi int_0^infty dv_perp int_-infty^0 dv_parallel v_parallel f_i(r-L2v_perpv_parallel) \n                           quad + int dv_zetadv_r int_-infty^0 dv_z v_z f_n(r-L2v_zetav_rv_z) \n  Gamma_mathrmupper(r) = R_mathrmrecycle fracB_zB 2pi int_0^infty dv_perp int_0^infty dv_parallel v_parallel f_i(rL2v_perpv_parallel) \n                           quad + int dv_zetadv_r int_0^infty dv_z v_z f_n(rL2v_zetav_rv_z)\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"For 1D1V, we 'marginalise' – i.e. integrate over v_perp, assuming that v_parallel=v_z (i.e. the magnetic field is perpendicular to the wall so B_zB = 1) – (see Excalibur report TN-08) which gives","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  f_Kw1V(v_parallel) = int dv_zeta dv_r f_Kw(v_zetav_rv_parallel) = 2pi int dv_perpv_perp f_Kw(v_perpv_parallel) \n                         = 3sqrtpi left(fracm_i2T_mathrmwallright)^32v_parallelmathrmerfcleft(sqrtfracm_i2T_mathrmwallv_parallelright)\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Moment-constraints-2","page":"Wall boundary conditions with moment constraints","title":"Moment constraints","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When using the moment kinetic approach, we first need to apply a boundary condition to the moments so that the net flux of neutrals leaving the wall matches the recycling fraction R_mathrmrecycle times the flux of ions reaching the wall","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  u_paralleln(z=pm L2) = -R_mathrmrecycle fracn_i(z=pm L2) u_paralleli(z=pm L2)n_n(z=pm L2)\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Having enforced the boundary condition on the flux, we need to impose that the outgoing neutrals have the shape of a Knudsen cosine distribution, and ensure that the constraints (Constraints on normalized distribution function) are satisfied. To impose three constraints we need three free parameters. Taking as before the updated, incoming part of the neutral distribution function before moment corrections to be","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  hatg_mathrmin(w_parallel) =\n    begincases\n      H(-w_parallel v_mathrmthn - u_paralleln)hatg(zw_parallel)  textat  z = -L2 \n      H(w_parallel v_mathrmthn + u_paralleln)hatg(zw_parallel)  textat  z = +L2\n    endcases\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and the shape for the Knudsen distribution to be","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  hatg_Kw(w_parallel) =\n    begincases\n      H(w_parallel v_mathrmthn + u_paralleln)f_Kw1V(w_parallel v_mathrmthn + u_paralleln)  textat  z = -L2 \n      H(-w_parallel v_mathrmthn - u_paralleln)f_Kw1V(w_parallel v_mathrmthn + u_paralleln)  textat  z = +L2\n    endcases\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"we define the final updated distribution function to be","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  tildeg_n(w_parallel) = N_mathrmout hatg_Kw + N_mathrmin hatg_mathrmin + C w_parallel hatg_mathrmin\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"(note that if we chose to use v_parallel = w_parallel v_mathrmthn + u_paralleln instead of w_parallel in the final term with the C coefficient, this is just a shift by a constant and scale by another constant, so would have the same form, just with different (but equivalent) values of the N_mathrmin and C coefficients).","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Defining the integrals","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  I_n = int dw_parallel w_parallel^n hatg_mathrmin(w_parallel)\n  K_n = int dw_parallel w_parallel^n hatg_Kw(w_parallel)\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"the constraints are","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dw_tildeg_n=1  =frac1sqrtpiint dw_left(N_mathrmout hatg_Kw + N_mathrmin hatg_mathrmin + C w_parallel hatg_mathrminright) \n  = N_mathrmout K_0 + N_mathrmin I_0 + C I_1 \n  frac1sqrtpiint dw_w_tildeg_n=0  =frac1sqrtpiint dw_left(N_mathrmout w_ hatg_Kw + N_mathrmin w_ hatg_mathrmin + C w_parallel^2 hatg_mathrminright) \n  = N_mathrmout K_1 + N_mathrmin I_1 + C I_2 \n  frac1sqrtpiint dw_w_^2tildeg_n=frac12  =frac1sqrtpiint dw_left(N_mathrmout w_^2 hatg_Kw + N_mathrmin w_^2 hatg_mathrmin + C w_parallel^3 hatg_mathrminright) \n  = N_mathrmout K_2 + N_mathrmin I_2 + C I_3\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"which can be solved to find","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracleft(frac12 - N_mathrmout K_2 - N_mathrmin I_2right)I_3 \n  N_mathrmout = fracleft(-N_mathrmin I_1 - C I_2 right)K_1 \n                 = -fracN_mathrmin I_1K_1 - fracI_2 left(frac12 - N_mathrmout K_2 - N_mathrmin I_2right)K_1 I_3 \n  N_mathrmout K_1 I_3 = -N_mathrmin I_1 I_3 - I_2 left(frac12 - N_mathrmout K_2 - N_mathrmin I_2right) \n  N_mathrmout = -fracleft(N_mathrmin left(I_1 I_3 - I_2^2right) + frac12 I_2right)left(K_1 I_3 - K_2 I_2right) \n  N_mathrmin = fracleft(1 - N_mathrmout K_0 - C I_1right)I_0 \n                = fracleft(1 - N_mathrmout K_0right)I_0 - fracC I_1I_0 \n                = fracleft(1 - N_mathrmout K_0right)I_0 - fracI_1 left(frac12 - N_mathrmout K_2 - N_mathrmin I_2right)I_0 I_3 \n  N_mathrmin I_0 I_3 = left(1 - N_mathrmout K_0right)I_3 - I_1 left(frac12 - N_mathrmout K_2 - N_mathrmin I_2right) \n  N_mathrmin left(I_0 I_3 - I_1 I_2right) = I_3 - frac12 I_1 - N_mathrmout left(K_0 I_3 - I_1 K_2right) \n  N_mathrmin left(I_0 I_3 - I_1 I_2right) = I_3 - frac12 I_1 + left(K_0 I_3 - I_1 K_2right) fracleft(N_mathrmin left(I_1 I_3 - I_2^2right) + frac12 I_2right)left(K_1 I_3 - K_2 I_2right) \n  N_mathrmin left(I_0 I_3 - I_1 I_2right) left(K_1 I_3 - K_2 I_2right) = left(I_3 - frac12 I_1right) left(K_1 I_3 - K_2 I_2right) + left(K_0 I_3 - I_1 K_2right) left(N_mathrmin left(I_1 I_3 - I_2^2right) + frac12 I_2right) \n  N_mathrmin left( left(I_0 I_3 - I_1 I_2right) left(K_1 I_3 - K_2 I_2right) - left(K_0 I_3 - I_1 K_2right) left(I_1 I_3 - I_2^2right) right) = left(I_3 - frac12 I_1right) left(K_1 I_3 - K_2 I_2right) + left(K_0 I_3 - I_1 K_2right) frac12 I_2 \n  N_mathrmin left( K_0 I_3 left(I_2^2 - I_1 I_3right) + K_1 I_3 left(I_0 I_3 - I_1 I_2right) + K_2 left(cancelI_1 I_2^2 - I_0 I_2 I_3 + I_1^2 I_3 - cancelI_1 I_2^2right)right) = frac12 K_0 I_2 I_3 + K_1 I_3 left(I_3 - frac12 I_1right) + K_2 left(cancelfrac12 I_1 I_2 - I_2 I_3 - cancelfrac12 I_1 I_2 right) \n  N_mathrmin left( K_0 left(I_2^2 - I_1 I_3right) + K_1 left(I_0 I_3 - I_1 I_2right) + K_2 left(I_1^2 - I_0 I_2right)right) = frac12 K_0 I_2 + K_1 left(I_3 - frac12 I_1right) - K_2 I_2 \n  N_mathrmin = fracleft(frac12 K_0 I_2 + K_1 left(I_3 - frac12 I_1right) - K_2 I_2right)left( K_0 left(I_2^2 - I_1 I_3right) + K_1 left(I_0 I_3 - I_1 I_2right) + K_2 left(I_1^2 - I_0 I_2right)right) \nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"</details>","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracleft(frac12 - N_mathrmout K_2 - N_mathrmin I_2right)I_3 \n  N_mathrmout = -fracleft(N_mathrmin left(I_1 I_3 - I_2^2right) + frac12 I_2right)left(K_1 I_3 - K_2 I_2right) \n  N_mathrmin = fracleft(frac12 K_0 I_2 + K_1 left(I_3 - frac12 I_1right) - K_2 I_2right)left( K_0 left(I_2^2 - I_1 I_3right) + K_1 left(I_0 I_3 - I_1 I_2right) + K_2 left(I_1^2 - I_0 I_2right)right)\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Evolving-u_\\parallel-2","page":"Wall boundary conditions with moment constraints","title":"Evolving u_parallel","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When evolving only u_parallel and n separately, we only need two constraints. This corresponds to C=0 so that","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  N_mathrmout = -fracI_1K_1 N_mathrmin \n  N_mathrmin = frac1I_0 - fracK_0 I_1K_1\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Evolving-n-2","page":"Wall boundary conditions with moment constraints","title":"Evolving n","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When only evolving n separately, we still have C=0, but N_mathrmin and N_mathrmout must be adjusted to impose the density-moment constraint and the flux boundary condition.","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dv_tildeg_n=1 = frac1sqrtpiint dv_left(N_mathrmout hatg_Kw + N_mathrmin hatg_mathrminright) \n  = N_mathrmout K_0 + N_mathrmin I_0 \n  frac1sqrtpiint dv_v_tildeg_n = u_n = frac1sqrtpiint dv_left(N_mathrmout v_ hatg_Kw + N_mathrmin v_ hatg_mathrmin right) \n  = N_mathrmout K_1 + N_mathrmin I_1\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"where u_n is calculated from the ion flux as above, which can be solved to give","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  N_mathrmout = fracleft(u_n - N_mathrmin I_1right)K_1 \n  1 = N_mathrmin I_0 + fracK_0 left(u_n - N_mathrmin I_1right)K_1 \n  Rightarrow N_mathrmin = fracleft(1 - fracK_0 u_nK_1right)left(I_0 - fracK_0 I_1K_1right)\nendalign","category":"page"},{"location":"zz_neutral_r_advection/#neutral_r_advection","page":"neutral_r_advection","title":"neutral_r_advection","text":"","category":"section"},{"location":"zz_neutral_r_advection/","page":"neutral_r_advection","title":"neutral_r_advection","text":"Modules = [moment_kinetics.neutral_r_advection]","category":"page"},{"location":"zz_neutral_r_advection/#moment_kinetics.neutral_r_advection","page":"neutral_r_advection","title":"moment_kinetics.neutral_r_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_neutral_r_advection/#moment_kinetics.neutral_r_advection.neutral_advection_r!-NTuple{13, Any}","page":"neutral_r_advection","title":"moment_kinetics.neutral_r_advection.neutral_advection_r!","text":"do a single stage time advance in r (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_r_advection/#moment_kinetics.neutral_r_advection.update_speed_neutral_r!-NTuple{6, Any}","page":"neutral_r_advection","title":"moment_kinetics.neutral_r_advection.update_speed_neutral_r!","text":"calculate the advection speed in the r-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#utils","page":"utils","title":"utils","text":"","category":"section"},{"location":"zz_utils/","page":"utils","title":"utils","text":"Modules = [moment_kinetics.utils]","category":"page"},{"location":"zz_utils/#moment_kinetics.utils","page":"utils","title":"moment_kinetics.utils","text":"Utility functions\n\n\n\n\n\n","category":"module"},{"location":"zz_utils/#moment_kinetics.utils.get_unnormalized_parameters","page":"utils","title":"moment_kinetics.utils.get_unnormalized_parameters","text":"get_unnormalized_parameters(input::Dict)\nget_unnormalized_parameters(input_filename::String)\n\nGet many parameters for the simulation setup given by input or in the file input_filename, in SI units and eV, returned as an OrderedDict.\n\n\n\n\n\n","category":"function"},{"location":"zz_utils/#moment_kinetics.utils.print_unnormalized_parameters-Tuple","page":"utils","title":"moment_kinetics.utils.print_unnormalized_parameters","text":"print_unnormalized_parameters(input)\n\nPrint many parameters for the simulation setup given by input (a Dict of parameters or a String giving a filename), in SI units and eV.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.to_hours-Tuple{T} where T<:Dates.TimePeriod","page":"utils","title":"moment_kinetics.utils.to_hours","text":"to_hours(x::T) where {T<:TimePeriod}\n\nConvert a time period x to seconds\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.to_minutes-Tuple{T} where T<:Dates.TimePeriod","page":"utils","title":"moment_kinetics.utils.to_minutes","text":"to_minutes(x::T) where {T<:TimePeriod}\n\nConvert a time period x to seconds\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.to_seconds-Tuple{T} where T<:Dates.TimePeriod","page":"utils","title":"moment_kinetics.utils.to_seconds","text":"to_seconds(x::T) where {T<:TimePeriod}\n\nConvert a time period x to seconds\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The full documentation is online at https://mabarnes.github.io/moment_kinetics.","category":"page"},{"location":"getting_started/#Setup","page":"Getting started","title":"Setup","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you are working on a supported machine, use the machines/machine_setup.sh script, see Setup for moment_kinetics on known clusters. Otherwise:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Ensure that the Julia version is >= 1.7.0 by doing  $ julia --version  at command line.\nDependencies need to be installed to the project  environment. Start Julia with  $ julia --project  (which activates the 'project' in the current directory, or after starting with julia, in the REPL type ] to enter pkg> mode, enter activate . and then backspace to leave pkg> mode). Once in the moment_kinetics project, enter pkg> mode by typing ] and then run the command  (moment_kinetics) pkg> instantiate  this should download and install all the dependencies.\nFor julia>=1.6, pre-compiling dependencies manually is not necessary any more due to improvements to the native pre-compilation, so this step can be skipped (although precompiling the whole moment_kinetics code may still be useful sometimes). To pre-compile a static image (dependencies.so) that includes most of the external packages required for running and post-processing, run  $ julia -O3 precompile_dependencies.jl  To use the precompiled code, add an option -Jdependencies.so when starting julia.  It is also possible to precompile the whole package into a static image (moment_kinetics.so) using  $ julia -O3 precompile.jl this significantly decreases the load time but prevents code changes from taking effect when moment_kinetics.so is used without repeating the precompilation (to use this option, add an option -Jmoment_kinetics.so when starting julia).\nIn the course of development, it is sometimes helpful to upgrade the Julia version. Upgrading the version of Julia or upgrading packages may require a fresh installation of moment_kinetics. To make a fresh install with the latest package versions it is necessary to remove (or rename) the Manifest.jl file in the main directory, and generate a new Manifest.jl with step 1) above. It can sometimes be necessary to remove or rename the .julia/ folder in your root directory for this step to be successful.\nOne may have to set an environment variable to avoid error messages from the Qt library. If you execute the command  $ julia --project run_post_processing.jl runs/your_run_dir/  and see the error message  qt.qpa.xcb: could not connect to display  qt.qpa.plugin: Could not load the Qt platform plugin \"xcb\" in \"\" even though it was found.  This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.  this can be suppressed by setting  export QT_QPA_PLATFORM=offscreen  in your .bashrc or .bash_profile files.","category":"page"},{"location":"getting_started/#Run-a-simulation","page":"Getting started","title":"Run a simulation","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To run julia with optimization, type","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project run_moment_kinetics.jl input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Options are specified in a TOML file, e.g. input.toml here. The defaults are specified in moment_kinetics_input.jl.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To run in parallel, just put mpirun -np <n> in front of the call you would normally use, with <n> the number of processes to use.\nIt may be more convenient when running moment_kinetics more than once to work from the Julia REPL, e.g.   $ julia -O3 --project   julia> using moment_kinetics   julia> run_moment_kinetics(input)   where input is a Dict() containing any non-default options desired.   Input can also be loaded from a TOML file passing the filaname as a String   to the second argument, e.g.   julia> run_moment_kinetics(\"input.toml\")   Especially when developing the code, a lot of compilation time can be saved   by using Revise.jl, and   re-running a test case in the REPL (without restarting julia).","category":"page"},{"location":"getting_started/#Stopping-a-run","page":"Getting started","title":"Stopping a run","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When running in the REPL (especially with MPI) interrupting a run using Ctrl-C can mess things up, and require you to restart Julia. There is also a chance that you might interrupt while writing the output files and corrupt them. To avoid these problems, you can stop the run cleanly (including writing the distribution functions at the last time point, so that it is possible to restart the run from where you stopped it), by creating an empty file called stop in the run directory. For example, if the name of your run is 'my_example'","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ touch runs/my_example/stop","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"moment_kinetics checks for this file when it is going to write output, and if it is present writes all output and then returns cleanly. The 'stop file' is deleted when a run is (re-)started, if present, so you do not have to manually delete it before (re-)starting the run again.","category":"page"},{"location":"getting_started/#Restarting","page":"Getting started","title":"Restarting","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To restart a simulation using input.toml from the last time point in the existing run directory,","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project run_moment_kinetics --restart input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"or to restart from a specific output file - either from the same run or (if the settings are compatible, see below) a different one - here runs/example/example.dfns.h5","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project run_moment_kinetics input.toml runs/example/example.dfns.h5","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The output file must include distribution functions. When not using parallel I/O there will be multiple output files from different MPI ranks - any one of these can be passed.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To do the same from the Julia REPL","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project\njulia> run_moment_kinetics(\"input.toml\", restart=true)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"or","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> run_moment_kinetics(\"input.toml\", restart=\"runs/example/example.dfns.h5\")","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When calling the run_moment_kinetics() function you can also choose a particular time index to restart from, e.g.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> run_moment_kinetics(\"input.toml\", restart=\"runs/example/example.dfns.h5\", restart_time_index=42)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"It is possible to restart a run from another output file with different resolution settings or different moment-kinetic options. This is done by interpolating variables from the old run onto the new grid.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When interpolating in spatial dimensions it is not recommended to change the length of the domain.\nFor velocity space dimensions, changing the size of the domain should be OK. Points outside the original domain will be filled with propto exp(-v^2) decreasing values.\nWhen changing from 1D (no r-dimension) to 2D (with r-dimension), the interpolated values will be constant in r.\nWhen changing from 1V to 2V or 3V, the interpolated values will be proportional to exp(-v_j^2) in the new dimension(s).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When running in parallel, both the old and the new grids must be compatible with the distributed-MPI parallelisation. When not using Parallel I/O, the distributed-MPI domain decomposition must be identical in the old and new runs (as each block only reads from a single file).","category":"page"},{"location":"getting_started/#Post-processing-quickstart","page":"Getting started","title":"Post processing quickstart","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To make plots and calculate frequencies/growth rates, run","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia --project run_post_processing.jl runs/<directory to process>","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"passing the directory to process as a command line argument. Input options for post-processing can be specified in post_processing_input.jl. Note that even when running interactively, it is necessary to restart Julia after modifying post_processing_input.jl.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Post processing can be done for several directories at once using","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia --project post_processing_driver.jl runs/<directory1> runs/<directory2> ...","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"passing the directories to process as command line arguments. Optionally pass a number as the first argument to parallelise post processing of different directories.","category":"page"},{"location":"getting_started/#Alternative-post-processing","page":"Getting started","title":"Alternative post-processing","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"An alternative post-processing module, written to be a bit more generic and flexible, and able to be used interactively, is provided in makie_post_processing, see Post processing.","category":"page"},{"location":"getting_started/#Parallel-I/O","page":"Getting started","title":"Parallel I/O","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Note that to enable parallel I/O, you need to get HDF5.jl to use the system HDF5 library (which must be MPI-enabled and compiled using the same MPI as you run Julia with). To do this (see the HDF5.jl docs) run (with the moment_kinetics project activated in Julia)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using HDF5\n\nHDF5.API.set_libraries!(\"/path/to/your/hdf5/directory/libhdf5.so\",\n                        \"/path/to/your/hdf5/directory/libhdf5_hl.so\")","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"JTO also found that (on a Linux laptop) it was necessary to compile HDF5 from source. The system-provided, MPI-linked libhdf5 depended on libcurl, and Julia links to an incompatible libcurl, causing an error. When compiled from source (enabling MPI!), HDF5 does not require libcurl (guess it is an optional dependency), avoiding the problem.","category":"page"},{"location":"getting_started/#Running-parameter-scans","page":"Getting started","title":"Running parameter scans","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Parameter scans can be run, and can (optionally) use multiple processors. Short summary of implementation and usage:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"mk_input() takes a Dict argument, which can modify values. So mk_input()  sets the 'defaults' (for a scan), which are overridden by any key/value  pairs in the Dict.\nmk_scan_inputs() (in scan_input.jl) creates an Array of Dicts that can  be passed to mk_input(). It first creates a Dict of parameters to scan  over (keys are the names of the variable, values are an Array to scan  over), then assembles an Array of Dicts (where each entry in the Array is a  Dict with a single value for each variable being scanned). Most variables  are combined as an 'inner product', e.g. {:ni=>[0.5, 1.], :nn=>[0.5, 0.]}  gives [{:ni=>0.5, :nn=>0.5}, {ni=>1., nn=>0.}]. Any special variables  specified in the combine_outer array are instead combined with the rest  as an 'outer product', i.e. an entry is created for every value of those  variables for each entry in the 'inner-producted' list. [This was just  complicated enough to run the scans I've done so far without wasted  simulations.]\nThe code in driver.jl picks between a single run (normal case), a  performancetest, or creating a scan by calling `mkscaninput()and then  looping over the returned array, callingmkinput()and running a  simulation for each entry. This loop is parallelised (with the set of  simulations dispatched over several processes - each simulation is still  running serially). Running a scan (on 12 processes - actually 13 but the  'master' process doesn't run any of the loop bodies, so there are 12  'workers'): julia -O3 --project driverjl 12`  (runs in serial if no argument is given)\nThe scan puts each run in a separate directory, named with a prefix  specified by base_name in scan_input.jl and the rest the names and  values of the scanned-over parameters (the names are created in  mk_scan_input() too, and passed as the :run_name entry of the returned  Dicts).\nTo run post_processing.analyze_and_plot_data() over a bunch of directories  (again parallelized trivially, and the number of processes to use is an  optional argument, serial if omitted):  $ julia -O3 --project post_processing_driver.jl 12 runs/scan_name_*\nPlotting the scan is not so general, plot_comparison.jl does it, but is  only set up for the particular scans I ran - everything except the charge  exchange frequencies is hard-coded in.  $ julia -O3 --project plot_comparison.jl","category":"page"},{"location":"getting_started/#Tests","page":"Getting started","title":"Tests","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"There is a test suite in the test/ subdirectory. It can be run in a few ways:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Run using Pkg. Either using pkg> mode   $ julia -O3 --project   julia> <press ']' to enter pkg mode>   (moment_kinetics) pkg> test   using Pkg in the REPL   $ julia -O3 --project   julia> import Pkg   julia> Pkg.test()   or run on the command line   julia -O3 --project -e \"import Pkg; Pkg.test()`\nExecute some or all of the tests as a script. For example in the terminal run   $ julia -O3 --project test/runtests.jl   or in the REPL run   julia> include(\"test/runtests.jl\")   Individual test files can also be used instead of runtests.jl, which runs all the tests.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"By default the test suite should run fairly quickly (in a few minutes). To do so, it skips many cases. To run more comprehensive tests, you can activate the --long option:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Using test_args argument   julia> Pkg.test(; test_args=[\"--long\"])   Note the semicolon is necessary.\nIn the REPL, run   julia> push!(ARGS, \"--long\")   before running the tests.\nRunning from the terminal, pass as a command line argument, e.g.   $ julia -O3 --project --long test/runtests.jl","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To get more output on what tests were successful, an option --verbose (or -v) can be passed in a similar way to --long (if any tests fail, the output is printed by default).","category":"page"}]
}
