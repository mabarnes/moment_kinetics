var documenterSearchIndex = {"docs":
[{"location":"force_balance/#force_balance","page":"force_balance","title":"force_balance","text":"","category":"section"},{"location":"force_balance/","page":"force_balance","title":"force_balance","text":"Modules = [moment_kinetics.force_balance]","category":"page"},{"location":"force_balance/#moment_kinetics.force_balance","page":"force_balance","title":"moment_kinetics.force_balance","text":"\n\n\n\n","category":"module"},{"location":"force_balance/#moment_kinetics.force_balance.force_balance!-NTuple{10, Any}","page":"force_balance","title":"moment_kinetics.force_balance.force_balance!","text":"use the force balance equation d(nu)/dt + d(ppar + nuparupar)/dz = -(dens/2)dphi/dz + Rdensi*densn(uparn-upari) to update the parallel particle flux densupar for each species\n\n\n\n\n\n","category":"method"},{"location":"force_balance/#moment_kinetics.force_balance.force_balance_CX!-NTuple{8, Any}","page":"force_balance","title":"moment_kinetics.force_balance.force_balance_CX!","text":"add the contribution to the evolution of the particle flux arising from charge exchange collisions\n\n\n\n\n\n","category":"method"},{"location":"force_balance/#moment_kinetics.force_balance.force_balance_Epar_species!-NTuple{6, Any}","page":"force_balance","title":"moment_kinetics.force_balance.force_balance_Epar_species!","text":"use the force balance equation d(mnu)/dt + ... = -n*Epar + ... to update mnu; this function accounts for the contribution from the Epar term\n\n\n\n\n\n","category":"method"},{"location":"force_balance/#moment_kinetics.force_balance.force_balance_flux_species!-NTuple{7, Any}","page":"force_balance","title":"moment_kinetics.force_balance.force_balance_flux_species!","text":"use the force balance equation d(mnu)/dt + d(ppar + mnu * u)/dz = ... to update the momentum flux mnu; this function accounts for the contribution from the flux term above\n\n\n\n\n\n","category":"method"},{"location":"force_balance/#moment_kinetics.force_balance.force_balance_ionization!-NTuple{7, Any}","page":"force_balance","title":"moment_kinetics.force_balance.force_balance_ionization!","text":"add the contribution to the evolution of the particle flux arising from ionization collisions\n\n\n\n\n\n","category":"method"},{"location":"z_advection/#z_advection","page":"z_advection","title":"z_advection","text":"","category":"section"},{"location":"z_advection/","page":"z_advection","title":"z_advection","text":"Modules = [moment_kinetics.z_advection]","category":"page"},{"location":"z_advection/#moment_kinetics.z_advection","page":"z_advection","title":"moment_kinetics.z_advection","text":"\n\n\n\n","category":"module"},{"location":"z_advection/#moment_kinetics.z_advection.adjust_advection_speed!-NTuple{6, Any}","page":"z_advection","title":"moment_kinetics.z_advection.adjust_advection_speed!","text":"\n\n\n\n","category":"method"},{"location":"z_advection/#moment_kinetics.z_advection.unnormalize_pdf!-NTuple{6, Any}","page":"z_advection","title":"moment_kinetics.z_advection.unnormalize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"z_advection/#moment_kinetics.z_advection.update_speed_z!-NTuple{9, Any}","page":"z_advection","title":"moment_kinetics.z_advection.update_speed_z!","text":"calculate the advection speed in the z-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"z_advection/#moment_kinetics.z_advection.z_advection!-NTuple{15, Any}","page":"z_advection","title":"moment_kinetics.z_advection.z_advection!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"energy_equation/#energy_equation","page":"energy_equation","title":"energy_equation","text":"","category":"section"},{"location":"energy_equation/","page":"energy_equation","title":"energy_equation","text":"Modules = [moment_kinetics.energy_equation]","category":"page"},{"location":"energy_equation/#moment_kinetics.energy_equation","page":"energy_equation","title":"moment_kinetics.energy_equation","text":"\n\n\n\n","category":"module"},{"location":"energy_equation/#moment_kinetics.energy_equation.energy_equation!-NTuple{9, Any}","page":"energy_equation","title":"moment_kinetics.energy_equation.energy_equation!","text":"\n\n\n\n","category":"method"},{"location":"energy_equation/#moment_kinetics.energy_equation.energy_equation_CX!-NTuple{6, Any}","page":"energy_equation","title":"moment_kinetics.energy_equation.energy_equation_CX!","text":"\n\n\n\n","category":"method"},{"location":"energy_equation/#moment_kinetics.energy_equation.energy_equation_noCX!-NTuple{7, Any}","page":"energy_equation","title":"moment_kinetics.energy_equation.energy_equation_noCX!","text":"\n\n\n\n","category":"method"},{"location":"file_io/#file_io","page":"file_io","title":"file_io","text":"","category":"section"},{"location":"file_io/","page":"file_io","title":"file_io","text":"Modules = [moment_kinetics.file_io]","category":"page"},{"location":"file_io/#moment_kinetics.file_io","page":"file_io","title":"moment_kinetics.file_io","text":"\n\n\n\n","category":"module"},{"location":"file_io/#moment_kinetics.file_io.debug_output_counter","page":"file_io","title":"moment_kinetics.file_io.debug_output_counter","text":"Global counter for calls to debug_dump\n\n\n\n\n\n","category":"constant"},{"location":"file_io/#moment_kinetics.file_io.debug_output_file","page":"file_io","title":"moment_kinetics.file_io.debug_output_file","text":"An nc_info instance that may be initialised for writing debug output\n\nThis is a non-const module variable, so does cause type instability, but it is only used for debugging (from debug_dump()) so performance is not critical.\n\n\n\n\n\n","category":"constant"},{"location":"file_io/#moment_kinetics.file_io.ios","page":"file_io","title":"moment_kinetics.file_io.ios","text":"structure containing the various input/output streams\n\n\n\n\n\n","category":"type"},{"location":"file_io/#moment_kinetics.file_io.netcdf_info","page":"file_io","title":"moment_kinetics.file_io.netcdf_info","text":"structure containing the data/metadata needed for netcdf file i/o\n\n\n\n\n\n","category":"type"},{"location":"file_io/#moment_kinetics.file_io.debug_dump","page":"file_io","title":"moment_kinetics.file_io.debug_dump","text":"debug_dump(ff, dens, upar, ppar, phi, t; istage=0, label=\"\")\ndebug_dump(fvec::scratch_pdf, fields::em_fields_struct, t; istage=0, label=\"\")\n\nDump variables into a NetCDF file for debugging\n\nIntended to be called more frequently than write_data_to_binary(), possibly several times within a timestep, so includes a label argument to identify the call site.\n\nWrites to a file called debug_output.cdf in the current directory.\n\nCan either be called directly with the arrays to be dumped (fist signature), or using scratch_pdf and em_fields_struct structs.\n\nnothing can be passed to any of the positional arguments (if they are unavailable at a certain point in the code, or just not interesting). t=nothing will set t to the value saved in the previous call (or 0.0 on the first call). Passing nothing to the other arguments will set that array to 0.0 for this call (need to write some value so all the arrays have the same length, with an entry for each call to debug_dump()).\n\n\n\n\n\n","category":"function"},{"location":"file_io/#moment_kinetics.file_io.define_dimensions!","page":"file_io","title":"moment_kinetics.file_io.define_dimensions!","text":"define_dimensions!(fid, nvpa, nvperp, nz, nr, n_species, n_ion_species=nothing,\n                   n_neutral_species=nothing)\n\nDefine dimensions for an output file.\n\n\n\n\n\n","category":"function"},{"location":"file_io/#moment_kinetics.file_io.define_dynamic_variables!-Tuple{Any}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_variables!","text":"define_dynamic_variables!(fid)\n\nDefine dynamic (i.e. time-evolving) variables for an output file.\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.define_static_variables!-NTuple{7, Any}","page":"file_io","title":"moment_kinetics.file_io.define_static_variables!","text":"define_static_variables!(vpa,vperp,z,r,composition,collisions,evolve_ppar)\n\nDefine static (i.e. time-independent) variables for an output file.\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.finish_file_io-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.finish_file_io","text":"close all opened output files\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.input_option_error-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.input_option_error","text":"accepts an option name which has been identified as problematic and returns an appropriate error message\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.open_output_file-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.open_output_file","text":"opens an output file with the requested prefix and extension and returns the corresponding io stream (identifier)\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.setup_file_io-NTuple{8, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_file_io","text":"open the necessary output files\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.setup_netcdf_io-NTuple{7, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_netcdf_io","text":"setup file i/o for netcdf\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_data_to_ascii-NTuple{9, Any}","page":"file_io","title":"moment_kinetics.file_io.write_data_to_ascii","text":"\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_data_to_binary-NTuple{7, Any}","page":"file_io","title":"moment_kinetics.file_io.write_data_to_binary","text":"write time-dependent data to the netcdf file\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_f_ascii-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.write_f_ascii","text":"write the function f(z,vpa) at this time slice\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_fields_ascii-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.write_fields_ascii","text":"write electrostatic potential at this time slice\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_moments_ascii-NTuple{6, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_ascii","text":"write moments of the distribution function f(z,vpa) at this time slice\n\n\n\n\n\n","category":"method"},{"location":"clenshaw_curtis/#clenshaw_curtis","page":"clenshaw_curtis","title":"clenshaw_curtis","text":"","category":"section"},{"location":"clenshaw_curtis/","page":"clenshaw_curtis","title":"clenshaw_curtis","text":"Modules = [moment_kinetics.clenshaw_curtis]","category":"page"},{"location":"clenshaw_curtis/#moment_kinetics.clenshaw_curtis","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis","text":"\n\n\n\n","category":"module"},{"location":"clenshaw_curtis/#moment_kinetics.clenshaw_curtis.chebyshevpoints-Tuple{Any}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.chebyshevpoints","text":"\n\n\n\n","category":"method"},{"location":"clenshaw_curtis/#moment_kinetics.clenshaw_curtis.clenshawcurtisnodes-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.clenshawcurtisnodes","text":"Compute nodes of the Clenshaw—Curtis quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"clenshaw_curtis/#moment_kinetics.clenshaw_curtis.clenshawcurtisweights-Tuple{}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.clenshawcurtisweights","text":"Compute weights of the Clenshaw—Curtis quadrature rule with modified Chebyshev moments of the first kind (μ)\n\n\n\n\n\n","category":"method"},{"location":"clenshaw_curtis/#moment_kinetics.clenshaw_curtis.plan_clenshawcurtis-Tuple{Any}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.plan_clenshawcurtis","text":"\n\n\n\n","category":"method"},{"location":"ionization/#ionization","page":"ionization","title":"ionization","text":"","category":"section"},{"location":"ionization/","page":"ionization","title":"ionization","text":"Modules = [moment_kinetics.ionization]","category":"page"},{"location":"ionization/#moment_kinetics.ionization","page":"ionization","title":"moment_kinetics.ionization","text":"\n\n\n\n","category":"module"},{"location":"ionization/#moment_kinetics.ionization.ionization_collisions!-NTuple{12, Any}","page":"ionization","title":"moment_kinetics.ionization.ionization_collisions!","text":"\n\n\n\n","category":"method"},{"location":"communication/#communication","page":"communication","title":"communication","text":"","category":"section"},{"location":"communication/","page":"communication","title":"communication","text":"Modules = [moment_kinetics.communication]","category":"page"},{"location":"communication/#moment_kinetics.communication","page":"communication","title":"moment_kinetics.communication","text":"Communication functions and setup\n\nSplit the grid into 'blocks'. Each block can use shared memory (MPI shared memory arrays). At the moment only works with a single 'block' containing the whole grid - eventually add more MPI communication functions to communicate between blocks. A block should probably be a 'NUMA region' for maximum efficiency.\n\nNote: charge-exchange collisions loop over neutral species for each ion species. At the moment this loop is not parallelised (although it could be, by introducing some more loop ranges), as at the moment we only run with 1 ion species and 1 neutral species.\n\n\n\n\n\n","category":"module"},{"location":"communication/#moment_kinetics.communication.block_rank","page":"communication","title":"moment_kinetics.communication.block_rank","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.block_size","page":"communication","title":"moment_kinetics.communication.block_size","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.comm_block","page":"communication","title":"moment_kinetics.communication.comm_block","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.comm_world","page":"communication","title":"moment_kinetics.communication.comm_world","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.global_Win_store","page":"communication","title":"moment_kinetics.communication.global_Win_store","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.global_rank","page":"communication","title":"moment_kinetics.communication.global_rank","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.global_size","page":"communication","title":"moment_kinetics.communication.global_size","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.MPISharedArray","page":"communication","title":"moment_kinetics.communication.MPISharedArray","text":"\n\n\n\n","category":"type"},{"location":"communication/#moment_kinetics.communication.__init__-Tuple{}","page":"communication","title":"moment_kinetics.communication.__init__","text":"\n\n\n\n","category":"method"},{"location":"communication/#moment_kinetics.communication._block_synchronize-Tuple{}","page":"communication","title":"moment_kinetics.communication._block_synchronize","text":"Call an MPI Barrier for all processors in a block.\n\nUsed to synchronise processors that are working on the same shared-memory array(s) between operations, to avoid race conditions. Should be (much) cheaper than a global MPI Barrier because it only requires communication within a single node.\n\nNote: some debugging code currently assumes that if blocksynchronize() is called on one block, it is called simultaneously on all blocks. It seems likely that this will always be true, but if it ever changes (i.e. different blocks doing totally different work), the debugging routines need to be updated.\n\n\n\n\n\n","category":"method"},{"location":"communication/#moment_kinetics.communication.allocate_shared-Tuple{Any, Any}","page":"communication","title":"moment_kinetics.communication.allocate_shared","text":"Get a shared-memory array of mk_float (shared by all processes in a 'block')\n\nCreate a shared-memory array using MPI.Win_allocate_shared(). Pointer to the memory allocated is wrapped in a Julia array. Memory is not managed by the Julia array though. A reference to the MPI.Win needs to be freed - this is done by saving the MPI.Win into a Vector in the Communication module, which has all its entries freed by the finalize_comms!() function, which should be called when moment_kinetics is done running a simulation/test.\n\nArguments\n\ndims - mkint or Tuple{mkint}     Dimensions of the array to be created. Dimensions passed define the size of the     array which is being handled by the 'block' (rather than the global array, or a     subset for a single process).\n\nReturns\n\nArray{mk_float}\n\n\n\n\n\n","category":"method"},{"location":"communication/#moment_kinetics.communication.finalize_comms!-Tuple{}","page":"communication","title":"moment_kinetics.communication.finalize_comms!","text":"Clean up from communications\n\nDo any needed clean-up for MPI, etc. Does not call MPI.Finalize() - this is called anyway when Julia exits, and we do not want to call it explicitly so that multiple runs can be done in a single Julia session.\n\nFrees any shared-memory arrays.\n\n\n\n\n\n","category":"method"},{"location":"communication/#moment_kinetics.communication.free_shared_arrays-Tuple{}","page":"communication","title":"moment_kinetics.communication.free_shared_arrays","text":"\n\n\n\n","category":"method"},{"location":"communication/#moment_kinetics.communication.initialize_comms!-Tuple{}","page":"communication","title":"moment_kinetics.communication.initialize_comms!","text":"Set up communications\n\nCheck that global variables are in the correct state (i.e. caches were emptied correctly if they were used before).\n\nAlso does some set up for debugging routines, if they are active.\n\n\n\n\n\n","category":"method"},{"location":"debugging/#debugging","page":"debugging","title":"debugging","text":"","category":"section"},{"location":"debugging/","page":"debugging","title":"debugging","text":"Modules = [moment_kinetics.debugging]","category":"page"},{"location":"debugging/#moment_kinetics.debugging","page":"debugging","title":"moment_kinetics.debugging","text":"Define debugging levels that can be used to include extra debugging steps\n\nProvides a bunch of macros (see the macronames Vector) that can be used to surround code in other modules so that it only runs if the 'debug level' passed to the --debug or -d command line argument is high enough.\n\nAlso provides macro *_ifelse whose names are taken from macronames, which can be used to switch definitions, etc. For example, if debug_shared_array is in macronames, then\n\nconst MPISharedArray = @debug_shared_array_ifelse(DebugMPISharedArray, Array)\n\ncan be used to make the type represented by MPISharedArray depend on the debug level.\n\n\n\n\n\n","category":"module"},{"location":"debugging/#moment_kinetics.debugging._debug_level","page":"debugging","title":"moment_kinetics.debugging._debug_level","text":"\n\n\n\n","category":"constant"},{"location":"debugging/#moment_kinetics.debugging.macronames","page":"debugging","title":"moment_kinetics.debugging.macronames","text":"\n\n\n\n","category":"constant"},{"location":"debugging/#moment_kinetics.debugging.@debug_block_synchronize-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_block_synchronize","text":"Check blocksynchronize() was called from the same place on every process.  Activated at _debug_level >= 2  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_block_synchronize_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_block_synchronize_ifelse","text":"Evaluate first expression if debugblocksynchronize is active, second expression if not  debugblocksynchronize is inactive (_debug_level = 0 < 2).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_detect_redundant_block_synchronize-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_detect_redundant_block_synchronize","text":"Check if any blocksynchronize() call could have been skipped without resulting in an error.  Activated at _debug_level >= 4  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_detect_redundant_block_synchronize_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_detect_redundant_block_synchronize_ifelse","text":"Evaluate first expression if debugdetectredundantblocksynchronize is active, second expression if not  debugdetectredundantblocksynchronize is inactive (_debug_level = 0 < 4).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_error_stop_all-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_error_stop_all","text":"Use MPI.Allgather to stop all processes following an error on any process.  Activated at _debug_level >= 1  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_error_stop_all_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_error_stop_all_ifelse","text":"Evaluate first expression if debugerrorstopall is active, second expression if not  debugerrorstopall is inactive (_debug_level = 0 < 1).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_initialize_NaN-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_initialize_NaN","text":"Initialize arrays with NaN.  Activated at _debug_level >= 1  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_initialize_NaN_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_initialize_NaN_ifelse","text":"Evaluate first expression if debuginitializeNaN is active, second expression if not  debuginitializeNaN is inactive (_debug_level = 0 < 1).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_shared_array-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array","text":"Check for incorrect reads/writes to shared-memory arrays  Activated at _debug_level >= 2  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_shared_array_allocate-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_allocate","text":"Check that allocateshared() was called from the same place on every process.  Activated at `debuglevel >= 3Currently inactive (debug_level = 0`).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_shared_array_allocate_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_allocate_ifelse","text":"Evaluate first expression if debugsharedarrayallocate is active, second expression if not  debugsharedarrayallocate is inactive (_debug_level = 0 < 3).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_shared_array_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_ifelse","text":"Evaluate first expression if debugsharedarray is active, second expression if not  debugsharedarray is inactive (_debug_level = 0 < 2).\n\n\n\n\n\n","category":"macro"},{"location":"coordinates/#coordinates","page":"coordinates","title":"coordinates","text":"","category":"section"},{"location":"coordinates/","page":"coordinates","title":"coordinates","text":"Modules = [moment_kinetics.coordinates]","category":"page"},{"location":"coordinates/#moment_kinetics.coordinates","page":"coordinates","title":"moment_kinetics.coordinates","text":"\n\n\n\n","category":"module"},{"location":"coordinates/#moment_kinetics.coordinates.coordinate","page":"coordinates","title":"moment_kinetics.coordinates.coordinate","text":"structure containing basic information related to coordinates\n\n\n\n\n\n","category":"type"},{"location":"coordinates/#moment_kinetics.coordinates.define_coordinate","page":"coordinates","title":"moment_kinetics.coordinates.define_coordinate","text":"create arrays associated with a given coordinate, setup the coordinate grid, and populate the coordinate structure containing all of this information\n\n\n\n\n\n","category":"function"},{"location":"coordinates/#moment_kinetics.coordinates.elemental_to_full_grid_map-Tuple{Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.elemental_to_full_grid_map","text":"returns imin and imax, which contain the minimum and maximum indices on the full grid for each element\n\n\n\n\n\n","category":"method"},{"location":"coordinates/#moment_kinetics.coordinates.equally_spaced_grid-Tuple{Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.equally_spaced_grid","text":"setup an equally spaced grid with n grid points between [-L/2,L/2]\n\n\n\n\n\n","category":"method"},{"location":"coordinates/#moment_kinetics.coordinates.full_to_elemental_grid_map-Tuple{Any, Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.full_to_elemental_grid_map","text":"setup arrays containing a map from the unpacked grid point indices to the element index and the grid point index within each element\n\n\n\n\n\n","category":"method"},{"location":"coordinates/#moment_kinetics.coordinates.grid_spacing-Tuple{Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.grid_spacing","text":"given a set of grid point locations calculate and return the length associated with the cell between adjacent grid points\n\n\n\n\n\n","category":"method"},{"location":"coordinates/#moment_kinetics.coordinates.init_grid-NTuple{8, Any}","page":"coordinates","title":"moment_kinetics.coordinates.init_grid","text":"setup a grid with n grid points on the interval [-L/2,L/2]\n\n\n\n\n\n","category":"method"},{"location":"semi_lagrange/#semi_lagrange","page":"semi_lagrange","title":"semi_lagrange","text":"","category":"section"},{"location":"semi_lagrange/","page":"semi_lagrange","title":"semi_lagrange","text":"Modules = [moment_kinetics.semi_lagrange]","category":"page"},{"location":"semi_lagrange/#moment_kinetics.semi_lagrange","page":"semi_lagrange","title":"moment_kinetics.semi_lagrange","text":"\n\n\n\n","category":"module"},{"location":"semi_lagrange/#moment_kinetics.semi_lagrange.semi_lagrange_info","page":"semi_lagrange","title":"moment_kinetics.semi_lagrange.semi_lagrange_info","text":"structure semilagrangeinfo contains the basic information needed to project backwards along approximate characteristics, which underpins the semi-Lagrange approach to time advancement\n\n\n\n\n\n","category":"type"},{"location":"semi_lagrange/#moment_kinetics.semi_lagrange.calculate_time_from_boundary!-NTuple{6, Any}","page":"semi_lagrange","title":"moment_kinetics.semi_lagrange.calculate_time_from_boundary!","text":"if periodic boundary condition, will be most efficient to store the time taken by a characteristic to pass from the downwind boundary to each point on the grid, as this will be used for all characteristics that wrap around from -L/2 to L/2\n\ntbound is the time spent on a characteristic in getting from the downdiwnd boundary to the ith grid point\n\n\n\n\n\n","category":"method"},{"location":"semi_lagrange/#moment_kinetics.semi_lagrange.departure_point!-NTuple{13, Any}","page":"semi_lagrange","title":"moment_kinetics.semi_lagrange.departure_point!","text":"calculate the departure point for the ith characteristic; overwrites SL.deppts[i], SL.depidx[i], and returns ... note that the dep_idx calculated here is the index of the nearest downwind gridpoint to the departure point (which is in general off-grid)\n\n\n\n\n\n","category":"method"},{"location":"semi_lagrange/#moment_kinetics.semi_lagrange.departure_point_single_transit!-NTuple{10, Any}","page":"semi_lagrange","title":"moment_kinetics.semi_lagrange.departure_point_single_transit!","text":"t_in is the time spent by a particle following this ith characteristic in going from the arrival point (grid point i at future time level) to the grid point jstart; note that the jstart grid point is the grid point immediately downwind of the departure point for the characteristic immediately downwind of this (ith) one.\n\n\n\n\n\n","category":"method"},{"location":"semi_lagrange/#moment_kinetics.semi_lagrange.find_approximate_characteristic!-NTuple{6, Any}","page":"semi_lagrange","title":"moment_kinetics.semi_lagrange.find_approximate_characteristic!","text":"\n\n\n\n","category":"method"},{"location":"semi_lagrange/#moment_kinetics.semi_lagrange.find_departure_points!-NTuple{7, Any}","page":"semi_lagrange","title":"moment_kinetics.semi_lagrange.find_departure_points!","text":"follow trajectory from each grid point at time level n+1 backwards in time until Δt has elapsed to find the departure points and the indices of the nearest downwind grid points to the departure points SL.deppts: array containing the locations of the departure points SL.depidx: array containing the indices of the nearest downwind grid point to the departure point tbound: array used to store the cumulative time spent by a particle moving along its characteristic backwards from the downwind boundary.  only needed if BC is periodic SL.crossing_time: array containing the amount of time required to cross each cell speed: the advection speed at the grid point locations given by coord.grid coord.grid: grid point locations dt: time step size\n\n\n\n\n\n","category":"method"},{"location":"semi_lagrange/#moment_kinetics.semi_lagrange.project_characteristics_onto_grid!-NTuple{7, Any}","page":"semi_lagrange","title":"moment_kinetics.semi_lagrange.project_characteristics_onto_grid!","text":"determine the nearest grid point to each departure point\n\n\n\n\n\n","category":"method"},{"location":"semi_lagrange/#moment_kinetics.semi_lagrange.setup_semi_lagrange-Tuple","page":"semi_lagrange","title":"moment_kinetics.semi_lagrange.setup_semi_lagrange","text":"create and return a structure containing the arrays needed for the semi-Lagrange time advance\n\n\n\n\n\n","category":"method"},{"location":"semi_lagrange/#moment_kinetics.semi_lagrange.update_crossing_times!-Tuple{Any, Any, Any}","page":"semi_lagrange","title":"moment_kinetics.semi_lagrange.update_crossing_times!","text":"obtain the time needed to cross the cell assigned to each grid point, given the advection speed within the cell d is an array contain cell widths, with d[1]=d[n] the distance between the 1st and 2nd grid points v is an array containing the speeds at grid points NB: assuming constant advection speed within each cell, taken as speed NB: at neighboring downwind grid point NB: might be better and not much harder to analytically solve NB: for crossing time assuming, e.g., linear variation of advection speed\n\n\n\n\n\n","category":"method"},{"location":"command_line_options/#command_line_options","page":"command_line_options","title":"command_line_options","text":"","category":"section"},{"location":"command_line_options/","page":"command_line_options","title":"command_line_options","text":"Modules = [moment_kinetics.command_line_options]","category":"page"},{"location":"command_line_options/#moment_kinetics.command_line_options","page":"command_line_options","title":"moment_kinetics.command_line_options","text":"Parse command line arguments\n\nHave to include test options here too, because ArgParse errors on unrecognized options.\n\n\n\n\n\n","category":"module"},{"location":"command_line_options/#moment_kinetics.command_line_options.get_options-Tuple{}","page":"command_line_options","title":"moment_kinetics.command_line_options.get_options","text":"\n\n\n\n","category":"method"},{"location":"type_definitions/#type_definitions","page":"type_definitions","title":"type_definitions","text":"","category":"section"},{"location":"type_definitions/","page":"type_definitions","title":"type_definitions","text":"Modules = [moment_kinetics.type_definitions]","category":"page"},{"location":"type_definitions/#moment_kinetics.type_definitions","page":"type_definitions","title":"moment_kinetics.type_definitions","text":"\n\n\n\n","category":"module"},{"location":"type_definitions/#moment_kinetics.type_definitions.mk_float","page":"type_definitions","title":"moment_kinetics.type_definitions.mk_float","text":"\n\n\n\n","category":"type"},{"location":"type_definitions/#moment_kinetics.type_definitions.mk_int","page":"type_definitions","title":"moment_kinetics.type_definitions.mk_int","text":"\n\n\n\n","category":"type"},{"location":"post_processing_input/#post_processing_input","page":"post_processing_input","title":"post_processing_input","text":"","category":"section"},{"location":"post_processing_input/","page":"post_processing_input","title":"post_processing_input","text":"Modules = [moment_kinetics.post_processing_input]","category":"page"},{"location":"post_processing_input/#moment_kinetics.post_processing_input","page":"post_processing_input","title":"moment_kinetics.post_processing_input","text":"\n\n\n\n","category":"module"},{"location":"initial_conditions/#initial_conditions","page":"initial_conditions","title":"initial_conditions","text":"","category":"section"},{"location":"initial_conditions/","page":"initial_conditions","title":"initial_conditions","text":"Modules = [moment_kinetics.initial_conditions]","category":"page"},{"location":"initial_conditions/#moment_kinetics.initial_conditions","page":"initial_conditions","title":"moment_kinetics.initial_conditions","text":"\n\n\n\n","category":"module"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.pdf_struct","page":"initial_conditions","title":"moment_kinetics.initial_conditions.pdf_struct","text":"\n\n\n\n","category":"type"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.create_and_init_pdf-NTuple{6, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.create_and_init_pdf","text":"\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_boundary_conditions!-Union{Tuple{T2}, Tuple{T1}, Tuple{Any, Any, Any, Any, Any, Any, Any, Any, T1, T2, Any}} where {T1, T2}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_boundary_conditions!","text":"enforce boundary conditions in vpa and z on the evolved pdf; also enforce boundary conditions in z on all separately evolved velocity space moments of the pdf\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_neutral_wall_bc!-NTuple{12, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_neutral_wall_bc!","text":"enforce the wall boundary condition on neutrals; i.e., the incoming flux of neutrals equals the sum of the ion/neutral outgoing fluxes\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_vpa_boundary_condition!-Union{Tuple{T}, Tuple{Any, Any, T}} where T","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_vpa_boundary_condition!","text":"impose the prescribed vpa boundary condition on f at every z grid point\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_vpa_boundary_condition_local!-Union{Tuple{T}, Tuple{T, Any, Any, Any}} where T","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_vpa_boundary_condition_local!","text":"\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_z_boundary_condition!-Union{Tuple{T}, Tuple{Any, Any, Any, Any, String, T, Any, Any, Any}} where T","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_z_boundary_condition!","text":"enforce boundary conditions on f in z\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_z_boundary_condition_moments!-Tuple{Any, Any, String}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_z_boundary_condition_moments!","text":"enforce the z boundary condition on the evolved velocity space moments of f\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_zero_incoming_bc!-Tuple{Any, Any, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_zero_incoming_bc!","text":"enforce a zero incoming BC in z for given species pdf at each radial location\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.init_density!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_density!","text":"\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.init_pdf_and_moments-NTuple{8, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_pdf_and_moments","text":"creates the normalised pdf and the velocity-space moments and populates them with a self-consistent initial condition\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.init_pdf_over_density!-NTuple{9, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_pdf_over_density!","text":"\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.init_upar!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_upar!","text":"for now the only initialisation option is zero parallel flow\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.init_vth!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_vth!","text":"for now the only initialisation option for the temperature is constant in z returns vth0 = sqrt(2Ts/ms) / sqrt(2Te/ms) = sqrt(Ts/Te)\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.vpagrid_to_dzdt-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.vpagrid_to_dzdt","text":"create an array of dz/dt values corresponding to the given vpagrid values\n\n\n\n\n\n","category":"method"},{"location":"em_fields/#em_fields","page":"em_fields","title":"em_fields","text":"","category":"section"},{"location":"em_fields/","page":"em_fields","title":"em_fields","text":"Modules = [moment_kinetics.em_fields]","category":"page"},{"location":"em_fields/#moment_kinetics.em_fields","page":"em_fields","title":"moment_kinetics.em_fields","text":"\n\n\n\n","category":"module"},{"location":"em_fields/#moment_kinetics.em_fields.setup_em_fields-NTuple{5, Any}","page":"em_fields","title":"moment_kinetics.em_fields.setup_em_fields","text":"\n\n\n\n","category":"method"},{"location":"em_fields/#moment_kinetics.em_fields.update_phi!-NTuple{5, Any}","page":"em_fields","title":"moment_kinetics.em_fields.update_phi!","text":"update_phi updates the electrostatic potential, phi\n\n\n\n\n\n","category":"method"},{"location":"input_structs/#input_structs","page":"input_structs","title":"input_structs","text":"","category":"section"},{"location":"input_structs/","page":"input_structs","title":"input_structs","text":"Modules = [moment_kinetics.input_structs]","category":"page"},{"location":"input_structs/#moment_kinetics.input_structs","page":"input_structs","title":"moment_kinetics.input_structs","text":"\n\n\n\n","category":"module"},{"location":"input_structs/#moment_kinetics.input_structs.advection_input","page":"input_structs","title":"moment_kinetics.input_structs.advection_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.advection_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.advection_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.collisions_input","page":"input_structs","title":"moment_kinetics.input_structs.collisions_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.drive_input","page":"input_structs","title":"moment_kinetics.input_structs.drive_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.drive_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.drive_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.electron_physics_type","page":"input_structs","title":"moment_kinetics.input_structs.electron_physics_type","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.evolve_moments_options","page":"input_structs","title":"moment_kinetics.input_structs.evolve_moments_options","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.grid_input","page":"input_structs","title":"moment_kinetics.input_structs.grid_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.grid_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.grid_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.initial_condition_input","page":"input_structs","title":"moment_kinetics.input_structs.initial_condition_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.initial_condition_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.initial_condition_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.pp_input","page":"input_structs","title":"moment_kinetics.input_structs.pp_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.species_composition","page":"input_structs","title":"moment_kinetics.input_structs.species_composition","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.species_parameters","page":"input_structs","title":"moment_kinetics.input_structs.species_parameters","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.species_parameters_mutable","page":"input_structs","title":"moment_kinetics.input_structs.species_parameters_mutable","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.time_input","page":"input_structs","title":"moment_kinetics.input_structs.time_input","text":"\n\n\n\n","category":"type"},{"location":"calculus/#calculus","page":"calculus","title":"calculus","text":"","category":"section"},{"location":"calculus/","page":"calculus","title":"calculus","text":"Modules = [moment_kinetics.calculus]","category":"page"},{"location":"calculus/#moment_kinetics.calculus","page":"calculus","title":"moment_kinetics.calculus","text":"\n\n\n\n","category":"module"},{"location":"calculus/#moment_kinetics.calculus.derivative!-NTuple{4, Any}","page":"calculus","title":"moment_kinetics.calculus.derivative!","text":"derivative!(df, f, coord, spectral)\n\nNon-upwinding derivative.\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.derivative!-NTuple{5, Any}","page":"calculus","title":"moment_kinetics.calculus.derivative!","text":"derivative!(df, f, coord, adv_fac, spectral)\n\nUpwinding derivative.\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.derivative_elements_to_full_grid!-Tuple{Any, Any, Any, AbstractVector{Float64}}","page":"calculus","title":"moment_kinetics.calculus.derivative_elements_to_full_grid!","text":"\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.derivative_elements_to_full_grid!-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.derivative_elements_to_full_grid!","text":"\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.elements_to_full_grid_interior_pts!-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.elements_to_full_grid_interior_pts!","text":"maps the derivative at points away from element boundaries from the grid/element representation to the full grid representation\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.elementwise_derivative!","page":"calculus","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, adv_fac, spectral)\nelementwise_derivative!(coord, f, spectral)\n\nGeneric function for element-by-element derivatives\n\nFirst signature, with adv_fac, calculates an upwind derivative, the second signature calculates a derivative without upwinding information.\n\nResult is stored in coord.scratch_2d.\n\n\n\n\n\n","category":"function"},{"location":"calculus/#moment_kinetics.calculus.integral-NTuple{4, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand multiplied by v^n, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.integral-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand multiplied by v, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.integral-Tuple{Any, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.reconcile_element_boundaries_centered!-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.reconcile_element_boundaries_centered!","text":"if at the boundary point within the element, must carefully choose which value of df to use; this is because df is multi-valued at the overlapping point at the boundary between neighboring elements. here we choose to use the value of df from the upwind element.\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.reconcile_element_boundaries_upwind!-Tuple{Any, Any, Any, AbstractVector{Float64}}","page":"calculus","title":"moment_kinetics.calculus.reconcile_element_boundaries_upwind!","text":"if at the boundary point within the element, must carefully choose which value of df to use; this is because df is multi-valued at the overlapping point at the boundary between neighboring elements. here we choose to use the value of df from the upwind element.\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#velocity_moments","page":"velocity_moments","title":"velocity_moments","text":"","category":"section"},{"location":"velocity_moments/","page":"velocity_moments","title":"velocity_moments","text":"Modules = [moment_kinetics.velocity_moments]","category":"page"},{"location":"velocity_moments/#moment_kinetics.velocity_moments","page":"velocity_moments","title":"moment_kinetics.velocity_moments","text":"\n\n\n\n","category":"module"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.moments","page":"velocity_moments","title":"moment_kinetics.velocity_moments.moments","text":"\n\n\n\n","category":"type"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.create_moments-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.create_moments","text":"\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.enforce_moment_constraints!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.enforce_moment_constraints!","text":"\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.integrate_over_negative_vpa-NTuple{4, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_negative_vpa","text":"computes the integral over vpa <= 0 of the integrand, using the input vpa_wgts this could be made more efficient for the case that dz/dt = vpa is time-independent, but it has been left general for the cases where, e.g., dz/dt = wpa*vth + upar varies in time\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.integrate_over_positive_vpa-NTuple{4, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_positive_vpa","text":"computes the integral over vpa >= 0 of the integrand, using the input vpa_wgts this could be made more efficient for the case that dz/dt = vpa is time-independent, but it has been left general for the cases where, e.g., dz/dt = wpa*vth + upar varies in time\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.integrate_over_vspace-Tuple","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_vspace","text":"computes the integral over vpa of the integrand, using the input vpa_wgts\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.reset_moments_status!-Tuple{Any, Any, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.reset_moments_status!","text":"\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_density!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_density!","text":"NB: if this function is called and if dens_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_density_species!-NTuple{5, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_density_species!","text":"calculate the updated density (dens) for a given species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_moments!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_moments!","text":"calculate the updated density (dens) and parallel pressure (ppar) for all species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_ppar!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_ppar!","text":"NB: if this function is called and if ppar_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_ppar_species!-NTuple{5, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_ppar_species!","text":"calculate the updated parallel pressure (ppar) for a given species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_qpar!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_qpar!","text":"NB: if this function is called and if ppar_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_qpar_species!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_qpar_species!","text":"calculate the updated parallel heat flux (qpar) for a given species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_upar!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_upar!","text":"NB: if this function is called and if upar_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_upar_species!-NTuple{5, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_upar_species!","text":"calculate the updated parallel flow (upar) for a given species\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#time_advance","page":"time_advance","title":"time_advance","text":"","category":"section"},{"location":"time_advance/","page":"time_advance","title":"time_advance","text":"Modules = [moment_kinetics.time_advance]","category":"page"},{"location":"time_advance/#moment_kinetics.time_advance","page":"time_advance","title":"moment_kinetics.time_advance","text":"\n\n\n\n","category":"module"},{"location":"time_advance/#moment_kinetics.time_advance.advance_info","page":"time_advance","title":"moment_kinetics.time_advance.advance_info","text":"\n\n\n\n","category":"type"},{"location":"time_advance/#moment_kinetics.time_advance.euler_time_advance!-NTuple{23, Any}","page":"time_advance","title":"moment_kinetics.time_advance.euler_time_advance!","text":"eulertimeadvance! advances the vector equation dfvec/dt = G[f] that includes the kinetic equation + any evolved moment equations using the forward Euler method: fvecout = fvecin + dt*fvecin, with fvecin an input and fvec_out the output\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.normalize_pdf!-Tuple{Any, Any, Any}","page":"time_advance","title":"moment_kinetics.time_advance.normalize_pdf!","text":"if evolving the density via continuity equation, redefine the normalised f → f/n if evolving the parallel pressure via energy equation, redefine f -> f * vth / n 'scratch' should be a (nz,nspecies) array\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.rk_update!-NTuple{10, Any}","page":"time_advance","title":"moment_kinetics.time_advance.rk_update!","text":"\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.setup_runge_kutta_coefficients-Tuple{Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_runge_kutta_coefficients","text":"given the number of Runge Kutta stages that are requested, returns the needed Runge Kutta coefficients; e.g., if f is the function to be updated, then f^{n+1}[stage+1] = rkcoef[1,stage]*f^{n} + rkcoef[2,stage]f^{n+1}[stage] + rk_coef[3,stage](f^{n}+dt*G[f^{n+1}[stage]]\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.setup_scratch_arrays-Tuple{Any, Any, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_scratch_arrays","text":"create an array of structs containing scratch arrays for the normalised pdf and low-order moments that may be evolved separately via fluid equations\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.setup_time_advance!-NTuple{11, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_time_advance!","text":"create arrays and do other work needed to setup the main time advance loop. this includes creating and populating structs for Chebyshev transforms, velocity space moments, EM fields, semi-Lagrange treatment, and advection terms\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.ssp_rk!-NTuple{23, Any}","page":"time_advance","title":"moment_kinetics.time_advance.ssp_rk!","text":"\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.time_advance!-NTuple{24, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance!","text":"solve ∂f/∂t + v(z,t)⋅∂f/∂z + dvpa/dt ⋅ ∂f/∂vpa= 0 define approximate characteristic velocity v₀(z)=vⁿ(z) and take time derivative along this characteristic df/dt + δv⋅∂f/∂z = 0, with δv(z,t)=v(z,t)-v₀(z) for prudent choice of v₀, expect δv≪v so that explicit time integrator can be used without severe CFL condition\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.time_advance_no_splitting!-NTuple{23, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance_no_splitting!","text":"\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.time_advance_split_operators!-NTuple{18, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance_split_operators!","text":"\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.update_pdf_unnorm!-NTuple{5, Any}","page":"time_advance","title":"moment_kinetics.time_advance.update_pdf_unnorm!","text":"if separately evolving the density via the continuity equation, the evolved pdf has been normalised by the particle density undo this normalisation to get the true particle distribution function\n\nscratch should be a (nz,nspecies) array\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.update_solution_vector!-NTuple{7, Any}","page":"time_advance","title":"moment_kinetics.time_advance.update_solution_vector!","text":"update the vector containing the pdf and any evolved moments of the pdf for use in the Runge-Kutta time advance\n\n\n\n\n\n","category":"method"},{"location":"bgk/#bgk","page":"bgk","title":"bgk","text":"","category":"section"},{"location":"bgk/","page":"bgk","title":"bgk","text":"Modules = [moment_kinetics.bgk]","category":"page"},{"location":"bgk/#moment_kinetics.bgk","page":"bgk","title":"moment_kinetics.bgk","text":"\n\n\n\n","category":"module"},{"location":"bgk/#moment_kinetics.bgk.allowed_wave_amplitude!-NTuple{5, Any}","page":"bgk","title":"moment_kinetics.bgk.allowed_wave_amplitude!","text":"\n\n\n\n","category":"method"},{"location":"bgk/#moment_kinetics.bgk.init_bgk_pdf!-NTuple{6, Any}","page":"bgk","title":"moment_kinetics.bgk.init_bgk_pdf!","text":"\n\n\n\n","category":"method"},{"location":"bgk/#moment_kinetics.bgk.passing_pdf!-NTuple{5, Any}","page":"bgk","title":"moment_kinetics.bgk.passing_pdf!","text":"inputs\n\npdf is the particle distribution function, with the passing part of phase space not filled in\nphi_max is the maximum value that e * phi / Te takes\ntau = Ti/Te is the ion-electron temperature ratio\nx = mvpa^2/2Te + ephi/Te is 1D array containing the total parallel energy (conserved)\n\noutput\n\npdf = particle distribution function; this function fills in the part of phase space where x > e*phi_max/T\n\n\n\n\n\n","category":"method"},{"location":"bgk/#moment_kinetics.bgk.setup_dummy_integrals-Tuple{}","page":"bgk","title":"moment_kinetics.bgk.setup_dummy_integrals","text":"\n\n\n\n","category":"method"},{"location":"bgk/#moment_kinetics.bgk.total_energy_grid-Tuple{Any, Any}","page":"bgk","title":"moment_kinetics.bgk.total_energy_grid","text":"inputs:\n\nvpa = parallel velocity normalized by vts = sqrt(2*Te/ms)\nphi = electrostatic potential normalized by Te/e\n\noutput: x = vpa^2 + phi is the total parallel energy\n\n\n\n\n\n","category":"method"},{"location":"bgk/#moment_kinetics.bgk.trapped_passing_boundary-Tuple{Any, Any}","page":"bgk","title":"moment_kinetics.bgk.trapped_passing_boundary","text":"\n\n\n\n","category":"method"},{"location":"bgk/#moment_kinetics.bgk.trapped_pdf!-NTuple{8, Any}","page":"bgk","title":"moment_kinetics.bgk.trapped_pdf!","text":"inputs\n\nphi_max is the maximum value that e * phi / Te takes\ntau = Ti/Te is the ion-electron temperature ratio\nx = vpa^2 + e*phi is a 2D array containing the total parallel energy on the (z,vpa) grid\ny = dummy coordinate for the necessary integrals in the function\nintegrand = dummy array used to hold integrands defined and integrated in this function\nwgts = integration weights associated with y integrals\n\noutput\n\npdf is the particle distribution function for all of phase space, with this function filling in only the part with x < e*phi_max/T\n\n\n\n\n\n","category":"method"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for moment_kinetics.jl","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"getting_started.md\", \"developing.md\", \"debugging-hints.md\"]","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Order = [:module]","category":"page"},{"location":"chebyshev/#chebyshev","page":"chebyshev","title":"chebyshev","text":"","category":"section"},{"location":"chebyshev/","page":"chebyshev","title":"chebyshev","text":"Modules = [moment_kinetics.chebyshev]","category":"page"},{"location":"chebyshev/#moment_kinetics.chebyshev","page":"chebyshev","title":"moment_kinetics.chebyshev","text":"\n\n\n\n","category":"module"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshev_info","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_info","text":"\n\n\n\n","category":"type"},{"location":"chebyshev/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Any, moment_kinetics.chebyshev.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, ff, adv_fac, spectral::chebyshev_info)\n\nChebyshev transform f to get Chebyshev spectral coefficients and use them to calculate f'.\n\nNote: Chebyshev derivative does not make use of upwinding information within each element.\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, moment_kinetics.chebyshev.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, ff, chebyshev::chebyshev_info)\n\nChebyshev transform f to get Chebyshev spectral coefficients and use them to calculate f'.\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshev_backward_transform!-NTuple{5, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_backward_transform!","text":"\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshev_derivative_single_element!-NTuple{7, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_derivative_single_element!","text":"\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshev_forward_transform!-NTuple{5, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_forward_transform!","text":"takes the real function ff on a Chebyshev grid in z (domain [-1, 1]), which corresponds to the domain [π, 2π] in variable theta = ArcCos(z). interested in functions of form f(z) = sumn cn Tn(z) using Tn(cos(theta)) = cos(ntheta) and z = cos(theta) gives f(z) = sumn cn cos(ntheta) thus a Chebyshev transform is equivalent to a discrete cosine transform doing this directly turns out to be slower than extending the domain from [0, 2pi] and using the fact that f(z) must be even (as cosines are all even) on this extended domain, can do a standard complex-to-complex fft fext is an array used to store f(theta) on the extended grid theta ∈ [0,2π) ff is f(theta) on the grid [π,2π] the Chebyshev coefficients of ff are calculated and stored in chebyf n is the number of grid points on the Chebyshev-Gauss-Lobatto grid transform is the plan for the complex-to-complex, in-place fft\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshev_interpolate_single_element!-NTuple{7, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_interpolate_single_element!","text":"\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshev_spectral_derivative!-Tuple{Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_spectral_derivative!","text":"use Chebyshev basis to compute the derivative of f\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshevmoments-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshevmoments","text":"compute and return modified Chebyshev moments of the first kind: ∫dx Tᵢ(x) over range [-1,1]\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshevpoints-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshevpoints","text":"returns the Chebyshev-Gauss-Lobatto grid points on an n point grid\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.clenshaw_curtis_weights-NTuple{6, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.clenshaw_curtis_weights","text":"returns wgts array containing the integration weights associated with all grid points for Clenshaw-Curtis quadrature\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.scaled_chebyshev_grid-NTuple{6, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.scaled_chebyshev_grid","text":"initialize chebyshev grid scaled to interval [-boxlength/2, boxlength/2]\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.setup_chebyshev_pseudospectral-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.setup_chebyshev_pseudospectral","text":"create arrays needed for explicit Chebyshev pseudospectral treatment and create the plans for the forward and backward fast Fourier transforms\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.update_df_chebyshev!-Tuple{Any, Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.update_df_chebyshev!","text":"compute the Chebyshev spectral coefficients of the spatial derivative of f\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.update_fcheby!-Tuple{Any, Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.update_fcheby!","text":"Chebyshev transform f to get Chebyshev spectral coefficients\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.interpolation.interpolate_to_grid_1d!-Tuple{Any, Any, Any, Any, moment_kinetics.chebyshev.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.interpolation.interpolate_to_grid_1d!","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nArguments\n\nresult : Array{mkfloat, 1}     Array to be overwritten with the result of the interpolation newgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies chebyshev : chebyshev_info     struct containing information for Chebyshev transforms\n\n\n\n\n\n","category":"method"},{"location":"advection/#advection","page":"advection","title":"advection","text":"","category":"section"},{"location":"advection/","page":"advection","title":"advection","text":"Modules = [moment_kinetics.advection]","category":"page"},{"location":"advection/#moment_kinetics.advection","page":"advection","title":"moment_kinetics.advection","text":"\n\n\n\n","category":"module"},{"location":"advection/#moment_kinetics.advection.advection_info","page":"advection","title":"moment_kinetics.advection.advection_info","text":"structure containing the basic arrays associated with the advection terms appearing in the advection equation for each coordinate\n\n\n\n\n\n","category":"type"},{"location":"advection/#moment_kinetics.advection.advance_f_local!-NTuple{12, Any}","page":"advection","title":"moment_kinetics.advection.advance_f_local!","text":"do all the work needed to update f(coord) at a single value of other coords\n\n\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.calculate_explicit_advection!-NTuple{8, Any}","page":"advection","title":"moment_kinetics.advection.calculate_explicit_advection!","text":"calculate the explicit advection terms on the rhs of the equation; i.e., -Δt⋅δv⋅f'\n\n\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.setup_advection-Tuple{Any, Vararg{Any}}","page":"advection","title":"moment_kinetics.advection.setup_advection","text":"create arrays needed to compute the advection term(s) for a 1D problem\n\n\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.setup_advection_per_species-Tuple","page":"advection","title":"moment_kinetics.advection.setup_advection_per_species","text":"create arrays needed to compute the advection term(s)\n\n\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.update_advection_factor!-NTuple{12, Any}","page":"advection","title":"moment_kinetics.advection.update_advection_factor!","text":"calculate the factor appearing in front of f' in the advection term at time level n in the frame moving with the approximate characteristic\n\n\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.update_boundary_indices!-Tuple{Any, Any, Any}","page":"advection","title":"moment_kinetics.advection.update_boundary_indices!","text":"Calculate the grid index correspond to the upwind and downwind boundaries, as well as the index increment needed to sweep in the upwind direction\n\nArguments\n\nadvection : advectioninfo     struct containing information on how to advect in a direction. orthogonalcoordinaterange : UnitRange{mkint}     Range of indices for the dimension orthogonal to the advection direction, used to     iterate over the orthogonal coordinate.\n\n\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.update_f!-NTuple{10, Any}","page":"advection","title":"moment_kinetics.advection.update_f!","text":"update ff at time level n+1 using an explicit Runge-Kutta method along approximate characteristics\n\n\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.update_rhs!-NTuple{9, Any}","page":"advection","title":"moment_kinetics.advection.update_rhs!","text":"update the righthand side of the equation to account for 1d advection in this coordinate\n\n\n\n\n\n","category":"method"},{"location":"debugging-hints/#Debugging","page":"Debugging","title":"Debugging","text":"","category":"section"},{"location":"debugging-hints/#Shared-memory-parallelism","page":"Debugging","title":"Shared-memory parallelism","text":"","category":"section"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"For information on race conditions and debugging, see debug_test/README.md.","category":"page"},{"location":"debugging-hints/#Dumping-state-of-physics-variables","page":"Debugging","title":"Dumping state of physics variables","text":"","category":"section"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"There is a function moment_kinetics.file_io.debug_dump provided in the moment_kinetics.file_io module that can be inserted to save the distribution function, moments, etc. These can include a label so that if there are several 'dumps' within a timestep, they can be easily identified.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"To use, first import the function","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"using ..file_io: debug_dump","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"then insert calls at the point where you want to save the variables, e.g.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"debug_dump(f, density, upar, ppar, phi, t, istage=istage, label=\"foo\")","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"where f, density, upar, ppar, and phi are arrays and t is an mk_float. istage is an optional mk_int, and can be used to identify the stage in the ssp_rk!() function. label is optional and can be any string, intended to distinguish different calls to debug_dump().","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"There is an alternative method (implementation) of the function that takes moment_kinetics.moment_kinetics_structs.scratch_pdf and moment_kinetics.moment_kinetics_structs.em_fields_struct arguments. This can be convenient within the functions in moment_kinetics.time_advance, e.g.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"debug_dump(fvec_out, fields, t, istage=istage, label=\"bar\")","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"Any of the positional arguments can be replaced by nothing if they are not available in a certain place, or just not needed. If nothing is passed, then arrays filled with 0.0 are written into the output.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"The output is written into a NetCDF file debug_output.cdf in the current directory (the filename is currently hard-coded because that was simpler than adding more command line arguments, etc.).","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"For debugging, a script util/compare_debug_files.jl is provided to compare two output files, assumed to have similar structure (i.e. the same set of debug_dump() calls). An example workflow could be:","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"Checkout master branch.\nCreate new branch, git checkout -b newfeature.\nWork on newfeature...\nAt some point, a bug is introduced which breaks some test or example - i.e. changes its output. Commit the current state of the code.\nAdd debug_dump() calls before and after locations where the bug is likely to be.\nRun the broken case.\nmv debug_output.cdf debug_after.cdf, so the file does not get overwritten.\ngit stash to 'save' the debug_dump() statements.\ngit checkout a commit where the test/example was working.\ngit stash pop to add the debug_dump() statements on top of the working commit  (fingers crossed there are no merge conflicts).\nRun the test example again.\nmv debug_output.cdf debug_before.cdf\nRun the comparison script  julia util/compare_debug_files.jl debug_before.cdf debug_after.cdf\nThe script identifies the first point (by t, istage and label) where any  variable in the two output files has a maximum difference that is larger than some  very tight (1.e-14) absolute and relative tolerances, and reports which  variables were different and their maximum difference.","category":"page"},{"location":"analysis/#analysis","page":"analysis","title":"analysis","text":"","category":"section"},{"location":"analysis/","page":"analysis","title":"analysis","text":"Modules = [moment_kinetics.analysis]","category":"page"},{"location":"analysis/#moment_kinetics.analysis","page":"analysis","title":"moment_kinetics.analysis","text":"\n\n\n\n","category":"module"},{"location":"analysis/#moment_kinetics.analysis.analyze_fields_data-NTuple{5, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_fields_data","text":"\n\n\n\n","category":"method"},{"location":"analysis/#moment_kinetics.analysis.analyze_moments_data-NTuple{9, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_moments_data","text":"\n\n\n\n","category":"method"},{"location":"analysis/#moment_kinetics.analysis.analyze_pdf_data-NTuple{11, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"analysis/#moment_kinetics.analysis.field_line_average-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.field_line_average","text":"\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics_input","page":"moment_kinetics_input","title":"moment_kinetics_input","text":"","category":"section"},{"location":"moment_kinetics_input/","page":"moment_kinetics_input","title":"moment_kinetics_input","text":"Modules = [moment_kinetics.moment_kinetics_input]","category":"page"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input","text":"\n\n\n\n","category":"module"},{"location":"moment_kinetics_input/#Base.get-Tuple{Dict, Any, Enum}","page":"moment_kinetics_input","title":"Base.get","text":"Utility mothod for converting a string to an Enum when getting from a Dict, based on the type of the default value\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_coordinate_input-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_coordinate_input","text":"Check input for a coordinate\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input-NTuple{11, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input","text":"check various input options to ensure they are all valid/consistent\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input_initialization-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input_initialization","text":"\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input_time_advance-NTuple{4, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input_time_advance","text":"\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.load_defaults-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.load_defaults","text":"\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.mk_input","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.mk_input","text":"\n\n\n\n","category":"function"},{"location":"quadrature/#quadrature","page":"quadrature","title":"quadrature","text":"","category":"section"},{"location":"quadrature/","page":"quadrature","title":"quadrature","text":"Modules = [moment_kinetics.quadrature]","category":"page"},{"location":"quadrature/#moment_kinetics.quadrature","page":"quadrature","title":"moment_kinetics.quadrature","text":"\n\n\n\n","category":"module"},{"location":"quadrature/#moment_kinetics.quadrature.composite_simpson_weights-Tuple{Any}","page":"quadrature","title":"moment_kinetics.quadrature.composite_simpson_weights","text":"compositesimpsonweights creates, computes, and returns an array for the 1D integration weights associated with each grid point using composite Simpson's rule\n\n\n\n\n\n","category":"method"},{"location":"vpa_advection/#vpa_advection","page":"vpa_advection","title":"vpa_advection","text":"","category":"section"},{"location":"vpa_advection/","page":"vpa_advection","title":"vpa_advection","text":"Modules = [moment_kinetics.vpa_advection]","category":"page"},{"location":"vpa_advection/#moment_kinetics.vpa_advection","page":"vpa_advection","title":"moment_kinetics.vpa_advection","text":"\n\n\n\n","category":"module"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.update_speed_constant!-NTuple{4, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_constant!","text":"update the advection speed dvpa/dt = constant\n\n\n\n\n\n","category":"method"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.update_speed_default!-NTuple{11, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_default!","text":"\n\n\n\n","category":"method"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.update_speed_linear-NTuple{4, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_linear","text":"update the advection speed dvpa/dt = const*(vpa + L/2)\n\n\n\n\n\n","category":"method"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.update_speed_vpa!-NTuple{11, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_vpa!","text":"calculate the advection speed in the vpa-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.vpa_advection!-NTuple{18, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.vpa_advection!","text":"\n\n\n\n","category":"method"},{"location":"looping/#looping","page":"looping","title":"looping","text":"","category":"section"},{"location":"looping/","page":"looping","title":"looping","text":"Modules = [moment_kinetics.looping]","category":"page"},{"location":"looping/#moment_kinetics.looping","page":"looping","title":"moment_kinetics.looping","text":"Provides convenience macros for shared-memory-parallel loops\n\n\n\n\n\n","category":"module"},{"location":"looping/#moment_kinetics.looping.loop_ranges","page":"looping","title":"moment_kinetics.looping.loop_ranges","text":"module variable that we can access by giving fully-qualified name in loop macros\n\n\n\n\n\n","category":"constant"},{"location":"looping/#moment_kinetics.looping.loop_ranges_store","page":"looping","title":"moment_kinetics.looping.loop_ranges_store","text":"module variable used to store LoopRanges that are swapped into the loopranges variable in begin*_region() functions\n\n\n\n\n\n","category":"constant"},{"location":"looping/#moment_kinetics.looping.LoopRanges","page":"looping","title":"moment_kinetics.looping.LoopRanges","text":"LoopRanges structs contain information on which points should be included on this process in loops over shared-memory arrays.\n\nMembers\n\nparalleldims::Tuple{Vararg{Symbol}}        Indicates which dimensions are (or might be) parallelized when using        this LoopRanges. Provided for information for developers, to make it        easier to tell (when using a Debugger, or printing debug informatino)        which LoopRanges instance is active in looping.loopranges at any point        in the code. rank0::Bool        Is this process the one with rank 0 in the 'block' which work in        parallel on shared memory arrays. <d>::UnitRange{mkint}        Loop ranges for each dimension <d> in looping.alldimensions.\n\n\n\n\n\n","category":"type"},{"location":"looping/#moment_kinetics.looping.begin_r_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_region","text":"Begin region in which (:r,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vpa_region","text":"Begin region in which (:r, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_region","text":"Begin region in which (:r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vpa_region","text":"Begin region in which (:r, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_r_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_region","text":"Begin region in which (:s, :r) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_r_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_vpa_region","text":"Begin region in which (:s, :r, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_r_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_region","text":"Begin region in which (:s, :r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_r_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_vpa_region","text":"Begin region in which (:s, :r, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_region","text":"Begin region in which (:s,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_vpa_region","text":"Begin region in which (:s, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_region","text":"Begin region in which (:s, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_vpa_region","text":"Begin region in which (:s, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_serial_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_serial_region","text":"Begin region in which only rank-0 in each group of processes operating on a shared-memory block operates on shared-memory arrays.\n\nReturns immediately if loopranges[] is already set for a serial region. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vpa_region","text":"Begin region in which (:vpa,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_region","text":"Begin region in which (:z,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vpa_region","text":"Begin region in which (:z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.dims_string-Tuple{Tuple}","page":"looping","title":"moment_kinetics.looping.dims_string","text":"Construct a string composed of the dimension names given in the Tuple dims, separated by underscores\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.get_best_ranges-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.get_best_ranges","text":"Find the ranges for loop variables that optimize load balance for a certain block_size\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.get_best_ranges_from_sizes-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.get_best_ranges_from_sizes","text":"\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.get_load_balance-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_load_balance","text":"Calculate the expected load balance\n\n'Load balance' is the ratio of the maximum and minimum numbers of points on any process.\n\nArguments\n\nnprocslist : Vector{mkint}     Number of processes for each dimension sizes : Vector{mk_int}     Size of each dimension\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.get_local_range-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.get_local_range","text":"Get local range of indices when splitting a loop over processes in a sub-block\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.get_splits-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_splits","text":"Find possible divisions of subblocksize into n factors\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.setup_loop_ranges!-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.setup_loop_ranges!","text":"Create ranges for loops with different combinations of variables\n\nArguments\n\nKeyword arguments dim=n are required for each dim in (:s, :r, :z, :vpa) where n is an integer giving the size of the dimension.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.@loop_r-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r","text":"Loop over (:r,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vpa","text":"Loop over (:r, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z","text":"Loop over (:r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vpa","text":"Loop over (:r, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s","text":"Loop over (:s,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_r-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r","text":"Loop over (:s, :r) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_r_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vpa","text":"Loop over (:s, :r, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_r_z-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z","text":"Loop over (:s, :r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_r_z_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vpa","text":"Loop over (:s, :r, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vpa","text":"Loop over (:s, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z","text":"Loop over (:s, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_z_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vpa","text":"Loop over (:s, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_vpa-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vpa","text":"Loop over (:vpa,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z","text":"Loop over (:z,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vpa","text":"Loop over (:z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@serial_region-Tuple{Any}","page":"looping","title":"moment_kinetics.looping.@serial_region","text":"Run a block of code on only rank-0 of each group of processes operating on a shared-memory block\n\n\n\n\n\n","category":"macro"},{"location":"moment_kinetics/#moment_kinetics","page":"moment_kinetics","title":"moment_kinetics","text":"","category":"section"},{"location":"moment_kinetics/","page":"moment_kinetics","title":"moment_kinetics","text":"Modules = [moment_kinetics.moment_kinetics]","category":"page"},{"location":"moment_kinetics/#moment_kinetics.moment_kinetics","page":"moment_kinetics","title":"moment_kinetics.moment_kinetics","text":"\n\n\n\n","category":"module"},{"location":"moment_kinetics/#moment_kinetics.cleanup_moment_kinetics!-Tuple{Union{Nothing, moment_kinetics.file_io.ios}, Union{Nothing, moment_kinetics.file_io.netcdf_info}}","page":"moment_kinetics","title":"moment_kinetics.cleanup_moment_kinetics!","text":"Clean up after a run\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics/#moment_kinetics.run_moment_kinetics","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"main function that contains all of the content of the program\n\n\n\n\n\n","category":"function"},{"location":"moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{Any}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload with no TimerOutput arguments\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{TimerOutputs.TimerOutput, String}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload which takes a filename and loads input\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload which gets the input file name from command line arguments\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics/#moment_kinetics.setup_moment_kinetics-Tuple{Dict}","page":"moment_kinetics","title":"moment_kinetics.setup_moment_kinetics","text":"Perform all the initialization steps for a run.\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#finite_differences","page":"finite_differences","title":"finite_differences","text":"","category":"section"},{"location":"finite_differences/","page":"finite_differences","title":"finite_differences","text":"Modules = [moment_kinetics.finite_differences]","category":"page"},{"location":"finite_differences/#moment_kinetics.finite_differences","page":"finite_differences","title":"moment_kinetics.finite_differences","text":"\n\n\n\n","category":"module"},{"location":"finite_differences/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Any, Bool}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, adv_fac, not_spectral::Bool)\n\nCalculate the derivative of f using finite differences, with particular scheme specified by coord.fdoption; result stored in coord.scratch2d.\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Bool}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, not_spectral::Bool)\n\nCalculate the derivative of f using 4th order centered finite differences; result stored in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.centered_fourth_order!-Tuple{Matrix{Float64}, Any, Any, Any, Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_fourth_order!","text":"take the derivative of input function f and return as df using fourth-order, centered differences. input/output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.centered_second_order!-Tuple{Matrix{Float64}, Any, Any, Any, Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_second_order!","text":"take the derivative of input function f and return as df using second-order, centered differences. input/output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.centered_second_order!-Tuple{Vector{Float64}, Any, Any, Any, Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_second_order!","text":"take the derivative of input function f and return as df using second-order, centered differences. input/output df is 1D array of size n (full grid)\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.derivative_finite_difference!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.derivative_finite_difference!","text":"\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.derivative_finite_difference!-NTuple{8, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.derivative_finite_difference!","text":"\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.fd_check_option-Tuple{Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.fd_check_option","text":"\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.upwind_first_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_first_order!","text":"\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.upwind_second_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_second_order!","text":"\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.upwind_third_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_third_order!","text":"\n\n\n\n","category":"method"},{"location":"charge_exchange/#charge_exchange","page":"charge_exchange","title":"charge_exchange","text":"","category":"section"},{"location":"charge_exchange/","page":"charge_exchange","title":"charge_exchange","text":"Modules = [moment_kinetics.charge_exchange]","category":"page"},{"location":"charge_exchange/#moment_kinetics.charge_exchange","page":"charge_exchange","title":"moment_kinetics.charge_exchange","text":"\n\n\n\n","category":"module"},{"location":"charge_exchange/#moment_kinetics.charge_exchange.charge_exchange_collisions!-NTuple{9, Any}","page":"charge_exchange","title":"moment_kinetics.charge_exchange.charge_exchange_collisions!","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#interpolation","page":"interpolation","title":"interpolation","text":"","category":"section"},{"location":"interpolation/","page":"interpolation","title":"interpolation","text":"Modules = [moment_kinetics.interpolation]","category":"page"},{"location":"interpolation/#moment_kinetics.interpolation","page":"interpolation","title":"moment_kinetics.interpolation","text":"Interpolation routines intended for post-processing.\n\nNote these are not guaranteed to be highly optimized!\n\n\n\n\n\n","category":"module"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_1d!-Tuple{}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_1d!","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nArguments\n\nresult : Array{mkfloat, 1}     Array to be overwritten with the result of the interpolation newgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies spectral : Bool or chebyshev_info     struct containing information for discretization, whose type determines which method     is used.\n\n\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_1d-Tuple{Any, Vararg{Any}}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_1d","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nThis version allocates a new array for the result, which is returned.\n\nArguments\n\nnewgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies spectral : Bool or chebyshevinfo     struct containing information for discretization, whose type determines which method     is used.\n\nReturns\n\nresult : Array     Array with the values of f interpolated to the points in new_grid.\n\n\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa!-Tuple{AbstractVector{Float64}, Any, AbstractVector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa!","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa!-Tuple{Array{Float64, 3}, Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa!","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa-Tuple{Any, AbstractVector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa-Tuple{Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Array{Float64, 3}, Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Matrix{Float64}, Any, Matrix{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Vector{Float64}, Any, Vector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Matrix{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Vector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"moment_kinetics_structs/#moment_kinetics_structs","page":"moment_kinetics_structs","title":"moment_kinetics_structs","text":"","category":"section"},{"location":"moment_kinetics_structs/","page":"moment_kinetics_structs","title":"moment_kinetics_structs","text":"Modules = [moment_kinetics.moment_kinetics_structs]","category":"page"},{"location":"moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs","text":"structs used within moment_kinetics that should be defined early to avoid dependency cycles when they are used by several other modules.\n\n\n\n\n\n","category":"module"},{"location":"moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.em_fields_struct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.em_fields_struct","text":"\n\n\n\n","category":"type"},{"location":"moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.scratch_pdf","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.scratch_pdf","text":"\n\n\n\n","category":"type"},{"location":"array_allocation/#array_allocation","page":"array_allocation","title":"array_allocation","text":"","category":"section"},{"location":"array_allocation/","page":"array_allocation","title":"array_allocation","text":"Modules = [moment_kinetics.array_allocation]","category":"page"},{"location":"array_allocation/#moment_kinetics.array_allocation","page":"array_allocation","title":"moment_kinetics.array_allocation","text":"\n\n\n\n","category":"module"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_bool-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_bool","text":"allocate array with dimensions given by dims and entries of type Bool\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_complex-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_complex","text":"allocate 1d array with dimensions given by dims and entries of type Complex{mk_float}\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_float-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_float","text":"allocate array with dimensions given by dims and entries of type mk_float\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_int-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_int","text":"allocate 1d array with dimensions given by dims and entries of type mk_int\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_shared_bool-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_bool","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_shared_complex-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_complex","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_shared_float-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_float","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_shared_int-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_int","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"developing/#Developing","page":"Developing","title":"Developing","text":"","category":"section"},{"location":"developing/#Dependencies","page":"Developing","title":"Dependencies","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"If you need to add a dependency, start the REPL with the moment_kinetics package activated (see above), enter pkg> mode (press ]) and then to add, for example, the FFTW.jl package enter","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"(moment_kinetics) pkg> add FFTW","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"This should take care of adding the package (FFTW) to the Project.toml and Manifest.toml files.","category":"page"},{"location":"developing/#Revise.jl","page":"Developing","title":"Revise.jl","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"When working on the code, one way to avoid waiting for everything to recompile frequently is to load the Revise.jl package","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> using Revise","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Revise.jl will recompile each edited function/method as needed, so it is possible to keep a REPL session open and avoid long recompilation. moment_kinetics can be run fairly conveniently from the REPL","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> using moment_kinetics\njulia> run_moment_kinetics(input)","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"where input is a Dict() containing any non-default options desired. Input can also be loaded from a TOML file passing the filaname as a String to the second argument, e.g.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> run_moment_kinetics(\"input.toml\")","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It might be convenient to add using Revise to your startup.jl file (~/julia/config/startup.jl) so it's always loaded.","category":"page"},{"location":"developing/#Parallelization","page":"Developing","title":"Parallelization","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"The code is parallelized at the moment using MPI and shared-memory arrays. Arrays representing the pdf, moments, etc. are shared between all processes. Using shared memory means, for example, we can take derivatives along one dimension while parallelising the other for any dimension without having to communicate to re-distribute the arrays. Using shared memory instead of (in future as well as) distributed memory parallelism has the advantage that it is easier to split up the points within each element between processors, giving a finer-grained parallelism which should let the code use larger numbers of processors efficiently.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It is possible to use a REPL workflow with parallel code:","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Recommended option is to use tmpi. This utility (it's a bash script that uses tmux) starts an mpi program with each process in a separate pane in a single terminal, and mirrors input to all processes simultaneously (which is normally what you want, there are also commands to 'zoom in' on a single process).\nAnother 'low-tech' possibilty is to use something like mpirun -np 4 xterm -e julia --project, but that will start each process in a separate xterm and you would have to enter commands separately in each one. Occasionally useful for debugging when nothing else is available.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"There is no restriction on the number of processes or number of grid points, although load-balancing may be affected - if there are only very few points per process, and a small fraction of processes have an extra grid point (e.g. splitting 5 points over 4 processes, so 3 process have 1 point but 1 process has 2 points), many processes will spend time waiting for the few with an extra point.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Parallelism is implemented through macros that get the local ranges of points that each process should handle. The inner-most level of nested loops is typically not parallelized, to allow efficient FFTs for derivatives, etc. A loop over one (possibly parallelized) dimension can be written as, for example,","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s is begin\n    f[is] = ...\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"These macros can be nested as needed for relatively complex loops","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s is begin\n    some_setup(is)\n    @loop_z iz begin\n        @views do_something(f[:,iz,is])\n    end\n    @loop_z iz begin\n        @views do_something_else(f[:,iz,is])\n    end\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Simpler nested loops can (optionally) be written more compactly","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s_z_vpa is iz ivpa begin\n    f[ivpa,iz,is] = ...\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Which dimensions are actually parallelized by these macros is controlled by the 'region' that the code is currently in, as set by the begin_<dims>_region() functions, where <dims> are the dimensions that will be parallelized in the following region. For example, after calling begin_s_z_region() loops over species and z will be divided up over the processes in a 'block' (currently there is only one block, which contains the whole grid and all the processes being used, as we have not yet implemented distributed-memory parallelism). Every process will loop over all points in the remaining dimensions if the loop macros for those dimensions are called.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The recommended place to put begin_*_region() calls is at the beginning of a function whose contents should use loops parallelised according to the settings for that region.\nEach begin_*_region() function checks if the region it would set is already active, and if so returns immediately (doing nothing). This means that begin_*_region() can (and should) be used to mark a block of code as belonging to that region, and if moment_kinetics is already in that region type, the call will have essentially zero cost.\nIn some places it may be necessary to change the region type half way through a function, etc. This is fine.\nWhen choosing which region type to select, note that all 'parallelised dimensions' must be looped over for each operation (otherwise some points may be written more than once), unless some special handling is used (e.g. species dimension s is parallelised, but a conditional like if 1 in loop_ranges[].s is wrapped around code to be executed so that only processes which should handle the point at s=1 do anything). It may be more optimal in some places to choose region types that do not parallelise all possible dimensions, to reduce the number of synchronisations that are needed.\nAs a matter of style, it is recommended to place begin_*_region() calls within functions where the loops are (or at most one level above), so that it is not necessary to search back along the execution path of the code to find the most recent begin_*_region() call, and therefore know what region type is active.\nIn a region after begin_serial_region(), the rank 0 process in each block will loop over all points in every dimension, and all other ranks will not loop over any.\nInside serial regions, the macro @serial_region can also be used to wrap blocks of code so that they only run on rank 0 of the block. This is useful for example to allow the use of array-broadcast expressions during initialization where performance is not critical.\nTo help show how these macros work, a script is provided that print a set of examples where the loop macros are expanded. It can be run from the Julia REPL\n$ julia --project\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.7.0 (2021-11-30)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> include(\"util/print-macros.jl\")\nor on the command line\n$ julia --project util/print-macros.jl","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The ranges used are stored in a LoopRanges struct in the Ref variable loop_ranges (which is exported by the looping module). The range for each dimension is stored in a member with the same name as the dimension, e.g. loop_ranges[].s for the species. Occasionally it is useful to access the range directly. There are different LoopRanges instances for different parallelization patterns - the instance stored in loop_ranges is updated when begin_*_region() is called. It is possible to find out the current region type (i.e. which dimensions are being parallelized) by looking at loop_ranges[].parallel_dims.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"note: Note\nThe square brackets [] after loop_ranges[] are needed because loop_ranges is a reference to a LoopRanges object Ref{LoopRanges} (a bit like a pointer) - it allows loop_ranges to be a const variable, so its type is always known at compile time, but the actual LoopRanges can be set/modified at run-time.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It is also possible to run a block of code in serial (on just the rank-0 member of each block of processes) by wrapping it in a @serial_region macro. This is mostly useful for initialization or file I/O where performance is not critical. For example","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@serial_region begin\n    # Do some initialization\n    f .= 0.0\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Internally, when the begin_*_region() functions need to change the region type (i.e. the requested region is not already active), they call _block_synchronize(), which calls MPI.Barrier(). They also switch over the LoopRanges struct contained in looping.loop_ranges as noted above. For optimization, the _block_synchronize() call can be skipped - when it is correct to do so - by passing the argument no_synchronize=true (or some more complicated conditional expression if synchronization is necessary when using some options but not for others).","category":"page"},{"location":"post_processing/#post_processing","page":"post_processing","title":"post_processing","text":"","category":"section"},{"location":"post_processing/","page":"post_processing","title":"post_processing","text":"Modules = [moment_kinetics.post_processing]","category":"page"},{"location":"post_processing/#moment_kinetics.post_processing","page":"post_processing","title":"moment_kinetics.post_processing","text":"\n\n\n\n","category":"module"},{"location":"post_processing/#moment_kinetics.post_processing.analyze_and_plot_data-Tuple{Any}","page":"post_processing","title":"moment_kinetics.post_processing.analyze_and_plot_data","text":"\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.calculate_and_write_frequencies-NTuple{10, Any}","page":"post_processing","title":"moment_kinetics.post_processing.calculate_and_write_frequencies","text":"\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.fit_cosine","page":"post_processing","title":"moment_kinetics.post_processing.fit_cosine","text":"Fit a cosine to a 1d array\n\nFit function is Acos(2πn(z + δ)/L)\n\nThe domain z is taken to be periodic, with the first and last points identified, so L=z[end]-z[begin]\n\nArguments\n\nz : Array     1d array with positions of the grid points - should have the same length as data data : Array     1d array of the data to be fit amplitudeguess : Float     Initial guess for the amplitude (the value from the previous time point might be a     good choice) offsetguess : Float     Initial guess for the offset (the value from the previous time point might be a good     choice) n : Int, default 1     The periodicity used for the fit\n\nReturns\n\namplitude : Float     The amplitude A of the cosine fit offset : Float     The offset δ of the cosine fit error : Float     The RMS of the difference between data and the fit\n\n\n\n\n\n","category":"function"},{"location":"post_processing/#moment_kinetics.post_processing.fit_delta_phi_mode-Tuple{Any, Any, Any}","page":"post_processing","title":"moment_kinetics.post_processing.fit_delta_phi_mode","text":"Fit delta_phi to get the frequency and growth rate.\n\nNote, expect the input to be a standing wave (as simulations are initialised with just a density perturbation), so need to extract both frequency and growth rate from the time-variation of the amplitude.\n\nThe function assumes that if the amplitude does not cross zero, then the mode is non-oscillatory and so fits just an exponential, not exp*cos. The simulation used as input should be long enough to contain at least ~1 period of oscillation if the mode is oscillatory or the fit will not work.\n\nArguments\n\nz : Array{mkfloat, 1}     1d array of the grid point positions t : Array{mkfloat, 1}     1d array of the time points deltaphi : Array{mkfloat, 2}     2d array of the values of delta_phi(z, t)\n\nReturns\n\nphifitresult struct whose fields are:     growthrate : mkflaot         Fitted growth rate of the mode     amplitude0 : mkfloat         Fitted amplitude at t=0     frequency : mkfloat         Fitted frequency of the mode     offset0 : mkfloat         Fitted offset at t=0     amplitudefiterror : mkfloat         RMS error in fit to ln(amplitude) - i.e. ln(A)     offsetfiterror : mkfloat         RMS error in fit to offset - i.e. δ     cosinefiterror : mkfloat         Maximum of the RMS errors of the cosine fits at each time point     amplitude : Array{mkfloat, 1}         Values of amplitude from which growthrate fit was calculated     offset : Array{mk_float, 1}         Values of offset from which frequency fit was calculated\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.init_postprocessing_options-NTuple{5, Any}","page":"post_processing","title":"moment_kinetics.post_processing.init_postprocessing_options","text":"\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.moving_average-Tuple{AbstractVector, Int64}","page":"post_processing","title":"moment_kinetics.post_processing.moving_average","text":"Calculate a moving average\n\nresult[i] = mean(v[i-n:i+n])\n\nExcept near the ends of the array where indices outside the range of v are skipped.\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.plot_1D_1V_diagnostics-NTuple{27, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_1D_1V_diagnostics","text":"\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.plot_fields-NTuple{11, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_fields","text":"\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.plot_moments-NTuple{21, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_moments","text":"\n\n\n\n","category":"method"},{"location":"source_terms/#source_terms","page":"source_terms","title":"source_terms","text":"","category":"section"},{"location":"source_terms/","page":"source_terms","title":"source_terms","text":"Modules = [moment_kinetics.source_terms]","category":"page"},{"location":"source_terms/#moment_kinetics.source_terms","page":"source_terms","title":"moment_kinetics.source_terms","text":"\n\n\n\n","category":"module"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms!-NTuple{10, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms!","text":"calculate the source terms due to redefinition of the pdf to split off density, and use them to update the pdf\n\n\n\n\n\n","category":"method"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms_evolve_density!-NTuple{8, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_density!","text":"\n\n\n\n","category":"method"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar!-NTuple{11, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar!","text":"\n\n\n\n","category":"method"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_CX!-NTuple{9, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_CX!","text":"\n\n\n\n","category":"method"},{"location":"r_advection/#r_advection","page":"r_advection","title":"r_advection","text":"","category":"section"},{"location":"r_advection/","page":"r_advection","title":"r_advection","text":"Modules = [moment_kinetics.r_advection]","category":"page"},{"location":"r_advection/#moment_kinetics.r_advection","page":"r_advection","title":"moment_kinetics.r_advection","text":"\n\n\n\n","category":"module"},{"location":"r_advection/#moment_kinetics.r_advection.adjust_advection_speed!-NTuple{6, Any}","page":"r_advection","title":"moment_kinetics.r_advection.adjust_advection_speed!","text":"\n\n\n\n","category":"method"},{"location":"r_advection/#moment_kinetics.r_advection.r_advection!-NTuple{15, Any}","page":"r_advection","title":"moment_kinetics.r_advection.r_advection!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"r_advection/#moment_kinetics.r_advection.unnormalize_pdf!-NTuple{6, Any}","page":"r_advection","title":"moment_kinetics.r_advection.unnormalize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"r_advection/#moment_kinetics.r_advection.update_speed_r!-NTuple{9, Any}","page":"r_advection","title":"moment_kinetics.r_advection.update_speed_r!","text":"calculate the advection speed in the r-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"load_data/#load_data","page":"load_data","title":"load_data","text":"","category":"section"},{"location":"load_data/","page":"load_data","title":"load_data","text":"Modules = [moment_kinetics.load_data]","category":"page"},{"location":"load_data/#moment_kinetics.load_data","page":"load_data","title":"moment_kinetics.load_data","text":"\n\n\n\n","category":"module"},{"location":"load_data/#moment_kinetics.load_data.load_coordinate_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_coordinate_data","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_fields_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_fields_data","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_moments_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_moments_data","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_pdf_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.open_netcdf_file-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.open_netcdf_file","text":"\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The full documentation is online at https://mabarnes.github.io/moment_kinetics.","category":"page"},{"location":"getting_started/#Basics","page":"Getting started","title":"Basics","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Ensure that the Julia version is >= 1.7.0 by doing  $ julia --version  at command line.\nDependencies need to be installed to the project environment. Start Julia with  $ julia --project  (which activates the 'project' in the current directory) (or after starting with julia, in the REPL type ] to enter pkg> mode, enter activate . and then backspace to leave pkg> mode). Once in the moment_kinetics project, enter pkg> mode by typing ] and then run the command  (moment_kinetics) pkg> instantiate  this should download and install all the dependencies.\nFor julia>=1.6, pre-compiling dependencies manually is not necessary any more due to improvements to the native pre-compilation, so this step can be skipped (although precompiling the whole moment_kinetics code may still be useful sometimes). To pre-compile a static image (dependencies.so) that includes most of the external packages required for running and post-processing, run  $ julia -O3 precompile_dependencies.jl  To use the precompiled code, add an option -Jdependencies.so when starting julia.  It is also possible to precompile the whole package into a static image (moment_kinetics.so) using  $ julia -O3 precompile.jl this significantly decreases the load time but prevents code changes from taking effect when moment_kinetics.so is used without repeating the precompilation (to use this option, replace dependencies.so below with moment_kinetics.so).\nTo run julia with optimization, type  $ julia -O3 --project run_moment_kinetics.jl  Default input options are specified in moment_kinetics_input.jl. The defaults can be modified for a particular run by setting options in a TOML file, for example input.toml, which can be passed as an argument  $ julia -O3 --project run_moment_kinetics.jl input.toml\nTo run in parallel, just put mpirun -np <n> in front of the call you would normally use, with <n> the number of processes to use.\nIt may be more convenient when running moment_kinetics more than once to work from the Julia REPL, e.g.   $ julia -O3 --project   julia> using moment_kinetics   julia> run_moment_kinetics(input)   where input is a Dict() containing any non-default options desired. Input can also be loaded from a TOML file passing the filaname as a String to the second argument, e.g.   julia> run_moment_kinetics(\"input.toml\")\nTo make plots and calculate frequencies/growth rates, run  $ julia --project run_post_processing.jl runs/<directory to process>  passing the directory to process as a command line argument. Input options for post-processing can be specified in postprocessinginput.jl.\nParameter scans (see Running parameter scans) or performance tests can be performed by running  $ julia -O3 --project driver.jl  If running a scan, it can be parallelised by passing the number of processors as an argument. Scan options are set in scan_inputs.jl.\nPost processing can be done for several directories at once using  $ julia --project post_processing_driver.jl runs/<directory1> runs/<directory2> ...  passing the directories to process as command line arguments. Optionally pass a number as the first argument to parallelise post processing of different directories. Input options for post-processing can be specified in post_processing_input.jl.","category":"page"},{"location":"getting_started/#Running-parameter-scans","page":"Getting started","title":"Running parameter scans","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Parameter scans can be run, and can (optionally) use multiple processors. Short summary of implementation and usage:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"mk_input() takes a Dict argument, which can modify values. So mk_input() sets the 'defaults' (for a scan), which are overridden by any key/value pairs in the Dict.\nmk_scan_inputs() (in scan_input.jl) creates an Array of Dicts that can be passed to mk_input(). It first creates a Dict of parameters to scan over (keys are the names of the variable, values are an Array to scan over), then assembles an Array of Dicts (where each entry in the Array is a Dict with a single value for each variable being scanned). Most variables are combined as an 'inner product', e.g. {:ni=>[0.5, 1.], :nn=>[0.5, 0.]} gives [{:ni=>0.5, :nn=>0.5}, {ni=>1., nn=>0.}]. Any special variables specified in the combine_outer array are instead combined with the rest as an 'outer product', i.e. an entry is created for every value of those variables for each entry in the 'inner-producted' list. [This was just complicated enough to run the scans I've done so far without wasted simulations.]\nThe code in driver.jl picks between a single run (normal case), a performancetest, or creating a scan by calling `mkscaninput()and then looping over the returned array, callingmkinput()and running a simulation for each entry. This loop is parallelised (with the set of simulations dispatched over several processes - each simulation is still running serially). Running a scan (on 12 processes - actually 13 but the 'master' process doesn't run any of the loop bodies, so there are 12 'workers'): julia -O3 --project driverjl 12`  (runs in serial if no argument is given)\nThe scan puts each run in a separate directory, named with a prefix specified by base_name in scan_input.jl and the rest the names and values of the scanned-over parameters (the names are created in mk_scan_input() too, and passed as the :run_name entry of the returned Dicts).\nTo run post_processing.analyze_and_plot_data() over a bunch of directories (again parallelized trivially, and the number of processes to use is an optional argument, serial if omitted):  $ julia -O3 --project post_processing_driver.jl 12 runs/scan_name_*\nPlotting the scan is not so general, plot_comparison.jl does it, but is only set up for the particular scans I ran - everything except the charge exchange frequencies is hard-coded in.  $ julia -O3 --project plot_comparison.jl","category":"page"},{"location":"getting_started/#Tests","page":"Getting started","title":"Tests","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"There is a test suite in the test/ subdirectory. It can be run in a few ways:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Run using Pkg. Either using pkg> mode   $ julia -O3 --project   julia> <press ']' to enter pkg mode>   (moment_kinetics) pkg> test   using Pkg in the REPL   $ julia -O3 --project   julia> import Pkg   julia> Pkg.test()   or run on the command line   julia -O3 --project -e \"import Pkg; Pkg.test()`\nExecute some or all of the tests as a script. For example in the terminal run   $ julia -O3 --project test/runtests.jl   or in the REPL run   julia> include(\"test/runtests.jl\")   Individual test files can also be used instead of runtests.jl, which runs all the tests.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"By default the test suite should run fairly quickly (in a few minutes). To do so, it skips many cases. To run more comprehensive tests, you can activate the --long option:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Using test_args argument   julia> Pkg.test(; test_args=[\"--long\"])   Note the semicolon is necessary.\nIn the REPL, run   julia> push!(ARGS, \"--long\")   before running the tests.\nRunning from the terminal, pass as a command line argument, e.g.   $ julia -O3 --project --long test/runtests.jl","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To get more output on what tests were successful, an option --verbose (or -v) can be passed in a similar way to --long (if any tests fail, the output is printed by default).","category":"page"},{"location":"continuity/#continuity","page":"continuity","title":"continuity","text":"","category":"section"},{"location":"continuity/","page":"continuity","title":"continuity","text":"Modules = [moment_kinetics.continuity]","category":"page"},{"location":"continuity/#moment_kinetics.continuity","page":"continuity","title":"moment_kinetics.continuity","text":"\n\n\n\n","category":"module"},{"location":"continuity/#moment_kinetics.continuity.continuity_equation!-NTuple{10, Any}","page":"continuity","title":"moment_kinetics.continuity.continuity_equation!","text":"use the continuity equation dn/dt + d(n*upar)/dz to update the density n for all species\n\n\n\n\n\n","category":"method"},{"location":"continuity/#moment_kinetics.continuity.continuity_equation_single_species!-NTuple{9, Any}","page":"continuity","title":"moment_kinetics.continuity.continuity_equation_single_species!","text":"use the continuity equation dn/dt + d(n*upar)/dz to update the density n\n\n\n\n\n\n","category":"method"},{"location":"scan_input/#scan_input","page":"scan_input","title":"scan_input","text":"","category":"section"},{"location":"scan_input/","page":"scan_input","title":"scan_input","text":"Modules = [moment_kinetics.scan_input]","category":"page"},{"location":"scan_input/#moment_kinetics.scan_input.base_name","page":"scan_input","title":"moment_kinetics.scan_input.base_name","text":"\n\n\n\n","category":"constant"},{"location":"scan_input/#moment_kinetics.scan_input.combine_outer","page":"scan_input","title":"moment_kinetics.scan_input.combine_outer","text":"By default, inputs are combined with an 'inner product', i.e. inputs a,b,c are combined as (a[1],b[1],c[1]), (a[2],b[2],c[2]), etc. Any inputs named in 'combine_outer' are instead combined with an 'outer product', i.e. an entry is created for every value of those inputs combined with every combination of the other inputs.\n\n\n\n\n\n","category":"constant"},{"location":"scan_input/#moment_kinetics.scan_input.mk_name-Tuple{Any}","page":"scan_input","title":"moment_kinetics.scan_input.mk_name","text":"\n\n\n\n","category":"method"},{"location":"scan_input/#moment_kinetics.scan_input.mk_scan_inputs-Tuple{}","page":"scan_input","title":"moment_kinetics.scan_input.mk_scan_inputs","text":"\n\n\n\n","category":"method"}]
}
