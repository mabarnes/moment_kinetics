var documenterSearchIndex = {"docs":
[{"location":"numerical_dissipation/#numerical_dissipation","page":"numerical_dissipation","title":"numerical_dissipation","text":"","category":"section"},{"location":"numerical_dissipation/","page":"numerical_dissipation","title":"numerical_dissipation","text":"Modules = [moment_kinetics.numerical_dissipation]","category":"page"},{"location":"numerical_dissipation/#moment_kinetics.numerical_dissipation","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation","text":"\n\n\n\n","category":"module"},{"location":"numerical_dissipation/#moment_kinetics.numerical_dissipation.force_minimum_pdf_value!-Tuple{Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.force_minimum_pdf_value!","text":"force_minimum_pdf_value!(f, num_diss_paras::numerical_dissipation_parameters)\n\nSet a minimum value for the pdf-sized array f. Any points less than the minimum are set to the minimum. By default, no minimum is applied. The minimum value can be set by\n\n[numerical_dissipation]\nforce_minimum_pdf_value = 0.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_dissipation/#moment_kinetics.numerical_dissipation.force_minimum_pdf_value_neutral!-Tuple{Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.force_minimum_pdf_value_neutral!","text":"force_minimum_pdf_value_neutral!(f, num_diss_paras::numerical_dissipation_parameters)\n\nSet a minimum value for the neutral-pdf-sized array f. Any points less than the minimum are set to the minimum. By default, no minimum is applied. The minimum value can be set by\n\n[numerical_dissipation]\nforce_minimum_pdf_value = 0.0\n\n\n\n\n\n","category":"method"},{"location":"numerical_dissipation/#moment_kinetics.numerical_dissipation.r_dissipation!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.r_dissipation!","text":"Add diffusion in the r direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nr_dissipation_coefficient = 0.1\n\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"numerical_dissipation/#moment_kinetics.numerical_dissipation.r_dissipation_neutral!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.r_dissipation_neutral!","text":"Add diffusion in the r direction to suppress oscillations for neutrals\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nr_dissipation_coefficient = 0.1\n\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_boundary_buffer_decay!-Tuple{Any, Any, Any, Any, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_boundary_buffer_decay!","text":"Suppress the distribution function by damping towards a Maxwellian in the last element before the vpa boundaries, to avoid numerical instabilities there.\n\nDisabled by default.\n\nThe damping rate is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nvpa_boundary_buffer_damping_rate = 0.1\n\n\n\n\n\n","category":"method"},{"location":"numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_boundary_buffer_diffusion!-Tuple{Any, Any, Any, Any, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_boundary_buffer_diffusion!","text":"Suppress the distribution function by applying diffusion in the last element before the vpa boundaries, to avoid numerical instabilities there.\n\nDisabled by default.\n\nThe maximum diffusion rate in the buffer is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nvpa_boundary_buffer_diffusion_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_boundary_force_decreasing!-Tuple{Any, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_boundary_force_decreasing!","text":"Try to suppress oscillations near the boundary by ensuring that every point in the final element is ≤ the innermost value. The distribution function should be decreasing near the boundaries, so this should be an OK thing to force.\n\nNote: not currently used.\n\n\n\n\n\n","category":"method"},{"location":"numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_dissipation!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_dissipation!","text":"Add diffusion in the vpa direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nvpa_dissipation_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"numerical_dissipation/#moment_kinetics.numerical_dissipation.vz_dissipation_neutral!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vz_dissipation_neutral!","text":"Add diffusion in the vz direction to suppress oscillations for neutrals\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nvz_dissipation_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"numerical_dissipation/#moment_kinetics.numerical_dissipation.z_dissipation!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.z_dissipation!","text":"Add diffusion in the z direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nz_dissipation_coefficient = 0.1\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"numerical_dissipation/#moment_kinetics.numerical_dissipation.z_dissipation_neutral!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, moment_kinetics.numerical_dissipation.numerical_dissipation_parameters, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.z_dissipation_neutral!","text":"Add diffusion in the z direction to suppress oscillations for neutrals\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[numerical_dissipation]\nz_dissipation_coefficient = 0.1\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"shared_memory_debugging/#Shared-memory-debugging","page":"Shared memory debugging","title":"Shared memory debugging","text":"","category":"section"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"This debug_test directory contains scripts for running a set of short runs, intended to be used with the --debug flag to check for bugs (e.g. race conditions). The output is not checked - the intention is just to catch errors raised by the debugging checks.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The inputs only have 3 time-steps, and very few grid points, because the debug checks are very slow. The actual output is not important, so it does not matter that the runs are badly under-resolved.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"It may be necessary to use the --compiled-modules=no flag to Julia for changes to the --debug setting to be picked up correctly. This setting means that all precompilation is redone each time Julia is started, which can be slow. An alternative workaround is to hard-code the moment_kinetics.debugging._debug_level variable in debugging.jl to the desired value.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"To run the debug tests, call (from the top-level moment_kinetics directory) something like","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"julia --project --check-bounds=yes --compiled-modules=no debug_test/runtests.jl --debug 99","category":"page"},{"location":"shared_memory_debugging/#Finding-race-conditions","page":"Shared memory debugging","title":"Finding race conditions","text":"","category":"section"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The code is parallelized using MPI with shared memory arrays. 'Race conditions' can occur if a shared array is accessed incorrectly. All the processes sharing an array can be synchronized, ensuring they pass through the following code block with a consistent state, by using the _block_synchronize() function (which calls MPI.Barrier() to synchronize the processes). Race conditions occur if between consecutive calls to _block_synchronize() any array is:","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"written by 2 or more processes at the same position\nwritten by one process at a certain position, and read by one or more other processes at the same position.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"If a race condition occurs, it can result in errors in the results. These are sometimes small, but often show inconsistent results between runs (because results erroneously depend on the execution order on different processes). They are undefined behaviour though, and so can also cause anything up to segfaults.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The provided debugging routines can help to pin down where either of these errors happen.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The @debug_shared_array macro (activated at --debug 2 or higher) counts all reads and writes to shared arrays by each process, and checks at each _block_synchronize() call whether either pattern has occurred since the previous _block_synchronize(). If they have and in addition @debug_track_array_allocate_location is active (--debug 3 or higher), then the array for which the error occured is identified by printing a stack-trace of the location where it was allocated, and the stack-trace for the exception shows the location of the _block_synchronize() call where the error occured.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"@debug_block_synchronize (activated at --debug 4)checks that all processes called _block_synchronize() from the same place - i.e. the same line in the code, checked by comparing stack traces.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"@debug_detect_redundant_block_synchronize (activated at --debug 5) aims to find any unnecessary calls to _block_synchronize(). These calls can be somewhat expensive (for large numbers of processes at least), so it is good to minimise the number. When this mode is active, at each _block_synchronize() a check is made whether there would be a race-condition error if the previous _block_synchronize() call was removed. If there would not be, then the previous call was unnecessary and could be removed. The tricky part is that whether it was necessary or not could depend on the options being used... Detecting redundant block_synchronize() calls requires that all dimensions that could be split over processes are actually split over processes, which demands a large number of processes are used. The @debug_detect_redundant_block_synchronize flag, when activated, modifies the splitting algorithm to force every dimension to be split if possible, and raise an error if not.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"Suggested debugging strategy for race conditions is:","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"Look at the loop types and ensure that there is an appropriate begin_*_region() call before each new loop type.\nRun debug_test/runtests.jl with @debug_shared_array activated, but not @debug_detect_redundant_block_synchronize. It will be faster to first run without @debug_track_array_allocate_location to find failing tests, then with @debug_track_array_allocate_location to help identify the cause of the failure. Usually a failure should indicate where there is a missing begin_*_region() call. There may be places though where synchronization is required even though the type of loop macros used does not change (for example when phi is calculated contributions from all charged species need to be summed, resulting in an unusual pattern of array accesses); in this case _block_synchronize() can be called directly.\nThe function debug_check_shared_memory() can be inserted between begin_*_region() calls when debugging to narrow down the location where the incorrect array access occured. It is defined when @debug_shared_array is active, and can be imported with using ..communication: debug_check_shared_memory(). The function runs the same error checks as are added by @debug_shared_array in _block_synchronize().\nThe tests in debug_test/ check for correctness by looping over the dimensions and forcing each to be split over separate processes in turn. This allows the correctness checks to be run using only 2 processes, which would not be possible if all dimensions had to be split at the same time.\n[This final level of checking only looks for minor optimizations rather than finding bugs, so it is much less important than the checks above.] Run debug_test/debug_redundant_synchronization/runtests.jl with @debug_detect_redundant_block_synchronize activated. This should show if any call to _block_synchronize() (including the ones inside begin_*_region() calls) was 'unnecessary' - i.e. there would be no incorrect array accesses if it was removed. This test needs to be run on a suitable combination of grid sizes and numbers of processes so that all dimensions are split across multiple processes to avoid false positives.  Any redundant calls which appear in all tests can be deleted.  Redundant calls that appear in only some tests (unless they are in some code block that is just not called in all the other tests) should preferably be moved inside a conditional block, so that they are called only when necessary, if a suitable one exists. If there is no conditional block that the call can be moved to, it may sometimes be necessary to just test one or more options before calling, e.g.\nmoments.evolve_upar && _block_synchronize()\nThe checks for redundant _block_synchronize() calls have been separated from the correctness checks so that the correctness checks can be run in the CI using only 2 processes, while the redundancy checks can be run manually on a machine with enough memory and cpu cores.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"You can find out what loop type is currently active by looking at loop_ranges[].parallel_dims. This variable is a Tuple containing Symbols for each dimension currently being parallelized.","category":"page"},{"location":"force_balance/#force_balance","page":"force_balance","title":"force_balance","text":"","category":"section"},{"location":"force_balance/","page":"force_balance","title":"force_balance","text":"Modules = [moment_kinetics.force_balance]","category":"page"},{"location":"force_balance/#moment_kinetics.force_balance","page":"force_balance","title":"moment_kinetics.force_balance","text":"\n\n\n\n","category":"module"},{"location":"force_balance/#moment_kinetics.force_balance.force_balance!-NTuple{11, Any}","page":"force_balance","title":"moment_kinetics.force_balance.force_balance!","text":"use the force balance equation d(nu)/dt + d(ppar + nuparupar)/dz = -(dens/2)dphi/dz + Rdensi*densn(uparn-upari) to update the parallel particle flux densupar for each species\n\n\n\n\n\n","category":"method"},{"location":"z_advection/#z_advection","page":"z_advection","title":"z_advection","text":"","category":"section"},{"location":"z_advection/","page":"z_advection","title":"z_advection","text":"Modules = [moment_kinetics.z_advection]","category":"page"},{"location":"z_advection/#moment_kinetics.z_advection","page":"z_advection","title":"moment_kinetics.z_advection","text":"\n\n\n\n","category":"module"},{"location":"z_advection/#moment_kinetics.z_advection.adjust_advection_speed!-NTuple{5, Any}","page":"z_advection","title":"moment_kinetics.z_advection.adjust_advection_speed!","text":"\n\n\n\n","category":"method"},{"location":"z_advection/#moment_kinetics.z_advection.unnormalize_pdf!-NTuple{6, Any}","page":"z_advection","title":"moment_kinetics.z_advection.unnormalize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"z_advection/#moment_kinetics.z_advection.update_speed_z!-NTuple{12, Any}","page":"z_advection","title":"moment_kinetics.z_advection.update_speed_z!","text":"calculate the advection speed in the z-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"z_advection/#moment_kinetics.z_advection.z_advection!-NTuple{15, Any}","page":"z_advection","title":"moment_kinetics.z_advection.z_advection!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"energy_equation/#energy_equation","page":"energy_equation","title":"energy_equation","text":"","category":"section"},{"location":"energy_equation/","page":"energy_equation","title":"energy_equation","text":"Modules = [moment_kinetics.energy_equation]","category":"page"},{"location":"energy_equation/#moment_kinetics.energy_equation","page":"energy_equation","title":"moment_kinetics.energy_equation","text":"\n\n\n\n","category":"module"},{"location":"energy_equation/#moment_kinetics.energy_equation.energy_equation!-NTuple{8, Any}","page":"energy_equation","title":"moment_kinetics.energy_equation.energy_equation!","text":"evolve the parallel pressure by solving the energy equation\n\n\n\n\n\n","category":"method"},{"location":"energy_equation/#moment_kinetics.energy_equation.neutral_energy_equation!-NTuple{8, Any}","page":"energy_equation","title":"moment_kinetics.energy_equation.neutral_energy_equation!","text":"evolve the neutral parallel pressure by solving the energy equation\n\n\n\n\n\n","category":"method"},{"location":"velocity_grid_transforms/#velocity_grid_transforms","page":"velocity_grid_transforms","title":"velocity_grid_transforms","text":"","category":"section"},{"location":"velocity_grid_transforms/","page":"velocity_grid_transforms","title":"velocity_grid_transforms","text":"Modules = [moment_kinetics.velocity_grid_transforms]","category":"page"},{"location":"velocity_grid_transforms/#moment_kinetics.velocity_grid_transforms","page":"velocity_grid_transforms","title":"moment_kinetics.velocity_grid_transforms","text":"\n\n\n\n","category":"module"},{"location":"file_io/#file_io","page":"file_io","title":"file_io","text":"","category":"section"},{"location":"file_io/","page":"file_io","title":"file_io","text":"Modules = [moment_kinetics.file_io]","category":"page"},{"location":"file_io/#moment_kinetics.file_io","page":"file_io","title":"moment_kinetics.file_io","text":"\n\n\n\n","category":"module"},{"location":"file_io/#moment_kinetics.file_io.debug_output_counter","page":"file_io","title":"moment_kinetics.file_io.debug_output_counter","text":"Global counter for calls to debug_dump\n\n\n\n\n\n","category":"constant"},{"location":"file_io/#moment_kinetics.file_io.debug_output_file","page":"file_io","title":"moment_kinetics.file_io.debug_output_file","text":"An nc_info instance that may be initialised for writing debug output\n\nThis is a non-const module variable, so does cause type instability, but it is only used for debugging (from debug_dump()) so performance is not critical.\n\n\n\n\n\n","category":"constant"},{"location":"file_io/#moment_kinetics.file_io.ascii_ios","page":"file_io","title":"moment_kinetics.file_io.ascii_ios","text":"structure containing the various input/output streams\n\n\n\n\n\n","category":"type"},{"location":"file_io/#moment_kinetics.file_io.io_dfns_info","page":"file_io","title":"moment_kinetics.file_io.io_dfns_info","text":"structure containing the data/metadata needed for binary file i/o distribution function data only\n\n\n\n\n\n","category":"type"},{"location":"file_io/#moment_kinetics.file_io.io_moments_info","page":"file_io","title":"moment_kinetics.file_io.io_moments_info","text":"structure containing the data/metadata needed for binary file i/o moments & fields only\n\n\n\n\n\n","category":"type"},{"location":"file_io/#moment_kinetics.file_io.add_attribute!-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.add_attribute!","text":"Add an attribute to a file, group or variable\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.add_vspace_coordinates!-NTuple{7, Any}","page":"file_io","title":"moment_kinetics.file_io.add_vspace_coordinates!","text":"Add to coords group in output file information about vspace coordinate grids\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.append_to_dynamic_var-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.append_to_dynamic_var","text":"append_to_dynamic_var(io_var, data, t_idx, coords...)\n\nAppend data to the dynamic variable io_var. The time-index of the data being appended is t_idx. coords... is used to get the ranges to write from/to (needed for parallel I/O) - the entries in the coords tuple can be either coordinate instances or integers (for an integer n the range is 1:n).\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.create_dynamic_variable!-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.create_dynamic_variable!","text":"create_dynamic_variable!(file_or_group, name, type, coords::coordinate...;\n                         nspecies=1, description=nothing, units=nothing)\n\nCreate a time-evolving variable in file_or_group named name of type type. coords are the coordinates corresponding to the dimensions of the array, in the order of the array dimensions. The species dimension does not have a coordinate, so the number of species is passed as nspecies. A description and/or units can be added with the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.debug_dump","page":"file_io","title":"moment_kinetics.file_io.debug_dump","text":"debug_dump(ff, dens, upar, ppar, phi, t; istage=0, label=\"\")\ndebug_dump(fvec::scratch_pdf, fields::em_fields_struct, t; istage=0, label=\"\")\n\nDump variables into a NetCDF file for debugging\n\nIntended to be called more frequently than write_data_to_binary(), possibly several times within a timestep, so includes a label argument to identify the call site.\n\nWrites to a file called debug_output.h5 in the current directory.\n\nCan either be called directly with the arrays to be dumped (fist signature), or using scratch_pdf and em_fields_struct structs.\n\nnothing can be passed to any of the positional arguments (if they are unavailable at a certain point in the code, or just not interesting). t=nothing will set t to the value saved in the previous call (or 0.0 on the first call). Passing nothing to the other arguments will set that array to 0.0 for this call (need to write some value so all the arrays have the same length, with an entry for each call to debug_dump()).\n\n\n\n\n\n","category":"function"},{"location":"file_io/#moment_kinetics.file_io.define_dynamic_dfn_variables!-NTuple{11, Any}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_dfn_variables!","text":"define dynamic (time-evolving) distribution function variables for writing to the output file\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.define_dynamic_moment_variables!-Tuple{Any, Any, Any, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate, Any}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_moment_variables!","text":"define dynamic (time-evolving) moment variables for writing to the hdf5 file\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.define_io_coordinate!-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.define_io_coordinate!","text":"define a sub-group for each code coordinate and write to output file\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.define_spatial_coordinates!-NTuple{4, Any}","page":"file_io","title":"moment_kinetics.file_io.define_spatial_coordinates!","text":"Define coords group for coordinate information in the output file and write information about spatial coordinate grids\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.finish_file_io-Tuple{Union{Nothing, moment_kinetics.file_io.ascii_ios}, Union{Nothing, moment_kinetics.file_io.io_moments_info}, Union{Nothing, moment_kinetics.file_io.io_dfns_info}}","page":"file_io","title":"moment_kinetics.file_io.finish_file_io","text":"close all opened output files\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.get_group-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.get_group","text":"Get a (sub-)group from a file or group\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.get_subgroup_keys-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.get_subgroup_keys","text":"Get names of all subgroups\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.get_variable_keys-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.get_variable_keys","text":"Get names of all variables\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.hdf5_get_dynamic_dim_sizes-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.hdf5_get_dynamic_dim_sizes","text":"given a tuple, fixed_coords, containing all dimensions except the time dimension, get the dimension sizes and chunk sizes\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.hdf5_get_fixed_dim_sizes-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.hdf5_get_fixed_dim_sizes","text":"Get sizes of fixed dimensions and chunks (i.e. everything but time) for I/O\n\ncoords should be a tuple whose elements are coordinate structs or integers (e.g. number of species).\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.input_option_error-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.input_option_error","text":"accepts an option name which has been identified as problematic and returns an appropriate error message\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.io_has_parallel-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.io_has_parallel","text":"io_has_parallel(Val(binary_format))\n\nTest if the backend supports parallel I/O.\n\nbinary_format should be one of the values of the binary_format_type enum\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.is_group-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.is_group","text":"Test if a member of a (sub-)group is a group\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.open_ascii_output_file-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.open_ascii_output_file","text":"opens an output file with the requested prefix and extension and returns the corresponding io stream (identifier)\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.open_output_file-NTuple{4, Any}","page":"file_io","title":"moment_kinetics.file_io.open_output_file","text":"Open an output file, selecting the backend based on io_option\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.setup_dfns_io-NTuple{18, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_dfns_io","text":"setup file i/o for distribution function variables\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.setup_file_io-NTuple{15, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_file_io","text":"open the necessary output files\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.setup_moments_io-NTuple{12, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_moments_io","text":"setup file i/o for moment variables\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_boundary_distributions!-NTuple{10, Any}","page":"file_io","title":"moment_kinetics.file_io.write_boundary_distributions!","text":"Write the distributions that may be used for boundary conditions to the output file\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_data_to_ascii-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Union{Nothing, moment_kinetics.file_io.ascii_ios}}","page":"file_io","title":"moment_kinetics.file_io.write_data_to_ascii","text":"\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_dfns_data_to_binary-NTuple{16, Any}","page":"file_io","title":"moment_kinetics.file_io.write_dfns_data_to_binary","text":"write time-dependent distribution function data to the binary output file\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_f_ascii-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.write_f_ascii","text":"write the function f(z,vpa) at this time slice\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_fields_ascii-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.write_fields_ascii","text":"write electrostatic potential at this time slice\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_input!-Tuple{Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_input!","text":"Save info from the dict with input settings to the output file\n\nNote: assumes all keys in input_dict are strings.\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_moments_charged_ascii-NTuple{6, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_charged_ascii","text":"write moments of the charged species distribution function f at this time slice\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_moments_data_to_binary-NTuple{9, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_data_to_binary","text":"write time-dependent moments data to the binary output file\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_moments_neutral_ascii-NTuple{6, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_neutral_ascii","text":"write moments of the neutral species distribution function f_neutral at this time slice\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_overview!-NTuple{7, Any}","page":"file_io","title":"moment_kinetics.file_io.write_overview!","text":"write some overview information for the simulation to the binary file\n\n\n\n\n\n","category":"method"},{"location":"file_io/#moment_kinetics.file_io.write_single_value!-Tuple{}","page":"file_io","title":"moment_kinetics.file_io.write_single_value!","text":"write_single_value!(file_or_group, name, value; description=nothing)\n\nWrite a single variable to a file or group. If a description is passed, add as an attribute of the variable.\n\n\n\n\n\n","category":"method"},{"location":"clenshaw_curtis/#clenshaw_curtis","page":"clenshaw_curtis","title":"clenshaw_curtis","text":"","category":"section"},{"location":"clenshaw_curtis/","page":"clenshaw_curtis","title":"clenshaw_curtis","text":"Modules = [moment_kinetics.clenshaw_curtis]","category":"page"},{"location":"clenshaw_curtis/#moment_kinetics.clenshaw_curtis","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis","text":"\n\n\n\n","category":"module"},{"location":"clenshaw_curtis/#moment_kinetics.clenshaw_curtis.chebyshevpoints-Tuple{Any}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.chebyshevpoints","text":"\n\n\n\n","category":"method"},{"location":"clenshaw_curtis/#moment_kinetics.clenshaw_curtis.clenshawcurtisnodes-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.clenshawcurtisnodes","text":"Compute nodes of the Clenshaw—Curtis quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"clenshaw_curtis/#moment_kinetics.clenshaw_curtis.clenshawcurtisweights-Tuple{}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.clenshawcurtisweights","text":"Compute weights of the Clenshaw—Curtis quadrature rule with modified Chebyshev moments of the first kind (μ)\n\n\n\n\n\n","category":"method"},{"location":"clenshaw_curtis/#moment_kinetics.clenshaw_curtis.plan_clenshawcurtis-Tuple{Any}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.plan_clenshawcurtis","text":"\n\n\n\n","category":"method"},{"location":"neutral_z_advection/#neutral_z_advection","page":"neutral_z_advection","title":"neutral_z_advection","text":"","category":"section"},{"location":"neutral_z_advection/","page":"neutral_z_advection","title":"neutral_z_advection","text":"Modules = [moment_kinetics.neutral_z_advection]","category":"page"},{"location":"neutral_z_advection/#moment_kinetics.neutral_z_advection","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection","text":"\n\n\n\n","category":"module"},{"location":"neutral_z_advection/#moment_kinetics.neutral_z_advection.adjust_advection_speed!-NTuple{5, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.adjust_advection_speed!","text":"\n\n\n\n","category":"method"},{"location":"neutral_z_advection/#moment_kinetics.neutral_z_advection.neutral_advection_z!-NTuple{14, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.neutral_advection_z!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"neutral_z_advection/#moment_kinetics.neutral_z_advection.unnormalize_pdf!-NTuple{6, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.unnormalize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"neutral_z_advection/#moment_kinetics.neutral_z_advection.update_speed_neutral_z!-NTuple{11, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.update_speed_neutral_z!","text":"calculate the advection speed in the z-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"ionization/#ionization","page":"ionization","title":"ionization","text":"","category":"section"},{"location":"ionization/","page":"ionization","title":"ionization","text":"Modules = [moment_kinetics.ionization]","category":"page"},{"location":"ionization/#moment_kinetics.ionization","page":"ionization","title":"moment_kinetics.ionization","text":"\n\n\n\n","category":"module"},{"location":"communication/#communication","page":"communication","title":"communication","text":"","category":"section"},{"location":"communication/","page":"communication","title":"communication","text":"Modules = [moment_kinetics.communication]","category":"page"},{"location":"communication/#moment_kinetics.communication","page":"communication","title":"moment_kinetics.communication","text":"Communication functions and setup\n\nSplit the grid into 'blocks'. Each block can use shared memory (MPI shared memory arrays). At the moment only works with a single 'block' containing the whole grid - eventually add more MPI communication functions to communicate between blocks. A block should probably be a 'NUMA region' for maximum efficiency.\n\nNote: charge-exchange collisions loop over neutral species for each ion species. At the moment this loop is not parallelised (although it could be, by introducing some more loop ranges), as at the moment we only run with 1 ion species and 1 neutral species.\n\n\n\n\n\n","category":"module"},{"location":"communication/#moment_kinetics.communication.block_rank","page":"communication","title":"moment_kinetics.communication.block_rank","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.block_size","page":"communication","title":"moment_kinetics.communication.block_size","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.comm_block","page":"communication","title":"moment_kinetics.communication.comm_block","text":"Communicator connecting a shared-memory region\n\nMust use a Ref{MPI.Comm} to allow a non-const MPI.Comm to be stored. Need to actually assign to this and not just copy a pointer into the .val member because otherwise the MPI.Comm object created by MPI.Comm_split() would be deleted, which probably makes MPI.jl delete the communicator.\n\n\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.comm_inter_block","page":"communication","title":"moment_kinetics.communication.comm_inter_block","text":"Communicator connecting the root processes of each shared memory block\n\nMust use a Ref{MPI.Comm} to allow a non-const MPI.Comm to be stored. Need to actually assign to this and not just copy a pointer into the .val member because otherwise the MPI.Comm object created by MPI.Comm_split() would be deleted, which probably makes MPI.jl delete the communicator.\n\n\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.comm_world","page":"communication","title":"moment_kinetics.communication.comm_world","text":"Can use a const MPI.Comm for comm_world and just copy the pointer from MPI.COMM_WORLD because MPI.COMM_WORLD is never deleted, so pointer stays valid.\n\n\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.global_Win_store","page":"communication","title":"moment_kinetics.communication.global_Win_store","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.global_rank","page":"communication","title":"moment_kinetics.communication.global_rank","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.global_size","page":"communication","title":"moment_kinetics.communication.global_size","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.iblock_index","page":"communication","title":"moment_kinetics.communication.iblock_index","text":"\n\n\n\n","category":"constant"},{"location":"communication/#moment_kinetics.communication.MPISharedArray","page":"communication","title":"moment_kinetics.communication.MPISharedArray","text":"\n\n\n\n","category":"type"},{"location":"communication/#moment_kinetics.communication.__init__-Tuple{}","page":"communication","title":"moment_kinetics.communication.__init__","text":"\n\n\n\n","category":"method"},{"location":"communication/#moment_kinetics.communication._block_synchronize-Tuple{}","page":"communication","title":"moment_kinetics.communication._block_synchronize","text":"Call an MPI Barrier for all processors in a block.\n\nUsed to synchronise processors that are working on the same shared-memory array(s) between operations, to avoid race conditions. Should be (much) cheaper than a global MPI Barrier because it only requires communication within a single node.\n\nNote: some debugging code currently assumes that if blocksynchronize() is called on one block, it is called simultaneously on all blocks. It seems likely that this will always be true, but if it ever changes (i.e. different blocks doing totally different work), the debugging routines need to be updated.\n\n\n\n\n\n","category":"method"},{"location":"communication/#moment_kinetics.communication.allocate_shared-Tuple{Any, Any}","page":"communication","title":"moment_kinetics.communication.allocate_shared","text":"Get a shared-memory array of mk_float (shared by all processes in a 'block')\n\nCreate a shared-memory array using MPI.Win_allocate_shared(). Pointer to the memory allocated is wrapped in a Julia array. Memory is not managed by the Julia array though. A reference to the MPI.Win needs to be freed - this is done by saving the MPI.Win into a Vector in the Communication module, which has all its entries freed by the finalize_comms!() function, which should be called when moment_kinetics is done running a simulation/test.\n\nArguments\n\ndims - mkint or Tuple{mkint}     Dimensions of the array to be created. Dimensions passed define the size of the     array which is being handled by the 'block' (rather than the global array, or a     subset for a single process).\n\nReturns\n\nArray{mk_float}\n\n\n\n\n\n","category":"method"},{"location":"communication/#moment_kinetics.communication.finalize_comms!-Tuple{}","page":"communication","title":"moment_kinetics.communication.finalize_comms!","text":"Clean up from communications\n\nDo any needed clean-up for MPI, etc. Does not call MPI.Finalize() - this is called anyway when Julia exits, and we do not want to call it explicitly so that multiple runs can be done in a single Julia session.\n\nFrees any shared-memory arrays.\n\n\n\n\n\n","category":"method"},{"location":"communication/#moment_kinetics.communication.free_shared_arrays-Tuple{}","page":"communication","title":"moment_kinetics.communication.free_shared_arrays","text":"\n\n\n\n","category":"method"},{"location":"communication/#moment_kinetics.communication.initialize_comms!-Tuple{}","page":"communication","title":"moment_kinetics.communication.initialize_comms!","text":"Set up communications\n\nCheck that global variables are in the correct state (i.e. caches were emptied correctly if they were used before).\n\nAlso does some set up for debugging routines, if they are active.\n\n\n\n\n\n","category":"method"},{"location":"communication/#moment_kinetics.communication.setup_distributed_memory_MPI-NTuple{4, Any}","page":"communication","title":"moment_kinetics.communication.setup_distributed_memory_MPI","text":"Function to take information from user about r z grids and  number of processes allocated to set up communicators notation definitions:     - block: group of processes that share data with shared memory     - z group: group of processes that need to communicate data for z derivatives     - r group: group of processes that need to communicate data for r derivatives\n\n\n\n\n\n","category":"method"},{"location":"debugging/#debugging","page":"debugging","title":"debugging","text":"","category":"section"},{"location":"debugging/","page":"debugging","title":"debugging","text":"Modules = [moment_kinetics.debugging]","category":"page"},{"location":"debugging/#moment_kinetics.debugging","page":"debugging","title":"moment_kinetics.debugging","text":"Define debugging levels that can be used to include extra debugging steps\n\nProvides a bunch of macros (see the macronames Vector) that can be used to surround code in other modules so that it only runs if the 'debug level' passed to the --debug or -d command line argument is high enough.\n\nAlso provides macro *_ifelse whose names are taken from macronames, which can be used to switch definitions, etc. For example, if debug_shared_array is in macronames, then\n\nconst MPISharedArray = @debug_shared_array_ifelse(DebugMPISharedArray, Array)\n\ncan be used to make the type represented by MPISharedArray depend on the debug level.\n\n\n\n\n\n","category":"module"},{"location":"debugging/#moment_kinetics.debugging._debug_level","page":"debugging","title":"moment_kinetics.debugging._debug_level","text":"\n\n\n\n","category":"constant"},{"location":"debugging/#moment_kinetics.debugging.macronames","page":"debugging","title":"moment_kinetics.debugging.macronames","text":"\n\n\n\n","category":"constant"},{"location":"debugging/#moment_kinetics.debugging.@debug_block_synchronize-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_block_synchronize","text":"Check blocksynchronize() was called from the same place on every process.  Activated at _debug_level >= 4  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_block_synchronize_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_block_synchronize_ifelse","text":"Evaluate first expression if debugblocksynchronize is active, second expression if not  debugblocksynchronize is inactive (_debug_level = 0 < 4).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_detect_redundant_block_synchronize-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_detect_redundant_block_synchronize","text":"Check if any blocksynchronize() call could have been skipped without resulting in an error.  Activated at _debug_level >= 5  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_detect_redundant_block_synchronize_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_detect_redundant_block_synchronize_ifelse","text":"Evaluate first expression if debugdetectredundantblocksynchronize is active, second expression if not  debugdetectredundantblocksynchronize is inactive (_debug_level = 0 < 5).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_error_stop_all-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_error_stop_all","text":"Use MPI.Allgather to stop all processes following an error on any process.  Activated at _debug_level >= 1  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_error_stop_all_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_error_stop_all_ifelse","text":"Evaluate first expression if debugerrorstopall is active, second expression if not  debugerrorstopall is inactive (_debug_level = 0 < 1).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_initialize_NaN-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_initialize_NaN","text":"Initialize arrays with NaN.  Activated at _debug_level >= 1  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_initialize_NaN_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_initialize_NaN_ifelse","text":"Evaluate first expression if debuginitializeNaN is active, second expression if not  debuginitializeNaN is inactive (_debug_level = 0 < 1).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_shared_array-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array","text":"Check for incorrect reads/writes to shared-memory arrays  Activated at _debug_level >= 2  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_shared_array_allocate-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_allocate","text":"Check that allocateshared() was called from the same place on every process.  Activated at `debuglevel >= 4Currently inactive (debug_level = 0`).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_shared_array_allocate_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_allocate_ifelse","text":"Evaluate first expression if debugsharedarrayallocate is active, second expression if not  debugsharedarrayallocate is inactive (_debug_level = 0 < 4).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_shared_array_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_ifelse","text":"Evaluate first expression if debugsharedarray is active, second expression if not  debugsharedarray is inactive (_debug_level = 0 < 2).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_track_array_allocate_location-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_array_allocate_location","text":"Record where every array was allocated.  Activated at _debug_level >= 3  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"debugging/#moment_kinetics.debugging.@debug_track_array_allocate_location_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_array_allocate_location_ifelse","text":"Evaluate first expression if debugtrackarrayallocatelocation is active, second expression if not  debugtrackarrayallocatelocation is inactive (_debug_level = 0 < 3).\n\n\n\n\n\n","category":"macro"},{"location":"boundary_conditions_notes/#Wall-boundary-conditions-with-moment-constraints","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"","category":"section"},{"location":"boundary_conditions_notes/#Boundary-conditions","page":"Wall boundary conditions with moment constraints","title":"Boundary conditions","text":"","category":"section"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"The sheath-edge boundary conditions for the ions is that no ions leave from the sheath edge. So at the lower boundary z=-L_z2","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  f(z=-L2v_parallel0) = 0\nendalign","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and at the upper boundary z=L_z/2","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  f(z=L2v_parallel0) = 0\nendalign","category":"page"},{"location":"boundary_conditions_notes/#Moment-constraints","page":"Wall boundary conditions with moment constraints","title":"Moment constraints","text":"","category":"section"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"At the sheath-entrance boundary, the constraints need to be enforced slightly differently to how they are done in the bulk of the domain (see Constraints on normalized distribution function). For compatibility with the boundary condition, the corrections which are added to impose the constraints should go to zero at v_parallel=0. Note that the constraints are imposed after the boundary condition is applied by setting f(v_parallel0)=0 on the lower sheath boundary or f(v_parallel0)=0 on the upper sheath boundary.","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"The form of the correction that we choose is","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\ntildeg_s = Ahatg_s + Bw_parallel fracv_parallel1+v_parallelhatg_s + Cw_parallel^2 fracv_parallel1+v_parallelhatg_s\nendalign","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"We have the same set of constraints","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s  =1\n  frac1sqrtpiint dw_w_tildeg_s  =0\n  frac1sqrtpiint dw_w_^2tildeg_s  =frac12\nendalign","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Defining the integrals","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  I_n=frac1sqrtpiint dw_w_^nhatg_s\n  J_n=frac1sqrtpiint dw_w_^nfracv_parallel1+v_parallelhatg_s\nendalign","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"We can write the constraints as","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s=1  =frac1sqrtpiint dw_left(Ahatg_s+Bw_fracv_parallel1+v_parallelhatg_s+Cw_^2fracv_parallel1+v_parallelhatg_sright) \n  =AI_0+BJ_1+CJ_2\n  frac1sqrtpiint dw_w_tildeg_s=0  =frac1sqrtpiint dw_left(Aw_hatg_s+Bw_^2fracv_parallel1+v_parallelhatg_s+Cw_^3fracv_parallel1+v_parallelhatg_sright) \n  =AI_1+BJ_2+CJ_3\n  frac1sqrtpiint dw_w_^2tildeg_s=frac12  =frac1sqrtpiint dw_left(Aw_^2hatg_s+Bw_^3fracv_parallel1+v_parallelhatg_s+Cw_^4fracv_parallel1+v_parallelhatg_sright) \n  =AI_2+BJ_3+CJ_4\nendalign","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and solving these simultaneous equations","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracleft( frac12 - A I_2 - B J_3 right)J_4  \n  B = -fracA I_1 + C J_3J_2 \n    = -fracI_1J_2 A - fracJ_3J_2 left( frac12J_4 - fracI_2J_4 A - fracJ_3J_4 B right) \n  left( 1 - fracJ_3^2J_2 J_4 right) B = -fracJ_32 J_2 J_4 + left( fracI_2 J_3J_2 J_4 - fracI_1J_2 right) A \n  B = fracleft( fracI_2 J_3J_2 J_4 - fracI_1J_2 right) A - fracJ_32 J_2 J_4left( 1 - fracJ_3^2J_2 J_4 right) \n  = fracleft( I_2 J_3 - I_1 J_4 right) A - fracJ_32J_2 J_4 - J_3^2 \n  1 = A I_0 + B J_1 + C J_2 \n  = A I_0 + B J_1 + fracJ_2J_4left( frac12 - A I_2 - B J_3 right) \n  1 - fracJ_22 J_4 = left( I_0 - fracI_2 J_2J_4 right) A + left( J_1 - fracJ_2 J_3J_4 right) B \n  1 - fracJ_22 J_4 = left( I_0 - fracI_2 J_2J_4 right) A - fracleft( J_1 - fracJ_2 J_3J_4 right) J_32left( J_2 J_4 - J_3^2 right) + fracleft( J_1 - fracJ_2 J_3J_4 right)left( I_2 J_3 - I_1 J_4 right)left( J_2 J_4 - J_3^2 right) A \n  left( 1 - fracJ_22J_4 right) left( J_2 J_4 - J_3^2 right) = left( J_2 J_4 - J_3^2 right) left( I_0 - fracI_2 J_2J_4 right) A - fracleft( J_1 - fracJ_2 J_3J_4 right) J_32 + left( J_1 - fracJ_2 J_3J_4 right) left( I_2 J_3 - I_1 J_4 right) A \n  left( 1 - fracJ_22 J_4 right)left( J_2 J_4 - J_3^2 right) + fracleft( J_1 - fracJ_2 J_3J_4 right) J_32 = left left( J_2 J_4 - J_3^2 right)left( I_0 - fracI_2 J_2J_4 right) + left( J_1 - fracJ_2 J_3J_4 right)left( I_2 J_3 - I_1 J_4 right) right A \n  J_2 J_4 - fracJ_2^22 - J_3^2 + cancelfracJ_2 J_3^22 J_4 + fracJ_1 J_32 - cancelfracJ_2 J_3^22 J_4 = left I_0 J_2 J_4 - I_2 J_2^2 - I_0 J_3^2 + cancelfracI_2 J_2 J_3^2J_4 + I_2 J_1 J_3 - I_1 J_1 J_4 - cancelfracI_2 J_2 J_3^2J_4 + I_1 J_2 J_3 right A \n  J_2 J_4 - fracJ_2^22 + J_3left( fracJ_12 - J_3 right) = left I_0left( J_2 J_4 - J_3^2 right) + I_1left( J_2 J_3 - J_1 J_4 right) + I_2left( J_1 J_3 - J_2^2 right) right A \n  A =fracJ_2 J_4 - fracJ_2^22 + J_3left( fracJ_12 - J_3 right)I_0left( J_2 J_4 - J_3^2 right) + I_1 left( J_2 J_3 - J_1 J_4 right) + I_2left( J_1 J_3 - J_2^2 right)\nendalign","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"</details>","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracfrac12 - A I_2 - B J_3J_4  \n  B = fracfrac12 J_3 + A (I_1 J_4 - I_2 J_3)J_3^2 - J_2 J_4 \n  A = fracJ_3^2 - J_2 J_4 + frac12 (J_2^2 - J_1 J_3)I_0 (J_3^2 - J_2 J_4) + I_1 (J_1 J_4 - J_2 J_3) + I_2 (J_2^2 - J_1 J_3)\nendalign","category":"page"},{"location":"boundary_conditions_notes/#Evolving-u_\\parallel","page":"Wall boundary conditions with moment constraints","title":"Evolving u_parallel","text":"","category":"section"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When evolving only u_parallel and n separately, we only need two constraints. This corresponds to C=0 so that","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  1 = A I_0 + B J_1 \n  0 = A I_1 + B J_2 \n  B = -fracA I_1J_2 \n  A I_0 = 1 - B J_1 = 1 + fracA I_1 J_1J_2 \n  A = frac1I_0 - fracI_1 J_1J_2\nendalign","category":"page"},{"location":"boundary_conditions_notes/#Evolving-n","page":"Wall boundary conditions with moment constraints","title":"Evolving n","text":"","category":"section"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When only evolving n separately, the constraint is the same as in the bulk of the domain","category":"page"},{"location":"boundary_conditions_notes/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  1 = AI_0 \n  A = frac1I_0\nendalign","category":"page"},{"location":"input_options/#Input-Options","page":"Input Options","title":"Input Options","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"This page describes the input options that can be specified in momentkineticsinput.jl. The input variable name is given first, followed by its default value and a brief description.","category":"page"},{"location":"input_options/#File-I/O","page":"Input Options","title":"File I/O","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"run_name ::  :: prefix for all output files associated with this run base_directory :: \"runs\" :: directory where the simulation data will be stored","category":"page"},{"location":"input_options/#Model-Options","page":"Input Options","title":"Model Options","text":"","category":"section"},{"location":"coordinates/#coordinates","page":"coordinates","title":"coordinates","text":"","category":"section"},{"location":"coordinates/","page":"coordinates","title":"coordinates","text":"Modules = [moment_kinetics.coordinates]","category":"page"},{"location":"coordinates/#moment_kinetics.coordinates","page":"coordinates","title":"moment_kinetics.coordinates","text":"\n\n\n\n","category":"module"},{"location":"coordinates/#moment_kinetics.coordinates.coordinate","page":"coordinates","title":"moment_kinetics.coordinates.coordinate","text":"structure containing basic information related to coordinates\n\n\n\n\n\n","category":"type"},{"location":"coordinates/#moment_kinetics.coordinates.define_coordinate","page":"coordinates","title":"moment_kinetics.coordinates.define_coordinate","text":"create arrays associated with a given coordinate, setup the coordinate grid, and populate the coordinate structure containing all of this information\n\n\n\n\n\n","category":"function"},{"location":"coordinates/#moment_kinetics.coordinates.elemental_to_full_grid_map-Tuple{Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.elemental_to_full_grid_map","text":"returns imin and imax, which contain the minimum and maximum indices on the full grid for each element\n\n\n\n\n\n","category":"method"},{"location":"coordinates/#moment_kinetics.coordinates.equally_spaced_grid-NTuple{4, Any}","page":"coordinates","title":"moment_kinetics.coordinates.equally_spaced_grid","text":"setup an equally spaced grid with n_global grid points between [-L/2,L/2]\n\n\n\n\n\n","category":"method"},{"location":"coordinates/#moment_kinetics.coordinates.equally_spaced_grid_shifted-NTuple{4, Any}","page":"coordinates","title":"moment_kinetics.coordinates.equally_spaced_grid_shifted","text":"setup an equally spaced grid with n_global grid points between [0,L]\n\n\n\n\n\n","category":"method"},{"location":"coordinates/#moment_kinetics.coordinates.full_to_elemental_grid_map-Tuple{Any, Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.full_to_elemental_grid_map","text":"setup arrays containing a map from the unpacked grid point indices to the element index and the grid point index within each element\n\n\n\n\n\n","category":"method"},{"location":"coordinates/#moment_kinetics.coordinates.grid_spacing-Tuple{Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.grid_spacing","text":"given a set of grid point locations calculate and return the length associated with the cell between adjacent grid points\n\n\n\n\n\n","category":"method"},{"location":"coordinates/#moment_kinetics.coordinates.init_grid-NTuple{12, Any}","page":"coordinates","title":"moment_kinetics.coordinates.init_grid","text":"setup a grid with n_global grid points on the interval [-L/2,L/2]\n\n\n\n\n\n","category":"method"},{"location":"command_line_options/#command_line_options","page":"command_line_options","title":"command_line_options","text":"","category":"section"},{"location":"command_line_options/","page":"command_line_options","title":"command_line_options","text":"Modules = [moment_kinetics.command_line_options]","category":"page"},{"location":"command_line_options/#moment_kinetics.command_line_options","page":"command_line_options","title":"moment_kinetics.command_line_options","text":"Parse command line arguments\n\nHave to include test options here too, because ArgParse errors on unrecognized options.\n\n\n\n\n\n","category":"module"},{"location":"command_line_options/#moment_kinetics.command_line_options.get_options-Tuple{}","page":"command_line_options","title":"moment_kinetics.command_line_options.get_options","text":"\n\n\n\n","category":"method"},{"location":"type_definitions/#type_definitions","page":"type_definitions","title":"type_definitions","text":"","category":"section"},{"location":"type_definitions/","page":"type_definitions","title":"type_definitions","text":"Modules = [moment_kinetics.type_definitions]","category":"page"},{"location":"type_definitions/#moment_kinetics.type_definitions","page":"type_definitions","title":"moment_kinetics.type_definitions","text":"\n\n\n\n","category":"module"},{"location":"type_definitions/#moment_kinetics.type_definitions.mk_float","page":"type_definitions","title":"moment_kinetics.type_definitions.mk_float","text":"\n\n\n\n","category":"type"},{"location":"type_definitions/#moment_kinetics.type_definitions.mk_int","page":"type_definitions","title":"moment_kinetics.type_definitions.mk_int","text":"\n\n\n\n","category":"type"},{"location":"post_processing_input/#post_processing_input","page":"post_processing_input","title":"post_processing_input","text":"","category":"section"},{"location":"post_processing_input/","page":"post_processing_input","title":"post_processing_input","text":"Modules = [moment_kinetics.post_processing_input]","category":"page"},{"location":"post_processing_input/#moment_kinetics.post_processing_input","page":"post_processing_input","title":"moment_kinetics.post_processing_input","text":"\n\n\n\n","category":"module"},{"location":"derivatives/#derivatives","page":"derivatives","title":"derivatives","text":"","category":"section"},{"location":"derivatives/","page":"derivatives","title":"derivatives","text":"Modules = [moment_kinetics.derivatives]","category":"page"},{"location":"derivatives/#moment_kinetics.derivatives","page":"derivatives","title":"moment_kinetics.derivatives","text":"This module contains all the necessary derivatives needed to carry out distributed memory differential operations on the arrays in moment kinetics. We provide separate derivative functions for each (i) distributed dimension and (ii) array shape. We do not need to provide derivatives for non-distributed dimensions as these can by handled by the derivative! function from calculus.jl\n\n\n\n\n\n","category":"module"},{"location":"initial_conditions/#initial_conditions","page":"initial_conditions","title":"initial_conditions","text":"","category":"section"},{"location":"initial_conditions/","page":"initial_conditions","title":"initial_conditions","text":"Modules = [moment_kinetics.initial_conditions]","category":"page"},{"location":"initial_conditions/#moment_kinetics.initial_conditions","page":"initial_conditions","title":"moment_kinetics.initial_conditions","text":"\n\n\n\n","category":"module"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.pdf_substruct","page":"initial_conditions","title":"moment_kinetics.initial_conditions.pdf_substruct","text":"\n\n\n\n","category":"type"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.allocate_pdf_and_moments-NTuple{11, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.allocate_pdf_and_moments","text":"Creates the structs for the pdf and the velocity-space moments\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.convert_full_f_charged_to_normalised!-NTuple{11, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.convert_full_f_charged_to_normalised!","text":"Take the full charged-particle distribution function, calculate the moments, then normalise and shift to the moment-kinetic grid.\n\nUses input value of f and modifies in place to the normalised distribution functions. Input density, upar, ppar, and vth are not used, the values are overwritten with the moments of f.\n\nInputs/outputs depend on z, vperp, and vpa (should be inside loops over species, r)\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.convert_full_f_neutral_to_normalised!-NTuple{12, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.convert_full_f_neutral_to_normalised!","text":"Take the full neutral-particle distribution function, calculate the moments, then normalise and shift to the moment-kinetic grid.\n\nUses input value of f and modifies in place to the normalised distribution functions. Input density, upar, ppar, and vth are not used, the values are overwritten with the moments of f.\n\nInputs/outputs depend on z, vzeta, vr and vz (should be inside loops over species, r)\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.create_boundary_distributions-NTuple{7, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.create_boundary_distributions","text":"Allocate arrays for distributions to be applied as boundary conditions to the pdf at various boundaries. Also initialise the Knudsen cosine distribution here so it can be used when initialising the neutral pdf.\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.create_pdf-NTuple{8, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.create_pdf","text":"Allocate arrays for pdfs\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_boundary_conditions!-NTuple{20, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_boundary_conditions!","text":"enforce boundary conditions in vpa and z on the evolved pdf; also enforce boundary conditions in z on all separately evolved velocity space moments of the pdf\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_initial_tapered_zero_incoming!-Tuple{Any, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_initial_tapered_zero_incoming!","text":"Set up an initial condition that tries to be smoothly compatible with the sheath boundary condition for ions, by setting f(±(v_parallel-u0)<0) where u0=0 at the sheath boundaries and for z<0 increases linearly to u0=vpa.L at z=0, while for z>0 increases from u0=-vpa.L at z=0 to zero at the z=z.L/2 sheath.\n\nTo be applied to 'full-f' distribution function on vparallel grid (not wparallel grid).\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_neutral_boundary_conditions!-NTuple{25, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_neutral_boundary_conditions!","text":"enforce boundary conditions on neutral particle distribution function\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_neutral_wall_bc!-NTuple{16, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_neutral_wall_bc!","text":"enforce the wall boundary condition on neutrals; i.e., the incoming flux of neutrals equals the sum of the ion/neutral outgoing fluxes\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_neutral_z_boundary_condition!-NTuple{16, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_neutral_z_boundary_condition!","text":"enforce boundary conditions on neutral particle f in z\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_r_boundary_condition!-Union{Tuple{T}, Tuple{AbstractArray{Float64, 5}, Any, String, T, Any, Any, Any, Any, Any, AbstractArray{Float64, 4}, AbstractArray{Float64, 4}, AbstractArray{Float64, 4}, AbstractArray{Float64, 4}, AbstractArray{Float64, 5}, Bool}} where T","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_r_boundary_condition!","text":"enforce boundary conditions on f in r\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_v_boundary_condition_local!-NTuple{4, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_v_boundary_condition_local!","text":"\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_vpa_boundary_condition!-NTuple{4, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_vpa_boundary_condition!","text":"impose the prescribed vpa boundary condition on f at every z grid point\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_z_boundary_condition!-Tuple{Any, Any, Any, Any, Any, String, Any, Any, Any, Any, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_z_boundary_condition!","text":"enforce boundary conditions on charged particle f in z\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_z_boundary_condition_moments!-Tuple{Any, Any, String}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_z_boundary_condition_moments!","text":"enforce the z boundary condition on the evolved velocity space moments of f\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.enforce_zero_incoming_bc!-NTuple{4, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.enforce_zero_incoming_bc!","text":"enforce a zero incoming BC in z for given species pdf at each radial location\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.init_charged_pdf_over_density!-NTuple{15, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_charged_pdf_over_density!","text":"\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.init_density!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_density!","text":"\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.init_neutral_pdf_over_density!-NTuple{19, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_neutral_pdf_over_density!","text":"\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.init_pdf_and_moments!-NTuple{16, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_pdf_and_moments!","text":"creates the normalised pdf and the velocity-space moments and populates them with a self-consistent initial condition\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.init_upar!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_upar!","text":"\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.init_uz!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_uz!","text":"\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.init_vth!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_vth!","text":"for now the only initialisation option for the temperature is constant in z returns vth0 = sqrt(2Ts/ms) / sqrt(2Te/ms) = sqrt(Ts/Te)\n\n\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.initialize_pdf!-NTuple{14, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.initialize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"initial_conditions/#moment_kinetics.initial_conditions.vpagrid_to_dzdt-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.vpagrid_to_dzdt","text":"create an array of dz/dt values corresponding to the given vpagrid values\n\n\n\n\n\n","category":"method"},{"location":"em_fields/#em_fields","page":"em_fields","title":"em_fields","text":"","category":"section"},{"location":"em_fields/","page":"em_fields","title":"em_fields","text":"Modules = [moment_kinetics.em_fields]","category":"page"},{"location":"em_fields/#moment_kinetics.em_fields","page":"em_fields","title":"moment_kinetics.em_fields","text":"\n\n\n\n","category":"module"},{"location":"em_fields/#moment_kinetics.em_fields.setup_em_fields-NTuple{6, Any}","page":"em_fields","title":"moment_kinetics.em_fields.setup_em_fields","text":"\n\n\n\n","category":"method"},{"location":"em_fields/#moment_kinetics.em_fields.update_phi!-NTuple{8, Any}","page":"em_fields","title":"moment_kinetics.em_fields.update_phi!","text":"update_phi updates the electrostatic potential, phi\n\n\n\n\n\n","category":"method"},{"location":"input_structs/#input_structs","page":"input_structs","title":"input_structs","text":"","category":"section"},{"location":"input_structs/","page":"input_structs","title":"input_structs","text":"Modules = [moment_kinetics.input_structs]","category":"page"},{"location":"input_structs/#moment_kinetics.input_structs","page":"input_structs","title":"moment_kinetics.input_structs","text":"\n\n\n\n","category":"module"},{"location":"input_structs/#moment_kinetics.input_structs.advance_info","page":"input_structs","title":"moment_kinetics.input_structs.advance_info","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.advection_input","page":"input_structs","title":"moment_kinetics.input_structs.advection_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.advection_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.advection_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.collisions_input","page":"input_structs","title":"moment_kinetics.input_structs.collisions_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.drive_input","page":"input_structs","title":"moment_kinetics.input_structs.drive_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.drive_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.drive_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.electron_physics_type","page":"input_structs","title":"moment_kinetics.input_structs.electron_physics_type","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.evolve_moments_options","page":"input_structs","title":"moment_kinetics.input_structs.evolve_moments_options","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.geometry_input","page":"input_structs","title":"moment_kinetics.input_structs.geometry_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.grid_input","page":"input_structs","title":"moment_kinetics.input_structs.grid_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.grid_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.grid_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.initial_condition_input","page":"input_structs","title":"moment_kinetics.input_structs.initial_condition_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.initial_condition_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.initial_condition_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.io_input","page":"input_structs","title":"moment_kinetics.input_structs.io_input","text":"Settings and input for setting up file I/O\n\n\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.pp_input","page":"input_structs","title":"moment_kinetics.input_structs.pp_input","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.species_composition","page":"input_structs","title":"moment_kinetics.input_structs.species_composition","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.species_parameters","page":"input_structs","title":"moment_kinetics.input_structs.species_parameters","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.species_parameters_mutable","page":"input_structs","title":"moment_kinetics.input_structs.species_parameters_mutable","text":"\n\n\n\n","category":"type"},{"location":"input_structs/#moment_kinetics.input_structs.time_input","page":"input_structs","title":"moment_kinetics.input_structs.time_input","text":"\n\n\n\n","category":"type"},{"location":"calculus/#calculus","page":"calculus","title":"calculus","text":"","category":"section"},{"location":"calculus/","page":"calculus","title":"calculus","text":"Modules = [moment_kinetics.calculus]","category":"page"},{"location":"calculus/#moment_kinetics.calculus","page":"calculus","title":"moment_kinetics.calculus","text":"\n\n\n\n","category":"module"},{"location":"calculus/#moment_kinetics.calculus.derivative!-NTuple{4, Any}","page":"calculus","title":"moment_kinetics.calculus.derivative!","text":"derivative!(df, f, coord, spectral)\n\nNon-upwinding derivative.\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.derivative!-Tuple{Any, Any, Any, Any, Union{Bool, moment_kinetics.moment_kinetics_structs.chebyshev_info}}","page":"calculus","title":"moment_kinetics.calculus.derivative!","text":"derivative!(df, f, coord, adv_fac, spectral)\n\nUpwinding derivative.\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.derivative_elements_to_full_grid!-Tuple{Any, Any, Any, AbstractVector{Float64}}","page":"calculus","title":"moment_kinetics.calculus.derivative_elements_to_full_grid!","text":"\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.derivative_elements_to_full_grid!-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.derivative_elements_to_full_grid!","text":"\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.elements_to_full_grid_interior_pts!-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.elements_to_full_grid_interior_pts!","text":"maps the derivative at points away from element boundaries from the grid/element representation to the full grid representation\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.elementwise_derivative!","page":"calculus","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, adv_fac, spectral)\nelementwise_derivative!(coord, f, spectral)\n\nGeneric function for element-by-element derivatives\n\nFirst signature, with adv_fac, calculates an upwind derivative, the second signature calculates a derivative without upwinding information.\n\nResult is stored in coord.scratch_2d.\n\n\n\n\n\n","category":"function"},{"location":"calculus/#moment_kinetics.calculus.elementwise_second_derivative!","page":"calculus","title":"moment_kinetics.calculus.elementwise_second_derivative!","text":"elementwise_second_derivative!(coord, f, spectral)\n\nGeneric function for element-by-element second derivatives.\n\nNote: no upwinding versions of second deriatives.\n\nResult is stored in coord.scratch_2d.\n\n\n\n\n\n","category":"function"},{"location":"calculus/#moment_kinetics.calculus.integral-NTuple{10, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the 3D integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.integral-NTuple{4, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand multiplied by v^n, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.integral-NTuple{7, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the 2D integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.integral-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand multiplied by v, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.integral-Tuple{Any, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"calculus/#moment_kinetics.calculus.reconcile_element_boundaries_upwind!-Tuple{Any, Any, Any, AbstractVector{Float64}}","page":"calculus","title":"moment_kinetics.calculus.reconcile_element_boundaries_upwind!","text":"if at the boundary point within the element, must carefully choose which value of df to use; this is because df is multi-valued at the overlapping point at the boundary between neighboring elements. here we choose to use the value of df from the upwind element.\n\n\n\n\n\n","category":"method"},{"location":"plot_MMS_sequence/#plot_MMS_sequence","page":"plot_MMS_sequence","title":"plot_MMS_sequence","text":"","category":"section"},{"location":"plot_MMS_sequence/","page":"plot_MMS_sequence","title":"plot_MMS_sequence","text":"Modules = [moment_kinetics.plot_MMS_sequence]","category":"page"},{"location":"plot_MMS_sequence/#moment_kinetics.plot_MMS_sequence","page":"plot_MMS_sequence","title":"moment_kinetics.plot_MMS_sequence","text":"\n\n\n\n","category":"module"},{"location":"velocity_moments/#velocity_moments","page":"velocity_moments","title":"velocity_moments","text":"","category":"section"},{"location":"velocity_moments/","page":"velocity_moments","title":"velocity_moments","text":"Modules = [moment_kinetics.velocity_moments]","category":"page"},{"location":"velocity_moments/#moment_kinetics.velocity_moments","page":"velocity_moments","title":"moment_kinetics.velocity_moments","text":"\n\n\n\n","category":"module"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.moments_charged_substruct","page":"velocity_moments","title":"moment_kinetics.velocity_moments.moments_charged_substruct","text":"\n\n\n\n","category":"type"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.moments_neutral_substruct","page":"velocity_moments","title":"moment_kinetics.velocity_moments.moments_neutral_substruct","text":"\n\n\n\n","category":"type"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.calculate_moment_derivatives!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_moment_derivatives!","text":"Pre-calculate spatial derivatives of the moments that will be needed for the time advance\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.calculate_moment_derivatives_neutral!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_moment_derivatives_neutral!","text":"Pre-calculate spatial derivatives of the neutral moments that will be needed for the time advance\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.create_moments_charged-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.create_moments_charged","text":"\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.integrate_over_negative_vpa-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_negative_vpa","text":"computes the integral over vpa <= 0 of the integrand, using the input vpa_wgts this could be made more efficient for the case that dz/dt = vpa is time-independent, but it has been left general for the cases where, e.g., dz/dt = wpa*vth + upar varies in time\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.integrate_over_positive_vpa-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_positive_vpa","text":"computes the integral over vpa >= 0 of the integrand, using the input vpa_wgts this could be made more efficient for the case that dz/dt = vpa is time-independent, but it has been left general for the cases where, e.g., dz/dt = wpa*vth + upar varies in time\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.integrate_over_vspace-Tuple","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_vspace","text":"computes the integral over vpa of the integrand, using the input vpa_wgts\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.reset_moments_status!-Tuple{Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.reset_moments_status!","text":"\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_density!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_density!","text":"NB: if this function is called and if dens_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_density_species!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_density_species!","text":"calculate the updated density (dens) for a given species; should only be called when evolvedensity = false, in which case the vpa coordinate is vpa/cs\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_moments!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_moments!","text":"calculate the updated density (dens) and parallel pressure (ppar) for all species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_moments_neutral!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_moments_neutral!","text":"update velocity moments of the evolved neutral pdf\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_neutral_density!-NTuple{9, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_density!","text":"calculate the neutral density from the neutral pdf\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_neutral_density_species!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_density_species!","text":"calculate the updated density (dens) for a given species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_neutral_pr_species!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_pr_species!","text":"calculate the updated pressure in the rr direction (pr) for a given species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_neutral_pz_species!-NTuple{11, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_pz_species!","text":"calculate the updated pressure in zz direction (pz) for a given species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_neutral_pzeta_species!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_pzeta_species!","text":"calculate the updated pressure in the zeta zeta direction (pzeta) for a given species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_neutral_qz_species!-NTuple{13, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_qz_species!","text":"calculate the updated heat flux zzz direction (qz) for a given species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_neutral_ur_species!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_ur_species!","text":"calculate the updated ur (mean velocity in r) for a given species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_neutral_uz_species!-NTuple{11, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_uz_species!","text":"calculate the updated uz (mean velocity in z) for a given species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_neutral_uzeta_species!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_uzeta_species!","text":"calculate the updated uzeta (mean velocity in zeta) for a given species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_ppar!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_ppar!","text":"NB: if this function is called and if ppar_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_ppar_species!-NTuple{10, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_ppar_species!","text":"calculate the updated energy density (or parallel pressure, ppar) for a given species; which of these is calculated depends on the definition of the vpa coordinate\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_qpar!-NTuple{14, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_qpar!","text":"NB: the incoming pdf is the normalized pdf\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_qpar_species!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_qpar_species!","text":"calculate the updated parallel heat flux (qpar) for a given species\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_upar!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_upar!","text":"NB: if this function is called and if upar_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"velocity_moments/#moment_kinetics.velocity_moments.update_upar_species!-NTuple{10, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_upar_species!","text":"calculate the updated parallel flow (upar) for a given species\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#time_advance","page":"time_advance","title":"time_advance","text":"","category":"section"},{"location":"time_advance/","page":"time_advance","title":"time_advance","text":"Modules = [moment_kinetics.time_advance]","category":"page"},{"location":"time_advance/#moment_kinetics.time_advance","page":"time_advance","title":"moment_kinetics.time_advance","text":"\n\n\n\n","category":"module"},{"location":"time_advance/#moment_kinetics.time_advance.euler_time_advance!-NTuple{25, Any}","page":"time_advance","title":"moment_kinetics.time_advance.euler_time_advance!","text":"eulertimeadvance! advances the vector equation dfvec/dt = G[f] that includes the kinetic equation + any evolved moment equations using the forward Euler method: fvecout = fvecin + dt*fvecin, with fvecin an input and fvec_out the output\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.normalize_pdf!-Tuple{Any, Any, Any}","page":"time_advance","title":"moment_kinetics.time_advance.normalize_pdf!","text":"if evolving the density via continuity equation, redefine the normalised f → f/n if evolving the parallel pressure via energy equation, redefine f -> f * vth / n 'scratch' should be a (nz,nspecies) array\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.rk_update!-NTuple{22, Any}","page":"time_advance","title":"moment_kinetics.time_advance.rk_update!","text":"use information obtained from the Runge-Kutta stages to compute the updated pdf; for the quantities (density, upar, ppar, vth, qpar and phi) that are derived from the 'true', un-modified pdf, either: update them using info from Runge Kutta stages, if the quantities are evolved separately from the modified pdf; or update them by taking the appropriate velocity moment of the evolved pdf\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.rk_update_evolved_moments!-NTuple{4, Any}","page":"time_advance","title":"moment_kinetics.time_advance.rk_update_evolved_moments!","text":"use Runge Kutta to update any charged-particle velocity moments evolved separately from the pdf\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.rk_update_evolved_moments_neutral!-NTuple{4, Any}","page":"time_advance","title":"moment_kinetics.time_advance.rk_update_evolved_moments_neutral!","text":"use Runge Kutta to update any neutral-particle velocity moments evolved separately from the pdf\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.setup_advance_flags-NTuple{12, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_advance_flags","text":"create the 'advance_info' struct to be used in later Euler advance to indicate which parts of the equations are to be advanced concurrently. if no splitting of operators, all terms advanced concurrently; else, will advance one term at a time.\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.setup_runge_kutta_coefficients-Tuple{Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_runge_kutta_coefficients","text":"given the number of Runge Kutta stages that are requested, returns the needed Runge Kutta coefficients; e.g., if f is the function to be updated, then f^{n+1}[stage+1] = rkcoef[1,stage]*f^{n} + rkcoef[2,stage]f^{n+1}[stage] + rk_coef[3,stage](f^{n}+dt*G[f^{n+1}[stage]]\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.setup_scratch_arrays-NTuple{4, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_scratch_arrays","text":"create an array of structs containing scratch arrays for the normalised pdf and low-order moments that may be evolved separately via fluid equations\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.setup_time_advance!-NTuple{25, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_time_advance!","text":"create arrays and do other work needed to setup the main time advance loop. this includes creating and populating structs for Chebyshev transforms, velocity space moments, EM fields, and advection terms\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.ssp_rk!-NTuple{25, Any}","page":"time_advance","title":"moment_kinetics.time_advance.ssp_rk!","text":"\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.time_advance!-NTuple{27, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance!","text":"solve ∂f/∂t + v(z,t)⋅∂f/∂z + dvpa/dt ⋅ ∂f/∂vpa= 0 define approximate characteristic velocity v₀(z)=vⁿ(z) and take time derivative along this characteristic df/dt + δv⋅∂f/∂z = 0, with δv(z,t)=v(z,t)-v₀(z) for prudent choice of v₀, expect δv≪v so that explicit time integrator can be used without severe CFL condition\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.time_advance_no_splitting!-NTuple{25, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance_no_splitting!","text":"\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.time_advance_split_operators!-NTuple{17, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance_split_operators!","text":"\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.update_derived_moments!-NTuple{7, Any}","page":"time_advance","title":"moment_kinetics.time_advance.update_derived_moments!","text":"update velocity moments that are calculable from the evolved charged pdf\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.update_derived_moments_neutral!-NTuple{8, Any}","page":"time_advance","title":"moment_kinetics.time_advance.update_derived_moments_neutral!","text":"update velocity moments that are calculable from the evolved neutral pdf\n\n\n\n\n\n","category":"method"},{"location":"time_advance/#moment_kinetics.time_advance.update_solution_vector!-NTuple{8, Any}","page":"time_advance","title":"moment_kinetics.time_advance.update_solution_vector!","text":"update the vector containing the pdf and any evolved moments of the pdf for use in the Runge-Kutta time advance\n\n\n\n\n\n","category":"method"},{"location":"bgk/#bgk","page":"bgk","title":"bgk","text":"","category":"section"},{"location":"bgk/","page":"bgk","title":"bgk","text":"Modules = [moment_kinetics.bgk]","category":"page"},{"location":"bgk/#moment_kinetics.bgk","page":"bgk","title":"moment_kinetics.bgk","text":"\n\n\n\n","category":"module"},{"location":"bgk/#moment_kinetics.bgk.allowed_wave_amplitude!-NTuple{5, Any}","page":"bgk","title":"moment_kinetics.bgk.allowed_wave_amplitude!","text":"\n\n\n\n","category":"method"},{"location":"bgk/#moment_kinetics.bgk.init_bgk_pdf!-NTuple{6, Any}","page":"bgk","title":"moment_kinetics.bgk.init_bgk_pdf!","text":"\n\n\n\n","category":"method"},{"location":"bgk/#moment_kinetics.bgk.passing_pdf!-NTuple{5, Any}","page":"bgk","title":"moment_kinetics.bgk.passing_pdf!","text":"inputs\n\npdf is the particle distribution function, with the passing part of phase space not filled in\nphi_max is the maximum value that e * phi / Te takes\ntau = Ti/Te is the ion-electron temperature ratio\nx = mvpa^2/2Te + ephi/Te is 1D array containing the total parallel energy (conserved)\n\noutput\n\npdf = particle distribution function; this function fills in the part of phase space where x > e*phi_max/T\n\n\n\n\n\n","category":"method"},{"location":"bgk/#moment_kinetics.bgk.setup_dummy_integrals-Tuple{}","page":"bgk","title":"moment_kinetics.bgk.setup_dummy_integrals","text":"\n\n\n\n","category":"method"},{"location":"bgk/#moment_kinetics.bgk.total_energy_grid-Tuple{Any, Any}","page":"bgk","title":"moment_kinetics.bgk.total_energy_grid","text":"inputs:\n\nvpa = parallel velocity normalized by vts = sqrt(2*Te/ms)\nphi = electrostatic potential normalized by Te/e\n\noutput: x = vpa^2 + phi is the total parallel energy\n\n\n\n\n\n","category":"method"},{"location":"bgk/#moment_kinetics.bgk.trapped_passing_boundary-Tuple{Any, Any}","page":"bgk","title":"moment_kinetics.bgk.trapped_passing_boundary","text":"\n\n\n\n","category":"method"},{"location":"bgk/#moment_kinetics.bgk.trapped_pdf!-NTuple{8, Any}","page":"bgk","title":"moment_kinetics.bgk.trapped_pdf!","text":"inputs\n\nphi_max is the maximum value that e * phi / Te takes\ntau = Ti/Te is the ion-electron temperature ratio\nx = vpa^2 + e*phi is a 2D array containing the total parallel energy on the (z,vpa) grid\ny = dummy coordinate for the necessary integrals in the function\nintegrand = dummy array used to hold integrands defined and integrated in this function\nwgts = integration weights associated with y integrals\n\noutput\n\npdf is the particle distribution function for all of phase space, with this function filling in only the part with x < e*phi_max/T\n\n\n\n\n\n","category":"method"},{"location":"moment_constraints_notes/#Constraints-on-normalized-distribution-function","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"","category":"section"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Note: Equation references give the Excalibur/Neptune report number and equation number, e.g. (TN-04;1) is equation (1) from report TN-04.pdf.","category":"page"},{"location":"moment_constraints_notes/#Constraints","page":"Constraints on normalized distribution function","title":"Constraints","text":"","category":"section"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"The normalized particle distribution function that is evolved when using the moment-kinetic approach has to satisfy integral constraints related to particle number, momentum and energy conservation (TN-04;70-72)","category":"page"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s  =1\n  frac1sqrtpiint dw_w_tildeg_s  =0\n  frac1sqrtpiint dw_w_^2tildeg_s  =frac12\nendalign","category":"page"},{"location":"moment_constraints_notes/#Old-algorithm","page":"Constraints on normalized distribution function","title":"Old algorithm","text":"","category":"section"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"The algorithm described in TN-04 used the distribution function from the previous time step and also made use of a symmetrized distribution function tildeg_E(w_)=frac12left(tildeg(w_)+tildeg(-w_)right). These choices caused problems when in combination with the boundary conditions as: applying the boundary condition at the new timestep (with an updated tildeu_) to the old tildeg_s could mean that it no longer satisfied the moment constraints (e.g. if a grid point that was previously non-zero is now set to zero by the ion sheath boundary condition); the symmetrized tildeg_E will be non-zero at places where the boundary condition forces tildeg_s to be zero. It is possible to extend the algorithm to allow the constraints to be enforced using only the initial guess of the distribution function at the new timestep, as described below.","category":"page"},{"location":"moment_constraints_notes/#Current-algorithm","page":"Constraints on normalized distribution function","title":"Current algorithm","text":"","category":"section"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"After the time advance updates the distribution function, it will in general not obey the constraints, but the errors will be small, with the size depending on the accuracy of the spatial and temporal discretizations. We can take this updated value hatg_s as an initial guess, to be corrected to give the actual updated value tildeg_s, which does obey the constraints to machine precision.","category":"page"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"We define the corrected distribution function as","category":"page"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  tildeg_s=Ahatg_s+Bw_hatg_s+Cw_^2hatg_s\nendalign","category":"page"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"and define the moments of hatg_s","category":"page"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  I_n=frac1sqrtpiint dw_w_^nhatg_s\nendalign","category":"page"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Then the moments of tildeg_s are","category":"page"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s=1  =frac1sqrtpiint dw_left(Ahatg_s+Bw_hatg_s+Cw_^2hatg_sright)=AI_0+BI_1+CI_2\n  frac1sqrtpiint dw_w_tildeg_s=0  =frac1sqrtpiint dw_left(Aw_hatg_s+Bw_^2hatg_s+Cw_^3hatg_sright)=AI_1+BI_2+CI_3\n  frac1sqrtpiint dw_w_^2tildeg_s=frac12  =frac1sqrtpiint dw_left(Aw_^2hatg_s+Bw_^3hatg_s+Cw_^4hatg_sright)=AI_2+BI_3+CI_4\nendalign","category":"page"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Solving the simultaneous equations for A, B, C gives","category":"page"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  C  =fracfrac12-AI_2-BI_3I_4\n  B  =fracleft(I_2I_3-I_1I_4right)A-fracI_32I_2I_4-I_3^2\n  A  =fracI_2I_4-fracI_2^22+I_3left(fracI_12-I_3right)I_0left(I_2I_4-I_3^2right)+I_1left(I_2I_3-I_1I_4right)+I_2left(I_1I_3-I_2^2right)\nendalign","category":"page"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Note that there is no guarantee that tildeg_s is geq0 even if hatg_sgeq0, although if the violations of the integral constraints are small, it should be true that Aapprox1 while B and C are small.","category":"page"},{"location":"moment_constraints_notes/#Evolving-u_\\parallel","page":"Constraints on normalized distribution function","title":"Evolving u_parallel","text":"","category":"section"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"When evolving fewer moments separately, the constraints become simpler. When evolving n and u_parallel, only the first two constraints are needed. This corresponds to C=0 so that","category":"page"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  1 = AI_0 + BI_1 \n  0 = AI_1 + BI_2 \n  Rightarrow B = -fracAI_1I_2 \n  AI_0 = 1 - BI_1 = 1 + fracAI_1^2I_2 \n  A = frac1I_0 - I_1^2I_2\nendalign","category":"page"},{"location":"moment_constraints_notes/#Evolving-n","page":"Constraints on normalized distribution function","title":"Evolving n","text":"","category":"section"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"When evolving only n separately, we only need one constraint and the correction is just a re-scaling. This corresponds to B=0C=0 so that","category":"page"},{"location":"moment_constraints_notes/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  1 = AI_0 \n  A = frac1I_0\nendalign","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for moment_kinetics.jl","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"getting_started.md\",\n         \"input_options.md\",\n         \"moment_kinetic_equations.md\",\n         \"moment_constraints_notes.md\",\n         \"boundary_conditions_notes.md\",\n         \"developing.md\",\n         \"debugging-hints.md\",\n        ]","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Order = [:module]","category":"page"},{"location":"chebyshev/#chebyshev","page":"chebyshev","title":"chebyshev","text":"","category":"section"},{"location":"chebyshev/","page":"chebyshev","title":"chebyshev","text":"Modules = [moment_kinetics.chebyshev]","category":"page"},{"location":"chebyshev/#moment_kinetics.chebyshev","page":"chebyshev","title":"moment_kinetics.chebyshev","text":"\n\n\n\n","category":"module"},{"location":"chebyshev/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Any, moment_kinetics.moment_kinetics_structs.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, ff, adv_fac, spectral::chebyshev_info)\n\nChebyshev transform f to get Chebyshev spectral coefficients and use them to calculate f'.\n\nNote: Chebyshev derivative does not make use of upwinding information within each element.\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, moment_kinetics.moment_kinetics_structs.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, ff, chebyshev::chebyshev_info)\n\nChebyshev transform f to get Chebyshev spectral coefficients and use them to calculate f'.\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshev_backward_transform!-NTuple{5, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_backward_transform!","text":"\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshev_derivative_single_element!-NTuple{7, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_derivative_single_element!","text":"\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshev_forward_transform!-NTuple{5, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_forward_transform!","text":"takes the real function ff on a Chebyshev grid in z (domain [-1, 1]), which corresponds to the domain [π, 2π] in variable theta = ArcCos(z). interested in functions of form f(z) = sumn cn Tn(z) using Tn(cos(theta)) = cos(ntheta) and z = cos(theta) gives f(z) = sumn cn cos(ntheta) thus a Chebyshev transform is equivalent to a discrete cosine transform doing this directly turns out to be slower than extending the domain from [0, 2pi] and using the fact that f(z) must be even (as cosines are all even) on this extended domain, can do a standard complex-to-complex fft fext is an array used to store f(theta) on the extended grid theta ∈ [0,2π) ff is f(theta) on the grid [π,2π] the Chebyshev coefficients of ff are calculated and stored in chebyf n is the number of grid points on the Chebyshev-Gauss-Lobatto grid transform is the plan for the complex-to-complex, in-place fft\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshev_interpolate_single_element!-NTuple{7, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_interpolate_single_element!","text":"\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshev_spectral_derivative!-Tuple{Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_spectral_derivative!","text":"use Chebyshev basis to compute the first derivative of f\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshevmoments-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshevmoments","text":"compute and return modified Chebyshev moments of the first kind: ∫dx Tᵢ(x) over range [-1,1]\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.chebyshevpoints-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshevpoints","text":"returns the Chebyshev-Gauss-Lobatto grid points on an n point grid\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.clenshaw_curtis_weights-NTuple{6, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.clenshaw_curtis_weights","text":"returns wgts array containing the integration weights associated with all grid points for Clenshaw-Curtis quadrature\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.scaled_chebyshev_grid-NTuple{8, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.scaled_chebyshev_grid","text":"initialize chebyshev grid scaled to interval [-boxlength/2, boxlength/2]\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.setup_chebyshev_pseudospectral-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.setup_chebyshev_pseudospectral","text":"create arrays needed for explicit Chebyshev pseudospectral treatment and create the plans for the forward and backward fast Fourier transforms\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.update_df_chebyshev!-Tuple{Any, Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.update_df_chebyshev!","text":"compute the Chebyshev spectral coefficients of the spatial derivative of f\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.chebyshev.update_fcheby!-Tuple{Any, Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.update_fcheby!","text":"Chebyshev transform f to get Chebyshev spectral coefficients\n\n\n\n\n\n","category":"method"},{"location":"chebyshev/#moment_kinetics.interpolation.interpolate_to_grid_1d!-Tuple{Any, Any, Any, Any, moment_kinetics.moment_kinetics_structs.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.interpolation.interpolate_to_grid_1d!","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nArguments\n\nresult : Array{mkfloat, 1}     Array to be overwritten with the result of the interpolation newgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies chebyshev : chebyshev_info     struct containing information for Chebyshev transforms\n\n\n\n\n\n","category":"method"},{"location":"advection/#advection","page":"advection","title":"advection","text":"","category":"section"},{"location":"advection/","page":"advection","title":"advection","text":"Modules = [moment_kinetics.advection]","category":"page"},{"location":"advection/#moment_kinetics.advection","page":"advection","title":"moment_kinetics.advection","text":"\n\n\n\n","category":"module"},{"location":"advection/#moment_kinetics.advection.advection_info","page":"advection","title":"moment_kinetics.advection.advection_info","text":"structure containing the basic arrays associated with the advection terms appearing in the advection equation for each coordinate\n\n\n\n\n\n","category":"type"},{"location":"advection/#moment_kinetics.advection.advance_f_local!-NTuple{9, Any}","page":"advection","title":"moment_kinetics.advection.advance_f_local!","text":"do all the work needed to update f(coord) at a single value of other coords\n\n\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.calculate_explicit_advection!-NTuple{4, Any}","page":"advection","title":"moment_kinetics.advection.calculate_explicit_advection!","text":"calculate the explicit advection terms on the rhs of the equation; i.e., -Δt⋅δv⋅f'\n\n\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.setup_advection-Tuple{Any, Vararg{Any}}","page":"advection","title":"moment_kinetics.advection.setup_advection","text":"create arrays needed to compute the advection term(s) for a 1D problem\n\n\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.setup_advection_per_species-Tuple","page":"advection","title":"moment_kinetics.advection.setup_advection_per_species","text":"create arrays needed to compute the advection term(s)\n\n\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.update_advection_factor!-NTuple{4, Any}","page":"advection","title":"moment_kinetics.advection.update_advection_factor!","text":"calculate the factor appearing in front of f' in the advection term at time level n in the frame moving with the approximate characteristic\n\n\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.update_f!-Tuple{Any, Any, Any}","page":"advection","title":"moment_kinetics.advection.update_f!","text":"\n\n\n\n","category":"method"},{"location":"advection/#moment_kinetics.advection.update_rhs!-NTuple{8, Any}","page":"advection","title":"moment_kinetics.advection.update_rhs!","text":"update the righthand side of the equation to account for 1d advection in this coordinate\n\n\n\n\n\n","category":"method"},{"location":"debugging-hints/#Debugging","page":"Debugging","title":"Debugging","text":"","category":"section"},{"location":"debugging-hints/#Shared-memory-parallelism","page":"Debugging","title":"Shared-memory parallelism","text":"","category":"section"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"For information on race conditions and debugging, see Shared memory debugging.","category":"page"},{"location":"debugging-hints/#Dumping-state-of-physics-variables","page":"Debugging","title":"Dumping state of physics variables","text":"","category":"section"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"There is a function moment_kinetics.file_io.debug_dump provided in the moment_kinetics.file_io module that can be inserted to save the distribution function, moments, etc. These can include a label so that if there are several 'dumps' within a timestep, they can be easily identified.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"To use, first import the function","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"using ..file_io: debug_dump","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"then insert calls at the point where you want to save the variables, e.g.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"debug_dump(f, density, upar, ppar, phi, t, istage=istage, label=\"foo\")","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"where f, density, upar, ppar, and phi are arrays and t is an mk_float. istage is an optional mk_int, and can be used to identify the stage in the ssp_rk!() function. label is optional and can be any string, intended to distinguish different calls to debug_dump().","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"There is an alternative method (implementation) of the function that takes moment_kinetics.moment_kinetics_structs.scratch_pdf and moment_kinetics.moment_kinetics_structs.em_fields_struct arguments. This can be convenient within the functions in moment_kinetics.time_advance, e.g.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"debug_dump(fvec_out, fields, t, istage=istage, label=\"bar\")","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"Any of the positional arguments can be replaced by nothing if they are not available in a certain place, or just not needed. If nothing is passed, then arrays filled with 0.0 are written into the output.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"The output is written into a NetCDF file debug_output.cdf in the current directory (the filename is currently hard-coded because that was simpler than adding more command line arguments, etc.).","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"For debugging, a script util/compare_debug_files.jl is provided to compare two output files, assumed to have similar structure (i.e. the same set of debug_dump() calls). An example workflow could be:","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"Checkout master branch.\nCreate new branch, git checkout -b newfeature.\nWork on newfeature...\nAt some point, a bug is introduced which breaks some test or example - i.e. changes its output. Commit the current state of the code.\nAdd debug_dump() calls before and after locations where the bug is likely to be.\nRun the broken case.\nmv debug_output.cdf debug_after.cdf, so the file does not get overwritten.\ngit stash to 'save' the debug_dump() statements.\ngit checkout a commit where the test/example was working.\ngit stash pop to add the debug_dump() statements on top of the working commit  (fingers crossed there are no merge conflicts).\nRun the test example again.\nmv debug_output.cdf debug_before.cdf\nRun the comparison script  julia util/compare_debug_files.jl debug_before.cdf debug_after.cdf\nThe script identifies the first point (by t, istage and label) where any  variable in the two output files has a maximum difference that is larger than some  very tight (1.e-14) absolute and relative tolerances, and reports which  variables were different and their maximum difference.","category":"page"},{"location":"neutral_vz_advection/#neutral_vz_advection","page":"neutral_vz_advection","title":"neutral_vz_advection","text":"","category":"section"},{"location":"neutral_vz_advection/","page":"neutral_vz_advection","title":"neutral_vz_advection","text":"Modules = [moment_kinetics.neutral_vz_advection]","category":"page"},{"location":"neutral_vz_advection/#moment_kinetics.neutral_vz_advection","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection","text":"\n\n\n\n","category":"module"},{"location":"neutral_vz_advection/#moment_kinetics.neutral_vz_advection.neutral_advection_vz!-NTuple{14, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.neutral_advection_vz!","text":"\n\n\n\n","category":"method"},{"location":"neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_constant_neutral!-NTuple{6, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_constant_neutral!","text":"update the advection speed dvpa/dt = constant\n\n\n\n\n\n","category":"method"},{"location":"neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_default_neutral!-NTuple{9, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_default_neutral!","text":"\n\n\n\n","category":"method"},{"location":"neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_linear_neutral-NTuple{6, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_linear_neutral","text":"update the advection speed dvpa/dt = const*(vpa + L/2)\n\n\n\n\n\n","category":"method"},{"location":"neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_n_p_evolution_neutral!-NTuple{9, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_n_p_evolution_neutral!","text":"update the advection speed in the parallel velocity coordinate for the case where density and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized velocity vpahat = vpa/vth\n\n\n\n\n\n","category":"method"},{"location":"neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_n_u_evolution_neutral!-NTuple{8, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_n_u_evolution_neutral!","text":"update the advection speed in the parallel velocity coordinate for the case where density and flow are evolved independently from the pdf; in this case, the parallel velocity coordinate is the peculiar velocity wpa = vpa-upar\n\n\n\n\n\n","category":"method"},{"location":"neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_n_u_p_evolution_neutral!-NTuple{8, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_n_u_p_evolution_neutral!","text":"update the advection speed (for the neutral distribution function) in the z-velocity coordinate for the case where density, flow and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized peculiar velocity wpahat = (vpa - upar)/vth\n\n\n\n\n\n","category":"method"},{"location":"neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_neutral_vz!-NTuple{11, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_neutral_vz!","text":"calculate the advection speed in the vz-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"analysis/#analysis","page":"analysis","title":"analysis","text":"","category":"section"},{"location":"analysis/","page":"analysis","title":"analysis","text":"Modules = [moment_kinetics.analysis]","category":"page"},{"location":"analysis/#moment_kinetics.analysis","page":"analysis","title":"moment_kinetics.analysis","text":"\n\n\n\n","category":"module"},{"location":"analysis/#moment_kinetics.analysis.analyze_fields_data-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_fields_data","text":"\n\n\n\n","category":"method"},{"location":"analysis/#moment_kinetics.analysis.analyze_moments_data-NTuple{8, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_moments_data","text":"\n\n\n\n","category":"method"},{"location":"analysis/#moment_kinetics.analysis.analyze_pdf_data-NTuple{7, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"analysis/#moment_kinetics.analysis.check_Chodura_condition-NTuple{11, Any}","page":"analysis","title":"moment_kinetics.analysis.check_Chodura_condition","text":"Check the (kinetic) Chodura condition\n\nChodura condition is: ∫d^3v F/vpa^2 ≤ mi ne/Te\n\nReturn a tuple (whose first entry is the result for the lower boundary and second for the upper) of the ratio which is 1 if the Chodura condition is satisfied (with equality): Te/(mi ne) * ∫d^3v F/vpa^2\n\nCurrently only evaluates condition for the first species: is=1\n\n2D2V\n\nIn normalised form (normalised variables suffixed with 'N'): vpa = cref vpaN vperp = cref vperpN ne = nref neN Te = Tref TeN F = FN nref / cref^3 pi^3/2 cref = sqrt(2 Tref / mi)\n\ncref^3 ∫d^3vN FN nref / cref^3 pi^3/2 cref^2 vpaN^2 ≤ mi nref neN / Tref TeN nref / (pi^3/2 cref^2) * ∫d^3vN FN / vpaN^2 ≤ mi nref neN / Tref TeN mi nref / (pi^3/2 2 Tref) * ∫d^3vN FN / vpaN^2 ≤ mi nref neN / Tref TeN 1 / (2 pi^3/2) * ∫d^3vN FN / vpaN^2 ≤ neN / TeN 1 / (2 pi^3/2) * ∫d^3vN FN / vpaN^2 ≤ neN / TeN TeN / (2 neN pi^3/2) * ∫d^3vN FN / vpaN^2 ≤ 1\n\nNote that integrate_over_vspace() includes the 1/pi^3/2 factor already.\n\n1D1V\n\nThe 1D1V code evolves the marginalised distribution function f = ∫d^2vperp F so the Chodura condition becomes ∫dvpa f/vpa^2 ≤ mi ne/Te\n\nIn normalised form (normalised variables suffixed with 'N'): vpa = cref vpaN ne = nref neN Te = Tref TeN f = fN nref / cref sqrt(pi) cref = sqrt(2 Tref / mi)\n\ncref ∫dvpaN fN nref / cref sqrt(pi) cref^2 vpaN^2 ≤ mi nref neN / Tref TeN nref / (sqrt(pi) cref^2) * ∫dvpaN fN / vpaN^2 ≤ mi nref neN / Tref TeN mi nref / (sqrt(pi) 2 Tref) * ∫dvpaN fN / vpaN^2 ≤ mi nref neN / Tref TeN 1 / (2 sqrt(pi)) * ∫dvpaN fN / vpaN^2 ≤ neN / TeN 1 / (2 sqrt(pi)) * ∫dvpaN fN / vpaN^2 ≤ neN / TeN TeN / (2 neN sqrt(pi)) * ∫dvpaN fN / vpaN^2 ≤ 1\n\nNote that integrate_over_vspace() includes the 1/sqrt(pi) factor already.\n\n\n\n\n\n","category":"method"},{"location":"analysis/#moment_kinetics.analysis.field_line_average-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.field_line_average","text":"\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics_input","page":"moment_kinetics_input","title":"moment_kinetics_input","text":"","category":"section"},{"location":"moment_kinetics_input/","page":"moment_kinetics_input","title":"moment_kinetics_input","text":"Modules = [moment_kinetics.moment_kinetics_input]","category":"page"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input","text":"\n\n\n\n","category":"module"},{"location":"moment_kinetics_input/#Base.get-Tuple{Dict, Any, Enum}","page":"moment_kinetics_input","title":"Base.get","text":"Utility method for converting a string to an Enum when getting from a Dict, based on the type of the default value\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_coordinate_input-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_coordinate_input","text":"Check input for a coordinate\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input-NTuple{11, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input","text":"check various input options to ensure they are all valid/consistent\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input_initialization-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input_initialization","text":"\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input_time_advance-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input_time_advance","text":"\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.load_defaults-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.load_defaults","text":"\n\n\n\n","category":"method"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.mk_input","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.mk_input","text":"\n\n\n\n","category":"function"},{"location":"moment_kinetics_input/#moment_kinetics.moment_kinetics_input.read_input_file-Tuple{String}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.read_input_file","text":"Read input from a TOML file\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#quadrature","page":"quadrature","title":"quadrature","text":"","category":"section"},{"location":"quadrature/","page":"quadrature","title":"quadrature","text":"Modules = [moment_kinetics.quadrature]","category":"page"},{"location":"quadrature/#moment_kinetics.quadrature","page":"quadrature","title":"moment_kinetics.quadrature","text":"\n\n\n\n","category":"module"},{"location":"quadrature/#moment_kinetics.quadrature.composite_simpson_weights-Tuple{Any}","page":"quadrature","title":"moment_kinetics.quadrature.composite_simpson_weights","text":"compositesimpsonweights creates, computes, and returns an array for the 1D integration weights associated with each grid point using composite Simpson's rule\n\n\n\n\n\n","category":"method"},{"location":"vpa_advection/#vpa_advection","page":"vpa_advection","title":"vpa_advection","text":"","category":"section"},{"location":"vpa_advection/","page":"vpa_advection","title":"vpa_advection","text":"Modules = [moment_kinetics.vpa_advection]","category":"page"},{"location":"vpa_advection/#moment_kinetics.vpa_advection","page":"vpa_advection","title":"moment_kinetics.vpa_advection","text":"\n\n\n\n","category":"module"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.update_speed_constant!-NTuple{5, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_constant!","text":"update the advection speed dvpa/dt = constant\n\n\n\n\n\n","category":"method"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.update_speed_default!-NTuple{11, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_default!","text":"\n\n\n\n","category":"method"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.update_speed_linear-NTuple{5, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_linear","text":"update the advection speed dvpa/dt = const*(vpa + L/2)\n\n\n\n\n\n","category":"method"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.update_speed_n_p_evolution!-NTuple{9, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_n_p_evolution!","text":"update the advection speed in the parallel velocity coordinate for the case where density and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized velocity vpahat = vpa/vth\n\n\n\n\n\n","category":"method"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.update_speed_n_u_evolution!-NTuple{8, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_n_u_evolution!","text":"update the advection speed in the parallel velocity coordinate for the case where density and flow are evolved independently from the pdf; in this case, the parallel velocity coordinate is the peculiar velocity wpa = vpa-upar\n\n\n\n\n\n","category":"method"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.update_speed_n_u_p_evolution!-NTuple{8, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_n_u_p_evolution!","text":"update the advection speed in the parallel velocity coordinate for the case where density, flow and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized peculiar velocity wpahat = (vpa - upar)/vth\n\n\n\n\n\n","category":"method"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.update_speed_vpa!-NTuple{12, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_vpa!","text":"calculate the advection speed in the vpa-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"vpa_advection/#moment_kinetics.vpa_advection.vpa_advection!-NTuple{15, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.vpa_advection!","text":"\n\n\n\n","category":"method"},{"location":"moment_constraints/#moment_kinetics","page":"moment_kinetics","title":"moment_kinetics","text":"","category":"section"},{"location":"moment_constraints/","page":"moment_kinetics","title":"moment_kinetics","text":"Modules = [moment_kinetics.moment_constraints]","category":"page"},{"location":"moment_constraints/#moment_kinetics.moment_constraints","page":"moment_kinetics","title":"moment_kinetics.moment_constraints","text":"Functions for enforcing integral constraints on the normalised distribution function. Ensures consistency of evolution split into moments and normalised distribution function.\n\n\n\n\n\n","category":"module"},{"location":"moment_constraints/#moment_kinetics.moment_constraints.hard_force_moment_constraints!-Tuple{Any, Any, Any}","page":"moment_kinetics","title":"moment_kinetics.moment_constraints.hard_force_moment_constraints!","text":"hard_force_moment_constraints!(f, moments, vpa)\n\nForce the moment constraints needed for the system being evolved to be applied to f. Not guaranteed to be a small correction, if f does not approximately obey the constraints to start with, but can be useful at initialisation to ensure a consistent initial state, and when applying boundary conditions.\n\nNote this function assumes the input is given at a single spatial position.\n\n\n\n\n\n","category":"method"},{"location":"moment_constraints/#moment_kinetics.moment_constraints.hard_force_moment_constraints_neutral!-Tuple{Any, Any, Any}","page":"moment_kinetics","title":"moment_kinetics.moment_constraints.hard_force_moment_constraints_neutral!","text":"hard_force_moment_constraints_neutral!(f, moments, vz)\n\nForce the moment constraints needed for the system being evolved to be applied to f. Not guaranteed to be a small correction, if f does not approximately obey the constraints to start with, but can be useful at initialisation to ensure a consistent initial state, and when applying boundary conditions.\n\nNotes:\n\nthis function assumes the input is given at a single spatial position.\ncurrently only works with '1V' runs, where vz is the only velocity-space dimension\n\n\n\n\n\n","category":"method"},{"location":"looping/#looping","page":"looping","title":"looping","text":"","category":"section"},{"location":"looping/","page":"looping","title":"looping","text":"Modules = [moment_kinetics.looping]","category":"page"},{"location":"looping/#moment_kinetics.looping","page":"looping","title":"moment_kinetics.looping","text":"Provides convenience macros for shared-memory-parallel loops\n\n\n\n\n\n","category":"module"},{"location":"looping/#moment_kinetics.looping.loop_ranges","page":"looping","title":"moment_kinetics.looping.loop_ranges","text":"module variable that we can access by giving fully-qualified name in loop macros\n\n\n\n\n\n","category":"constant"},{"location":"looping/#moment_kinetics.looping.loop_ranges_store","page":"looping","title":"moment_kinetics.looping.loop_ranges_store","text":"module variable used to store LoopRanges that are swapped into the loopranges variable in begin*_region() functions\n\n\n\n\n\n","category":"constant"},{"location":"looping/#moment_kinetics.looping.LoopRanges","page":"looping","title":"moment_kinetics.looping.LoopRanges","text":"LoopRanges structs contain information on which points should be included on this process in loops over shared-memory arrays.\n\nMembers\n\nparalleldims::Tuple{Vararg{Symbol}}        Indicates which dimensions are (or might be) parallelized when using        this LoopRanges. Provided for information for developers, to make it        easier to tell (when using a Debugger, or printing debug informatino)        which LoopRanges instance is active in looping.loopranges at any point        in the code. rank0::Bool        Is this process the one with rank 0 in the 'block' which work in        parallel on shared memory arrays. <d>::UnitRange{mkint}        Loop ranges for each dimension <d> in looping.alldimensions.\n\n\n\n\n\n","category":"type"},{"location":"looping/#moment_kinetics.looping.begin_r_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_region","text":"Begin region in which (:r,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vpa_region","text":"Begin region in which (:r, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vperp_region","text":"Begin region in which (:r, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vperp_vpa_region","text":"Begin region in which (:r, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vr_region","text":"Begin region in which (:r, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vr_vz_region","text":"Begin region in which (:r, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vz_region","text":"Begin region in which (:r, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vzeta_region","text":"Begin region in which (:r, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vzeta_vr_region","text":"Begin region in which (:r, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vzeta_vr_vz_region","text":"Begin region in which (:r, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vzeta_vz_region","text":"Begin region in which (:r, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_region","text":"Begin region in which (:r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vpa_region","text":"Begin region in which (:r, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vperp_region","text":"Begin region in which (:r, :z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vperp_vpa_region","text":"Begin region in which (:r, :z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vr_region","text":"Begin region in which (:r, :z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vr_vz_region","text":"Begin region in which (:r, :z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vz_region","text":"Begin region in which (:r, :z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vzeta_region","text":"Begin region in which (:r, :z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vzeta_vr_region","text":"Begin region in which (:r, :z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vzeta_vr_vz_region","text":"Begin region in which (:r, :z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_r_z_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vzeta_vz_region","text":"Begin region in which (:r, :z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_r_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_region","text":"Begin region in which (:s, :r) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_r_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_vpa_region","text":"Begin region in which (:s, :r, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_r_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_vperp_region","text":"Begin region in which (:s, :r, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_r_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_vperp_vpa_region","text":"Begin region in which (:s, :r, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_r_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_region","text":"Begin region in which (:s, :r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_r_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_vpa_region","text":"Begin region in which (:s, :r, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_r_z_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_vperp_region","text":"Begin region in which (:s, :r, :z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_r_z_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_vperp_vpa_region","text":"Begin region in which (:s, :r, :z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_region","text":"Begin region in which (:s,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_vpa_region","text":"Begin region in which (:s, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_vperp_region","text":"Begin region in which (:s, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_vperp_vpa_region","text":"Begin region in which (:s, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_region","text":"Begin region in which (:s, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_vpa_region","text":"Begin region in which (:s, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_z_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_vperp_region","text":"Begin region in which (:s, :z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_s_z_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_vperp_vpa_region","text":"Begin region in which (:s, :z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_serial_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_serial_region","text":"Begin region in which only rank-0 in each group of processes operating on a shared-memory block operates on shared-memory arrays.\n\nReturns immediately if loopranges[] is already set for a serial region. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_region","text":"Begin region in which (:sn, :r) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vr_region","text":"Begin region in which (:sn, :r, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vr_vz_region","text":"Begin region in which (:sn, :r, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vz_region","text":"Begin region in which (:sn, :r, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vzeta_region","text":"Begin region in which (:sn, :r, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vzeta_vr_region","text":"Begin region in which (:sn, :r, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vzeta_vr_vz_region","text":"Begin region in which (:sn, :r, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vzeta_vz_region","text":"Begin region in which (:sn, :r, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_region","text":"Begin region in which (:sn, :r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_z_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vr_region","text":"Begin region in which (:sn, :r, :z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_z_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vr_vz_region","text":"Begin region in which (:sn, :r, :z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_z_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vz_region","text":"Begin region in which (:sn, :r, :z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_z_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vzeta_region","text":"Begin region in which (:sn, :r, :z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_z_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vzeta_vr_region","text":"Begin region in which (:sn, :r, :z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_z_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vzeta_vr_vz_region","text":"Begin region in which (:sn, :r, :z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_r_z_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vzeta_vz_region","text":"Begin region in which (:sn, :r, :z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_region","text":"Begin region in which (:sn,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vr_region","text":"Begin region in which (:sn, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vr_vz_region","text":"Begin region in which (:sn, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vz_region","text":"Begin region in which (:sn, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vzeta_region","text":"Begin region in which (:sn, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vzeta_vr_region","text":"Begin region in which (:sn, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vzeta_vr_vz_region","text":"Begin region in which (:sn, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vzeta_vz_region","text":"Begin region in which (:sn, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_region","text":"Begin region in which (:sn, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_z_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vr_region","text":"Begin region in which (:sn, :z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_z_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vr_vz_region","text":"Begin region in which (:sn, :z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_z_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vz_region","text":"Begin region in which (:sn, :z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_z_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vzeta_region","text":"Begin region in which (:sn, :z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_z_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vzeta_vr_region","text":"Begin region in which (:sn, :z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_z_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vzeta_vr_vz_region","text":"Begin region in which (:sn, :z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_sn_z_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vzeta_vz_region","text":"Begin region in which (:sn, :z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vpa_region","text":"Begin region in which (:vpa,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vperp_region","text":"Begin region in which (:vperp,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vperp_vpa_region","text":"Begin region in which (:vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vr_region","text":"Begin region in which (:vr,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vr_vz_region","text":"Begin region in which (:vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vz_region","text":"Begin region in which (:vz,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vzeta_region","text":"Begin region in which (:vzeta,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vzeta_vr_region","text":"Begin region in which (:vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vzeta_vr_vz_region","text":"Begin region in which (:vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vzeta_vz_region","text":"Begin region in which (:vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_region","text":"Begin region in which (:z,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vpa_region","text":"Begin region in which (:z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vperp_region","text":"Begin region in which (:z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vperp_vpa_region","text":"Begin region in which (:z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vr_region","text":"Begin region in which (:z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vr_vz_region","text":"Begin region in which (:z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vz_region","text":"Begin region in which (:z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vzeta_region","text":"Begin region in which (:z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vzeta_vr_region","text":"Begin region in which (:z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vzeta_vr_vz_region","text":"Begin region in which (:z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.begin_z_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vzeta_vz_region","text":"Begin region in which (:z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.debug_setup_loop_ranges_split_one_combination!-Tuple{Any, Any, Tuple{Vararg{Symbol, N}} where N, Vararg{Symbol}}","page":"looping","title":"moment_kinetics.looping.debug_setup_loop_ranges_split_one_combination!","text":"For debugging the shared-memory parallelism, create ranges where only the loops for a single combinations of variables (given by combination_to_split) are parallelised, and which dimensions are parallelised can be set with the dims_to_split... arguments.\n\nArguments\n\nKeyword arguments dim=n are required for each dim in all_dimensions where n is an integer giving the size of the dimension.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.dims_string-Tuple{Tuple}","page":"looping","title":"moment_kinetics.looping.dims_string","text":"Construct a string composed of the dimension names given in the Tuple dims, separated by underscores\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.get_best_ranges-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.get_best_ranges","text":"Find the ranges for loop variables that optimize load balance for a certain block_size\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.get_best_ranges_from_sizes-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.get_best_ranges_from_sizes","text":"\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.get_load_balance-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_load_balance","text":"Calculate the expected load balance\n\n'Load balance' is the ratio of the maximum and minimum numbers of points on any process.\n\nArguments\n\nnprocslist : Vector{mkint}     Number of processes for each dimension sizes : Vector{mk_int}     Size of each dimension\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.get_local_range-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.get_local_range","text":"Get local range of indices when splitting a loop over processes in a sub-block\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.get_splits-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_splits","text":"Find possible divisions of subblocksize into n factors\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.setup_loop_ranges!-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.setup_loop_ranges!","text":"Create ranges for loops with different combinations of variables\n\nArguments\n\nKeyword arguments dim=n are required for each dim in [:s, :r, :z, :vperp, :vpa, :sn, :vzeta, :vr, :vz] where n is an integer giving the size of the dimension.\n\n\n\n\n\n","category":"method"},{"location":"looping/#moment_kinetics.looping.@loop_r-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r","text":"Loop over (:r,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vpa","text":"Loop over (:r, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_vperp-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vperp","text":"Loop over (:r, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_vperp_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vperp_vpa","text":"Loop over (:r, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vr","text":"Loop over (:r, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vr_vz","text":"Loop over (:r, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vz","text":"Loop over (:r, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_vzeta-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta","text":"Loop over (:r, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_vzeta_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta_vr","text":"Loop over (:r, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_vzeta_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta_vr_vz","text":"Loop over (:r, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_vzeta_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta_vz","text":"Loop over (:r, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z","text":"Loop over (:r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vpa","text":"Loop over (:r, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z_vperp-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vperp","text":"Loop over (:r, :z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z_vperp_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vperp_vpa","text":"Loop over (:r, :z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vr","text":"Loop over (:r, :z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vr_vz","text":"Loop over (:r, :z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vz","text":"Loop over (:r, :z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z_vzeta-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta","text":"Loop over (:r, :z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z_vzeta_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta_vr","text":"Loop over (:r, :z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z_vzeta_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta_vr_vz","text":"Loop over (:r, :z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_r_z_vzeta_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta_vz","text":"Loop over (:r, :z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s","text":"Loop over (:s,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_r-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r","text":"Loop over (:s, :r) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_r_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vpa","text":"Loop over (:s, :r, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_r_vperp-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vperp","text":"Loop over (:s, :r, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_r_vperp_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vperp_vpa","text":"Loop over (:s, :r, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_r_z-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z","text":"Loop over (:s, :r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_r_z_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vpa","text":"Loop over (:s, :r, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_r_z_vperp-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vperp","text":"Loop over (:s, :r, :z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_r_z_vperp_vpa-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vperp_vpa","text":"Loop over (:s, :r, :z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vpa","text":"Loop over (:s, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_vperp-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vperp","text":"Loop over (:s, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_vperp_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vperp_vpa","text":"Loop over (:s, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z","text":"Loop over (:s, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_z_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vpa","text":"Loop over (:s, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_z_vperp-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vperp","text":"Loop over (:s, :z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_s_z_vperp_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vperp_vpa","text":"Loop over (:s, :z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn","text":"Loop over (:sn,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r","text":"Loop over (:sn, :r) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vr","text":"Loop over (:sn, :r, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vr_vz","text":"Loop over (:sn, :r, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vz","text":"Loop over (:sn, :r, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_vzeta-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta","text":"Loop over (:sn, :r, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_vzeta_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta_vr","text":"Loop over (:sn, :r, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_vzeta_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta_vr_vz","text":"Loop over (:sn, :r, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_vzeta_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta_vz","text":"Loop over (:sn, :r, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_z-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z","text":"Loop over (:sn, :r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_z_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vr","text":"Loop over (:sn, :r, :z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_z_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vr_vz","text":"Loop over (:sn, :r, :z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_z_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vz","text":"Loop over (:sn, :r, :z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta","text":"Loop over (:sn, :r, :z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta_vr-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta_vr","text":"Loop over (:sn, :r, :z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta_vr_vz-NTuple{7, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta_vr_vz","text":"Loop over (:sn, :r, :z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta_vz","text":"Loop over (:sn, :r, :z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vr","text":"Loop over (:sn, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vr_vz","text":"Loop over (:sn, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vz","text":"Loop over (:sn, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_vzeta-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta","text":"Loop over (:sn, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_vzeta_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta_vr","text":"Loop over (:sn, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_vzeta_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta_vr_vz","text":"Loop over (:sn, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_vzeta_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta_vz","text":"Loop over (:sn, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z","text":"Loop over (:sn, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_z_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vr","text":"Loop over (:sn, :z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_z_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vr_vz","text":"Loop over (:sn, :z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_z_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vz","text":"Loop over (:sn, :z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_z_vzeta-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta","text":"Loop over (:sn, :z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_z_vzeta_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta_vr","text":"Loop over (:sn, :z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_z_vzeta_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta_vr_vz","text":"Loop over (:sn, :z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_sn_z_vzeta_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta_vz","text":"Loop over (:sn, :z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_vpa-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vpa","text":"Loop over (:vpa,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_vperp-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vperp","text":"Loop over (:vperp,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_vperp_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vperp_vpa","text":"Loop over (:vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_vr-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vr","text":"Loop over (:vr,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_vr_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vr_vz","text":"Loop over (:vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_vz-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vz","text":"Loop over (:vz,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_vzeta-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta","text":"Loop over (:vzeta,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_vzeta_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta_vr","text":"Loop over (:vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_vzeta_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta_vr_vz","text":"Loop over (:vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_vzeta_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta_vz","text":"Loop over (:vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z","text":"Loop over (:z,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vpa","text":"Loop over (:z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z_vperp-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vperp","text":"Loop over (:z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z_vperp_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vperp_vpa","text":"Loop over (:z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vr","text":"Loop over (:z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vr_vz","text":"Loop over (:z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vz","text":"Loop over (:z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z_vzeta-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta","text":"Loop over (:z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z_vzeta_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta_vr","text":"Loop over (:z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z_vzeta_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta_vr_vz","text":"Loop over (:z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@loop_z_vzeta_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta_vz","text":"Loop over (:z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"looping/#moment_kinetics.looping.@serial_region-Tuple{Any}","page":"looping","title":"moment_kinetics.looping.@serial_region","text":"Run a block of code on only rank-0 of each group of processes operating on a shared-memory block\n\n\n\n\n\n","category":"macro"},{"location":"moment_kinetics/#moment_kinetics","page":"moment_kinetics","title":"moment_kinetics","text":"","category":"section"},{"location":"moment_kinetics/","page":"moment_kinetics","title":"moment_kinetics","text":"Modules = [moment_kinetics.moment_kinetics]","category":"page"},{"location":"moment_kinetics/#moment_kinetics.moment_kinetics","page":"moment_kinetics","title":"moment_kinetics.moment_kinetics","text":"\n\n\n\n","category":"module"},{"location":"moment_kinetics/#moment_kinetics.cleanup_moment_kinetics!-Tuple{Union{Nothing, moment_kinetics.file_io.ascii_ios}, Union{Nothing, moment_kinetics.file_io.io_moments_info}, Union{Nothing, moment_kinetics.file_io.io_dfns_info}}","page":"moment_kinetics","title":"moment_kinetics.cleanup_moment_kinetics!","text":"Clean up after a run\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics/#moment_kinetics.get_backup_filename-Tuple{Any}","page":"moment_kinetics","title":"moment_kinetics.get_backup_filename","text":"Append a number to the filename, to get a new, non-existing filename to backup the file to.\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics/#moment_kinetics.restart_moment_kinetics","page":"moment_kinetics","title":"moment_kinetics.restart_moment_kinetics","text":"Restart moment kinetics from an existing run. Space/velocity-space resolution in the input must be the same as for the original run.\n\n\n\n\n\n","category":"function"},{"location":"moment_kinetics/#moment_kinetics.run_moment_kinetics","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"main function that contains all of the content of the program\n\n\n\n\n\n","category":"function"},{"location":"moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{Any}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload with no TimerOutput arguments\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{TimerOutputs.TimerOutput, String}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload which takes a filename and loads input\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload which gets the input file name from command line arguments\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetics/#moment_kinetics.setup_moment_kinetics-Tuple{Dict}","page":"moment_kinetics","title":"moment_kinetics.setup_moment_kinetics","text":"Perform all the initialization steps for a run.\n\nIf backup_filename is nothing, set up for a regular run; if a filename is passed, reload data from time index given by restart_time_index for a restart.\n\ndebug_loop_type and debug_loop_parallel_dims are used to force specific set ups for parallel loop ranges, and are only used by the tests in debug_test/.\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#finite_differences","page":"finite_differences","title":"finite_differences","text":"","category":"section"},{"location":"finite_differences/","page":"finite_differences","title":"finite_differences","text":"Modules = [moment_kinetics.finite_differences]","category":"page"},{"location":"finite_differences/#moment_kinetics.finite_differences","page":"finite_differences","title":"moment_kinetics.finite_differences","text":"\n\n\n\n","category":"module"},{"location":"finite_differences/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Any, Bool}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, adv_fac, not_spectral::Bool)\n\nCalculate the derivative of f using finite differences, with particular scheme specified by coord.fdoption; result stored in coord.scratch2d.\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Bool}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, not_spectral::Bool)\n\nCalculate the derivative of f using 4th order centered finite differences; result stored in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.calculus.elementwise_second_derivative!-Tuple{Any, Any, Bool}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_second_derivative!","text":"elementwise_second_derivative!(coord, f, not_spectral::Bool)\n\nCalculate the second derivative of f using 2nd order centered finite differences; result stored in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.centered_fourth_order!-Tuple{Matrix{Float64}, Any, Any, Any, Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_fourth_order!","text":"take the derivative of input function f and return as df using fourth-order, centered differences. input/output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.centered_second_order!-Tuple{Matrix{Float64}, Any, Any, Any, Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_second_order!","text":"take the derivative of input function f and return as df using second-order, centered differences. input/output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.centered_second_order!-Tuple{Vector{Float64}, Any, Any, Any, Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_second_order!","text":"take the derivative of input function f and return as df using second-order, centered differences. input/output df is 1D array of size n (full grid)\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.derivative_finite_difference!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.derivative_finite_difference!","text":"\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.derivative_finite_difference!-NTuple{8, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.derivative_finite_difference!","text":"\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.fd_check_option-Tuple{Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.fd_check_option","text":"\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.second_derivative_finite_difference!-Tuple{Matrix{Float64}, Any, Any, Any, Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.second_derivative_finite_difference!","text":"Take the second derivative of input function f and return as df using second-order, centered differences. output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.upwind_first_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_first_order!","text":"\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.upwind_second_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_second_order!","text":"\n\n\n\n","category":"method"},{"location":"finite_differences/#moment_kinetics.finite_differences.upwind_third_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_third_order!","text":"\n\n\n\n","category":"method"},{"location":"manufactured_solns/#manufactured_solns","page":"manufactured_solns","title":"manufactured_solns","text":"","category":"section"},{"location":"manufactured_solns/","page":"manufactured_solns","title":"manufactured_solns","text":"Modules = [moment_kinetics.manufactured_solns]","category":"page"},{"location":"manufactured_solns/#moment_kinetics.manufactured_solns","page":"manufactured_solns","title":"moment_kinetics.manufactured_solns","text":"\n\n\n\n","category":"module"},{"location":"neutral_r_advection/#neutral_r_advection","page":"neutral_r_advection","title":"neutral_r_advection","text":"","category":"section"},{"location":"neutral_r_advection/","page":"neutral_r_advection","title":"neutral_r_advection","text":"Modules = [moment_kinetics.neutral_r_advection]","category":"page"},{"location":"neutral_r_advection/#moment_kinetics.neutral_r_advection","page":"neutral_r_advection","title":"moment_kinetics.neutral_r_advection","text":"\n\n\n\n","category":"module"},{"location":"neutral_r_advection/#moment_kinetics.neutral_r_advection.neutral_advection_r!-NTuple{13, Any}","page":"neutral_r_advection","title":"moment_kinetics.neutral_r_advection.neutral_advection_r!","text":"do a single stage time advance in r (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"neutral_r_advection/#moment_kinetics.neutral_r_advection.update_speed_neutral_r!-NTuple{6, Any}","page":"neutral_r_advection","title":"moment_kinetics.neutral_r_advection.update_speed_neutral_r!","text":"calculate the advection speed in the r-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"charge_exchange/#charge_exchange","page":"charge_exchange","title":"charge_exchange","text":"","category":"section"},{"location":"charge_exchange/","page":"charge_exchange","title":"charge_exchange","text":"Modules = [moment_kinetics.charge_exchange]","category":"page"},{"location":"charge_exchange/#moment_kinetics.charge_exchange","page":"charge_exchange","title":"moment_kinetics.charge_exchange","text":"\n\n\n\n","category":"module"},{"location":"charge_exchange/#moment_kinetics.charge_exchange.charge_exchange_collisions_1V!-NTuple{11, Any}","page":"charge_exchange","title":"moment_kinetics.charge_exchange.charge_exchange_collisions_1V!","text":"update the evolved pdf for each ion and electron species to account for charge exchange collisions between ions and neutrals\n\n\n\n\n\n","category":"method"},{"location":"charge_exchange/#moment_kinetics.charge_exchange.charge_exchange_collisions_single_species!-NTuple{14, Any}","page":"charge_exchange","title":"moment_kinetics.charge_exchange.charge_exchange_collisions_single_species!","text":"update the evolved pdf for a single species to account for charge exchange collisions with a single species of the opposite type; e.g., ions with neutrals or neutrals with ions\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetic_equations/#Moment-kinetic-equations","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The following are partial notes on the derivation of the equations being solved by moment_kinetics. It would be useful to expand them with more details from the Excalibur/Neptune reports. Equation references give the report number and equation number, e.g. (TN-04;1) is equation (1) from report TN-04.pdf.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The drift kinetic equation (DKE), marginalised over v_perp, for ions is, adding ionization to the form in (TN-04;1),","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartial f_ipartial t\n  +v_fracpartial f_ipartial z\n  -fracemfracpartialphipartial zfracpartial f_ipartial v_\n  = -R_mathrminleft(n_nf_i-n_if_nright)+R_mathrmionn_if_n\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and for neutrals, adding ionization to (TN-04;2)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartial f_npartial t\n  +v_fracpartial f_npartial z\n  = -R_mathrminleft(n_if_n-n_nf_iright)-R_mathrmionn_if_n\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Using the normalizations (TN04;5-11)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  tildef_s  doteq f_sfracc_ssqrtpiN_e\n  tildet  doteq tfracc_sL_z\n  tildez  doteqfraczL_z\n  tildev_  doteqfracv_c_s\n  tilden_s  doteqfracn_sN_e\n  tildephi  doteqfracephiT_e\n  tildeR_mathrmin  doteq R_mathrminfracN_eL_zc_s\n  tildeR_mathrmion  doteq R_mathrmionfracN_eL_zc_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"with c_sdoteqsqrt2T_em_s where L_z, N_e and T_e are constant reference parameters, the ion DKE is","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartialtildef_ipartialtildet\n  + tildev_fracpartialtildef_ipartialtildez\n  - frac12fracpartialtildephipartialtildez\n    fracpartialtildef_ipartialtildev_\n  = -tildeR_inleft(tilden_ntildef_i-tilden_itildef_nright)\n    + tildeR_mathrmiontilden_itildef_n\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and the neutral DKE is","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartialtildef_npartialtildet\n  + v_fracpartialtildef_npartialtildez\n  = -tildeR_inleft(tilden_itildef_n-tilden_ntildef_iright)\n    - tildeR_mathrmiontilden_itildef_n\nendequation","category":"page"},{"location":"moment_kinetic_equations/#Moment-equations","page":"Moment kinetic equations","title":"Moment equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Recalling the definitions (TN-04;15,29,63-66), but writing the integral in the energy equation over tildev_ instead of w_,","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  tilden_s\n   = frac1sqrtpiint dtildev_tildef_s\n\n  tilden_stildeu_s\n   = frac1sqrtpiint dtildev_tildev_tildef_s\n\n  tildep_s\n   = frac1sqrtpiint dtildev_left(tildev_\n      - tildeu_sright)^2tildef_s\n    = int dtildev_tildev_^2tildef_s\n      - tilden_stildeu_s^2\n\n  tildeq_s\n   = frac1sqrtpiint dtildev_\n      left(tildev_-tildeu_sright)^3tildef_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  tildeq_s\n    = frac1sqrtpiint dtildev_tildev_^3tildef_s\n       - 3tildeu_sfrac1sqrtpiint dv_v_^2f_s\n       + 3u_s^2frac1sqrtpiint dv_v_f_s\n       - u_s^3frac1sqrtpiint dv_f_s \n\n    = frac1sqrtpiint dtildev_tildev_^3tildef_s\n       - 3tildeu_sleft(tildep_s+tilden_stildeu_s^2right)\n       + 3tildeu_s^2tilden_stildeu_s-tildeu_s^3tilden_s\nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  tildeq_s\n    = frac1sqrtpiint dtildev_tildev_^3tildef_s\n       - 3tildeu_stildep_s\n       - tilden_stildeu_s^3\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"we can take moments of the ion DKE to give ion moment equations (dropping tildes from here on)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial n_ipartial t+fracpartialleft(n_iu_iright)partial z\n   = -R_inleft(n_nn_i-n_in_nright)+R_mathrmionn_in_n \n\n   = R_mathrmionn_in_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartialleft(n_iu_iright)partial t + fracpartialleft(p_i\n  + n_iu_i^2right)partial z + frac12fracpartialphipartial zn_i\n  = -R_inleft(n_nn_iu_i - n_in_nu_nright)\n    + R_mathrmionn_in_nu_n \nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  n_ifracpartial u_ipartial t + u_ifracpartial n_ipartial t\n  + fracpartial p_ipartial z\n  + u_ifracpartialleft(n_iu_iright)partial z\n  + n_iu_ifracpartial u_ipartial z\n  + frac12fracpartialphipartial zn_i\n   = -R_inleft(n_nn_iu_i - n_in_nu_nright)\n      + R_mathrmionn_in_nu_n \n\n  n_ifracpartial u_ipartial t + u_ileft(R_mathrmionn_in_nright)\n  + fracpartial p_ipartial z + n_iu_ifracpartial u_ipartial z\n  + frac12fracpartialphipartial zn_i\n   = -R_inleft(n_nn_iu_i - n_in_nu_nright)\n      + R_mathrmionn_in_nu_n \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartial u_ipartial t + frac1n_ifracpartial p_ipartial z\n  + u_ifracpartial u_ipartial z + frac12fracpartialphipartial z\n  = -R_inn_nleft(u_i-u_nright)\n    + R_mathrmionfracn_in_nn_sleft(u_n-u_iright)\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartialleft(p_i + n_iu_i^2right)partial t\n    + fracpartialleft(q_i + 3u_ip_i\n    + n_iu_i^3right)partial z + fracpartialphipartial zn_iu_i \n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n      - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n+n_nu_n^2right) \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial p_ipartial t\n  + frac1n_ifracpartialleft(n_iu_iright)^2partial t\n  - fracleft(n_iu_iright)^2n_i^2fracpartial n_ipartial t\n  + fracpartialleft(q_i + 3u_ip_i\n  + n_iu_i^3right)partial z + fracpartialphipartial zn_iu_i\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n                   - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n + n_nu_n^2right) \n\n  fracp_ipartial t + 2u_ifracpartial n_iu_ipartial t\n  - u_i^2fracpartial n_ipartial t + fracpartialleft(q_i\n  + 3u_ip_i + n_iu_i^3right)partial z\n  + fracpartialphipartial zn_iu_i\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n      - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n + n_nu_n^2right) \n\n  fracpartial p_ipartial t + 2u_ileft(-fracpartial p_ipartial z\n  - fracpartialleft(n_iu_i^2right)partial z\n  - frac12fracpartialphipartial zn_i\n  - R_inleft(n_nn_iu_i - n_in_nu_nright)\n  + R_mathrmionn_in_nu_nright) \n  -u_i^2left(-fracpartialleft(n_iu_iright)partial z\n  + R_mathrmionn_in_nright) + fracpartial q_ipartial z\n  + fracpartialleft(3u_ip_iright)partial z\n  + fracpartialleft(n_iu_i^3right)partial z\n  + fracpartialphipartial zn_iu_i\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n      - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n + n_nu_n^2right) \n\n  fracpartial p_ipartial t + u_ifracpartial p_ipartial z\n  + 3p_ifracpartial u_ipartial z + fracpartial q_ipartial z\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right) - n_ileft(p_n\n      + n_nu_n^2right) - 2u_ileft(n_nn_iu_i - n_in_nu_nright)right) \n       quad + R_mathrmionn_ileft(p_n + n_nu_n^2 + n_nu_i^2\n      - 2n_nu_iu_nright) \n\n  fracpartial p_ipartial t + u_ifracpartial p_ipartial z\n  + 3p_ifracpartial u_ipartial z + fracpartial q_ipartial z\n   = -R_inleft(n_np_i - n_ip_n - n_in_nleft(u_i^2 + u_n^2\n      - 2u_iu_nright)right) + R_mathrmionn_ileft(p_n + n_nleft(u_n\n      - u_iright)^2right) \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial p_ipartial t + u_ifracpartial p_ipartial z\n    + 3p_ifracpartial u_ipartial z + fracpartial q_ipartial z \n   = -R_inleft(n_np_i - n_ip_n\n      - n_in_nleft(u_i - u_nright)^2right)\n      + R_mathrmionn_ileft(p_n + n_nleft(u_n - u_iright)^2right)\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and of the neutral DKE to give neutral moment equations","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial n_npartial t + fracpartialleft(n_nu_nright)partial z\n   = -R_ileft(n_in_n - n_nn_iright) - R_mathrmionn_in_n \n\n   =-R_mathrmionn_in_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartialleft(n_nu_nright)partial t\n  + fracpartialleft(p_n + n_nu_n^2right)partial z\n  = -R_inleft(n_in_nu_n - n_nn_iu_iright)\n    - R_mathrmionn_in_nu_n \nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  n_nfracpartial u_npartial t + u_nfracpartial n_npartial t\n  + fracpartial p_npartial z\n  + u_nfracpartialleft(n_nu_nright)partial z\n  + n_nu_nfracpartial u_npartial z\n   = -R_inleft(n_in_nu_n - n_nn_iu_iright)\n      - R_mathrmionn_in_nu_n \n\n  n_nfracpartial u_npartial t\n  + u_nleft(-R_mathrmionn_in_nright) + fracpartial p_npartial z\n  + n_nu_sfracpartial u_npartial z\n   = -R_inleft(n_in_nu_n - n_nn_iu_iright)\n      - R_mathrmionn_in_nu_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\n  fracpartial u_npartial t + frac1n_nfracpartial p_npartial z\n  + u_nfracpartial u_npartial z\n  = -R_inn_ileft(u_n - u_iright)\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartialleft(p_n + n_nu_n^2right)partial t\n    + fracpartialleft(q_n + 3u_np_n\n    + n_nu_n^3right)partial z + q_nfracpartialphipartial zn_nu_n \n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right)right)\n      - R_mathrmionn_ileft(p_n + n_nu_n^2right) \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial p_npartial t\n  + frac1n_nfracpartialleft(n_nu_nright)^2partial t\n  - fracleft(n_nu_nright)^2n_n^2fracpartial n_npartial t\n  + fracpartialleft(q_n + 3u_np_n + n_nu_n^3right)partial z\n  + q_nfracpartialphipartial zn_nu_n\n   =-R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right)right)\n      - R_mathrmionn_ileft(p_n + n_nu_n^2right) \n\n  fracpartial p_npartial t + 2u_nfracpartial n_nu_npartial t\n  - u_n^2fracpartial n_npartial t + fracpartialleft(q_n\n  + 3u_np_n + n_nu_n^3right)partial z\n  + q_nfracpartialphipartial zn_nu_n\n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right)right) - R_mathrmionn_ileft(p_n\n      + n_nu_n^2right) \n\n  fracpartial p_npartial t\n  + 2u_nleft(-fracpartial p_npartial z\n  - fracpartialleft(n_nu_n^2right)partial z\n  - fracq_n2fracpartialphipartial zn_n\n  - R_inleft(n_in_nu_n - n_nn_iu_iright)\n  - R_mathrmionn_in_nu_nright) \n  - u_n^2left(-fracpartialleft(n_nu_nright)partial z\n  - R_mathrmionn_in_nright) + fracpartial q_npartial z\n  + fracpartialleft(3u_np_nright)partial z\n  + fracpartialleft(n_nu_n^3right)partial z\n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n  + n_iu_i^2right)right)\n  - R_mathrmionn_ileft(p_n + n_nu_n^2right) \n\n  fracpartial p_npartial t + u_nfracpartial p_npartial z\n  + 3p_nfracpartial u_npartial z + fracpartial q_npartial z\n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right) - 2u_nleft(n_in_nu_n\n      - n_nn_iu_iright)right) - R_mathrmionn_ileft(p_n\n      + n_nu_n^2 + n_nu_n^2 - 2n_nu_nu_nright) \n\n  fracpartial p_npartial t + u_nfracpartial p_npartial z\n  + 3p_nfracpartial u_npartial z + fracpartial q_npartial z\n   = -R_inleft(n_ip_n - n_np_i - n_nn_ileft(u_n^2 + u_i^2\n      - 2u_nu_iright)right) - R_mathrmionn_ip_n \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial p_npartial t + u_nfracpartial p_npartial z\n    + 3p_nfracpartial u_npartial z + fracpartial q_npartial z \n   = -R_inleft(n_ip_n - n_np_i\n      - n_nn_ileft(u_n - u_iright)^2right) - R_mathrmionn_ip_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/#Kinetic-equation","page":"Moment kinetic equations","title":"Kinetic equation","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"For the moment-kinetic equation for the normalized distribution function","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\ng_s(w_s)=fracv_mathrmthsn_sf_s(v_(w_s))\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"we transform to the normalized velocity coordinate","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginequation\nw_s=fracv_ - u_sv_mathrmths\nendequation","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The derivatives transform as","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  leftfracpartial f_spartial tright_zv\n   rightarrowleftfracpartial f_spartial tright_zw\n               - frac1v_mathrmthsfracpartial u_spartial tleftfracpartial f_spartial w_sright_zw\n               - fracw_sv_mathrmthsfracpartial v_mathrmthspartial tleftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial zright_zv\n   rightarrowleftfracpartial f_spartial zright_zw\n               - frac1v_mathrmthsfracpartial u_spartial zleftfracpartial f_spartial w_sright_zw\n               - fracw_sv_mathrmthsfracpartial v_mathrmthspartial zleftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial v_right_zv\n   rightarrowfrac1v_mathrmthsleftfracpartial f_spartial w_sright_zw\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"We use an energy equation that evolves p_s not v_mathrmths, so use","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  v_mathrmths^2  = 2fracp_sn_s \n\n  Rightarrow v_mathrmthsfracpartial v_mathrmthspartial t\n   = frac1n_sfracpartial p_spartial t\n      - fracp_sn_s^2fracpartial n_spartial t\n\n  v_mathrmthsfracpartial v_mathrmthspartial z\n   = frac1n_sfracpartial p_spartial z\n      - fracp_sn_s^2fracpartial n_spartial z\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"to convert the transformations above to","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  leftfracpartial f_spartial tright_zv\n   rightarrowleftfracpartial f_spartial tright_zw\n    - frac1v_mathrmthsfracpartial u_spartial tleftfracpartial f_spartial w_sright_zw\n    - fracw_sv_mathrmths^2left(frac1n_sfracpartial p_spartial t\n    - fracp_sn_s^2fracpartial n_spartial tright)leftfracpartial f_spartial w_sright_zw\n\n   = leftfracpartial f_spartial tright_zw\n      - frac1v_mathrmthsfracpartial u_spartial tleftfracpartial f_spartial w_sright_zw\n      - fracw_s2left(frac1p_sfracpartial p_spartial t\n      - frac1n_sfracpartial n_spartial tright)leftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial zright_zv\n   rightarrowleftfracpartial f_spartial zright_zw\n    - frac1v_mathrmthsfracpartial u_spartial zleftfracpartial f_spartial w_sright_zw\n    - fracw_sv_mathrmths^2left(frac1n_sfracpartial p_spartial z\n    - fracp_sn_s^2fracpartial n_spartial zright)leftfracpartial f_spartial w_sright_zw\n\n   = leftfracpartial f_spartial zright_zw\n      - frac1v_mathrmthsfracpartial u_spartial zleftfracpartial f_spartial w_sright_zw\n      - fracw_s2left(frac1p_sfracpartial p_spartial z\n      - frac1n_sfracpartial n_spartial zright)leftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial v_right_zv\n   rightarrowfrac1v_mathrmthsleftfracpartial f_spartial w_sright_zw\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Using these transformations gives the ion DKE in a form similar to (TN-04;55) (but writing out dotw_ in full here, and not using the moment equations for the moment)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_ipartial t\n    - frac1v_mathrmthifracpartial u_ipartial tfracpartial f_ipartial w_i\n    - fracw_i2left(frac1p_ifracpartial p_ipartial t\n    - frac1n_ifracpartial n_ipartial tright)fracpartial f_ipartial w_i \n   + left(v_mathrmthiw_i + u_iright)left(fracpartial f_ipartial z\n    - frac1v_mathrmthifracpartial u_ipartial zfracpartial f_ipartial w_i\n    - fracw_i2left(frac1p_ifracpartial p_ipartial z\n    - frac1n_ifracpartial n_ipartial zright)fracpartial f_ipartial w_iright) \n   - frac12v_mathrmthifracpartialphipartial zfracpartial f_ipartial w_i \n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial f_ipartial t + left(v_mathrmthiw_i\n  + u_iright)fracpartial f_ipartial z\n  - frac1v_mathrmthifracpartial u_ipartial tfracpartial f_ipartial w_i\n  - fracw_i2left(frac1p_ifracpartial p_ipartial t\n  - frac1n_ifracpartial n_ipartial tright)fracpartial f_ipartial w_i\n  + left(v_mathrmthiw_i\n  + u_iright)left(-frac1v_mathrmthifracpartial u_ipartial zfracpartial f_ipartial w_i\n  - fracw_i2left(frac1p_ifracpartial p_ipartial z\n  - frac1n_ifracpartial n_ipartial zright)fracpartial f_ipartial w_iright)\n  - frac12v_mathrmthifracpartialphipartial zfracpartial f_ipartial w_i\n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n \n\n  fracpartial f_ipartial t + left(v_mathrmthiw_i\n  + u_iright)fracpartial f_ipartial z\n  + left-frac1v_mathrmthifracpartial u_ipartial t\n  - fracw_i2left(frac1p_ifracpartial p_ipartial t\n  - frac1n_ifracpartial n_ipartial tright)\n  + left(v_mathrmthiw_i\n  + u_iright)left(-frac1v_mathrmthifracpartial u_ipartial z\n  - fracw_i2left(frac1p_ifracpartial p_ipartial z\n  - frac1n_ifracpartial n_ipartial zright)right)\n  - frac12v_mathrmthifracpartialphipartial zrightfracpartial f_ipartial w_i\n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_ipartial t + left(v_mathrmthiw_i\n    + u_iright)fracpartial f_ipartial z \n   + left-frac1v_mathrmthileft(fracpartial u_ipartial t\n    + left(v_mathrmthiw_i + u_iright)fracpartial u_ipartial z\n    + frac12fracpartialphipartial zright)right \n   qquad - fracw_i2frac1p_ileft(fracpartial p_ipartial t\n          + left(v_mathrmthiw_i + u_iright)fracpartial p_ipartial zright) \n   qquad + fracw_i2frac1n_ileft(fracpartial n_ipartial t\n          + left(v_mathrmthiw_i\n          + leftu_iright)fracpartial n_ipartial zright)rightfracpartial f_ipartial w_i \n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and the neutral DKE","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_npartial t\n    - frac1v_mathrmthnfracpartial u_npartial tfracpartial f_npartial w_n\n    - fracw_n2left(frac1p_nfracpartial p_npartial t\n    - frac1n_nfracpartial n_npartial tright)fracpartial f_npartial w_n \n   + left(v_mathrmthnw_n + u_nright)left(fracpartial f_npartial z\n    - frac1v_mathrmthnfracpartial u_npartial zfracpartial f_npartial w_n\n    - fracw_n2left(frac1p_nfracpartial p_npartial z\n    - frac1n_nfracpartial n_npartial zright)fracpartial f_npartial w_nright) \n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial f_npartial t + left(v_mathrmthnw_n\n  + u_nright)fracpartial f_npartial z\n  - frac1v_mathrmthnfracpartial u_npartial tfracpartial f_npartial w_n\n  - fracw_n2left(frac1p_nfracpartial p_npartial t\n  - frac1n_nfracpartial n_npartial tright)fracpartial f_npartial w_n\n  + left(v_mathrmthnw_n\n  + u_nright)left(-frac1v_mathrmthnfracpartial u_npartial zfracpartial f_npartial w_n\n  - fracw_n2left(frac1p_nfracpartial p_npartial z\n  - frac1n_nfracpartial n_npartial zright)fracpartial f_npartial w_nright)\n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n \n\n  fracpartial f_npartial t + left(v_mathrmthnw_n\n  + u_nright)fracpartial f_npartial z\n  + left-frac1v_mathrmthnfracpartial u_npartial t\n  - fracw_n2left(frac1p_nfracpartial p_npartial t\n  - frac1n_nfracpartial n_npartial tright) + left(v_mathrmthnw_n\n  + u_nright)left(-frac1v_mathrmthnfracpartial u_npartial z\n  - fracw_n2left(frac1p_nfracpartial p_npartial z\n  - frac1n_nfracpartial n_npartial zright)right)rightfracpartial f_npartial w_n\n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_npartial t + left(v_mathrmthnw_n\n    + u_nright)fracpartial f_npartial z \n   + left-frac1v_mathrmthnleft(fracpartial u_npartial t\n    + left(v_mathrmthnw_n+u_nright)fracpartial u_npartial zright)right \n   qquad - fracw_n2frac1p_nleft(fracpartial p_npartial t\n           + left(v_mathrmthnw_n + u_nright)fracpartial p_npartial zright) \n   qquad + leftfracw_n2frac1n_nleft(fracpartial n_npartial t\n           + left(v_mathrmthnw_n\n           + u_nright)fracpartial n_npartial zright)rightfracpartial f_npartial w_n \n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"We also normalise f and write the DKEs for","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  g_s  =fracv_mathrmthsn_sf_s \n\n  Rightarrowfracpartial f_spartial t\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n  + fracg_sv_mathrmthsfracpartial n_spartial t\n  - fracn_sg_sv_mathrmths^2fracpartial v_mathrmthspartial t \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial f_spartial t\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n      + fracg_sv_mathrmthsfracpartial n_spartial t\n      - fracn_sg_sv_mathrmths^3left(frac1n_sfracpartial p_spartial t\n      - fracp_sn_s^2fracpartial n_spartial tright) \n\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n      + fracg_sv_mathrmthsfracpartial n_spartial t\n      - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial t\n      + fracg_s2v_mathrmthsfracpartial n_spartial t \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial f_spartial t\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n      + frac3g_s2v_mathrmthsfracpartial n_spartial t\n      - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial t \n\n  fracpartial f_spartial w_s\n   = fracn_sv_mathrmthsfracpartial g_spartial w_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"For brevity, do the following manipulations for g_s rather than for ions and neutrals separately by using q_i=1, q_n=0 and with the +'ve sign for the ion DKE and -'ve sign for the neutral DKE.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracn_sv_mathrmthsfracpartial g_spartial t\n  + frac3g_s2v_mathrmthsfracpartial n_spartial t\n  - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial f_spartial z \n   + left-frac1v_mathrmthsleft(fracpartial u_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial u_spartial z\n  + fracq_s2fracpartialphipartial zright)right \n   qquad - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright) \n   qquad + leftfracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracn_sv_mathrmthsfracpartial g_spartial w_s \n   = -R_ssleft(n_sfracn_sv_mathrmthsg_s\n      - n_sfracn_sv_mathrmthsg_sright)\n      pm R_mathrmionn_ifracn_nv_mathrmthng_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t \n   + left-frac1v_mathrmthsleft(fracpartial u_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial u_spartial z\n  + fracq_s2fracpartialphipartial zright)\n  - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright)\n  + fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n \n\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t \n   + left-frac1v_mathrmthsleft(fracn_sn_sfracpartial u_spartial t\n  + fracn_sn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial u_spartial z\n  + fracu_sn_sleft(fracpartial npartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial npartial zright)\n  + fracq_s2fracpartialphipartial zright)\n  + fracu_sn_sv_mathrmthsleft(fracpartial npartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial npartial zright)\n  - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright)\n  + fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t \n   + left-frac1n_sv_mathrmthsleft(fracpartial n_su_spartial t\n  + left(v_mathrmthsw_s + u_sright)left(n_sfracpartial u_spartial z\n  + u_sfracpartial n_spartial zright)\n  + fracq_s2n_sfracpartialphipartial zright)right \n   qquad + fracu_sn_sv_mathrmthsleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial n_spartial zright)\n  - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright) \n   qquad left+ fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"So then if we use the moment equations we can rewrite the DKE as","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t \n   + left-frac1n_sv_mathrmthsleft(fracpartial n_su_spartial t\n  + u_sleft(n_sfracpartial u_spartial z\n  + u_sfracpartial n_spartial zright)\n  - frac12n_sE_\n  + v_mathrmthsw_sleft(n_sfracpartial u_spartial z\n  + u_sfracpartial n_spartial zright)right)right \n   qquad + fracu_sn_sv_mathrmthsleft(fracpartial n_spartial t\n  + u_sfracpartial n_spartial z\n  + v_mathrmthsw_sfracpartial n_spartial zright) \n   qquad-fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + u_sfracpartial p_spartial z\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   qquadleft + fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + u_sfracpartial n_spartial z\n  + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sleft(pm R_mathrmionn_in_n\n  - u_sfracpartial n_spartial z\n  - n_sfracpartial u_spartial zright) \n   -fracg_s2p_sleft(-u_sfracpartial p_spartial z\n  - fracpartial q_spartial z\n  - 3p_sfracpartial u_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n - u_sright)^2right)right) \n   + left-frac1n_sv_mathrmthsleft(-underbracecanceln_su_sfracpartial u_spartial z_A\n  - fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)\n  pm R_mathrmionn_in_nu_n\n  + v_mathrmthsw_sleft(underbracecanceln_sfracpartial u_spartial z_B\n  + underbracecancelu_sfracpartial n_spartial z_Cright)right)right \n   quad + fracu_sn_sv_mathrmthsleft(pm R_mathrmionn_in_n\n  - underbracecanceln_sfracpartial u_spartial z_A\n  + underbracecancelv_mathrmthsw_sfracpartial n_spartial z_Cright) \n   quad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - underbracecancel3p_sfracpartial u_spartial z_B\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n\n  - u_sright)^2right) + v_mathrmthsw_sfracpartial p_spartial zright) \n   quadleft + fracw_s2frac1n_sleft(pm R_mathrmionn_in_n\n  - underbracecanceln_sfracpartial u_spartial z_B\n  + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n \n\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sleft(pm R_mathrmionn_in_n\n  - u_sfracpartial n_spartial z - n_sfracpartial u_spartial zright) \n   -fracg_s2p_sleft(-u_sfracpartial p_spartial z\n  - fracpartial q_spartial z - 3p_sfracpartial u_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n - u_sright)^2right)right) \n   + left-frac1n_sv_mathrmthsleft(-fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)pm R_mathrmionn_in_nu_nright)right \n   quad + fracu_sn_sv_mathrmthsleft(pm R_mathrmionn_in_nright) \n   quad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n\n  - u_sright)^2right) + v_mathrmthsw_sfracpartial p_spartial zright) \n   quadleft + fracw_s2frac1n_sleft(pm R_mathrmionn_in_n\n  + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n \n\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + g_sleft(pmfrac32R_mathrmionn_ifracn_nn_s\n  - frac3u_s2n_sfracpartial n_spartial zright) \n   + g_sleft(fracu_s2p_sfracpartial p_spartial z\n  + frac12p_sfracpartial q_spartial z\n  + frac12p_sR_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right)\n  mpfrac12R_mathrmionfracn_ip_sleft(p_n\n  + n_nleft(u_n - u_sright)^2right)right) \n   + left-frac1n_sv_mathrmthsleft(-fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)\n  pm R_mathrmionn_in_nleft(u_n - u_sright)right)right \n   quad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right)\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   quadmpfracw_s2R_mathrmionn_ileft(fracp_np_s\n  - fracn_nn_s + fracn_np_sleft(u_n - u_sright)^2right) \n   quadleft + fracw_s2frac1n_sleft(v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and finally using","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracu_sv_mathrmthsfracpartial v_mathrmthspartial z\n   =u_ssqrtfracn_sp_sfracpartialpartial zsqrtfracp_sn_s \n   = fracu_s2left(frac1p_sfracpartial p_spartial z\n      - frac1n_sfracpartial n_spartial zright)\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"gives","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + left(pmfrac32R_mathrmionn_ifracn_nn_s\n  - fracu_sn_sfracpartial n_spartial zright)g_s \n   + left(fracu_sv_mathrmthsfracpartial v_mathrmthspartial z\n  + frac12p_sfracpartial q_spartial zright \n   qquad + frac12p_sR_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right) \n   qquad leftmpfrac12R_mathrmionfracn_ip_sleft(p_n\n  + n_nleft(u_n - u_sright)^2right)right)g_s \n   + left-frac1n_sv_mathrmthsleft(-fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)\n  pm R_mathrmionn_in_nleft(u_n - u_sright)right)right \n   qquad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right)\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   qquadmpfracw_s2R_mathrmionn_ileft(fracp_np_s\n  - fracn_nn_s + fracn_np_sleft(u_n - u_sright)^2right) \n   qquadleft + fracw_s^22fracv_mathrmthsn_sfracpartial n_spartial zrightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Writing out the final result fully for ions","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial g_ipartial t\n  + fracv_mathrmthin_ileft(v_mathrmthiw_i\n  + u_iright)fracpartial f_ipartial z\n  + left(frac32R_mathrmionn_n\n  - fracu_in_ifracpartial n_ipartial zright)g_i \n   + left(fracu_iv_mathrmthifracpartial v_mathrmthipartial z\n  + frac12p_ifracpartial q_ipartial zright \n   qquad + frac12p_iR_inleft(n_np_i - n_ip_n\n  - n_in_nleft(u_i - u_nright)^2right) \n   qquad left - frac12R_mathrmionfracn_ip_ileft(p_n\n  + n_nleft(u_n - u_iright)^2right)right)g_i \n   + left-frac1n_iv_mathrmthileft(-fracpartial p_ipartial z\n  + R_inn_in_nleft(u_n - u_iright)\n  + R_mathrmionn_in_nleft(u_n - u_iright)right)right \n   qquad-fracw_i2frac1p_ileft(-fracpartial q_ipartial z\n  - R_inleft(n_np_i - n_ip_n\n  - n_in_nleft(u_i - u_nright)^2right)\n  + v_mathrmthiw_ifracpartial p_ipartial zright) \n   qquad - fracw_i2R_mathrmionn_ileft(fracp_np_i\n  - fracn_nn_i + fracn_np_ileft(u_n - u_iright)^2right) \n   qquadleft + fracw_i^22fracv_mathrmthin_ifracpartial n_ipartial zrightfracpartial g_ipartial w_i \n   = -R_inn_nleft(g_i - fracv_mathrmthiv_mathrmthng_nright)\n      + R_mathrmionv_mathrmthifracn_nv_mathrmthng_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and for neutrals where several of the ionization terms cancel","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_npartial t\n  + fracv_mathrmthnn_nleft(v_mathrmthnw_n\n  + u_nright)fracpartial f_npartial z\n  + left(-frac32R_mathrmionn_i\n  - fracu_nn_nfracpartial n_npartial zright)g_n \n   + left(fracu_nv_mathrmthnfracpartial v_mathrmthnpartial z\n  + frac12p_nfracpartial q_npartial zright \n   qquad left + frac12p_nR_inleft(n_ip_n - n_np_i\n  - n_nn_ileft(u_n - u_iright)^2right)\n  + frac12R_mathrmionn_iright)g_n \n   + left-frac1n_nv_mathrmthnleft(-fracpartial p_npartial z\n  + R_inn_nn_ileft(u_i - u_nright)right)right \n   qquad-fracw_n2frac1p_nleft(-fracpartial q_npartial z\n  - R_inleft(n_ip_n - n_np_i\n  - n_nn_ileft(u_n - u_iright)^2right)\n  + v_mathrmthnw_nfracpartial p_npartial zright) \n   qquadleft + fracw_n^22fracv_mathrmthnn_nfracpartial n_npartial zrightfracpartial g_npartial w_n \n   = -R_inn_ileft(g_n - fracv_mathrmthnv_mathrmthig_iright)\n      - R_mathrmionn_ig_n\nendalign","category":"page"},{"location":"interpolation/#interpolation","page":"interpolation","title":"interpolation","text":"","category":"section"},{"location":"interpolation/","page":"interpolation","title":"interpolation","text":"Modules = [moment_kinetics.interpolation]","category":"page"},{"location":"interpolation/#moment_kinetics.interpolation","page":"interpolation","title":"moment_kinetics.interpolation","text":"Interpolation routines intended for post-processing.\n\nNote these are not guaranteed to be highly optimized!\n\n\n\n\n\n","category":"module"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_1d!-Tuple{}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_1d!","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nArguments\n\nresult : Array{mkfloat, 1}     Array to be overwritten with the result of the interpolation newgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies spectral : Bool or chebyshev_info     struct containing information for discretization, whose type determines which method     is used.\n\n\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_1d-Tuple{Any, Vararg{Any}}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_1d","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nThis version allocates a new array for the result, which is returned.\n\nArguments\n\nnewgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies spectral : Bool or chebyshevinfo     struct containing information for discretization, whose type determines which method     is used.\n\nReturns\n\nresult : Array     Array with the values of f interpolated to the points in new_grid.\n\n\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa!-Tuple{AbstractVector{Float64}, Any, AbstractVector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa!","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa!-Tuple{Array{Float64, 3}, Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa!","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa-Tuple{Any, AbstractVector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa-Tuple{Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Array{Float64, 3}, Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Matrix{Float64}, Any, Matrix{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Vector{Float64}, Any, Vector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Matrix{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Vector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"moment_kinetics_structs/#moment_kinetics_structs","page":"moment_kinetics_structs","title":"moment_kinetics_structs","text":"","category":"section"},{"location":"moment_kinetics_structs/","page":"moment_kinetics_structs","title":"moment_kinetics_structs","text":"Modules = [moment_kinetics.moment_kinetics_structs]","category":"page"},{"location":"moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs","text":"structs used within moment_kinetics that should be defined early to avoid dependency cycles when they are used by several other modules.\n\n\n\n\n\n","category":"module"},{"location":"moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.chebyshev_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.chebyshev_info","text":"\n\n\n\n","category":"type"},{"location":"moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.em_fields_struct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.em_fields_struct","text":"\n\n\n\n","category":"type"},{"location":"moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.scratch_pdf","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.scratch_pdf","text":"\n\n\n\n","category":"type"},{"location":"array_allocation/#array_allocation","page":"array_allocation","title":"array_allocation","text":"","category":"section"},{"location":"array_allocation/","page":"array_allocation","title":"array_allocation","text":"Modules = [moment_kinetics.array_allocation]","category":"page"},{"location":"array_allocation/#moment_kinetics.array_allocation","page":"array_allocation","title":"moment_kinetics.array_allocation","text":"\n\n\n\n","category":"module"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_bool-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_bool","text":"allocate array with dimensions given by dims and entries of type Bool\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_complex-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_complex","text":"allocate 1d array with dimensions given by dims and entries of type Complex{mk_float}\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_float-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_float","text":"allocate array with dimensions given by dims and entries of type mk_float\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_int-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_int","text":"allocate 1d array with dimensions given by dims and entries of type mk_int\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_shared_bool-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_bool","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_shared_complex-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_complex","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_shared_float-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_float","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"array_allocation/#moment_kinetics.array_allocation.allocate_shared_int-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_int","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"developing/#Developing","page":"Developing","title":"Developing","text":"","category":"section"},{"location":"developing/#Dependencies","page":"Developing","title":"Dependencies","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"If you need to add a dependency, start the REPL with the moment_kinetics package activated (see above), enter pkg> mode (press ]) and then to add, for example, the FFTW.jl package enter","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"(moment_kinetics) pkg> add FFTW","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"This should take care of adding the package (FFTW) to the Project.toml and Manifest.toml files.","category":"page"},{"location":"developing/#Revise.jl","page":"Developing","title":"Revise.jl","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"When working on the code, one way to avoid waiting for everything to recompile frequently is to load the Revise.jl package","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> using Revise","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Revise.jl will recompile each edited function/method as needed, so it is possible to keep a REPL session open and avoid long recompilation. moment_kinetics can be run fairly conveniently from the REPL","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> using moment_kinetics\njulia> run_moment_kinetics(input)","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"where input is a Dict() containing any non-default options desired. Input can also be loaded from a TOML file passing the filaname as a String to the second argument, e.g.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> run_moment_kinetics(\"input.toml\")","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It might be convenient to add using Revise to your startup.jl file (~/julia/config/startup.jl) so it's always loaded.","category":"page"},{"location":"developing/#Parallelization","page":"Developing","title":"Parallelization","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"The code is parallelized at the moment using MPI and shared-memory arrays. Arrays representing the pdf, moments, etc. are shared between all processes. Using shared memory means, for example, we can take derivatives along one dimension while parallelising the other for any dimension without having to communicate to re-distribute the arrays. Using shared memory instead of (in future as well as) distributed memory parallelism has the advantage that it is easier to split up the points within each element between processors, giving a finer-grained parallelism which should let the code use larger numbers of processors efficiently.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It is possible to use a REPL workflow with parallel code:","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Recommended option is to use tmpi. This utility (it's a bash script that uses tmux) starts an mpi program with each process in a separate pane in a single terminal, and mirrors input to all processes simultaneously (which is normally what you want, there are also commands to 'zoom in' on a single process).\nAnother 'low-tech' possibilty is to use something like mpirun -np 4 xterm -e julia --project, but that will start each process in a separate xterm and you would have to enter commands separately in each one. Occasionally useful for debugging when nothing else is available.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"There is no restriction on the number of processes or number of grid points, although load-balancing may be affected - if there are only very few points per process, and a small fraction of processes have an extra grid point (e.g. splitting 5 points over 4 processes, so 3 process have 1 point but 1 process has 2 points), many processes will spend time waiting for the few with an extra point.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Parallelism is implemented through macros that get the local ranges of points that each process should handle. The inner-most level of nested loops is typically not parallelized, to allow efficient FFTs for derivatives, etc. A loop over one (possibly parallelized) dimension can be written as, for example,","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s is begin\n    f[is] = ...\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"These macros can be nested as needed for relatively complex loops","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s is begin\n    some_setup(is)\n    @loop_z iz begin\n        @views do_something(f[:,iz,is])\n    end\n    @loop_z iz begin\n        @views do_something_else(f[:,iz,is])\n    end\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Simpler nested loops can (optionally) be written more compactly","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s_z_vpa is iz ivpa begin\n    f[ivpa,iz,is] = ...\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Which dimensions are actually parallelized by these macros is controlled by the 'region' that the code is currently in, as set by the begin_<dims>_region() functions, where <dims> are the dimensions that will be parallelized in the following region. For example, after calling begin_s_z_region() loops over species and z will be divided up over the processes in a 'block' (currently there is only one block, which contains the whole grid and all the processes being used, as we have not yet implemented distributed-memory parallelism). Every process will loop over all points in the remaining dimensions if the loop macros for those dimensions are called.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The recommended place to put begin_*_region() calls is at the beginning of a function whose contents should use loops parallelised according to the settings for that region.\nEach begin_*_region() function checks if the region it would set is already active, and if so returns immediately (doing nothing). This means that begin_*_region() can (and should) be used to mark a block of code as belonging to that region, and if moment_kinetics is already in that region type, the call will have essentially zero cost.\nIn some places it may be necessary to change the region type half way through a function, etc. This is fine.\nWhen choosing which region type to select, note that all 'parallelised dimensions' must be looped over for each operation (otherwise some points may be written more than once), unless some special handling is used (e.g. species dimension s is parallelised, but a conditional like if 1 in loop_ranges[].s is wrapped around code to be executed so that only processes which should handle the point at s=1 do anything). It may be more optimal in some places to choose region types that do not parallelise all possible dimensions, to reduce the number of synchronisations that are needed.\nAs a matter of style, it is recommended to place begin_*_region() calls within functions where the loops are (or at most one level above), so that it is not necessary to search back along the execution path of the code to find the most recent begin_*_region() call, and therefore know what region type is active.\nIn a region after begin_serial_region(), the rank 0 process in each block will loop over all points in every dimension, and all other ranks will not loop over any.\nInside serial regions, the macro @serial_region can also be used to wrap blocks of code so that they only run on rank 0 of the block. This is useful for example to allow the use of array-broadcast expressions during initialization where performance is not critical.\nTo help show how these macros work, a script is provided that print a set of examples where the loop macros are expanded. It can be run from the Julia REPL\n$ julia --project\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.7.0 (2021-11-30)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> include(\"util/print-macros.jl\")\nor on the command line\n$ julia --project util/print-macros.jl","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The ranges used are stored in a LoopRanges struct in the Ref variable loop_ranges (which is exported by the looping module). The range for each dimension is stored in a member with the same name as the dimension, e.g. loop_ranges[].s for the species. Occasionally it is useful to access the range directly. There are different LoopRanges instances for different parallelization patterns - the instance stored in loop_ranges is updated when begin_*_region() is called. It is possible to find out the current region type (i.e. which dimensions are being parallelized) by looking at loop_ranges[].parallel_dims.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"note: Note\nThe square brackets [] after loop_ranges[] are needed because loop_ranges is a reference to a LoopRanges object Ref{LoopRanges} (a bit like a pointer) - it allows loop_ranges to be a const variable, so its type is always known at compile time, but the actual LoopRanges can be set/modified at run-time.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It is also possible to run a block of code in serial (on just the rank-0 member of each block of processes) by wrapping it in a @serial_region macro. This is mostly useful for initialization or file I/O where performance is not critical. For example","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@serial_region begin\n    # Do some initialization\n    f .= 0.0\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Internally, when the begin_*_region() functions need to change the region type (i.e. the requested region is not already active), they call _block_synchronize(), which calls MPI.Barrier(). They also switch over the LoopRanges struct contained in looping.loop_ranges as noted above. For optimization, the _block_synchronize() call can be skipped - when it is correct to do so - by passing the argument no_synchronize=true (or some more complicated conditional expression if synchronization is necessary when using some options but not for others).","category":"page"},{"location":"post_processing/#post_processing","page":"post_processing","title":"post_processing","text":"","category":"section"},{"location":"post_processing/","page":"post_processing","title":"post_processing","text":"Modules = [moment_kinetics.post_processing]","category":"page"},{"location":"post_processing/#moment_kinetics.post_processing","page":"post_processing","title":"moment_kinetics.post_processing","text":"\n\n\n\n","category":"module"},{"location":"post_processing/#moment_kinetics.post_processing.allocate_global_zr_fields-Tuple{Any, Any, Any}","page":"post_processing","title":"moment_kinetics.post_processing.allocate_global_zr_fields","text":"functions to allocate arrays that are used at run-time to postprocess data that is stored in the netcdf files\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.analyze_and_plot_data-Tuple","page":"post_processing","title":"moment_kinetics.post_processing.analyze_and_plot_data","text":"analyze_and_plot_data(prefix...)\n\nMake some plots for the simulation at prefix. If more than one argument is passed to prefix, plot all the simulations together.\n\nThe strings passed to prefix should be either a directory (which contains run output) or the prefix of output files, like <directory>/<prefix> where the output files are <directory>/<prefix>.moments.h5 and <directory>/<prefix>.dfns.h5.\n\nIf a single value is passed for prefix the plots/movies are created in the same directory as the run, and given names based on the name of the run. If multiple values are passed, the plots/movies are given names beginning with compare_ and are created in the comparison_plots/ subdirectory.\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.calculate_and_write_frequencies-NTuple{9, Any}","page":"post_processing","title":"moment_kinetics.post_processing.calculate_and_write_frequencies","text":"\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.calculate_differences-Tuple","page":"post_processing","title":"moment_kinetics.post_processing.calculate_differences","text":"Find the maximum difference, as a function of time, between two or more outputs for each variable.\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.compare_fields_symbolic_test-NTuple{13, Any}","page":"post_processing","title":"moment_kinetics.post_processing.compare_fields_symbolic_test","text":"\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.draw_v_parallel_zero!-Tuple{Plots.Plot, AbstractVector, Any, Any, Bool, Bool}","page":"post_processing","title":"moment_kinetics.post_processing.draw_v_parallel_zero!","text":"Add a thin, red, dashed line showing vparallel=(vth*wparallel+upar)=0 to a 2d plot with axes (z,vpa).\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.fit_cosine","page":"post_processing","title":"moment_kinetics.post_processing.fit_cosine","text":"Fit a cosine to a 1d array\n\nFit function is Acos(2πn(z + δ)/L)\n\nThe domain z is taken to be periodic, with the first and last points identified, so L=z[end]-z[begin]\n\nArguments\n\nz : Array     1d array with positions of the grid points - should have the same length as data data : Array     1d array of the data to be fit amplitudeguess : Float     Initial guess for the amplitude (the value from the previous time point might be a     good choice) offsetguess : Float     Initial guess for the offset (the value from the previous time point might be a good     choice) n : Int, default 1     The periodicity used for the fit\n\nReturns\n\namplitude : Float     The amplitude A of the cosine fit offset : Float     The offset δ of the cosine fit error : Float     The RMS of the difference between data and the fit\n\n\n\n\n\n","category":"function"},{"location":"post_processing/#moment_kinetics.post_processing.fit_delta_phi_mode-Tuple{Any, Any, Any}","page":"post_processing","title":"moment_kinetics.post_processing.fit_delta_phi_mode","text":"Fit delta_phi to get the frequency and growth rate.\n\nNote, expect the input to be a standing wave (as simulations are initialised with just a density perturbation), so need to extract both frequency and growth rate from the time-variation of the amplitude.\n\nThe function assumes that if the amplitude does not cross zero, then the mode is non-oscillatory and so fits just an exponential, not exp*cos. The simulation used as input should be long enough to contain at least ~1 period of oscillation if the mode is oscillatory or the fit will not work.\n\nArguments\n\nz : Array{mkfloat, 1}     1d array of the grid point positions t : Array{mkfloat, 1}     1d array of the time points deltaphi : Array{mkfloat, 2}     2d array of the values of delta_phi(z, t)\n\nReturns\n\nphifitresult struct whose fields are:     growthrate : mkfloat         Fitted growth rate of the mode     amplitude0 : mkfloat         Fitted amplitude at t=0     frequency : mkfloat         Fitted frequency of the mode     offset0 : mkfloat         Fitted offset at t=0     amplitudefiterror : mkfloat         RMS error in fit to ln(amplitude) - i.e. ln(A)     offsetfiterror : mkfloat         RMS error in fit to offset - i.e. δ     cosinefiterror : mkfloat         Maximum of the RMS errors of the cosine fits at each time point     amplitude : Array{mkfloat, 1}         Values of amplitude from which growthrate fit was calculated     offset : Array{mk_float, 1}         Values of offset from which frequency fit was calculated\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.get_tuple_of_return_values-Tuple{Any, Vararg{Any}}","page":"post_processing","title":"moment_kinetics.post_processing.get_tuple_of_return_values","text":"get_tuple_of_return_values(func, arg_tuples...)\n\nSuppose func(args...) returns a tuple of return values, then get_tuple_of_return_values(func, arg_tuples...) returns a tuple (with an entry for each return value of func) of tuples (one for each argument in each of arg_tuples...) of return values.\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.get_unnormalised_f_coords_2d-NTuple{9, Any}","page":"post_processing","title":"moment_kinetics.post_processing.get_unnormalised_f_coords_2d","text":"Get the unnormalised distribution function and unnormalised ('lab space') coordinates.\n\nInputs should depend only on z and vpa.\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.get_unnormalised_f_dzdt_1d-NTuple{8, Any}","page":"post_processing","title":"moment_kinetics.post_processing.get_unnormalised_f_dzdt_1d","text":"Get the unnormalised distribution function and unnormalised ('lab space') dzdt coordinate at a point in space.\n\nInputs should depend only on vpa.\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.init_postprocessing_options-NTuple{10, Any}","page":"post_processing","title":"moment_kinetics.post_processing.init_postprocessing_options","text":"\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.moving_average-Tuple{AbstractVector, Int64}","page":"post_processing","title":"moment_kinetics.post_processing.moving_average","text":"Calculate a moving average\n\nresult[i] = mean(v[i-n:i+n])\n\nExcept near the ends of the array where indices outside the range of v are skipped.\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.plot_1D_1V_diagnostics-NTuple{47, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_1D_1V_diagnostics","text":"\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.plot_charged_pdf-NTuple{16, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_charged_pdf","text":"plots various slices of the ion pdf (1d and 2d, stills and animations)\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.plot_dfns-NTuple{21, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_dfns","text":"\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.plot_fields-NTuple{11, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_fields","text":"\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.plot_moments-NTuple{25, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_moments","text":"\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.plot_neutral_pdf-NTuple{18, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_neutral_pdf","text":"plots various slices of the neutral pdf (1d and 2d, stills and animations)\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.plot_unnormalised_f2d-Tuple{Any, Any, Any}","page":"post_processing","title":"moment_kinetics.post_processing.plot_unnormalised_f2d","text":"Make a 2d plot of an unnormalised f on unnormalised coordinates, as returned from getunnormalisedf_coords()\n\nNote this function requires using the PyPlot backend to support 2d coordinates being passed to heatmap().\n\n\n\n\n\n","category":"method"},{"location":"post_processing/#moment_kinetics.post_processing.read_distributed_zr_data!-Tuple{Array{Float64, 3}, String, String, String, Int64, Int64, Int64}","page":"post_processing","title":"moment_kinetics.post_processing.read_distributed_zr_data!","text":"\n\n\n\n","category":"method"},{"location":"source_terms/#source_terms","page":"source_terms","title":"source_terms","text":"","category":"section"},{"location":"source_terms/","page":"source_terms","title":"source_terms","text":"Modules = [moment_kinetics.source_terms]","category":"page"},{"location":"source_terms/#moment_kinetics.source_terms","page":"source_terms","title":"moment_kinetics.source_terms","text":"\n\n\n\n","category":"module"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms!-NTuple{10, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms!","text":"calculate the source terms due to redefinition of the pdf to split off density, flow and/or pressure, and use them to update the pdf\n\n\n\n\n\n","category":"method"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms_evolve_density!-NTuple{8, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_density!","text":"\n\n\n\n","category":"method"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms_evolve_density_neutral!-NTuple{8, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_density_neutral!","text":"\n\n\n\n","category":"method"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_collisions!-NTuple{13, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_collisions!","text":"update the evolved pdf to account for the charge exchange and ionization source terms in the kinetic equation arising due to the re-normalization of the pdf as g = f * vth / n\n\n\n\n\n\n","category":"method"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_collisions_neutral!-NTuple{13, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_collisions_neutral!","text":"update the evolved pdf to account for the charge exchange and ionization source terms in the kinetic equation arising due to the re-normalization of the pdf as g = f * vth / n\n\n\n\n\n\n","category":"method"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_no_collisions!-NTuple{11, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_no_collisions!","text":"update the evolved pdf to account for the collisionless source terms in the kinetic equation arising due to the re-normalization of the pdf as g = f * vth / n\n\n\n\n\n\n","category":"method"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_no_collisions_neutral!-NTuple{11, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_no_collisions_neutral!","text":"update the evolved pdf to account for the collisionless source terms in the kinetic equation arising due to the re-normalization of the pdf as g = f * vth / n\n\n\n\n\n\n","category":"method"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms_manufactured!-NTuple{13, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_manufactured!","text":"advance the dfn with an arbitrary source function \n\n\n\n\n\n","category":"method"},{"location":"source_terms/#moment_kinetics.source_terms.source_terms_neutral!-NTuple{10, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_neutral!","text":"calculate the source terms due to redefinition of the pdf to split off density, flow and/or pressure, and use them to update the pdf\n\n\n\n\n\n","category":"method"},{"location":"r_advection/#r_advection","page":"r_advection","title":"r_advection","text":"","category":"section"},{"location":"r_advection/","page":"r_advection","title":"r_advection","text":"Modules = [moment_kinetics.r_advection]","category":"page"},{"location":"r_advection/#moment_kinetics.r_advection","page":"r_advection","title":"moment_kinetics.r_advection","text":"\n\n\n\n","category":"module"},{"location":"r_advection/#moment_kinetics.r_advection.adjust_advection_speed!-NTuple{5, Any}","page":"r_advection","title":"moment_kinetics.r_advection.adjust_advection_speed!","text":"\n\n\n\n","category":"method"},{"location":"r_advection/#moment_kinetics.r_advection.r_advection!-NTuple{14, Any}","page":"r_advection","title":"moment_kinetics.r_advection.r_advection!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"r_advection/#moment_kinetics.r_advection.unnormalize_pdf!-NTuple{6, Any}","page":"r_advection","title":"moment_kinetics.r_advection.unnormalize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"r_advection/#moment_kinetics.r_advection.update_speed_r!-NTuple{11, Any}","page":"r_advection","title":"moment_kinetics.r_advection.update_speed_r!","text":"calculate the advection speed in the r-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"load_data/#load_data","page":"load_data","title":"load_data","text":"","category":"section"},{"location":"load_data/","page":"load_data","title":"load_data","text":"Modules = [moment_kinetics.load_data]","category":"page"},{"location":"load_data/#moment_kinetics.load_data","page":"load_data","title":"moment_kinetics.load_data","text":"\n\n\n\n","category":"module"},{"location":"load_data/#moment_kinetics.load_data.load_block_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_block_data","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_charged_particle_moments_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_charged_particle_moments_data","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_coordinate_data-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.load_coordinate_data","text":"Load data for a coordinate\n\n\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_fields_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_fields_data","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_input-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_input","text":"Load saved input settings\n\n\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_mk_options-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_mk_options","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_neutral_pdf_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_neutral_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_pdf_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_rank_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_rank_data","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_slice-Tuple{}","page":"load_data","title":"moment_kinetics.load_data.load_slice","text":"Load a slice of a single variable from a file\n\n\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_species_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_species_data","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_time_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_time_data","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.load_variable-Tuple{}","page":"load_data","title":"moment_kinetics.load_data.load_variable","text":"Load a single variable from a file\n\n\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.open_readonly_output_file-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.open_readonly_output_file","text":"\n\n\n\n","category":"method"},{"location":"load_data/#moment_kinetics.load_data.reload_evolving_fields!-NTuple{13, Any}","page":"load_data","title":"moment_kinetics.load_data.reload_evolving_fields!","text":"Reload pdf and moments from an existing output file.\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The full documentation is online at https://mabarnes.github.io/moment_kinetics.","category":"page"},{"location":"getting_started/#Basics","page":"Getting started","title":"Basics","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Ensure that the Julia version is >= 1.7.0 by doing  $ julia --version  at command line.\nDependencies need to be installed to the project environment. Start Julia with  $ julia --project  (which activates the 'project' in the current directory) (or after starting with julia, in the REPL type ] to enter pkg> mode, enter activate . and then backspace to leave pkg> mode). Once in the moment_kinetics project, enter pkg> mode by typing ] and then run the command  (moment_kinetics) pkg> instantiate  this should download and install all the dependencies.\nFor julia>=1.6, pre-compiling dependencies manually is not necessary any more due to improvements to the native pre-compilation, so this step can be skipped (although precompiling the whole moment_kinetics code may still be useful sometimes). To pre-compile a static image (dependencies.so) that includes most of the external packages required for running and post-processing, run  $ julia -O3 precompile_dependencies.jl  To use the precompiled code, add an option -Jdependencies.so when starting julia.  It is also possible to precompile the whole package into a static image (moment_kinetics.so) using  $ julia -O3 precompile.jl this significantly decreases the load time but prevents code changes from taking effect when moment_kinetics.so is used without repeating the precompilation (to use this option, add an option -Jmoment_kinetics.so when starting julia).\nTo run julia with optimization, type  $ julia -O3 --project run_moment_kinetics.jl  Default input options are specified in moment_kinetics_input.jl. The defaults can be modified for a particular run by setting options in a TOML file, for example input.toml, which can be passed as an argument  $ julia -O3 --project run_moment_kinetics.jl input.toml\nTo run in parallel, just put mpirun -np <n> in front of the call you would normally use, with <n> the number of processes to use.\nIt may be more convenient when running moment_kinetics more than once to work from the Julia REPL, e.g.   $ julia -O3 --project   julia> using moment_kinetics   julia> run_moment_kinetics(input)   where input is a Dict() containing any non-default options desired. Input can also be loaded from a TOML file passing the filaname as a String to the second argument, e.g.   julia> run_moment_kinetics(\"input.toml\")\nTo make plots and calculate frequencies/growth rates, run  $ julia --project run_post_processing.jl runs/<directory to process>  passing the directory to process as a command line argument. Input options for post-processing can be specified in postprocessinginput.jl.\nParameter scans (see Running parameter scans) or performance tests can be performed by running  $ julia -O3 --project driver.jl  If running a scan, it can be parallelised by passing the number of processors as an argument. Scan options are set in scan_inputs.jl.\nPost processing can be done for several directories at once using  $ julia --project post_processing_driver.jl runs/<directory1> runs/<directory2> ...  passing the directories to process as command line arguments. Optionally pass a number as the first argument to parallelise post processing of different directories. Input options for post-processing can be specified in post_processing_input.jl.\nIn the course of development, it is sometimes helpful to upgrade the Julia veriosn. Upgrading the version of Julia or upgrading packages may require a fresh installation of moment_kinetics. To make a fresh install with the latest package versions it is necessary to remove (or rename) the Manifest.jl file in the main directory, and generate a new Manifest.jl with step 1) above. It can sometimes be necessary to remove or rename the .julia/ folder in your root directory for this step to be successful.\nOne may have to set an environment variable to avoid error messages from the Qt library. If you execute the command \n$ julia --project run_post_processing.jl runs/your_run_dir/","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"and see the error message    ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"qt.qpa.xcb: could not connect to display\nqt.qpa.plugin: Could not load the Qt platform plugin \"xcb\" in \"\" even though it was found.\nThis application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"this can be suppressed by setting ","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"    export QT_QPA_PLATFORM=offscreen\n    ```\nin your `.bashrc` or `.bash_profile` files. \n\n## Parallel I/O\n\nNote that to enable parallel I/O, you need to get HDF5.jl to use the system\nHDF5 library (which must be MPI-enabled and compiled using the same MPI as you\nrun Julia with). To do this (see [the HDF5.jl\ndocs](https://juliaio.github.io/HDF5.jl/stable/#Using-custom-or-system-provided-HDF5-binaries))\nrun (with the `moment_kinetics` project activated in Julia)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> ENV[\"JULIAHDF5PATH\"] = \"/path/to/your/hdf5/directory\"; using Pkg(); Pkg.build() ``` JTO also found that (on a Linux laptop) it was necessary to compile HDF5 from source. The system-provided, MPI-linked libhdf5 depended on libcurl, and Julia links to an incompatible libcurl, causing an error. When compiled from source (enabling MPI!), HDF5 does not require libcurl (guess it is an optional dependency), avoiding the problem.","category":"page"},{"location":"getting_started/#Running-parameter-scans","page":"Getting started","title":"Running parameter scans","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Parameter scans can be run, and can (optionally) use multiple processors. Short summary of implementation and usage:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"mk_input() takes a Dict argument, which can modify values. So mk_input() sets the 'defaults' (for a scan), which are overridden by any key/value pairs in the Dict.\nmk_scan_inputs() (in scan_input.jl) creates an Array of Dicts that can be passed to mk_input(). It first creates a Dict of parameters to scan over (keys are the names of the variable, values are an Array to scan over), then assembles an Array of Dicts (where each entry in the Array is a Dict with a single value for each variable being scanned). Most variables are combined as an 'inner product', e.g. {:ni=>[0.5, 1.], :nn=>[0.5, 0.]} gives [{:ni=>0.5, :nn=>0.5}, {ni=>1., nn=>0.}]. Any special variables specified in the combine_outer array are instead combined with the rest as an 'outer product', i.e. an entry is created for every value of those variables for each entry in the 'inner-producted' list. [This was just complicated enough to run the scans I've done so far without wasted simulations.]\nThe code in driver.jl picks between a single run (normal case), a performancetest, or creating a scan by calling `mkscaninput()and then looping over the returned array, callingmkinput()and running a simulation for each entry. This loop is parallelised (with the set of simulations dispatched over several processes - each simulation is still running serially). Running a scan (on 12 processes - actually 13 but the 'master' process doesn't run any of the loop bodies, so there are 12 'workers'): julia -O3 --project driverjl 12`  (runs in serial if no argument is given)\nThe scan puts each run in a separate directory, named with a prefix specified by base_name in scan_input.jl and the rest the names and values of the scanned-over parameters (the names are created in mk_scan_input() too, and passed as the :run_name entry of the returned Dicts).\nTo run post_processing.analyze_and_plot_data() over a bunch of directories (again parallelized trivially, and the number of processes to use is an optional argument, serial if omitted):  $ julia -O3 --project post_processing_driver.jl 12 runs/scan_name_*\nPlotting the scan is not so general, plot_comparison.jl does it, but is only set up for the particular scans I ran - everything except the charge exchange frequencies is hard-coded in.  $ julia -O3 --project plot_comparison.jl","category":"page"},{"location":"getting_started/#Tests","page":"Getting started","title":"Tests","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"There is a test suite in the test/ subdirectory. It can be run in a few ways:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Run using Pkg. Either using pkg> mode   $ julia -O3 --project   julia> <press ']' to enter pkg mode>   (moment_kinetics) pkg> test   using Pkg in the REPL   $ julia -O3 --project   julia> import Pkg   julia> Pkg.test()   or run on the command line   julia -O3 --project -e \"import Pkg; Pkg.test()`\nExecute some or all of the tests as a script. For example in the terminal run   $ julia -O3 --project test/runtests.jl   or in the REPL run   julia> include(\"test/runtests.jl\")   Individual test files can also be used instead of runtests.jl, which runs all the tests.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"By default the test suite should run fairly quickly (in a few minutes). To do so, it skips many cases. To run more comprehensive tests, you can activate the --long option:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Using test_args argument   julia> Pkg.test(; test_args=[\"--long\"])   Note the semicolon is necessary.\nIn the REPL, run   julia> push!(ARGS, \"--long\")   before running the tests.\nRunning from the terminal, pass as a command line argument, e.g.   $ julia -O3 --project --long test/runtests.jl","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To get more output on what tests were successful, an option --verbose (or -v) can be passed in a similar way to --long (if any tests fail, the output is printed by default).","category":"page"},{"location":"continuity/#continuity","page":"continuity","title":"continuity","text":"","category":"section"},{"location":"continuity/","page":"continuity","title":"continuity","text":"Modules = [moment_kinetics.continuity]","category":"page"},{"location":"continuity/#moment_kinetics.continuity","page":"continuity","title":"moment_kinetics.continuity","text":"\n\n\n\n","category":"module"},{"location":"continuity/#moment_kinetics.continuity.continuity_equation!-NTuple{8, Any}","page":"continuity","title":"moment_kinetics.continuity.continuity_equation!","text":"use the continuity equation dn/dt + d(n*upar)/dz to update the density n for all charged species\n\n\n\n\n\n","category":"method"},{"location":"continuity/#moment_kinetics.continuity.neutral_continuity_equation!-NTuple{8, Any}","page":"continuity","title":"moment_kinetics.continuity.neutral_continuity_equation!","text":"use the continuity equation dn/dt + d(n*upar)/dz to update the density n for all neutral species\n\n\n\n\n\n","category":"method"},{"location":"plot_sequence/#plot_sequence","page":"plot_sequence","title":"plot_sequence","text":"","category":"section"},{"location":"plot_sequence/","page":"plot_sequence","title":"plot_sequence","text":"Modules = [moment_kinetics.plot_sequence]","category":"page"},{"location":"plot_sequence/#moment_kinetics.plot_sequence","page":"plot_sequence","title":"moment_kinetics.plot_sequence","text":"\n\n\n\n","category":"module"},{"location":"scan_input/#scan_input","page":"scan_input","title":"scan_input","text":"","category":"section"},{"location":"scan_input/","page":"scan_input","title":"scan_input","text":"Modules = [moment_kinetics.scan_input]","category":"page"},{"location":"scan_input/#moment_kinetics.scan_input.base_name","page":"scan_input","title":"moment_kinetics.scan_input.base_name","text":"\n\n\n\n","category":"constant"},{"location":"scan_input/#moment_kinetics.scan_input.combine_outer","page":"scan_input","title":"moment_kinetics.scan_input.combine_outer","text":"By default, inputs are combined with an 'inner product', i.e. inputs a,b,c are combined as (a[1],b[1],c[1]), (a[2],b[2],c[2]), etc. Any inputs named in 'combine_outer' are instead combined with an 'outer product', i.e. an entry is created for every value of those inputs combined with every combination of the other inputs.\n\n\n\n\n\n","category":"constant"},{"location":"scan_input/#moment_kinetics.scan_input.mk_name-Tuple{Any}","page":"scan_input","title":"moment_kinetics.scan_input.mk_name","text":"\n\n\n\n","category":"method"},{"location":"scan_input/#moment_kinetics.scan_input.mk_scan_inputs-Tuple{}","page":"scan_input","title":"moment_kinetics.scan_input.mk_scan_inputs","text":"\n\n\n\n","category":"method"}]
}
