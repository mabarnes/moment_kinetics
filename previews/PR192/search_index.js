var documenterSearchIndex = {"docs":
[{"location":"zz_moment_kinetics_structs/#moment_kinetics_structs","page":"moment_kinetics_structs","title":"moment_kinetics_structs","text":"","category":"section"},{"location":"zz_moment_kinetics_structs/","page":"moment_kinetics_structs","title":"moment_kinetics_structs","text":"Modules = [moment_kinetics.moment_kinetics_structs]","category":"page"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs","text":"structs used within moment_kinetics that should be defined early to avoid dependency cycles when they are used by several other modules.\n\n\n\n\n\n","category":"module"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.boundary_distributions_struct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.boundary_distributions_struct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.discretization_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.discretization_info","text":"discretization_info for one dimension\n\nAll the specific discretizations in moment_kinetics are subtypes of this type.\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.em_fields_struct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.em_fields_struct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.moments_electron_substruct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.moments_electron_substruct","text":"momentselectronsubstruct is a struct that contains moment information for electrons\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.moments_ion_substruct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.moments_ion_substruct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.moments_neutral_substruct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.moments_neutral_substruct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.moments_struct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.moments_struct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.null_spatial_dimension_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.null_spatial_dimension_info","text":"Type representing a spatial dimension with only one grid point\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.null_velocity_dimension_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.null_velocity_dimension_info","text":"Type representing a velocity space dimension with only one grid point\n\n\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.pdf_struct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.pdf_struct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.pdf_substruct","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.pdf_substruct","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.scratch_pdf","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.scratch_pdf","text":"\n\n\n\n","category":"type"},{"location":"zz_moment_kinetics_structs/#moment_kinetics.moment_kinetics_structs.weak_discretization_info","page":"moment_kinetics_structs","title":"moment_kinetics.moment_kinetics_structs.weak_discretization_info","text":"discretization_info for a discretization that supports 'weak form' methods, for one dimension\n\n\n\n\n\n","category":"type"},{"location":"shared_memory_debugging/#Shared-memory-debugging","page":"Shared memory debugging","title":"Shared memory debugging","text":"","category":"section"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"This debug_test directory contains scripts for running a set of short runs, intended to be used with the --debug flag to check for bugs (e.g. race conditions). The output is not checked - the intention is just to catch errors raised by the debugging checks.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The inputs only have 3 time-steps, and very few grid points, because the debug checks are very slow. The actual output is not important, so it does not matter that the runs are badly under-resolved.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"It may be necessary to use the --compiled-modules=no flag to Julia for changes to the --debug setting to be picked up correctly. This setting means that all precompilation is redone each time Julia is started, which can be slow. An alternative workaround is to hard-code the moment_kinetics.debugging._debug_level variable in debugging.jl to the desired value.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"To run the debug tests, call (from the top-level moment_kinetics directory) something like","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"julia --project --check-bounds=yes --compiled-modules=no debug_test/runtests.jl --debug 99","category":"page"},{"location":"shared_memory_debugging/#Collision-operator-and-'anyv'-region","page":"Shared memory debugging","title":"Collision operator and 'anyv' region","text":"","category":"section"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The collision operator uses a slightly hacky special set of functions for shared memory parallelism, to allow the outer loop over species and spatial dimensions to be parallelised, but also inner loops over vperp, vpa or vperp and vpa to be parallelised - changing the type of inner-loop parallelism within the outer loop. This happens within an 'anyv' region, which is started with the begin_s_r_z_anyv_region() function. The debug checks within an 'anyv' region only check for correctness on the sub-block communicator that parallelises over velocity space, so if there were errors due to incorrect species or spatial parallelism they would not (might not?) be detected. These errors should be unlikely as the collision operator only writes to a single species at a single spatial point.","category":"page"},{"location":"shared_memory_debugging/#Finding-race-conditions","page":"Shared memory debugging","title":"Finding race conditions","text":"","category":"section"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The code is parallelized using MPI with shared memory arrays. 'Race conditions' can occur if a shared array is accessed incorrectly. All the processes sharing an array can be synchronized, ensuring they pass through the following code block with a consistent state, by using the _block_synchronize() function (which calls MPI.Barrier() to synchronize the processes). Race conditions occur if between consecutive calls to _block_synchronize() any array is:","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"written by 2 or more processes at the same position\nwritten by one process at a certain position, and read by one or more other processes at the same position.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"If a race condition occurs, it can result in errors in the results. These are sometimes small, but often show inconsistent results between runs (because results erroneously depend on the execution order on different processes). They are undefined behaviour though, and so can also cause anything up to segfaults.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The provided debugging routines can help to pin down where either of these errors happen.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"The @debug_shared_array macro (activated at --debug 2 or higher) counts all reads and writes to shared arrays by each process, and checks at each _block_synchronize() call whether either pattern has occurred since the previous _block_synchronize(). If they have and in addition @debug_track_array_allocate_location is active (--debug 3 or higher), then the array for which the error occured is identified by printing a stack-trace of the location where it was allocated, and the stack-trace for the exception shows the location of the _block_synchronize() call where the error occured.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"@debug_block_synchronize (activated at --debug 4)checks that all processes called _block_synchronize() from the same place - i.e. the same line in the code, checked by comparing stack traces.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"@debug_detect_redundant_block_synchronize (activated at --debug 5) aims to find any unnecessary calls to _block_synchronize(). These calls can be somewhat expensive (for large numbers of processes at least), so it is good to minimise the number. When this mode is active, at each _block_synchronize() a check is made whether there would be a race-condition error if the previous _block_synchronize() call was removed. If there would not be, then the previous call was unnecessary and could be removed. The tricky part is that whether it was necessary or not could depend on the options being used... Detecting redundant block_synchronize() calls requires that all dimensions that could be split over processes are actually split over processes, which demands a large number of processes are used. The @debug_detect_redundant_block_synchronize flag, when activated, modifies the splitting algorithm to force every dimension to be split if possible, and raise an error if not.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"Suggested debugging strategy for race conditions is:","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"Look at the loop types and ensure that there is an appropriate begin_*_region() call before each new loop type.\nRun debug_test/runtests.jl with @debug_shared_array activated, but not @debug_detect_redundant_block_synchronize. It will be faster to first run without @debug_track_array_allocate_location to find failing tests, then with @debug_track_array_allocate_location to help identify the cause of the failure. Usually a failure should indicate where there is a missing begin_*_region() call. There may be places though where synchronization is required even though the type of loop macros used does not change (for example when phi is calculated contributions from all ion species need to be summed, resulting in an unusual pattern of array accesses); in this case _block_synchronize() can be called directly.\nThe function debug_check_shared_memory() can be inserted between begin_*_region() calls when debugging to narrow down the location where the incorrect array access occured. It is defined when @debug_shared_array is active, and can be imported with using ..communication: debug_check_shared_memory(). The function runs the same error checks as are added by @debug_shared_array in _block_synchronize().\nThe tests in debug_test/ check for correctness by looping over the dimensions and forcing each to be split over separate processes in turn. This allows the correctness checks to be run using only 2 processes, which would not be possible if all dimensions had to be split at the same time.\n[This final level of checking only looks for minor optimizations rather than finding bugs, so it is much less important than the checks above.] Run debug_test/debug_redundant_synchronization/runtests.jl with @debug_detect_redundant_block_synchronize activated. This should show if any call to _block_synchronize() (including the ones inside begin_*_region() calls) was 'unnecessary' - i.e. there would be no incorrect array accesses if it was removed. This test needs to be run on a suitable combination of grid sizes and numbers of processes so that all dimensions are split across multiple processes to avoid false positives.  Any redundant calls which appear in all tests can be deleted.  Redundant calls that appear in only some tests (unless they are in some code block that is just not called in all the other tests) should preferably be moved inside a conditional block, so that they are called only when necessary, if a suitable one exists. If there is no conditional block that the call can be moved to, it may sometimes be necessary to just test one or more options before calling, e.g.\nmoments.evolve_upar && _block_synchronize()\nThe checks for redundant _block_synchronize() calls have been separated from the correctness checks so that the correctness checks can be run in the CI using only 2 processes, while the redundancy checks can be run manually on a machine with enough memory and cpu cores.","category":"page"},{"location":"shared_memory_debugging/","page":"Shared memory debugging","title":"Shared memory debugging","text":"You can find out what loop type is currently active by looking at loop_ranges[].parallel_dims. This variable is a Tuple containing Symbols for each dimension currently being parallelized.","category":"page"},{"location":"zz_analysis/#analysis","page":"analysis","title":"analysis","text":"","category":"section"},{"location":"zz_analysis/","page":"analysis","title":"analysis","text":"Modules = [moment_kinetics.analysis]","category":"page"},{"location":"zz_analysis/#moment_kinetics.analysis","page":"analysis","title":"moment_kinetics.analysis","text":"\n\n\n\n","category":"module"},{"location":"zz_analysis/#moment_kinetics.analysis.analyze_2D_instability-NTuple{7, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_2D_instability","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.analyze_fields_data-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_fields_data","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.analyze_moments_data-NTuple{8, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_moments_data","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.analyze_pdf_data-NTuple{7, Any}","page":"analysis","title":"moment_kinetics.analysis.analyze_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.check_Chodura_condition","page":"analysis","title":"moment_kinetics.analysis.check_Chodura_condition","text":"Check the (kinetic) Chodura condition\n\nChodura condition is: ∫d^3v F/vpa^2 ≤ mi ne/Te\n\nReturn a tuple (whose first entry is the result for the lower boundary and second for the upper) of the ratio which is 1 if the Chodura condition is satisfied (with equality): Te/(mi ne) * ∫d^3v F/vpa^2\n\nCurrently only evaluates condition for the first species: is=1\n\n2D2V\n\nIn normalised form (normalised variables suffixed with 'N'): vpa = cref vpaN vperp = cref vperpN ne = nref neN Te = Tref TeN F = FN nref / cref^3 pi^3/2 cref = sqrt(2 Tref / mi)\n\ncref^3 ∫d^3vN FN nref / cref^3 pi^3/2 cref^2 vpaN^2 ≤ mi nref neN / Tref TeN nref / (pi^3/2 cref^2) * ∫d^3vN FN / vpaN^2 ≤ mi nref neN / Tref TeN mi nref / (pi^3/2 2 Tref) * ∫d^3vN FN / vpaN^2 ≤ mi nref neN / Tref TeN 1 / (2 pi^3/2) * ∫d^3vN FN / vpaN^2 ≤ neN / TeN 1 / (2 pi^3/2) * ∫d^3vN FN / vpaN^2 ≤ neN / TeN TeN / (2 neN pi^3/2) * ∫d^3vN FN / vpaN^2 ≤ 1\n\nNote that integrate_over_vspace() includes the 1/pi^3/2 factor already.\n\n1D1V\n\nThe 1D1V code evolves the marginalised distribution function f = ∫d^2vperp F so the Chodura condition becomes ∫dvpa f/vpa^2 ≤ mi ne/Te\n\nIn normalised form (normalised variables suffixed with 'N'): vpa = cref vpaN ne = nref neN Te = Tref TeN f = fN nref / cref sqrt(pi) cref = sqrt(2 Tref / mi)\n\ncref ∫dvpaN fN nref / cref sqrt(pi) cref^2 vpaN^2 ≤ mi nref neN / Tref TeN nref / (sqrt(pi) cref^2) * ∫dvpaN fN / vpaN^2 ≤ mi nref neN / Tref TeN mi nref / (sqrt(pi) 2 Tref) * ∫dvpaN fN / vpaN^2 ≤ mi nref neN / Tref TeN 1 / (2 sqrt(pi)) * ∫dvpaN fN / vpaN^2 ≤ neN / TeN 1 / (2 sqrt(pi)) * ∫dvpaN fN / vpaN^2 ≤ neN / TeN TeN / (2 neN sqrt(pi)) * ∫dvpaN fN / vpaN^2 ≤ 1\n\nNote that integrate_over_vspace() includes the 1/sqrt(pi) factor already.\n\nIf ir0 is passed, only load the data for as single r-point (to save memory).\n\n\n\n\n\n","category":"function"},{"location":"zz_analysis/#moment_kinetics.analysis.field_line_average-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.field_line_average","text":"\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.fit_cosine","page":"analysis","title":"moment_kinetics.analysis.fit_cosine","text":"Fit a cosine to a 1d array\n\nFit function is Acos(2πn(z + δ)/L)\n\nThe domain z is taken to be periodic, with the first and last points identified, so L=z[end]-z[begin]\n\nArguments\n\nz : Array     1d array with positions of the grid points - should have the same length as data data : Array     1d array of the data to be fit amplitudeguess : Float     Initial guess for the amplitude (the value from the previous time point might be a     good choice) offsetguess : Float     Initial guess for the offset (the value from the previous time point might be a good     choice) n : Int, default 1     The periodicity used for the fit\n\nReturns\n\namplitude : Float     The amplitude A of the cosine fit offset : Float     The offset δ of the cosine fit error : Float     The RMS of the difference between data and the fit\n\n\n\n\n\n","category":"function"},{"location":"zz_analysis/#moment_kinetics.analysis.fit_delta_phi_mode-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.fit_delta_phi_mode","text":"Fit delta_phi to get the frequency and growth rate.\n\nNote, expect the input to be a standing wave (as simulations are initialised with just a density perturbation), so need to extract both frequency and growth rate from the time-variation of the amplitude.\n\nThe function assumes that if the amplitude does not cross zero, then the mode is non-oscillatory and so fits just an exponential, not exp*cos. The simulation used as input should be long enough to contain at least ~1 period of oscillation if the mode is oscillatory or the fit will not work.\n\nArguments\n\nz : Array{mkfloat, 1}     1d array of the grid point positions t : Array{mkfloat, 1}     1d array of the time points deltaphi : Array{mkfloat, 2}     2d array of the values of delta_phi(z, t)\n\nReturns\n\nphifitresult struct whose fields are:     growthrate : mkfloat         Fitted growth rate of the mode     amplitude0 : mkfloat         Fitted amplitude at t=0     frequency : mkfloat         Fitted frequency of the mode     offset0 : mkfloat         Fitted offset at t=0     amplitudefiterror : mkfloat         RMS error in fit to ln(amplitude) - i.e. ln(A)     offsetfiterror : mkfloat         RMS error in fit to offset - i.e. δ     cosinefiterror : mkfloat         Maximum of the RMS errors of the cosine fits at each time point     amplitude : Array{mkfloat, 1}         Values of amplitude from which growthrate fit was calculated     offset : Array{mk_float, 1}         Values of offset from which frequency fit was calculated\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_Fourier_modes_1D-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, moment_kinetics.coordinates.coordinate, Any, Any}} where T","page":"analysis","title":"moment_kinetics.analysis.get_Fourier_modes_1D","text":"Get 1D Fourier transform (in r) of nonuniformdata\n\nFirst interpolates to uniform grid, then uses FFT.\n\nIf zind is not given, find the zind where mode seems to be growing most strongly.\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_Fourier_modes_2D-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, moment_kinetics.coordinates.coordinate, Any, moment_kinetics.coordinates.coordinate, Any}} where T","page":"analysis","title":"moment_kinetics.analysis.get_Fourier_modes_2D","text":"Get 2D Fourier transform (in r and z) of nonuniformdata\n\nFirst interpolates to uniform grid, then uses FFT\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_r_perturbation-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T","page":"analysis","title":"moment_kinetics.analysis.get_r_perturbation","text":"Return (v - mean(v, dims=2))\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_unnormalised_f_coords_2d-NTuple{9, Any}","page":"analysis","title":"moment_kinetics.analysis.get_unnormalised_f_coords_2d","text":"Get the unnormalised distribution function and unnormalised ('lab space') coordinates.\n\nInputs should depend only on z and vpa.\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.get_unnormalised_f_dzdt_1d-NTuple{8, Any}","page":"analysis","title":"moment_kinetics.analysis.get_unnormalised_f_dzdt_1d","text":"Get the unnormalised distribution function and unnormalised ('lab space') dzdt coordinate at a point in space.\n\nInputs should depend only on vpa.\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.moving_average-Tuple{AbstractVector, Int64}","page":"analysis","title":"moment_kinetics.analysis.moving_average","text":"Calculate a moving average\n\nresult[i] = mean(v[i-n:i+n])\n\nExcept near the ends of the array where indices outside the range of v are skipped.\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.steady_state_residuals-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.steady_state_residuals","text":"steady_state_residuals(variable, variable_at_previous_time, dt;\n                       epsilon=0.0001, use_mpi=false)\n\nCalculate how close a variable is to steady state.\n\nCalculates several quantities. Define the 'squared absolute residual' r_mathrmabs(t)^2 for a quantity a(tx) as\n\nr_mathrmabs(t)^2 = left( a(tx) - a(t - delta tx) right)\n\nand the 'squared relative residual' r_mathrmrel(t)^2\n\nr_mathrmrel(t)^2 = left( fraca(tx) - a(t - delta tx)delta t left a(tx) + epsilon max_x(a(tx)) right right)\n\nwhere x stands for any spatial and velocity coordinates, and the offset epsilon max_x(a(tx)) is used to avoid points where a(tx) happens to be very close to zero from dominating the result in the 'squared relative residual', with max_x being the maximum over the x coordinate(s). Returns an OrderedDict containing: the maximum 'absolute residual' max_xleft( sqrtr_mathrmabs(t)^2 right) (\"RMS absolute residual\"); the root-mean-square (RMS) 'absolute residual' left sqrtr_mathrmabs(t)^2 right_x (\"max absolute residual\"); the maximum 'relative residual' max_xleft( sqrtr_mathrmrel(t)^2 right) (\"RMS relative residual\"); the root-mean-square (RMS) 'relative residual' left sqrtr_mathrmrel(t)^2 right_x (\"max relative residual\").\n\nvariable gives the value of a(tx) at the current time, variable_at_previous_time the value a(t - delta t x) at a previous time and dt gives the difference in times delta t. All three can be arrays with a time dimension of the same length, or have no time dimension.\n\nBy default runs in serial, but if use_mpi=true is passed, assume MPI has been initialised, and that variable has r and z dimensions but no species dimension, and use @loop_* macros. In this case the result is returned only on global rank 0. When using distributed-memory MPI, this routine will double-count the points on block boundaries.\n\nIf only_max_abs=true is passed, then only calculate the 'maxium absolute residual'. In this case the OrderedDict returned will have only one entry, for \"max absolute residual\".\n\n\n\n\n\n","category":"method"},{"location":"zz_analysis/#moment_kinetics.analysis.steady_state_square_residuals-Tuple{Any, Any, Any}","page":"analysis","title":"moment_kinetics.analysis.steady_state_square_residuals","text":"steady_state_square_residuals(variable, variable_at_previous_time, dt;\n                              variable_max=nothing, epsilon=1.0e-4,\n                              use_mpi=false, only_max_abs=false)\n\nUsed to calculate the mean square residual for steady_state_residuals.\n\nUseful to define this separately as it can be called on (equally-sized) chunks of the variable and then combined appropriately. If this is done, the global maximum of abs.(variable) should be passed to variable_max.\n\nSee steady_state_residuals for documenation of the other arguments. The return values of steady_state_residuals are the square-root of the return values of this function.\n\n\n\n\n\n","category":"method"},{"location":"zz_quadrature/#quadrature","page":"quadrature","title":"quadrature","text":"","category":"section"},{"location":"zz_quadrature/","page":"quadrature","title":"quadrature","text":"Modules = [moment_kinetics.quadrature]","category":"page"},{"location":"zz_quadrature/#moment_kinetics.quadrature","page":"quadrature","title":"moment_kinetics.quadrature","text":"\n\n\n\n","category":"module"},{"location":"zz_quadrature/#moment_kinetics.quadrature.composite_simpson_weights-Tuple{Any}","page":"quadrature","title":"moment_kinetics.quadrature.composite_simpson_weights","text":"compositesimpsonweights creates, computes, and returns an array for the 1D integration weights associated with each grid point using composite Simpson's rule\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#input_structs","page":"input_structs","title":"input_structs","text":"","category":"section"},{"location":"zz_input_structs/","page":"input_structs","title":"input_structs","text":"Modules = [moment_kinetics.input_structs]","category":"page"},{"location":"zz_input_structs/#moment_kinetics.input_structs","page":"input_structs","title":"moment_kinetics.input_structs","text":"\n\n\n\n","category":"module"},{"location":"zz_input_structs/#moment_kinetics.input_structs.advance_info","page":"input_structs","title":"moment_kinetics.input_structs.advance_info","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.advection_input","page":"input_structs","title":"moment_kinetics.input_structs.advection_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.advection_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.advection_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.collisions_input","page":"input_structs","title":"moment_kinetics.input_structs.collisions_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.drive_input","page":"input_structs","title":"moment_kinetics.input_structs.drive_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.drive_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.drive_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.electron_physics_type","page":"input_structs","title":"moment_kinetics.input_structs.electron_physics_type","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.evolve_moments_options","page":"input_structs","title":"moment_kinetics.input_structs.evolve_moments_options","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.geometry_input","page":"input_structs","title":"moment_kinetics.input_structs.geometry_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.grid_input","page":"input_structs","title":"moment_kinetics.input_structs.grid_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.grid_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.grid_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.initial_condition_input","page":"input_structs","title":"moment_kinetics.input_structs.initial_condition_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.initial_condition_input_mutable","page":"input_structs","title":"moment_kinetics.input_structs.initial_condition_input_mutable","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.io_input","page":"input_structs","title":"moment_kinetics.input_structs.io_input","text":"Settings and input for setting up file I/O\n\n\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.pp_input","page":"input_structs","title":"moment_kinetics.input_structs.pp_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.species_composition","page":"input_structs","title":"moment_kinetics.input_structs.species_composition","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.species_parameters","page":"input_structs","title":"moment_kinetics.input_structs.species_parameters","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.species_parameters_mutable","page":"input_structs","title":"moment_kinetics.input_structs.species_parameters_mutable","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#moment_kinetics.input_structs.time_input","page":"input_structs","title":"moment_kinetics.input_structs.time_input","text":"\n\n\n\n","category":"type"},{"location":"zz_input_structs/#Base.get-Tuple{Dict, Any, Enum}","page":"input_structs","title":"Base.get","text":"Utility method for converting a string to an Enum when getting from a Dict, based on the type of the default value\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#moment_kinetics.input_structs.Dict_to_NamedTuple-Tuple{Any}","page":"input_structs","title":"moment_kinetics.input_structs.Dict_to_NamedTuple","text":"Convert a Dict whose keys are String or Symbol to a NamedTuple\n\nUseful as NamedTuple is immutable, so option values cannot be accidentally changed.\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#moment_kinetics.input_structs.set_defaults_and_check_section!-Tuple{AbstractDict, Any}","page":"input_structs","title":"moment_kinetics.input_structs.set_defaults_and_check_section!","text":"Set the defaults for options in a section, and check that there are not any unexpected options (i.e. options that have no default).\n\nModifies the options[section_name]::Dict by adding defaults for any values that are not already present.\n\n\n\n\n\n","category":"method"},{"location":"zz_input_structs/#moment_kinetics.input_structs.set_defaults_and_check_top_level!-Tuple{AbstractDict}","page":"input_structs","title":"moment_kinetics.input_structs.set_defaults_and_check_top_level!","text":"Set the defaults for options in the top level of the input, and check that there are not any unexpected options (i.e. options that have no default).\n\nModifies the options[section_name]::Dict by adding defaults for any values that are not already present.\n\nIgnores any sections, as these will be checked separately.\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#array_allocation","page":"array_allocation","title":"array_allocation","text":"","category":"section"},{"location":"zz_array_allocation/","page":"array_allocation","title":"array_allocation","text":"Modules = [moment_kinetics.array_allocation]","category":"page"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation","page":"array_allocation","title":"moment_kinetics.array_allocation","text":"\n\n\n\n","category":"module"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_bool-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_bool","text":"allocate array with dimensions given by dims and entries of type Bool\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_complex-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_complex","text":"allocate 1d array with dimensions given by dims and entries of type Complex{mk_float}\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_float-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_float","text":"allocate array with dimensions given by dims and entries of type mk_float\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_int-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_int","text":"allocate 1d array with dimensions given by dims and entries of type mk_int\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_shared_bool-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_bool","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_shared_complex-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_complex","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_shared_float-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_float","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"zz_array_allocation/#moment_kinetics.array_allocation.allocate_shared_int-Tuple","page":"array_allocation","title":"moment_kinetics.array_allocation.allocate_shared_int","text":"variant where array is in shared memory for all processors in the 'block'\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#vpa_advection","page":"vpa_advection","title":"vpa_advection","text":"","category":"section"},{"location":"zz_vpa_advection/","page":"vpa_advection","title":"vpa_advection","text":"Modules = [moment_kinetics.vpa_advection]","category":"page"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection","page":"vpa_advection","title":"moment_kinetics.vpa_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_constant!-NTuple{5, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_constant!","text":"update the advection speed dvpa/dt = constant\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_default!-NTuple{13, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_default!","text":"\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_linear-NTuple{5, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_linear","text":"update the advection speed dvpa/dt = const*(vpa + L/2)\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_n_p_evolution!-NTuple{10, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_n_p_evolution!","text":"update the advection speed in the parallel velocity coordinate for the case where density and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized velocity vpahat = vpa/vth\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_n_u_evolution!-NTuple{9, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_n_u_evolution!","text":"update the advection speed in the parallel velocity coordinate for the case where density and flow are evolved independently from the pdf; in this case, the parallel velocity coordinate is the peculiar velocity wpa = vpa-upar\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_n_u_p_evolution!-NTuple{9, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_n_u_p_evolution!","text":"update the advection speed in the parallel velocity coordinate for the case where density, flow and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized peculiar velocity wpahat = (vpa - upar)/vth\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.update_speed_vpa!-NTuple{13, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.update_speed_vpa!","text":"calculate the advection speed in the vpa-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_vpa_advection/#moment_kinetics.vpa_advection.vpa_advection!-NTuple{16, Any}","page":"vpa_advection","title":"moment_kinetics.vpa_advection.vpa_advection!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#interpolation","page":"interpolation","title":"interpolation","text":"","category":"section"},{"location":"zz_interpolation/","page":"interpolation","title":"interpolation","text":"Modules = [moment_kinetics.interpolation]","category":"page"},{"location":"zz_interpolation/#moment_kinetics.interpolation","page":"interpolation","title":"moment_kinetics.interpolation","text":"Interpolation routines intended for post-processing.\n\nNote these are not guaranteed to be highly optimized!\n\n\n\n\n\n","category":"module"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_1d!","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_1d!","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nArguments\n\nresult : Array{mkfloat, 1}     Array to be overwritten with the result of the interpolation newgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies spectral : discretization_info     struct containing information for discretization, whose type determines which method     is used.\n\n\n\n\n\n","category":"function"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_1d-Tuple{Any, Vararg{Any}}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_1d","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nThis version allocates a new array for the result, which is returned.\n\nArguments\n\nnewgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies spectral : Bool or chebyshevinfo     struct containing information for discretization, whose type determines which method     is used.\n\nReturns\n\nresult : Array     Array with the values of f interpolated to the points in new_grid.\n\n\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa!-Tuple{AbstractVector{Float64}, Any, AbstractVector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa!-Tuple{Array{Float64, 3}, Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa-Tuple{Any, AbstractVector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_vpa-Tuple{Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_vpa","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Array{Float64, 3}, Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Matrix{Float64}, Any, Matrix{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z!-Tuple{Vector{Float64}, Any, Vector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z!","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Array{Float64, 3}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Matrix{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"zz_interpolation/#moment_kinetics.interpolation.interpolate_to_grid_z-Tuple{Any, Vector{Float64}, Any, Any}","page":"interpolation","title":"moment_kinetics.interpolation.interpolate_to_grid_z","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#initial_conditions","page":"initial_conditions","title":"initial_conditions","text":"","category":"section"},{"location":"zz_initial_conditions/","page":"initial_conditions","title":"initial_conditions","text":"Modules = [moment_kinetics.initial_conditions]","category":"page"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions","page":"initial_conditions","title":"moment_kinetics.initial_conditions","text":"\n\n\n\n","category":"module"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.allocate_pdf_and_moments-NTuple{13, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.allocate_pdf_and_moments","text":"Creates the structs for the pdf and the velocity-space moments\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.convert_full_f_ion_to_normalised!-NTuple{11, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.convert_full_f_ion_to_normalised!","text":"Take the full ion distribution function, calculate the moments, then normalise and shift to the moment-kinetic grid.\n\nUses input value of f and modifies in place to the normalised distribution functions. Input density, upar, ppar, and vth are not used, the values are overwritten with the moments of f.\n\nInputs/outputs depend on z, vperp, and vpa (should be inside loops over species, r)\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.convert_full_f_neutral_to_normalised!-NTuple{12, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.convert_full_f_neutral_to_normalised!","text":"Take the full neutral-particle distribution function, calculate the moments, then normalise and shift to the moment-kinetic grid.\n\nUses input value of f and modifies in place to the normalised distribution functions. Input density, upar, ppar, and vth are not used, the values are overwritten with the moments of f.\n\nInputs/outputs depend on z, vzeta, vr and vz (should be inside loops over species, r)\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.create_boundary_distributions-NTuple{7, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.create_boundary_distributions","text":"Allocate arrays for distributions to be applied as boundary conditions to the pdf at various boundaries. Also initialise the Knudsen cosine distribution here so it can be used when initialising the neutral pdf.\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.create_pdf-NTuple{8, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.create_pdf","text":"Allocate arrays for pdfs\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_density!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_density!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_electron_density!-Tuple{Any, Any, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_electron_density!","text":"initialise the electron density\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_electron_pdf_over_density_and_boundary_phi!-NTuple{14, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_electron_pdf_over_density_and_boundary_phi!","text":"initelectronpdfoverdensityandboundaryphi initialises the normalised electron pdf = pdfe * vthe / dense and the boundary values of the electrostatic potential phi; care is taken to ensure that the parallel boundary condition is satisfied; NB: as the electron pdf is obtained via a time-independent equation, this 'initital' value for the electron will just be the first guess in an iterative solution\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_electron_upar!-NTuple{8, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_electron_upar!","text":"initialise the electron parallel flow density\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_electron_vth!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_electron_vth!","text":"initialise the electron thermal speed profile. for now the only initialisation option for the temperature is constant in z. returns vth0 = sqrt(2*Ts/Te)\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_ion_pdf_over_density!-NTuple{15, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_ion_pdf_over_density!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_neutral_pdf_over_density!-NTuple{19, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_neutral_pdf_over_density!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_pdf_and_moments!-NTuple{29, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_pdf_and_moments!","text":"creates the normalised pdfs and the velocity-space moments and populates them with a self-consistent initial condition\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_upar!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_upar!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_uz!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_uz!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.init_vth!-NTuple{5, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.init_vth!","text":"for now the only initialisation option for the temperature is constant in z returns vth0 = sqrt(2Ts/ms) / sqrt(2Te/ms) = sqrt(Ts/Te)\n\n\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.initialize_pdf!-NTuple{14, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.initialize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"zz_initial_conditions/#moment_kinetics.initial_conditions.initialize_scratch_arrays!-NTuple{4, Any}","page":"initial_conditions","title":"moment_kinetics.initial_conditions.initialize_scratch_arrays!","text":"initialize the array of structs containing scratch arrays for the normalised pdf and low-order moments that may be evolved separately via fluid equations\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing","page":"makie_post_processing","title":"makie_post_processing","text":"","category":"section"},{"location":"zz_makie_post_processing/","page":"makie_post_processing","title":"makie_post_processing","text":"Modules = [makie_post_processing, makie_post_processing.shared_utils]","category":"page"},{"location":"zz_makie_post_processing/#makie_post_processing.makie_post_processing","page":"makie_post_processing","title":"makie_post_processing.makie_post_processing","text":"Post processing functions using Makie.jl\n\nOptions are read by default from a file post_processing_input.toml, if it exists.\n\nThe plots can be generated from the command line by running\n\njulia --project run_makie_post_processing.jl dir1 [dir2 [dir3 ...]]\n\n\n\n\n\n","category":"module"},{"location":"zz_makie_post_processing/#makie_post_processing.input_dict","page":"makie_post_processing","title":"makie_post_processing.input_dict","text":"Global dict containing settings for makiepostprocessing. Can be re-loaded at any time to change settings.\n\nIs an OrderedDict so the order of sections is nicer if input_dict is written out as a TOML file.\n\n\n\n\n\n","category":"constant"},{"location":"zz_makie_post_processing/#makie_post_processing.input_dict_dfns","page":"makie_post_processing","title":"makie_post_processing.input_dict_dfns","text":"Global dict containing settings for makiepostprocessing for files with distribution function output. Can be re-loaded at any time to change settings.\n\nIs an OrderedDict so the order of sections is nicer if input_dict_dfns is written out as a TOML file.\n\n\n\n\n\n","category":"constant"},{"location":"zz_makie_post_processing/#makie_post_processing.Chodura_condition_plots","page":"makie_post_processing","title":"makie_post_processing.Chodura_condition_plots","text":"Chodura_condition_plots(run_info::Tuple; plot_prefix)\nChodura_condition_plots(run_info; plot_prefix=nothing, axes=nothing)\n\nPlot the criterion from the Chodura condition at the sheath boundaries.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where line plots from the different runs are overlayed on the same axis, and heatmap plots are displayed in a horizontal row.\n\nSettings are read from the [Chodura_condition] section of the input.\n\nWhen run_info is a Tuple, plot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf. When run_info is not a Tuple, plot_prefix is optional - plots will be saved only if it is passed.\n\nWhen run_info is not a Tuple, a Vector of Axis objects can be passed to axes, and each plot will be added to one of axes.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing._MMS_pdf_plots-NTuple{10, Any}","page":"makie_post_processing","title":"makie_post_processing._MMS_pdf_plots","text":"_MMS_pdf_plots(run_info, input, variable_name, plot_prefix, field_label,\n               field_sym_label, norm_label, plot_dims, animate_dims)\n\nUtility function for making plots to avoid duplicated code in compare_ion_pdf_symbolic_test and compare_neutral_pdf_symbolic_test.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\ninput is a NamedTuple of settings to use.\n\nvariable_name is the name of the variable being plotted.\n\nplot_prefix gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nfield_label is the label for the computed variable that will be used in plots/animations, field_sym_label is the label for the manufactured solution, and norm_label is the label for the error.\n\nplot_dims are the dimensions of the variable, and animate_dims are the same but omitting :t.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing._get_steady_state_residual_fig_axes-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing._get_steady_state_residual_fig_axes","text":" _get_steady_state_residual_fig_axes(n_runs)\n\nUtility method to avoid code duplication when creating the figaxes OrderedDict for calculatesteadystateresidual.\n\nn_runs sets the number of axes to create in each entry.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_1d-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.animate_1d","text":"animate_1d(xcoord, data; frame_index=nothing, ax=nothing, fig=nothing,\n           xlabel=nothing, ylabel=nothing, title=nothing, yscale=nothing,\n           transform=identity, outfile=nothing, ylims=nothing,\n           axis_args=Dict{Symbol,Any}(), kwargs...)\n\nMake a 1d animation of data vs xcoord.\n\nxlabel, ylabel and title can be passed to set axis labels and title for the (sub-)plot.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nIf ax is passed, the animation will be added to that existing Axis, otherwise a new Figure and Axis will be created. If ax is passed, you should also pass an Observable{mk_int} to frame_index so that the data for this animation can be updated when frame_index is changed.\n\nIf outfile is passed the animation will be saved to a file with that name. The suffix determines the file type. If ax is passed at the same time as outfile then the Figure containing ax must also be passed (to the fig argument) so that the animation can be saved.\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nOther kwargs are passed to Makie's lines!() function.\n\nIf ax is not passed, returns the Figure, otherwise returns the object returned by lines!().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_2d-Tuple{Any, Any, Any}","page":"makie_post_processing","title":"makie_post_processing.animate_2d","text":"animate_2d(xcoord, ycoord, data; frame_index=nothing, ax=nothing, fig=nothing,\n           colorbar_place=nothing, xlabel=nothing, ylabel=nothing, title=nothing,\n           outfile=nothing, colormap=\"reverse_deep\", colorscale=nothing,\n           transform=identity, axis_args=Dict{Symbol,Any}(), kwargs...)\n\nMake a 2d animation of data vs xcoord and ycoord.\n\nxlabel, ylabel and title can be passed to set axis labels and title for the (sub-)plot.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nIf ax is passed, the animation will be added to that existing Axis, otherwise a new Figure and Axis will be created. If ax is passed, you should also pass an Observable{mk_int} to frame_index so that the data for this animation can be updated when frame_index is changed.\n\nIf outfile is passed the animation will be saved to a file with that name. The suffix determines the file type. If ax is passed at the same time as outfile then the Figure containing ax must also be passed (to the fig argument) so that the animation can be saved.\n\ncolormap is included explicitly because we do some special handling so that extra Makie functionality can be specified by a prefix to the colormap string, rather than the standard Makie mechanism of creating a struct that modifies the colormap. For example Reverse(\"deep\") can be passed as \"reverse_deep\". This is useful so that these extra colormaps can be specified in an input file, but is not needed for interactive use.\n\nWhen xcoord and ycoord are both one-dimensional, uses Makie's heatmap!() function for the plot. If either or both of xcoord and ycoord are two-dimensional, instead uses irregular_heatmap!.\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nOther kwargs are passed to Makie's heatmap!() function.\n\nIf ax is not passed, returns the Figure, otherwise returns the object returned by heatmap!().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_f_unnorm_vs_vpa","page":"makie_post_processing","title":"makie_post_processing.animate_f_unnorm_vs_vpa","text":"animate_f_unnorm_vs_vpa(run_info; input=nothing, neutral=false, is=1, iz=nothing,\n                        fig=nothing, ax=nothing, frame_index=nothing,\n                        outfile=nothing, yscale=identity, transform=identity,\n                        axis_args=Dict{Symbol,Any}(), kwargs...)\n\nPlot an unnormalized distribution function against v_parallel at a fixed z.\n\nThis function is only needed for moment-kinetic runs. These are currently only supported for the 1D1V case.\n\nThe information for the runs to animate is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where plots from the different runs are overlayed on the same axis.\n\nBy default animates the ion distribution function. If neutrals=true is passed, animates the neutral distribution function instead.\n\nis selects which species to analyse.\n\nit and iz specify the indices of the time- and z-points to choose. By default they are taken from input.\n\nIf input is not passed, it is taken from input_dict_dfns[\"f\"].\n\nThe data needed will be loaded from file.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen run_info is not a Tuple, an Axis can be passed to ax to have the plot added to ax. When ax is passed, if outfile is passed to save the plot, then the Figure containing ax must be passed to fig.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nAny extra kwargs are passed to plot_1d (which is used to create the plot, as we have to handle time-varying coordinates so cannot use animate_1d).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_f_unnorm_vs_vpa_z","page":"makie_post_processing","title":"makie_post_processing.animate_f_unnorm_vs_vpa_z","text":"animate_f_unnorm_vs_vpa_z(run_info; input=nothing, neutral=false, is=1,\n                          fig=nothing, ax=nothing, frame_index=nothing,\n                          outfile=nothing, yscale=identity, transform=identity,\n                          axis_args=Dict{Symbol,Any}(), kwargs...)\n\nAnimate an unnormalized distribution function against v_parallel and z.\n\nThis function is only needed for moment-kinetic runs. These are currently only supported for the 1D1V case.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where plots from the different runs are displayed in a horizontal row.\n\nBy default animates the ion distribution function. If neutrals=true is passed, animates the neutral distribution function instead.\n\nis selects which species to analyse.\n\nIf input is not passed, it is taken from input_dict_dfns[\"f\"].\n\nThe data needed will be loaded from file.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen run_info is not a Tuple, an Axis can be passed to ax to have the animation created in ax. When ax is passed, if outfile is passed to save the animation, then the Figure containing ax must be passed to fig.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nAny extra kwargs are passed to plot_2d (which is used to create the plot, as we have to handle time-varying coordinates so cannot use animate_2d).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_r","text":"animate_vs_r(run_info::Tuple, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, yscale=nothing,\n             transform=identity, ylims=nothing,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n             ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n             ivz=nothing, kwargs...)\nanimate_vs_r(run_info, var_name; is=1, data=nothing,\n             input=nothing, frame_index=nothing, ax=nothing,\n             fig=nothing, outfile=nothing, yscale=nothing,\n             transform=identity, ylims=nothing, label=nothing,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n             ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n             ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vpa","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vpa","text":"animate_vs_vpa(run_info::Tuple, var_name; is=1, data=nothing,\n               input=nothing, outfile=nothing, yscale=nothing,\n               transform=identity, ylims=nothing,\n               axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n               ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n               ivz=nothing, kwargs...)\nanimate_vs_vpa(run_info, var_name; is=1, data=nothing,\n               input=nothing, frame_index=nothing, ax=nothing,\n               fig=nothing, outfile=nothing, yscale=nothing,\n               transform=identity, ylims=nothing, label=nothing,\n               axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n               ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n               ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vpa.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vpa_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vpa_r","text":"animate_vs_vpa_r(run_info::Tuple, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\nanimate_vs_vpa_r(run_info, var_name; is=1, data=nothing,\n                 input=nothing, frame_index=nothing, ax=nothing,\n                 fig=nothing, colorbar_place=colorbar_place,\n                 title=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vpa.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vpa_vperp","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vpa_vperp","text":"animate_vs_vpa_vperp(run_info::Tuple, var_name; is=1, data=nothing,\n                     input=nothing, outfile=nothing, colorscale=identity,\n                     transform=identity, axis_args=Dict{Symbol,Any}(),\n                     it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                     ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                     kwargs...)\nanimate_vs_vpa_vperp(run_info, var_name; is=1, data=nothing,\n                     input=nothing, frame_index=nothing, ax=nothing,\n                     fig=nothing, colorbar_place=colorbar_place,\n                     title=nothing, outfile=nothing, colorscale=identity,\n                     transform=identity, axis_args=Dict{Symbol,Any}(),\n                     it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                     ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                     kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vperp and vpa.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vpa_z","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vpa_z","text":"animate_vs_vpa_z(run_info::Tuple, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\nanimate_vs_vpa_z(run_info, var_name; is=1, data=nothing,\n                 input=nothing, frame_index=nothing, ax=nothing,\n                 fig=nothing, colorbar_place=colorbar_place,\n                 title=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vpa.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vperp","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vperp","text":"animate_vs_vperp(run_info::Tuple, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, yscale=nothing,\n                 transform=identity, ylims=nothing,\n                 axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n                 ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n                 ivz=nothing, kwargs...)\nanimate_vs_vperp(run_info, var_name; is=1, data=nothing,\n                 input=nothing, frame_index=nothing, ax=nothing,\n                 fig=nothing, outfile=nothing, yscale=nothing,\n                 transform=identity, ylims=nothing, label=nothing,\n                 axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n                 ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n                 ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vperp.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vperp_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vperp_r","text":"animate_vs_vperp_r(run_info::Tuple, var_name; is=1, data=nothing,\n                   input=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\nanimate_vs_vperp_r(run_info, var_name; is=1, data=nothing,\n                   input=nothing, frame_index=nothing, ax=nothing,\n                   fig=nothing, colorbar_place=colorbar_place,\n                   title=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vperp.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vperp_z","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vperp_z","text":"animate_vs_vperp_z(run_info::Tuple, var_name; is=1, data=nothing,\n                   input=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\nanimate_vs_vperp_z(run_info, var_name; is=1, data=nothing,\n                   input=nothing, frame_index=nothing, ax=nothing,\n                   fig=nothing, colorbar_place=colorbar_place,\n                   title=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vperp.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vr","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vr","text":"animate_vs_vr(run_info::Tuple, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, yscale=nothing,\n              transform=identity, ylims=nothing,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n              ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n              ivz=nothing, kwargs...)\nanimate_vs_vr(run_info, var_name; is=1, data=nothing,\n              input=nothing, frame_index=nothing, ax=nothing,\n              fig=nothing, outfile=nothing, yscale=nothing,\n              transform=identity, ylims=nothing, label=nothing,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n              ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n              ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vr.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vr_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vr_r","text":"animate_vs_vr_r(run_info::Tuple, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nanimate_vs_vr_r(run_info, var_name; is=1, data=nothing,\n                input=nothing, frame_index=nothing, ax=nothing,\n                fig=nothing, colorbar_place=colorbar_place,\n                title=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vr.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vr_vzeta","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vr_vzeta","text":"animate_vs_vr_vzeta(run_info::Tuple, var_name; is=1, data=nothing,\n                    input=nothing, outfile=nothing, colorscale=identity,\n                    transform=identity, axis_args=Dict{Symbol,Any}(),\n                    it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                    ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                    kwargs...)\nanimate_vs_vr_vzeta(run_info, var_name; is=1, data=nothing,\n                    input=nothing, frame_index=nothing, ax=nothing,\n                    fig=nothing, colorbar_place=colorbar_place,\n                    title=nothing, outfile=nothing, colorscale=identity,\n                    transform=identity, axis_args=Dict{Symbol,Any}(),\n                    it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                    ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                    kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta and vr.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vr_z","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vr_z","text":"animate_vs_vr_z(run_info::Tuple, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nanimate_vs_vr_z(run_info, var_name; is=1, data=nothing,\n                input=nothing, frame_index=nothing, ax=nothing,\n                fig=nothing, colorbar_place=colorbar_place,\n                title=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vr.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vz","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vz","text":"animate_vs_vz(run_info::Tuple, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, yscale=nothing,\n              transform=identity, ylims=nothing,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n              ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n              ivz=nothing, kwargs...)\nanimate_vs_vz(run_info, var_name; is=1, data=nothing,\n              input=nothing, frame_index=nothing, ax=nothing,\n              fig=nothing, outfile=nothing, yscale=nothing,\n              transform=identity, ylims=nothing, label=nothing,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n              ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n              ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vz.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vz_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vz_r","text":"animate_vs_vz_r(run_info::Tuple, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nanimate_vs_vz_r(run_info, var_name; is=1, data=nothing,\n                input=nothing, frame_index=nothing, ax=nothing,\n                fig=nothing, colorbar_place=colorbar_place,\n                title=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vz.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vz_vr","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vz_vr","text":"animate_vs_vz_vr(run_info::Tuple, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\nanimate_vs_vz_vr(run_info, var_name; is=1, data=nothing,\n                 input=nothing, frame_index=nothing, ax=nothing,\n                 fig=nothing, colorbar_place=colorbar_place,\n                 title=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vr and vz.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vz_vzeta","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vz_vzeta","text":"animate_vs_vz_vzeta(run_info::Tuple, var_name; is=1, data=nothing,\n                    input=nothing, outfile=nothing, colorscale=identity,\n                    transform=identity, axis_args=Dict{Symbol,Any}(),\n                    it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                    ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                    kwargs...)\nanimate_vs_vz_vzeta(run_info, var_name; is=1, data=nothing,\n                    input=nothing, frame_index=nothing, ax=nothing,\n                    fig=nothing, colorbar_place=colorbar_place,\n                    title=nothing, outfile=nothing, colorscale=identity,\n                    transform=identity, axis_args=Dict{Symbol,Any}(),\n                    it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                    ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                    kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta and vz.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vz_z","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vz_z","text":"animate_vs_vz_z(run_info::Tuple, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nanimate_vs_vz_z(run_info, var_name; is=1, data=nothing,\n                input=nothing, frame_index=nothing, ax=nothing,\n                fig=nothing, colorbar_place=colorbar_place,\n                title=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vz.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vzeta","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vzeta","text":"animate_vs_vzeta(run_info::Tuple, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, yscale=nothing,\n                 transform=identity, ylims=nothing,\n                 axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n                 ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n                 ivz=nothing, kwargs...)\nanimate_vs_vzeta(run_info, var_name; is=1, data=nothing,\n                 input=nothing, frame_index=nothing, ax=nothing,\n                 fig=nothing, outfile=nothing, yscale=nothing,\n                 transform=identity, ylims=nothing, label=nothing,\n                 axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n                 ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n                 ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vzeta_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vzeta_r","text":"animate_vs_vzeta_r(run_info::Tuple, var_name; is=1, data=nothing,\n                   input=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\nanimate_vs_vzeta_r(run_info, var_name; is=1, data=nothing,\n                   input=nothing, frame_index=nothing, ax=nothing,\n                   fig=nothing, colorbar_place=colorbar_place,\n                   title=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vzeta.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_vzeta_z","page":"makie_post_processing","title":"makie_post_processing.animate_vs_vzeta_z","text":"animate_vs_vzeta_z(run_info::Tuple, var_name; is=1, data=nothing,\n                   input=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\nanimate_vs_vzeta_z(run_info, var_name; is=1, data=nothing,\n                   input=nothing, frame_index=nothing, ax=nothing,\n                   fig=nothing, colorbar_place=colorbar_place,\n                   title=nothing, outfile=nothing, colorscale=identity,\n                   transform=identity, axis_args=Dict{Symbol,Any}(),\n                   it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                   ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                   kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vzeta.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_z","page":"makie_post_processing","title":"makie_post_processing.animate_vs_z","text":"animate_vs_z(run_info::Tuple, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, yscale=nothing,\n             transform=identity, ylims=nothing,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n             ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n             ivz=nothing, kwargs...)\nanimate_vs_z(run_info, var_name; is=1, data=nothing,\n             input=nothing, frame_index=nothing, ax=nothing,\n             fig=nothing, outfile=nothing, yscale=nothing,\n             transform=identity, ylims=nothing, label=nothing,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing, iz=nothing,\n             ivperp=nothing, ivpa=nothing, ivzeta=nothing, ivr=nothing,\n             ivz=nothing, kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs z.\n\nIf a Tuple of run_info is passed, the animations from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nylims can be passed a Tuple (ymin, ymax) to set the y-axis limits. By default the minimum and maximum of the data (over all time points) will be used.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nWhen a single run_info is passed, label can be passed to set a custom label for the line. By default the run_info.run_name is used.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.animate_vs_z_r","page":"makie_post_processing","title":"makie_post_processing.animate_vs_z_r","text":"animate_vs_z_r(run_info::Tuple, var_name; is=1, data=nothing,\n               input=nothing, outfile=nothing, colorscale=identity,\n               transform=identity, axis_args=Dict{Symbol,Any}(),\n               it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n               ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n               kwargs...)\nanimate_vs_z_r(run_info, var_name; is=1, data=nothing,\n               input=nothing, frame_index=nothing, ax=nothing,\n               fig=nothing, colorbar_place=colorbar_place,\n               title=nothing, outfile=nothing, colorscale=identity,\n               transform=identity, axis_args=Dict{Symbol,Any}(),\n               it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n               ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n               kwargs...)\n\nAnimate var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and z.\n\nIf a Tuple of run_info is passed, the animations from each run are created in a horizontal row, with each sub-animation having the 'run name' as its subtitle.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be created in ax. When ax is passed, a colorbar will be created at colorbar_place if a GridPosition is passed to colorbar_place.\n\noutfile is required for animations unless ax is passed. The animation will be saved to a file named outfile.  The suffix determines the file type. If both outfile and ax are passed, then the Figure containing ax must be passed to fig to allow the animation to be saved.\n\nWhen a single run_info is passed, the (sub-)title can be set with the title argument.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case returns nothing.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.calculate_steady_state_residual","page":"makie_post_processing","title":"makie_post_processing.calculate_steady_state_residual","text":"calculatesteadystateresidual(runinfo, variablename; is=1, data=nothing,                                 plotprefix=nothing, figaxes=nothing, irun=1)\n\nCalculate and plot the 'residuals' for variable_name.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where plots from the different runs are displayed in a horizontal row.\n\nIf the variable has a species dimension, is selects which species to analyse.\n\nBy default the variable will be loaded from file. If the data has already been loaded, it can be passed to data instead. data should be a Tuple of the same length as run_info if run_info is a Tuple.\n\nIf plot_prefix is passed, it gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf.\n\nfig_axes can be passed an OrderedDict of Tuples as returned by _get_steady_state_residual_fig_axes - each tuple contains the Figure fig and Axis or Tuple{Axis} ax to which to add the plot corresponding to its key. If run_info is a Tuple, ax for each entry must be a Tuple of the same length.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.clear_Dict!-Tuple{AbstractDict}","page":"makie_post_processing","title":"makie_post_processing.clear_Dict!","text":"clear_Dict!(d::AbstractDict)\n\nRemove all entries from an AbstractDict, leaving it empty\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.compare_ion_pdf_symbolic_test-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.compare_ion_pdf_symbolic_test","text":"compare_ion_pdf_symbolic_test(run_info, plot_prefix; io=nothing,\n                                  input=nothing)\n\nCompare the computed and manufactured solutions for the ion distribution function.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nIf io is passed then error norms will be written to that file.\n\ninput is a NamedTuple of settings to use. If not given it will be read from the [manufactured_solns] section of [input_dict_dfns][@ref].\n\nNote: when calculating error norms, data is loaded only for 1 time point and for an r-z chunk that is the same size as computed by 1 block of the simulation at run time. This should prevent excessive memory requirements for this function.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.compare_moment_symbolic_test-NTuple{6, Any}","page":"makie_post_processing","title":"makie_post_processing.compare_moment_symbolic_test","text":"compare_moment_symbolic_test(run_info, plot_prefix, field_label, field_sym_label,\n                             norm_label, variable_name; io=nothing)\n\nCompare the computed and manufactured solutions for a field or moment variable variable_name.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nfield_label is the label that will be used for the name of the computed variable in plots, field_sym_label is the label for the manufactured solution, and norm_label is the label for the error (the difference between the computed and manufactured solutions).\n\nIf io is passed then error norms will be written to that file.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.compare_neutral_pdf_symbolic_test-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.compare_neutral_pdf_symbolic_test","text":"compare_neutral_pdf_symbolic_test(run_info, plot_prefix; io=nothing,\n                                  input=nothing)\n\nCompare the computed and manufactured solutions for the neutral distribution function.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nIf io is passed then error norms will be written to that file.\n\ninput is a NamedTuple of settings to use. If not given it will be read from the [manufactured_solns] section of [input_dict_dfns][@ref].\n\nNote: when calculating error norms, data is loaded only for 1 time point and for an r-z chunk that is the same size as computed by 1 block of the simulation at run time. This should prevent excessive memory requirements for this function.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.constraints_plots-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.constraints_plots","text":"constraints_plots(run_info; plot_prefix=plot_prefix)\n\nPlot and/or animate the coefficients used to correct the normalised distribution function(s) (aka shape functions) to obey the moment constraints.\n\nIf there were no discretisation errors, we would have A=1, B=0, C=0. The plots/animations show (A-1) so that all three coefficients can be shown nicely on the same axes.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.convert_to_OrderedDicts!-Tuple{AbstractDict}","page":"makie_post_processing","title":"makie_post_processing.convert_to_OrderedDicts!","text":"convert_to_OrderedDicts!(d::AbstractDict)\n\nRecursively convert an AbstractDict to OrderedDict.\n\nAny nested AbstractDicts are also converted to OrderedDict.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.curvilinear_grid_mesh-NTuple{4, Any}","page":"makie_post_processing","title":"makie_post_processing.curvilinear_grid_mesh","text":"curvilinear_grid_mesh(xs, ys, zs, colors)\n\nTesselates the grid defined by xs and ys in order to form a mesh with per-face coloring given by colors.\n\nThe grid defined by xs and ys must have dimensions (nx, ny) == size(colors) .+ 1, as is the case for heatmap/image.\n\nCode from: https://github.com/MakieOrg/Makie.jl/issues/742#issuecomment-1415809653\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.generate_example_input_Dict-Tuple{}","page":"makie_post_processing","title":"makie_post_processing.generate_example_input_Dict","text":"generate_example_input_Dict()\n\nCreate a Dict containing all the makie-post-processing options with default values\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.generate_example_input_file","page":"makie_post_processing","title":"makie_post_processing.generate_example_input_file","text":"generate_example_input_file(filename::String=post_processing_input.toml;\n                            overwrite::Bool=false)\n\nCreate an example makie-post-processing input file.\n\nEvery option is commented out, but filled with the default value.\n\nPass filename to choose the name of the example file (defaults to the default input file name used by makie_post_process()).\n\nPass overwrite=true to overwrite any existing file at filename.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.get_1d_ax","page":"makie_post_processing","title":"makie_post_processing.get_1d_ax","text":"get_1d_ax(n=nothing; title=nothing, subtitles=nothing, yscale=nothing,\n          get_legend_place=nothing, size=nothing, kwargs...)\n\nCreate a new Figure fig and Axis ax intended for 1d plots.\n\ntitle gives an overall title to the Figure.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10.\n\nBy default creates a single Axis, and returns (fig, ax). If a number of axes n is passed, then ax is a Vector{Axis} of length n (even if n is 1). The axes are created in a horizontal row, and the width of the figure is increased in proportion to n.\n\nget_legend_place can be set to one of (:left, :right, :above, :below) to create a GridPosition for a legend in the corresponding place relative to each Axis. If get_legend_place is set, (fig, ax, legend_place) is returned where legend_place is a GridPosition (if n=nothing) or a Tuple of n GridPositions.\n\nWhen n is passed, subtitles can be passed a Tuple of length n which will be used to set a subtitle for each Axis in ax.\n\nsize is passed through to the Figure constructor. Its default value is (600, 400) if n is not passed, or (600*n, 400) if n is passed.\n\nExtra kwargs are passed to the Axis() constructor.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.get_2d_ax","page":"makie_post_processing","title":"makie_post_processing.get_2d_ax","text":"get_2d_ax(n=nothing; title=nothing, subtitles=nothing, size=nothing, kwargs...)\n\nCreate a new Figure fig and Axis ax intended for 2d plots.\n\ntitle gives an overall title to the Figure.\n\nBy default creates a single Axis, and returns (fig, ax, colorbar_place), where colorbar_place is a location in the grid layout that can be passed to Colorbar() located immediately to the right of ax. If a number of axes n is passed, then ax is a Vector{Axis} and colorbar_place is a Vector{GridPosition} of length n (even if n is 1). The axes are created in a horizontal row, and the width of the figure is increased in proportion to n.\n\nWhen n is passed, subtitles can be passed a Tuple of length n which will be used to set a subtitle for each Axis in ax.\n\nsize is passed through to the Figure constructor. Its default value is (600, 400) if n is not passed, or (600*n, 400) if n is passed.\n\nExtra kwargs are passed to the Axis() constructor.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.get_dimension_slice_indices-Tuple","page":"makie_post_processing","title":"makie_post_processing.get_dimension_slice_indices","text":"getdimensionsliceindices(keepdims...; input, it=nothing, is=nothing,                             ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,                             ivzeta=nothing, ivr=nothing, ivz=nothing)\n\nGet indices for dimensions to slice\n\nThe indices are taken from input, unless they are passed as keyword arguments\n\nThe dimensions in keep_dims are not given a slice (those are the dimensions we want in the variable after slicing).\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.get_run_info-Tuple","page":"makie_post_processing","title":"makie_post_processing.get_run_info","text":"get_run_info(run_dir...; itime_min=1, itime_max=0,\n             itime_skip=1, dfns=false, initial_electron=false, do_setup=true,\n             setup_input_file=nothing)\nget_run_info((run_dir, restart_index)...; itime_min=1, itime_max=0,\n             itime_skip=1, dfns=false, initial_electron=false, do_setup=true,\n             setup_input_file=nothing)\n\nGet file handles and other info for a single run\n\nrun_dir is the directory to read output from.\n\nrestart_index can be given by passing a Tuple, e.g. (\"runs/example\", 42) as the positional argument. It specifies which restart to read if there are multiple restarts. If no restart_index is given or if nothing is passed, read all restarts and concatenate them. An integer value reads the restart with that index - -1 indicates the latest restart (which does not have an index).\n\nSeveral runs can be loaded at the same time by passing multiple positional arguments. Each argument can be a String run_dir giving a directory to read output from or a Tuple (run_dir, restart_index) giving both a directory and a restart index (it is allowed to mix Strings and Tuples in a call).\n\nBy default load data from moments files, pass dfns=true to load from distribution functions files, or initial_electron=true and dfns=true to load from initial electron state files.\n\nThe itime_min, itime_max and itime_skip options can be used to select only a slice of time points when loading data. In makie_post_process these options are read from the input (if they are set) before get_run_info() is called, so that the run_info returned can be passed to setup_makie_post_processing_input!, to be used for defaults for the remaining options. If either itime_min or itime_max are ≤0, their values are used as offsets from the final time index of the run.\n\nsetup_makie_post_processing_input!() is called at the end of get_run_info(), for convenience when working interactively. Use moment_kinetics.load_data.get_run_info_no_setup if you do not want this. A post-processing input file can be passed to setup_input_file that will be passed to setup_makie_post_processing_input!() if you do not want to use the default input file.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.get_variable_symbol-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.get_variable_symbol","text":"get_variable_symbol(variable_name)\n\nGet a symbol corresponding to a variable_name\n\nFor example get_variable_symbol(\"phi\") returns \"ϕ\".\n\nIf the symbol has not been defined, just return variable_name.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.grid_points_to_faces","page":"makie_post_processing","title":"makie_post_processing.grid_points_to_faces","text":"grid_points_to_faces(coord::AbstractVector)\ngrid_points_to_faces(coord::Observable{T} where T <: AbstractVector)\ngrid_points_to_faces(coord::AbstractMatrix)\ngrid_points_to_faces(coord::Observable{T} where T <: AbstractMatrix)\n\nTurn grid points in coord into 'cell faces'.\n\nReturns faces, which has a length one greater than coord. The first and last values of faces are the first and last values of coord. The intermediate values are the mid points between grid points.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.instability2D_plots","page":"makie_post_processing","title":"makie_post_processing.instability2D_plots","text":"instability2D_plots(run_info::Tuple, variable_name; plot_prefix, zind=nothing)\ninstability2D_plots(run_info, variable_name; plot_prefix, zind=nothing,\n                    axes_and_observables=nothing)\n\nMake plots of variable_name for analysis of 2D instability.\n\nThe information for the runs to analyse and plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, make plots comparing the runs, shown in a horizontal row..\n\nSettings are read from the [instability2D] section of the input.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nWhen run_info is not a Tuple, axes_and_observables can be passed to add plots and animations to existing figures, although this is not very convenient - see the use of this argument when called from the run_info::Tuple method.\n\nIf zind is not passed, it is calculated as the z-index where the mode seems to have the maximum growth rate for this variable. Returns zind.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.irregular_heatmap!-NTuple{4, Any}","page":"makie_post_processing","title":"makie_post_processing.irregular_heatmap!","text":"irregular_heatmap!(ax, xs, ys, zs; kwargs...)\n\nPlot a heatmap onto the Axis ax where xs and ys are allowed to define irregularly spaced, 2d grids.  zs gives the value in each cell of the grid.\n\nThe grid defined by xs and ys must have dimensions (nx, ny) == size(zs) .+ 1, as is the case for heatmap/image.\n\nxs be an array of size (nx,ny) or a vector of size (nx).\n\nys be an array of size (nx,ny) or a vector of size (ny).\n\nkwargs are passed to Makie's mesh() function.\n\nCode adapted from: https://github.com/MakieOrg/Makie.jl/issues/742#issuecomment-1415809653\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.irregular_heatmap-Tuple{Any, Any, Any}","page":"makie_post_processing","title":"makie_post_processing.irregular_heatmap","text":"irregular_heatmap(xs, ys, zs; kwargs...)\n\nPlot a heatmap where xs and ys are allowed to define irregularly spaced, 2d grids. zs gives the value in each cell of the grid.\n\nThe grid defined by xs and ys must have dimensions (nx, ny) == size(zs) .+ 1, as is the case for heatmap/image.\n\nxs be an array of size (nx,ny) or a vector of size (nx).\n\nys be an array of size (nx,ny) or a vector of size (ny).\n\nkwargs are passed to Makie's mesh() function.\n\nCode adapted from: https://github.com/MakieOrg/Makie.jl/issues/742#issuecomment-1415809653\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.makie_post_process-Tuple","page":"makie_post_processing","title":"makie_post_processing.makie_post_process","text":"makie_post_process(run_dir...;\n                   input_file::String=default_input_file_name,\n                   restart_index::Union{Nothing,mk_int,Tuple}=nothing,\n                   plot_prefix::Union{Nothing,AbstractString}=nothing)\n\nRun post processing with input read from a TOML file\n\nrun_dir... is the path to the directory to plot from. If more than one run_dir is given, plots comparing the runs in run_dir....\n\nrestart_index specifies which restart to read if there are multiple restarts. The default (nothing) reads all restarts and concatenates them. An integer value reads the restart with that index - -1 indicates the latest restart (which does not have an index). A tuple with the same length as run_dir can also be passed to give a different restart_index for each run.\n\nplot_prefix can be specified to give the prefix (directory and first part of file name) to use when saving plots/animations. By default the run directory and run name are used if there is only one run, and \"comparisonplots/compare\" is used if there are multiple runs.\n\nIf input_file does not exist, prints warning and uses default options.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.makie_post_process-Tuple{Union{String, Tuple}, AbstractDict{String, Any}}","page":"makie_post_processing","title":"makie_post_processing.makie_post_process","text":"makie_post_process(run_dir::Union{String,Tuple},\n                   new_input_dict::Dict{String,Any};\n                   restart_index::Union{Nothing,mk_int,Tuple}=nothing,\n                   plot_prefix::Union{Nothing,AbstractString}=nothing)\n\nRun post prossing, with (non-default) input given in a Dict\n\nrun_dir is the path to an output directory, or (to make comparison plots) a tuple of paths to output directories.\n\ninput_dict is a dictionary containing settings for the post-processing.\n\nrestart_index specifies which restart to read if there are multiple restarts. The default (nothing) reads all restarts and concatenates them. An integer value reads the restart with that index - -1 indicates the latest restart (which does not have an index). A tuple with the same length as run_dir can also be passed to give a different restart_index for each run.\n\nplot_prefix can be specified to give the prefix (directory and first part of file name) to use when saving plots/animations. By default the run directory and run name are used if there is only one run, and \"comparisonplots/compare\" is used if there are multiple runs.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.manufactured_solutions_analysis","page":"makie_post_processing","title":"makie_post_processing.manufactured_solutions_analysis","text":"manufactured_solutions_analysis(run_info; plot_prefix)\nmanufactured_solutions_analysis(run_info::Tuple; plot_prefix)\n\nCompare computed and manufactured solutions for field and moment variables for a 'method of manufactured solutions' (MMS) test.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nSettings are read from the [manufactured_solns] section of the input.\n\nWhile a Tuple of run_info can be passed for compatibility with makie_post_process(), at present comparison of multiple runs is not supported - passing a Tuple of length greater than one will result in an error.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.manufactured_solutions_analysis_dfns","page":"makie_post_processing","title":"makie_post_processing.manufactured_solutions_analysis_dfns","text":"manufactured_solutions_analysis_dfns(run_info; plot_prefix)\nmanufactured_solutions_analysis_dfns(run_info::Tuple; plot_prefix)\n\nCompare computed and manufactured solutions for distribution function variables for a 'method of manufactured solutions' (MMS) test.\n\nThe information for the run to analyse is passed in run_info (as returned by get_run_info).\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nSettings are read from the [manufactured_solns] section of the input.\n\nWhile a Tuple of run_info can be passed for compatibility with makie_post_process(), at present comparison of multiple runs is not supported - passing a Tuple of length greater than one will result in an error.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.manufactured_solutions_get_field_and_field_sym-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.manufactured_solutions_get_field_and_field_sym","text":" manufactured_solutions_get_field_and_field_sym(run_info, variable_name;\n     it=nothing, ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n     ivr=nothing, ivz=nothing)\n\nGet the data variable for variable_name from the output, and calculate the manufactured solution variable_sym.\n\nThe information for the runs to analyse and plot is passed in run_info (as returned by get_run_info).\n\nit, ir, iz, ivperp, ivpa, ivzeta, ivr, ivz can be used to select a subset of the grid by passing an integer or range for any dimension.\n\nReturns variable, variable_sym.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.parse_colormap-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.parse_colormap","text":"parse_colormap(colormap)\n\nParse a colormap option\n\nAllows us to have a string option which can be set in the input file and still use Reverse, etc. conveniently.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_1d-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.plot_1d","text":"plot_1d(xcoord, data; ax=nothing, xlabel=nothing, ylabel=nothing, title=nothing,\n        yscale=nothing, transform=identity, axis_args=Dict{Symbol,Any}(),\n        kwargs...)\n\nMake a 1d plot of data vs xcoord.\n\nxlabel, ylabel and title can be passed to set axis labels and title for the (sub-)plot.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nIf ax is passed, the plot will be added to that existing Axis, otherwise a new Figure and Axis will be created.\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nOther kwargs are passed to Makie's lines!() function.\n\nIf ax is not passed, returns the Figure, otherwise returns the object returned by lines!().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_2d-Tuple{Any, Any, Any}","page":"makie_post_processing","title":"makie_post_processing.plot_2d","text":"plot_2d(xcoord, ycoord, data; ax=nothing, colorbar_place=nothing, xlabel=nothing,\n        ylabel=nothing, title=nothing, colormap=\"reverse_deep\",\n        colorscale=nothing, transform=identity, axis_args=Dict{Symbol,Any}(),\n        kwargs...)\n\nMake a 2d plot of data vs xcoord and ycoord.\n\nxlabel, ylabel and title can be passed to set axis labels and title for the (sub-)plot.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nIf ax is passed, the plot will be added to that existing Axis, otherwise a new Figure and Axis will be created.\n\ncolormap is included explicitly because we do some special handling so that extra Makie functionality can be specified by a prefix to the colormap string, rather than the standard Makie mechanism of creating a struct that modifies the colormap. For example Reverse(\"deep\") can be passed as \"reverse_deep\". This is useful so that these extra colormaps can be specified in an input file, but is not needed for interactive use.\n\nWhen xcoord and ycoord are both one-dimensional, uses Makie's heatmap!() function for the plot. If either or both of xcoord and ycoord are two-dimensional, instead uses irregular_heatmap!.\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nOther kwargs are passed to Makie's heatmap!() function.\n\nIf ax is not passed, returns the Figure, otherwise returns the object returned by heatmap!().\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_f_unnorm_vs_vpa","page":"makie_post_processing","title":"makie_post_processing.plot_f_unnorm_vs_vpa","text":"plot_f_unnorm_vs_vpa(run_info; input=nothing, neutral=false, it=nothing, is=1,\n                     iz=nothing, fig=nothing, ax=nothing, outfile=nothing,\n                     yscale=identity, transform=identity,\n                     axis_args=Dict{Symbol,Any}(), kwargs...)\n\nPlot an unnormalized distribution function against v_parallel at a fixed z.\n\nThis function is only needed for moment-kinetic runs. These are currently only supported for the 1D1V case.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where plots from the different runs are overlayed on the same axis.\n\nBy default plots the ion distribution function. If neutrals=true is passed, plots the neutral distribution function instead.\n\nis selects which species to analyse.\n\nit and iz specify the indices of the time- and z-points to choose. By default they are taken from input.\n\nIf input is not passed, it is taken from input_dict_dfns[\"f\"].\n\nThe data needed will be loaded from file.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nWhen run_info is not a Tuple, an Axis can be passed to ax to have the plot added to ax. When ax is passed, if outfile is passed to save the plot, then the Figure containing ax must be passed to fig.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nAny extra kwargs are passed to plot_1d.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_f_unnorm_vs_vpa_z","page":"makie_post_processing","title":"makie_post_processing.plot_f_unnorm_vs_vpa_z","text":"plot_f_unnorm_vs_vpa_z(run_info; input=nothing, neutral=false, it=nothing, is=1,\n                       fig=nothing, ax=nothing, outfile=nothing, yscale=identity,\n                       transform=identity, rasterize=true, subtitles=nothing,\n                       axis_args=Dict{Symbol,Any}(), kwargs...)\n\nPlot unnormalized distribution function against v_parallel and z.\n\nThis function is only needed for moment-kinetic runs. These are currently only supported for the 1D1V case.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where plots from the different runs are displayed in a horizontal row.\n\nBy default plots the ion distribution function. If neutrals=true is passed, plots the neutral distribution function instead.\n\nis selects which species to analyse.\n\nit specifies the time-index to choose. By default it is taken from input.\n\nIf input is not passed, it is taken from input_dict_dfns[\"f\"].\n\nThe data needed will be loaded from file.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nWhen run_info is not a Tuple, an Axis can be passed to ax to have the plot created in ax. When ax is passed, if outfile is passed to save the plot, then the Figure containing ax must be passed to fig.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\nrasterize is passed through to Makie's mesh!() function. The default is to rasterize plots as vectorized plots from mesh!() have a very large file size. Pass false to keep plots vectorized. Pass a number to increase the resolution of the rasterized plot by that factor.\n\nWhen run_info is a Tuple, subtitles can be passed a Tuple (with the same length as run_info) to set the subtitle for each subplot.\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nAny extra kwargs are passed to plot_2d.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_ion_pdf_2D_at_wall-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.plot_ion_pdf_2D_at_wall","text":"plot_ion_pdf_2D_at_wall(run_info; plot_prefix)\n\nMake plots/animations of the ion distribution function at wall boundaries.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where line plots/animations from the different runs are overlayed on the same axis, and heatmap plots/animations are displayed in a horizontal row.\n\nSettings are read from the [wall_pdf] section of the input.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf. When run_info is not a Tuple, plot_prefix is optional - plots/animations will be saved only if it is passed.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_neutral_pdf_2D_at_wall-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.plot_neutral_pdf_2D_at_wall","text":"plot_neutral_pdf_2D_at_wall(run_info; plot_prefix)\n\nMake plots/animations of the neutral particle distribution function at wall boundaries.\n\nThe information for the runs to plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where line plots/animations from the different runs are overlayed on the same axis, and heatmap plots/animations are displayed in a horizontal row.\n\nSettings are read from the [wall_pdf_neutral] section of the input.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf. When run_info is not a Tuple, plot_prefix is optional - plots/animations will be saved only if it is passed.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_r","text":"plot_vs_r(run_info::Tuple, var_name; is=1, data=nothing,\n          input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n          ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n          ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_r(run_info, var_name; is=1, data=nothing,\n          input=nothing, ax=nothing, label=nothing,\n          outfile=nothing, yscale=nothing, transform=identity,\n          axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n          iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n          ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs r.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_r_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_r_t","text":"plot_vs_r_t(run_info::Tuple, var_name; is=1, data=nothing,\n            input=nothing, outfile=nothing, colorscale=identity,\n            transform=identity, axis_args=Dict{Symbol,Any}(),\n            it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n            ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n            kwargs...)\nplot_vs_r_t(run_info, var_name; is=1, data=nothing,\n            input=nothing, ax=nothing,\n            colorbar_place=nothing, title=nothing,\n            outfile=nothing, colorscale=identity, transform=identity,\n            axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n            iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n            ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and r.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_t","text":"plot_vs_t(run_info::Tuple, var_name; is=1, data=nothing,\n          input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n          ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n          ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_t(run_info, var_name; is=1, data=nothing,\n          input=nothing, ax=nothing, label=nothing,\n          outfile=nothing, yscale=nothing, transform=identity,\n          axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n          iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n          ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs t.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vpa","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vpa","text":"plot_vs_vpa(run_info::Tuple, var_name; is=1, data=nothing,\n            input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n            ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n            ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_vpa(run_info, var_name; is=1, data=nothing,\n            input=nothing, ax=nothing, label=nothing,\n            outfile=nothing, yscale=nothing, transform=identity,\n            axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n            iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n            ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vpa.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vpa_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vpa_r","text":"plot_vs_vpa_r(run_info::Tuple, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, colorscale=identity,\n              transform=identity, axis_args=Dict{Symbol,Any}(),\n              it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n              ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n              kwargs...)\nplot_vs_vpa_r(run_info, var_name; is=1, data=nothing,\n              input=nothing, ax=nothing,\n              colorbar_place=nothing, title=nothing,\n              outfile=nothing, colorscale=identity, transform=identity,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n              iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n              ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vpa.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vpa_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vpa_t","text":"plot_vs_vpa_t(run_info::Tuple, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, colorscale=identity,\n              transform=identity, axis_args=Dict{Symbol,Any}(),\n              it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n              ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n              kwargs...)\nplot_vs_vpa_t(run_info, var_name; is=1, data=nothing,\n              input=nothing, ax=nothing,\n              colorbar_place=nothing, title=nothing,\n              outfile=nothing, colorscale=identity, transform=identity,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n              iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n              ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vpa.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vpa_vperp","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vpa_vperp","text":"plot_vs_vpa_vperp(run_info::Tuple, var_name; is=1, data=nothing,\n                  input=nothing, outfile=nothing, colorscale=identity,\n                  transform=identity, axis_args=Dict{Symbol,Any}(),\n                  it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                  ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                  kwargs...)\nplot_vs_vpa_vperp(run_info, var_name; is=1, data=nothing,\n                  input=nothing, ax=nothing,\n                  colorbar_place=nothing, title=nothing,\n                  outfile=nothing, colorscale=identity, transform=identity,\n                  axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                  iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                  ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs vperp and vpa.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vpa_z","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vpa_z","text":"plot_vs_vpa_z(run_info::Tuple, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, colorscale=identity,\n              transform=identity, axis_args=Dict{Symbol,Any}(),\n              it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n              ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n              kwargs...)\nplot_vs_vpa_z(run_info, var_name; is=1, data=nothing,\n              input=nothing, ax=nothing,\n              colorbar_place=nothing, title=nothing,\n              outfile=nothing, colorscale=identity, transform=identity,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n              iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n              ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vpa.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vperp","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vperp","text":"plot_vs_vperp(run_info::Tuple, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n              ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n              ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_vperp(run_info, var_name; is=1, data=nothing,\n              input=nothing, ax=nothing, label=nothing,\n              outfile=nothing, yscale=nothing, transform=identity,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n              iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n              ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vperp.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vperp_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vperp_r","text":"plot_vs_vperp_r(run_info::Tuple, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nplot_vs_vperp_r(run_info, var_name; is=1, data=nothing,\n                input=nothing, ax=nothing,\n                colorbar_place=nothing, title=nothing,\n                outfile=nothing, colorscale=identity, transform=identity,\n                axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vperp.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vperp_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vperp_t","text":"plot_vs_vperp_t(run_info::Tuple, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nplot_vs_vperp_t(run_info, var_name; is=1, data=nothing,\n                input=nothing, ax=nothing,\n                colorbar_place=nothing, title=nothing,\n                outfile=nothing, colorscale=identity, transform=identity,\n                axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vperp.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vperp_z","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vperp_z","text":"plot_vs_vperp_z(run_info::Tuple, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nplot_vs_vperp_z(run_info, var_name; is=1, data=nothing,\n                input=nothing, ax=nothing,\n                colorbar_place=nothing, title=nothing,\n                outfile=nothing, colorscale=identity, transform=identity,\n                axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vperp.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vr","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vr","text":"plot_vs_vr(run_info::Tuple, var_name; is=1, data=nothing,\n           input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n           ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n           ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_vr(run_info, var_name; is=1, data=nothing,\n           input=nothing, ax=nothing, label=nothing,\n           outfile=nothing, yscale=nothing, transform=identity,\n           axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n           iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n           ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vr.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vr_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vr_r","text":"plot_vs_vr_r(run_info::Tuple, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, colorscale=identity,\n             transform=identity, axis_args=Dict{Symbol,Any}(),\n             it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n             ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n             kwargs...)\nplot_vs_vr_r(run_info, var_name; is=1, data=nothing,\n             input=nothing, ax=nothing,\n             colorbar_place=nothing, title=nothing,\n             outfile=nothing, colorscale=identity, transform=identity,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n             iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n             ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vr.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vr_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vr_t","text":"plot_vs_vr_t(run_info::Tuple, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, colorscale=identity,\n             transform=identity, axis_args=Dict{Symbol,Any}(),\n             it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n             ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n             kwargs...)\nplot_vs_vr_t(run_info, var_name; is=1, data=nothing,\n             input=nothing, ax=nothing,\n             colorbar_place=nothing, title=nothing,\n             outfile=nothing, colorscale=identity, transform=identity,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n             iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n             ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vr.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vr_vzeta","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vr_vzeta","text":"plot_vs_vr_vzeta(run_info::Tuple, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\nplot_vs_vr_vzeta(run_info, var_name; is=1, data=nothing,\n                 input=nothing, ax=nothing,\n                 colorbar_place=nothing, title=nothing,\n                 outfile=nothing, colorscale=identity, transform=identity,\n                 axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                 iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                 ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta and vr.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vr_z","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vr_z","text":"plot_vs_vr_z(run_info::Tuple, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, colorscale=identity,\n             transform=identity, axis_args=Dict{Symbol,Any}(),\n             it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n             ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n             kwargs...)\nplot_vs_vr_z(run_info, var_name; is=1, data=nothing,\n             input=nothing, ax=nothing,\n             colorbar_place=nothing, title=nothing,\n             outfile=nothing, colorscale=identity, transform=identity,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n             iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n             ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vr.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vz","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vz","text":"plot_vs_vz(run_info::Tuple, var_name; is=1, data=nothing,\n           input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n           ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n           ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_vz(run_info, var_name; is=1, data=nothing,\n           input=nothing, ax=nothing, label=nothing,\n           outfile=nothing, yscale=nothing, transform=identity,\n           axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n           iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n           ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vz.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vz_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vz_r","text":"plot_vs_vz_r(run_info::Tuple, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, colorscale=identity,\n             transform=identity, axis_args=Dict{Symbol,Any}(),\n             it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n             ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n             kwargs...)\nplot_vs_vz_r(run_info, var_name; is=1, data=nothing,\n             input=nothing, ax=nothing,\n             colorbar_place=nothing, title=nothing,\n             outfile=nothing, colorscale=identity, transform=identity,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n             iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n             ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vz.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vz_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vz_t","text":"plot_vs_vz_t(run_info::Tuple, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, colorscale=identity,\n             transform=identity, axis_args=Dict{Symbol,Any}(),\n             it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n             ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n             kwargs...)\nplot_vs_vz_t(run_info, var_name; is=1, data=nothing,\n             input=nothing, ax=nothing,\n             colorbar_place=nothing, title=nothing,\n             outfile=nothing, colorscale=identity, transform=identity,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n             iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n             ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vz.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vz_vr","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vz_vr","text":"plot_vs_vz_vr(run_info::Tuple, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, colorscale=identity,\n              transform=identity, axis_args=Dict{Symbol,Any}(),\n              it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n              ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n              kwargs...)\nplot_vs_vz_vr(run_info, var_name; is=1, data=nothing,\n              input=nothing, ax=nothing,\n              colorbar_place=nothing, title=nothing,\n              outfile=nothing, colorscale=identity, transform=identity,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n              iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n              ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs vr and vz.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vz_vzeta","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vz_vzeta","text":"plot_vs_vz_vzeta(run_info::Tuple, var_name; is=1, data=nothing,\n                 input=nothing, outfile=nothing, colorscale=identity,\n                 transform=identity, axis_args=Dict{Symbol,Any}(),\n                 it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                 ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                 kwargs...)\nplot_vs_vz_vzeta(run_info, var_name; is=1, data=nothing,\n                 input=nothing, ax=nothing,\n                 colorbar_place=nothing, title=nothing,\n                 outfile=nothing, colorscale=identity, transform=identity,\n                 axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                 iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                 ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs vzeta and vz.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vz_z","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vz_z","text":"plot_vs_vz_z(run_info::Tuple, var_name; is=1, data=nothing,\n             input=nothing, outfile=nothing, colorscale=identity,\n             transform=identity, axis_args=Dict{Symbol,Any}(),\n             it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n             ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n             kwargs...)\nplot_vs_vz_z(run_info, var_name; is=1, data=nothing,\n             input=nothing, ax=nothing,\n             colorbar_place=nothing, title=nothing,\n             outfile=nothing, colorscale=identity, transform=identity,\n             axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n             iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n             ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vz.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vzeta","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vzeta","text":"plot_vs_vzeta(run_info::Tuple, var_name; is=1, data=nothing,\n              input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n              ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n              ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_vzeta(run_info, var_name; is=1, data=nothing,\n              input=nothing, ax=nothing, label=nothing,\n              outfile=nothing, yscale=nothing, transform=identity,\n              axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n              iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n              ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs vzeta.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vzeta_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vzeta_r","text":"plot_vs_vzeta_r(run_info::Tuple, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nplot_vs_vzeta_r(run_info, var_name; is=1, data=nothing,\n                input=nothing, ax=nothing,\n                colorbar_place=nothing, title=nothing,\n                outfile=nothing, colorscale=identity, transform=identity,\n                axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and vzeta.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vzeta_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vzeta_t","text":"plot_vs_vzeta_t(run_info::Tuple, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nplot_vs_vzeta_t(run_info, var_name; is=1, data=nothing,\n                input=nothing, ax=nothing,\n                colorbar_place=nothing, title=nothing,\n                outfile=nothing, colorscale=identity, transform=identity,\n                axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and vzeta.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_vzeta_z","page":"makie_post_processing","title":"makie_post_processing.plot_vs_vzeta_z","text":"plot_vs_vzeta_z(run_info::Tuple, var_name; is=1, data=nothing,\n                input=nothing, outfile=nothing, colorscale=identity,\n                transform=identity, axis_args=Dict{Symbol,Any}(),\n                it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n                ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n                kwargs...)\nplot_vs_vzeta_z(run_info, var_name; is=1, data=nothing,\n                input=nothing, ax=nothing,\n                colorbar_place=nothing, title=nothing,\n                outfile=nothing, colorscale=identity, transform=identity,\n                axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n                iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n                ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs z and vzeta.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_z","page":"makie_post_processing","title":"makie_post_processing.plot_vs_z","text":"plot_vs_z(run_info::Tuple, var_name; is=1, data=nothing,\n          input=nothing, outfile=nothing, yscale=nothing,\ntransform=identity, axis_args=Dict{Symbol,Any}(), it=nothing,\n          ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n          ivzeta=nothing, ivr=nothing, ivz=nothing, kwargs...)\nplot_vs_z(run_info, var_name; is=1, data=nothing,\n          input=nothing, ax=nothing, label=nothing,\n          outfile=nothing, yscale=nothing, transform=identity,\n          axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n          iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n          ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info) vs z.\n\nIf a Tuple of run_info is passed, the plots from each run are overlayed on the same axis, and a legend is added.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\nyscale can be used to set the scaling function for the y-axis. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_1d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's lines!() function.\n\nWhen a single run_info is passed, label can be used to set the label for the line created by this plot, which would be used if it is added to a Legend.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's lines!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_z_r","page":"makie_post_processing","title":"makie_post_processing.plot_vs_z_r","text":"plot_vs_z_r(run_info::Tuple, var_name; is=1, data=nothing,\n            input=nothing, outfile=nothing, colorscale=identity,\n            transform=identity, axis_args=Dict{Symbol,Any}(),\n            it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n            ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n            kwargs...)\nplot_vs_z_r(run_info, var_name; is=1, data=nothing,\n            input=nothing, ax=nothing,\n            colorbar_place=nothing, title=nothing,\n            outfile=nothing, colorscale=identity, transform=identity,\n            axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n            iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n            ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs r and z.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plot_vs_z_t","page":"makie_post_processing","title":"makie_post_processing.plot_vs_z_t","text":"plot_vs_z_t(run_info::Tuple, var_name; is=1, data=nothing,\n            input=nothing, outfile=nothing, colorscale=identity,\n            transform=identity, axis_args=Dict{Symbol,Any}(),\n            it=nothing, ir=nothing, iz=nothing, ivperp=nothing,\n            ivpa=nothing, ivzeta=nothing, ivr=nothing, ivz=nothing,\n            kwargs...)\nplot_vs_z_t(run_info, var_name; is=1, data=nothing,\n            input=nothing, ax=nothing,\n            colorbar_place=nothing, title=nothing,\n            outfile=nothing, colorscale=identity, transform=identity,\n            axis_args=Dict{Symbol,Any}(), it=nothing, ir=nothing,\n            iz=nothing, ivperp=nothing, ivpa=nothing, ivzeta=nothing,\n            ivr=nothing, ivz=nothing, kwargs...)\n\nPlot var_name from the run(s) represented by run_info (as returned by get_run_info)vs t and z.\n\nIf a Tuple of run_info is passed, the plots from each run are displayed in a horizontal row, and the subtitle for each subplot is the 'run name'.\n\nit, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be used to select different indices (for non-plotted dimensions) or range (for the plotted dimension) to use.\n\nIf outfile is given, the plot will be saved to a file with that name. The suffix determines the file type.\n\ncolorscale can be used to set the scaling function for the colors. Options are identity, log, log2, log10, sqrt, Makie.logit, Makie.pseudolog10 and Makie.Symlog10. transform is a function that is applied element-by-element to the data before it is plotted. For example when using a log scale on data that may contain some negative values it might be useful to pass transform=abs (to plot the absolute value) or transform=positive_or_nan (to ignore any negative or zero values).\n\naxis_args are passed as keyword arguments to get_2d_ax(), and from there to the Axis constructor.\n\nExtra kwargs are passed to Makie's heatmap!() function.\n\nWhen a single run_info is passed, title can be used to set the title for the (sub-)plot.\n\nWhen a single run_info is passed, an Axis can be passed to ax. If it is, the plot will be added to ax. A colorbar will be created in colorbar_place if it is given a GridPosition.\n\nBy default the data for the variable is loaded from the output represented by run_info. The data can optionally be passed to data if you have already loaded it.\n\nReturns the Figure, unless ax was passed in which case the object returned by Makie's heatmap!() function is returned.\n\nBy default relevant settings are read from the var_name section of input_dict_dfns (if output that has distribution functions is being read) or input_dict (otherwise). The settings can also be passed as an AbstractDict or NamedTuple via the input argument.  Sometimes needed, for example if var_name is not present in input_dict (in which case you would have had to create the array to be plotted and pass it to data).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.plots_for_dfn_variable-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.plots_for_dfn_variable","text":"plots_for_dfn_variable(run_info, variable_name; plot_prefix, has_rdim=true,\n                       has_zdim=true, is_1V=false)\n\nMake plots for the distribution function variable variable_name.\n\nWhich plots to make are determined by the settings in the section of the input whose heading is the variable name.\n\nrun_info is the information returned by get_run_info(). The dfns=true keyword argument must have been passed to get_run_info() so that output files containing the distribution functions are being read.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nhas_rdim, has_zdim and/or is_1V can be passed to allow the function to skip some plots that do not make sense for 0D/1D or 1V simulations (regardless of the settings).\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.plots_for_variable-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.plots_for_variable","text":"plots_for_variable(run_info, variable_name; plot_prefix, has_rdim=true,\n                   has_zdim=true, is_1V=false,\n                   steady_state_residual_fig_axes=nothing)\n\nMake plots for the EM field or moment variable variable_name.\n\nWhich plots to make are determined by the settings in the section of the input whose heading is the variable name.\n\nrun_info is the information returned by get_run_info.\n\nplot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf for plots and plot_prefix<some_identifying_string>.gif, etc. for animations.\n\nhas_rdim, has_zdim and/or is_1V can be passed to allow the function to skip some plots that do not make sense for 0D/1D or 1V simulations (regardless of the settings).\n\nsteady_state_residual_fig_axes contains the figure, axes and legend places for steady state residual plots.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.positive_or_nan-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.positive_or_nan","text":"positive_or_nan(x; epsilon=0)\n\nIf the argument x is zero or negative, replace it with NaN, otherwise return x.\n\nepsilon can be passed if the number should be forced to be above some value (typically we would assume epsilon is small and positive, but nothing about this function forces it to be).\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.println_to_stdout_and_file-Tuple{Any, Vararg{Any}}","page":"makie_post_processing","title":"makie_post_processing.println_to_stdout_and_file","text":"println_to_stdout_and_file(io, stuff...)\n\nPrint stuff both to stdout and to a file io.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.put_legend_above-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.put_legend_above","text":"putlegendabove(fig, ax; kwargs...)\n\nAdd a legend corresponding to the plot in ax to fig on the left of a new row at the top of the figure layout.\n\nAdditional kwargs are passed to the Legend() constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.put_legend_below-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.put_legend_below","text":"putlegendbelow(fig, ax; kwargs...)\n\nAdd a legend corresponding to the plot in ax to fig on the left of a new row at the bottom of the figure layout.\n\nAdditional kwargs are passed to the Legend() constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.put_legend_left-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.put_legend_left","text":"putlegendleft(fig, ax; kwargs...)\n\nAdd a legend corresponding to the plot in ax to fig on the bottom of a new column at the left of the figure layout.\n\nAdditional kwargs are passed to the Legend() constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.put_legend_right-Tuple{Any, Any}","page":"makie_post_processing","title":"makie_post_processing.put_legend_right","text":"putlegendright(fig, ax; kwargs...)\n\nAdd a legend corresponding to the plot in ax to fig on the bottom of a new column at the right of the figure layout.\n\nAdditional kwargs are passed to the Legend() constructor.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.save_animation-NTuple{4, Any}","page":"makie_post_processing","title":"makie_post_processing.save_animation","text":"save_animation(fig, frame_index, nt, outfile)\n\nAnimate fig and save the result in outfile.\n\nframe_index is the Observable{mk_int} that updates the data used to make fig to a new time point. nt is the total number of time points to create.\n\nThe suffix of outfile determines the file type.\n\n\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.select_slice","page":"makie_post_processing","title":"makie_post_processing.select_slice","text":"select_slice(variable::AbstractArray, dims::Symbol...; input=nothing, it=nothing,\n             is=1, ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n             ivzeta=nothing, ivr=nothing, ivz=nothing)\n\nReturns a slice of variable that includes only the dimensions given in dims..., e.g.\n\nselect_slice(variable, :t, :r)\n\nto get a two dimensional slice with t- and r-dimensions.\n\nAny other dimensions present in variable have a single point selected. By default this point is set by the options in input (which must be a NamedTuple) (or the final point for time or the size of the dimension divided by 3 if input is not given). These defaults can be overridden using the keyword arguments it, is, ir, iz, ivperp, ivpa, ivzeta, ivr, ivz. Ranges can also be passed to these keyword arguments for the 'kept dimensions' in dims to select a subset of those dimensions.\n\nThis function only recognises what the dimensions of variable are by the number of dimensions in the array. It assumes that either the variable has already been sliced to the correct dimensions (if ndims(variable) == length(dims) it just returns variable) or that variable has the full number of dimensions it could have (i.e. 'field' variables have 3 dimensions, 'moment' variables 4, 'ion distribution function' variables 6 and 'neutral distribution function' variables 7).\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.setup_makie_post_processing_input!","page":"makie_post_processing","title":"makie_post_processing.setup_makie_post_processing_input!","text":"setup_makie_post_processing_input!(input_file::Union{AbstractString,Nothing}=nothing;\n                                   run_info_moments=nothing, run_info_dfns=nothing,\n                                   allow_missing_input_file=false)\nsetup_makie_post_processing_input!(new_input_dict::AbstractDict{String,Any};\n                                   run_info_moments=nothing,\n                                   run_info_dfns=nothing)\n\nPass input_file to read the input from an input file other than post_processing_input.toml. You can also pass a Dict{String,Any} of options.\n\nSet up input, storing in the global input_dict and input_dict_dfns to be used in the various plotting and analysis functions.\n\nThe run_info that you are using (as returned by get_run_info) should be passed to run_info_moments (if it contains only the moments), or run_info_dfns (if it also contains the distributions functions), or both (if you have loaded both sets of output).  This allows default values to be set based on the grid sizes and number of time points read from the output files. Note that setup_makie_post_processing_input!() is called by default at the end of get_run_info(), for conveinence in interactive use.\n\nBy default an error is raised if input_file does not exist. To continue anyway, using default options, pass allow_missing_input_file=true.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.sound_wave_plots","page":"makie_post_processing","title":"makie_post_processing.sound_wave_plots","text":"sound_wave_plots(run_info::Tuple; plot_prefix)\nsound_wave_plots(run_info; outfile=nothing, ax=nothing, phi=nothing)\n\nCalculate decay rate and frequency for the damped 'sound wave' in a 1D1V simulation in a periodic box. Plot the mode amplitude vs. time along with the fitted decay rate.\n\nThe information for the runs to analyse and plot is passed in run_info (as returned by get_run_info). If run_info is a Tuple, comparison plots are made where line plots from the different runs are overlayed on the same axis.\n\nSettings are read from the [sound_wave] section of the input.\n\nWhen run_info is a Tuple, plot_prefix is required and gives the path and prefix for plots to be saved to. They will be saved with the format plot_prefix<some_identifying_string>.pdf. When run_info is not a Tuple, outfile can be passed, to save the plot to outfile.\n\nWhen run_info is not a Tuple, ax can be passed to add the plot to an existing Axis.\n\nWhen run_info is not a Tuple, the array containing data for phi can be passed to phi - by default this data is loaded from the output file.\n\n\n\n\n\n","category":"function"},{"location":"zz_makie_post_processing/#makie_post_processing.shared_utils.calculate_and_write_frequencies-NTuple{9, Any}","page":"makie_post_processing","title":"makie_post_processing.shared_utils.calculate_and_write_frequencies","text":"\n\n\n\n","category":"method"},{"location":"zz_makie_post_processing/#makie_post_processing.shared_utils.get_composition-Tuple{Any}","page":"makie_post_processing","title":"makie_post_processing.shared_utils.get_composition","text":"\n\n\n\n","category":"method"},{"location":"zz_z_advection/#z_advection","page":"z_advection","title":"z_advection","text":"","category":"section"},{"location":"zz_z_advection/","page":"z_advection","title":"z_advection","text":"Modules = [moment_kinetics.z_advection]","category":"page"},{"location":"zz_z_advection/#moment_kinetics.z_advection","page":"z_advection","title":"moment_kinetics.z_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_z_advection/#moment_kinetics.z_advection.adjust_advection_speed!-NTuple{5, Any}","page":"z_advection","title":"moment_kinetics.z_advection.adjust_advection_speed!","text":"\n\n\n\n","category":"method"},{"location":"zz_z_advection/#moment_kinetics.z_advection.unnormalize_pdf!-NTuple{6, Any}","page":"z_advection","title":"moment_kinetics.z_advection.unnormalize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"zz_z_advection/#moment_kinetics.z_advection.update_speed_z!-NTuple{12, Any}","page":"z_advection","title":"moment_kinetics.z_advection.update_speed_z!","text":"calculate the advection speed in the z-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_z_advection/#moment_kinetics.z_advection.z_advection!-NTuple{15, Any}","page":"z_advection","title":"moment_kinetics.z_advection.z_advection!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"zz_derivatives/#derivatives","page":"derivatives","title":"derivatives","text":"","category":"section"},{"location":"zz_derivatives/","page":"derivatives","title":"derivatives","text":"Modules = [moment_kinetics.derivatives]","category":"page"},{"location":"zz_derivatives/#moment_kinetics.derivatives","page":"derivatives","title":"moment_kinetics.derivatives","text":"This module contains all the necessary derivatives needed to carry out distributed memory differential operations on the arrays in moment kinetics. We provide separate derivative functions for each (i) distributed dimension and (ii) array shape. We do not need to provide derivatives for non-distributed dimensions as these can by handled by the derivative! function from calculus.jl\n\n\n\n\n\n","category":"module"},{"location":"zz_calculus/#calculus","page":"calculus","title":"calculus","text":"","category":"section"},{"location":"zz_calculus/","page":"calculus","title":"calculus","text":"Modules = [moment_kinetics.calculus]","category":"page"},{"location":"zz_calculus/#moment_kinetics.calculus","page":"calculus","title":"moment_kinetics.calculus","text":"\n\n\n\n","category":"module"},{"location":"zz_calculus/#moment_kinetics.calculus.derivative!-NTuple{4, Any}","page":"calculus","title":"moment_kinetics.calculus.derivative!","text":"derivative!(df, f, coord, spectral)\n\nNon-upwinding derivative.\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.derivative!-Tuple{Any, Any, Any, Any, moment_kinetics.moment_kinetics_structs.discretization_info}","page":"calculus","title":"moment_kinetics.calculus.derivative!","text":"derivative!(df, f, coord, adv_fac, spectral)\n\nUpwinding derivative.\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.derivative_elements_to_full_grid!-Tuple{Any, Any, Any, AbstractVector{Float64}}","page":"calculus","title":"moment_kinetics.calculus.derivative_elements_to_full_grid!","text":"\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.derivative_elements_to_full_grid!-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.derivative_elements_to_full_grid!","text":"\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.elements_to_full_grid_interior_pts!-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.elements_to_full_grid_interior_pts!","text":"maps the derivative at points away from element boundaries from the grid/element representation to the full grid representation\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.elementwise_apply_Kmat!","page":"calculus","title":"moment_kinetics.calculus.elementwise_apply_Kmat!","text":"Apply 'K-matrix' as part of a weak-form second derivative\n\n\n\n\n\n","category":"function"},{"location":"zz_calculus/#moment_kinetics.calculus.elementwise_apply_Lmat!","page":"calculus","title":"moment_kinetics.calculus.elementwise_apply_Lmat!","text":"Apply 'L-matrix' as part of a weak-form Laplacian derivative\n\n\n\n\n\n","category":"function"},{"location":"zz_calculus/#moment_kinetics.calculus.elementwise_derivative!","page":"calculus","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, adv_fac, spectral)\nelementwise_derivative!(coord, f, spectral)\n\nGeneric function for element-by-element derivatives\n\nFirst signature, with adv_fac, calculates an upwind derivative, the second signature calculates a derivative without upwinding information.\n\nResult is stored in coord.scratch_2d.\n\n\n\n\n\n","category":"function"},{"location":"zz_calculus/#moment_kinetics.calculus.elementwise_second_derivative!","page":"calculus","title":"moment_kinetics.calculus.elementwise_second_derivative!","text":"elementwise_second_derivative!(coord, f, spectral)\n\nGeneric function for element-by-element second derivatives.\n\nNote: no upwinding versions of second deriatives.\n\nResult is stored in coord.scratch_2d.\n\n\n\n\n\n","category":"function"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-NTuple{10, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the 3D integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-NTuple{4, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand multiplied by v^n, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-NTuple{7, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the 2D integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-Tuple{Any, Any, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand multiplied by v, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.integral-Tuple{Any, Any}","page":"calculus","title":"moment_kinetics.calculus.integral","text":"Computes the integral of the integrand, using the input wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_calculus/#moment_kinetics.calculus.mass_matrix_solve!","page":"calculus","title":"moment_kinetics.calculus.mass_matrix_solve!","text":"mass_matrix_solve!(f, b, spectral::weak_discretization_info)\n\nSolve\n\nMf = b\n\nfor a, where M is the mass matrix of a weak-form finite element method and b is an input.\n\n\n\n\n\n","category":"function"},{"location":"zz_calculus/#moment_kinetics.calculus.reconcile_element_boundaries_upwind!-Tuple{Any, Any, Any, AbstractVector{Float64}}","page":"calculus","title":"moment_kinetics.calculus.reconcile_element_boundaries_upwind!","text":"if at the boundary point within the element, must carefully choose which value of df to use; this is because df is multi-valued at the overlapping point at the boundary between neighboring elements. here we choose to use the value of df from the upwind element.\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#numerical_dissipation","page":"numerical_dissipation","title":"numerical_dissipation","text":"","category":"section"},{"location":"zz_numerical_dissipation/","page":"numerical_dissipation","title":"numerical_dissipation","text":"Modules = [moment_kinetics.numerical_dissipation]","category":"page"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation","text":"\n\n\n\n","category":"module"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.force_minimum_pdf_value!-Tuple{Any, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.force_minimum_pdf_value!","text":"force_minimum_pdf_value!(f, minval)\n\nSet a minimum value for the pdf-sized array f. Any points less than the minimum are set to the minimum. By default, no minimum is applied. The minimum value can be set by\n\n[ion_numerical_dissipation]\nforce_minimum_pdf_value = 0.0\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.force_minimum_pdf_value_neutral!-Tuple{Any, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.force_minimum_pdf_value_neutral!","text":"force_minimum_pdf_value_neutral!(f, minval)\n\nSet a minimum value for the neutral-pdf-sized array f. Any points less than the minimum are set to the minimum. By default, no minimum is applied. The minimum value can be set by\n\n[neutral_numerical_dissipation]\nforce_minimum_pdf_value = 0.0\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.r_dissipation!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, Any, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.r_dissipation!","text":"Add diffusion in the r direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[ion_numerical_dissipation]\nr_dissipation_coefficient = 0.1\n\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.r_dissipation_neutral!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, Any, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.r_dissipation_neutral!","text":"Add diffusion in the r direction to suppress oscillations for neutrals\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[neutral_numerical_dissipation]\nr_dissipation_coefficient = 0.1\n\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_boundary_buffer_decay!-NTuple{6, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_boundary_buffer_decay!","text":"Suppress the distribution function by damping towards a Maxwellian in the last element before the vpa boundaries, to avoid numerical instabilities there.\n\nDisabled by default.\n\nThe damping rate is set in the input TOML file by the parameter\n\n[ion_numerical_dissipation]\nvpa_boundary_buffer_damping_rate = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_boundary_buffer_diffusion!-NTuple{6, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_boundary_buffer_diffusion!","text":"Suppress the distribution function by applying diffusion in the last element before the vpa boundaries, to avoid numerical instabilities there.\n\nDisabled by default.\n\nThe maximum diffusion rate in the buffer is set in the input TOML file by the parameter\n\n[ion_numerical_dissipation]\nvpa_boundary_buffer_diffusion_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_boundary_force_decreasing!-Tuple{Any, Any}","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_boundary_force_decreasing!","text":"Try to suppress oscillations near the boundary by ensuring that every point in the final element is ≤ the innermost value. The distribution function should be decreasing near the boundaries, so this should be an OK thing to force.\n\nNote: not currently used.\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vpa_dissipation!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vpa_dissipation!","text":"Add diffusion in the vpa direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[ion_numerical_dissipation]\nvpa_dissipation_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vperp_dissipation!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vperp_dissipation!","text":"Add diffusion in the vperp direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[ion_numerical_dissipation]\nvperp_dissipation_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.vz_dissipation_neutral!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.vz_dissipation_neutral!","text":"Add diffusion in the vz direction to suppress oscillations for neutrals\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[neutral_numerical_dissipation]\nvz_dissipation_coefficient = 0.1\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.z_dissipation!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, Any, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.z_dissipation!","text":"Add diffusion in the z direction to suppress oscillations\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[ion_numerical_dissipation]\nz_dissipation_coefficient = 0.1\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"zz_numerical_dissipation/#moment_kinetics.numerical_dissipation.z_dissipation_neutral!-Union{Tuple{T_spectral}, Tuple{Any, Any, Any, T_spectral, Any, Any, Any}} where T_spectral","page":"numerical_dissipation","title":"moment_kinetics.numerical_dissipation.z_dissipation_neutral!","text":"Add diffusion in the z direction to suppress oscillations for neutrals\n\nDisabled by default.\n\nThe diffusion coefficient is set in the input TOML file by the parameter\n\n[neutral_numerical_dissipation]\nz_dissipation_coefficient = 0.1\n\nNote that the current distributed-memory compatible implementation does not impose a penalisation term on internal or external element boundaries\n\n\n\n\n\n","category":"method"},{"location":"input_options/#Input-Options","page":"Input Options","title":"Input Options","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"This page describes the input options that can be specified in .toml input files.  The input variable name is given first, followed by its default value and a brief description.","category":"page"},{"location":"input_options/#File-I/O","page":"Input Options","title":"File I/O","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"Option name Default value Description\nrun_name  prefix for all output files associated with this run, defaults to the name of the input .toml file\nbase_directory \"runs\" directory where the simulation data will be stored","category":"page"},{"location":"input_options/#Model-Options","page":"Input Options","title":"Model Options","text":"","category":"section"},{"location":"input_options/#Special-cases","page":"Input Options","title":"Special cases","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"Some options apply only for certain types of run, etc. These special cases are described in the following subsections.","category":"page"},{"location":"input_options/#Steady-state-runs","page":"Input Options","title":"Steady state runs","text":"","category":"section"},{"location":"input_options/","page":"Input Options","title":"Input Options","text":"Option name Default value Description\nsteady_state_residual false Set to true to print out the maximum residual r(t) = fracleft n(t)-n(t-delta t)right delta t of the density for each species at each output step\nconverged_residual_value -1.0 If steady_state_residual = true and converged_residual_value is set to a positive value, then the simulation will be stopped if all the density residuals are less than converged_residual_value. Note the residuals are only calculated and checked at time steps where output for moment variables is written.","category":"page"},{"location":"zz_gauss_legendre/#gauss_legendre","page":"gauss_legendre","title":"gauss_legendre","text":"","category":"section"},{"location":"zz_gauss_legendre/","page":"gauss_legendre","title":"gauss_legendre","text":"Modules = [moment_kinetics.gauss_legendre]","category":"page"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre","text":"module for Gauss-Legendre-Lobatto and Gauss-Legendre-Radau spectral element grids\n\n\n\n\n\n","category":"module"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.gausslegendre_base_info","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.gausslegendre_base_info","text":"structs for passing around matrices for taking the derivatives on Gauss-Legendre points in 1D\n\n\n\n\n\n","category":"type"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.GaussLegendre_derivative_vector!-NTuple{5, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.GaussLegendre_derivative_vector!","text":"Gauss-Legendre derivative at arbitrary x values, for boundary condition on radau points D0 – the vector xj – the x location where the derivative is evaluated  ngrid – number of points in x x – the grid from -1, 1 Note that D0 is not scaled to the physical grid\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.GaussLegendre_weak_product_matrix!-Tuple{Array{Float64, 3}, Vararg{Any, 4}}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.GaussLegendre_weak_product_matrix!","text":"assign abitrary weak inner product matrix Q on a 1D line with Jacobian = 1 matrix Q acts on two vectors x1 and x2 such that the quadratic form  y = x1 * Q * x2 is also a vector\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.GaussLegendre_weak_product_matrix!-Tuple{Matrix{Float64}, Vararg{Any, 4}}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.GaussLegendre_weak_product_matrix!","text":"assign abitrary weak inner product matrix Q on a 1D line with Jacobian = 1 matrix Q acts on a single vector x such that y = Q * x is also a vector\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.Legendre_h_n-Tuple{Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.Legendre_h_n","text":"result of the inner product of Legendre polys of order k\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.gausslobattolegendre_differentiation_matrix!-Tuple{Matrix{Float64}, Vector{Float64}, Int64}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.gausslobattolegendre_differentiation_matrix!","text":"Formula for differentiation matrix taken from p196 of Chpt The Spectral Elemtent Method' ofComputational Seismology'. Heiner Igel First Edition. Published in 2017 by Oxford University Press. Or https://doc.nektar.info/tutorials/latest/fundamentals/differentiation/fundamentals-differentiationch2.html\n\nD – differentiation matrix  x – Gauss-Legendre-Lobatto points in [-1,1] ngrid – number of points per element (incl. boundary points)\n\nNote that D has does not include a scaling factor\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.gaussradaulegendre_differentiation_matrix!-Tuple{Matrix{Float64}, Vector{Float64}, Int64}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.gaussradaulegendre_differentiation_matrix!","text":"From  https://doc.nektar.info/tutorials/latest/fundamentals/differentiation/fundamentals-differentiationch2.html\n\nD – differentiation matrix  x – Gauss-Legendre-Radau points in [-1,1) ngrid – number of points per element (incl. boundary points)\n\nNote that D has does not include a scaling factor\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.scaled_gauss_legendre_lobatto_grid-NTuple{7, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.scaled_gauss_legendre_lobatto_grid","text":"function for setting up the full Gauss-Legendre-Lobatto grid and collocation point weights\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.scaled_gauss_legendre_radau_grid-NTuple{8, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.scaled_gauss_legendre_radau_grid","text":"function for setting up the full Gauss-Legendre-Radau grid and collocation point weights see comments of Gauss-Legendre-Lobatto routine above\n\n\n\n\n\n","category":"method"},{"location":"zz_gauss_legendre/#moment_kinetics.gauss_legendre.setup_global_weak_form_matrix!-Tuple{Matrix{Float64}, moment_kinetics.gauss_legendre.gausslegendre_base_info, moment_kinetics.gauss_legendre.gausslegendre_base_info, Any, Any}","page":"gauss_legendre","title":"moment_kinetics.gauss_legendre.setup_global_weak_form_matrix!","text":"A function that assigns the local weak-form matrices to  a global array QQglobal for later solving weak form of required 1D equation. This function only supports fully local grids  that have coord.nelementlocal = coord.nelement_global.\n\nThe 'option' variable is a flag for  choosing the type of matrix to be constructed.  Currently the function is set up to assemble the  elemental matrices without imposing boundary conditions on the  first and final rows of the matrix. This means that  the operators constructed from this function can only be used for differentiation, and not solving 1D ODEs.  The shared points in the element assembly are  averaged (instead of simply added) to be consistent with the  derivativeelementstofullgrid!() function in calculus.jl, which is used to form the RHS of the equation\n\nM * d2f = K * f \n\nwhere M is the mass matrix and K is the stiffness matrix. \n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#fokker_planck_calculus","page":"fokker_planck_calculus","title":"fokker_planck_calculus","text":"","category":"section"},{"location":"zz_fokker_planck_calculus/","page":"fokker_planck_calculus","title":"fokker_planck_calculus","text":"Modules = [moment_kinetics.fokker_planck_calculus]","category":"page"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus","text":"module for functions used  in calculating the integrals and doing  the numerical differentiation for  the implementation of the  the Full-F Fokker-Planck Collision Operator\n\n\n\n\n\n","category":"module"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.boundary_integration_weights_struct","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.boundary_integration_weights_struct","text":"a struct to contain the integration weights for the boundary points in the (vpa,vperp) domain\n\n\n\n\n\n","category":"type"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.fokkerplanck_boundary_data_arrays_struct","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.fokkerplanck_boundary_data_arrays_struct","text":"a struct used for calculating the integration weights for the  boundary of the velocity space domain in (vpa,vperp) coordinates\n\n\n\n\n\n","category":"type"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.fokkerplanck_weakform_arrays_struct","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.fokkerplanck_weakform_arrays_struct","text":"a struct of dummy arrays and precalculated coefficients for the weak-form Fokker-Planck collision operator \n\n\n\n\n\n","category":"type"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_integrals!-NTuple{20, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.calculate_rosenbluth_integrals!","text":"Function to carry out the integration of the revelant distribution functions to form the required coefficients for the full-F operator. We assume that the weights are precalculated. The function takes as arguments the arrays of coefficients (which we fill), the required distributions, the precomputed weights, the indicies of the `field' velocities, and the sizes of the primed vpa and vperp coordinates arrays.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.enforce_vpavperp_BCs!-NTuple{5, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.enforce_vpavperp_BCs!","text":"function to enforce boundary conditions on the collision operator result to be consistent with the boundary conditions imposed on the the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.get_element_limit_indices-NTuple{4, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.get_element_limit_indices","text":"function for getting the indices used to choose the integration quadrature \n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.get_global_compound_index-NTuple{6, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.get_global_compound_index","text":"get_global_compound_index(vpa,vperp,ielement_vpa,ielement_vperp,ivpa_local,ivperp_local)\n\nFor local (within the single element specified by ielement_vpa and ielement_vperp) indices ivpa_local and ivperp_local, get the global index in the 'linear-indexed' 2d space of size (vperp.n, vpa.n) (as returned by ic_func).\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.ic_func-Tuple{Int64, Int64, Int64}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.ic_func","text":"ic_func(ivpa::mk_int,ivperp::mk_int,nvpa::mk_int)\n\nGet the 'linear index' corresponding to ivpa and ivperp. Defined so that the linear index corresponds to the underlying layout in memory of a 2d array indexed by [ivpa,ivperp], i.e. for a 2d array f2d:\n\nsize(f2d) == (vpa.n, vperp.n)\nFor a reference to f2d that is reshaped to a vector (a 1d array) f1d = vec(f2d) than for any ivpa and ivperp it is true that f1d[ic_func(ivpa,ivperp)] == f2d[ivpa,ivperp].\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.init_Rosenbluth_potential_boundary_integration_weights!-NTuple{8, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.init_Rosenbluth_potential_boundary_integration_weights!","text":"function that precomputes the required integration weights only along the velocity space boundaries\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.init_Rosenbluth_potential_integration_weights!-NTuple{8, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.init_Rosenbluth_potential_integration_weights!","text":"function that precomputes the required integration weights\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.ivpa_func-Tuple{Int64, Int64}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.ivpa_func","text":"ivpa_func(ic::mk_int,nvpa::mk_int)\n\nGet the vpa index ivpa that corresponds to a 'linear index' ic that spans a 2d velocity space.\n\nDefined so that ivpa_func(inc_func(ivpa,ivperp,nvpa), nvpa) == ivpa.\n\nSee also ic_func, ivperp_func.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.ivperp_func-Tuple{Int64, Int64}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.ivperp_func","text":"ivperp_func(ic::mk_int,nvpa::mk_int)\n\nGet the vperp index ivperp that corresponds to a 'linear index' ic that spans a 2d velocity space.\n\nDefined so that ivperp_func(inc_func(ivpa,ivperp,nvpa), nvpa) == ivperp.\n\nSee also ic_func, ivpa_func.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.lagrange_poly-Tuple{Any, Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.lagrange_poly","text":"Lagrange polynomial args:  j - index of lj from list of nodes xnodes - array of x node values x - point where interpolated value is returned\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_calculus/#moment_kinetics.fokker_planck_calculus.setup_basic_quadratures-Tuple{Any, Any}","page":"fokker_planck_calculus","title":"moment_kinetics.fokker_planck_calculus.setup_basic_quadratures","text":"function for getting the basic quadratures used for the  numerical integration of the Lagrange polynomials and the  Green's function.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#load_data","page":"load_data","title":"load_data","text":"","category":"section"},{"location":"zz_load_data/","page":"load_data","title":"load_data","text":"Modules = [moment_kinetics.load_data]","category":"page"},{"location":"zz_load_data/#moment_kinetics.load_data","page":"load_data","title":"moment_kinetics.load_data","text":"\n\n\n\n","category":"module"},{"location":"zz_load_data/#moment_kinetics.load_data.close_run_info-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.close_run_info","text":"close_run_info(run_info)\n\nClose all the files in a run_info NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.construct_global_zr_coords-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.construct_global_zr_coords","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.get_run_info_no_setup-Tuple{Vararg{Union{AbstractString, Tuple{AbstractString, Union{Nothing, Int64}}}}}","page":"load_data","title":"moment_kinetics.load_data.get_run_info_no_setup","text":"get_run_info_no_setup(run_dir...; itime_min=1, itime_max=0, itime_skip=1, dfns=false,\n                      initial_electron=false)\nget_run_info_no_setup((run_dir, restart_index)...; itime_min=1, itime_max=0,\n                      itime_skip=1, dfns=false, initial_electron=false)\n\nGet file handles and other info for a single run\n\nrun_dir is the directory to read output from.\n\nrestart_index can be given by passing a Tuple, e.g. (\"runs/example\", 42) as the positional argument. It specifies which restart to read if there are multiple restarts. If no restart_index is given or if nothing is passed, read all restarts and concatenate them. An integer value reads the restart with that index - -1 indicates the latest restart (which does not have an index).\n\nSeveral runs can be loaded at the same time by passing multiple positional arguments. Each argument can be a String run_dir giving a directory to read output from or a Tuple (run_dir, restart_index) giving both a directory and a restart index (it is allowed to mix Strings and Tuples in a call).\n\nBy default load data from moments files, pass dfns=true to load from distribution functions files, or initial_electron=true and dfns=true to load from initial electron state files.\n\nThe itime_min, itime_max and itime_skip options can be used to select only a slice of time points when loading data. In makie_post_process these options are read from the input (if they are set) before get_run_info_no_setup() is called, so that the run_info returned can be passed to makie_post_processing.setup_makie_post_processing_input!(), to be used for defaults for the remaining options. If either itime_min or itime_max are ≤0, their values are used as offsets from the final time index of the run.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.get_variable","page":"load_data","title":"moment_kinetics.load_data.get_variable","text":"get_variable(run_info::Tuple, variable_name; kwargs...)\nget_variable(run_info, variable_name; kwargs...)\n\nGet an array (or Tuple of arrays, if run_info is a Tuple) of the data for variable_name from run_info.\n\nSome derived variables need to be calculated from the saved output, not just loaded from file (with postproc_load_variable). This function takes care of that calculation, and handles the case where run_info is a Tuple (which postproc_load_data does not handle).\n\nkwargs... are passed through to postproc_load_variable().\n\n\n\n\n\n","category":"function"},{"location":"zz_load_data/#moment_kinetics.load_data.load_block_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_block_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_coordinate_data-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.load_coordinate_data","text":"load_coordinate_data(fid, name; printout=false, irank=nothing, nrank=nothing)\n\nLoad data for the coordinate name from a file-handle fid.\n\nReturns (coord, spectral, chunk_size). coord is a coordinate object. spectral is the object used to implement the discretization in this coordinate. chunk_size is the size of chunks in this coordinate that was used when writing to the output file.\n\nIf printout is set to true a message will be printed when this function is called.\n\nIf irank and nrank are passed, then the coord and spectral objects returned will be set up for the parallelisation specified by irank and nrank, rather than the one implied by the output file.\n\nIf ignore_MPI=true is passed, the returned coordinates will be created without shared memory scratch arrays (ignore_MPI=true will be passed through to define_coordinate).\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_distributed_electron_pdf_slice-Tuple{Tuple, Tuple, Any, Int64, Vararg{moment_kinetics.coordinates.coordinate, 4}}","page":"load_data","title":"moment_kinetics.load_data.load_distributed_electron_pdf_slice","text":"Read a slice of an electron distribution function\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\nThe slice to take is specified by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_distributed_ion_pdf_slice-Tuple{Tuple, Tuple, Any, Int64, Vararg{moment_kinetics.coordinates.coordinate, 4}}","page":"load_data","title":"moment_kinetics.load_data.load_distributed_ion_pdf_slice","text":"Read a slice of an ion distribution function\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\nThe slice to take is specified by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_distributed_neutral_pdf_slice-Tuple{Tuple, Tuple, Any, Int64, Vararg{moment_kinetics.coordinates.coordinate, 5}}","page":"load_data","title":"moment_kinetics.load_data.load_distributed_neutral_pdf_slice","text":"Read a slice of a neutral distribution function\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\nThe slice to take is specified by the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_fields_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_fields_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_input-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_input","text":"Load saved input settings\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_ion_moments_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_ion_moments_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_mk_options-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_mk_options","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_neutral_pdf_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_neutral_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_pdf_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_pdf_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_rank_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_rank_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_slice","page":"load_data","title":"moment_kinetics.load_data.load_slice","text":"Load a slice of a single variable from a file\n\n\n\n\n\n","category":"function"},{"location":"zz_load_data/#moment_kinetics.load_data.load_species_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_species_data","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_time_data-Tuple{Any}","page":"load_data","title":"moment_kinetics.load_data.load_time_data","text":"If a tuple is given for fid, concatenate the \"time\" output from each file in the tuple\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.load_variable","page":"load_data","title":"moment_kinetics.load_data.load_variable","text":"Load a single variable from a file\n\n\n\n\n\n","category":"function"},{"location":"zz_load_data/#moment_kinetics.load_data.open_readonly_output_file-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.open_readonly_output_file","text":"\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.postproc_load_variable-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.postproc_load_variable","text":"postproc_load_variable(run_info, variable_name; it=nothing, is=nothing,\n                       ir=nothing, iz=nothing, ivperp=nothing, ivpa=nothing,\n                       ivzeta=nothing, ivr=nothing, ivz=nothing)\n\nLoad a variable\n\nrun_info is the information about a run returned by makie_post_processing.get_run_info().\n\nvariable_name is the name of the variable to load.\n\nThe keyword arguments it, is, ir, iz, ivperp, ivpa, ivzeta, ivr, and ivz can be set to an integer or a range (e.g. 3:8 or 3:2:8) to select subsets of the data. Only the data for the subset requested will be loaded from the output file (mostly - when loading fields or moments from runs which used parallel_io = false, the full array will be loaded and then sliced).\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.read_Dict_from_section-Tuple{Any, Any}","page":"load_data","title":"moment_kinetics.load_data.read_Dict_from_section","text":"read_Dict_from_section(file_or_group, section_name; ignore_subsections=false)\n\nRead information from section_name in file_or_group, returning a Dict.\n\nBy default, any subsections are included as nested Dicts. If ignore_subsections=true they are ignored.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.read_distributed_zr_data!-Union{Tuple{N}, Tuple{Array{Float64, N}, String, Tuple, String, Tuple, Int64, Int64, Int64}} where N","page":"load_data","title":"moment_kinetics.load_data.read_distributed_zr_data!","text":"Read data which is a function of (z,r,t) or (z,r,species,t)\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.reload_electron_data!-NTuple{12, Any}","page":"load_data","title":"moment_kinetics.load_data.reload_electron_data!","text":"Reload electron pdf and moments from an existing output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_load_data/#moment_kinetics.load_data.reload_evolving_fields!-NTuple{14, Any}","page":"load_data","title":"moment_kinetics.load_data.reload_evolving_fields!","text":"Reload pdf and moments from an existing output file.\n\n\n\n\n\n","category":"method"},{"location":"post_processing_notes/#Post-processing","page":"Post processing","title":"Post processing","text":"","category":"section"},{"location":"post_processing_notes/#How-to","page":"Post processing","title":"How to","text":"","category":"section"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"Post processing functionality is provided by the makie_post_processing.makie_post_processing module. To run the post processing, call makie_post_processing.makie_post_process e.g.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> using makie_post_processing\njulia> makie_post_process(\"runs/example-run/\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"or","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> makie_post_process(\"runs/example-run1/\", \"runs/example-run2/\", \"runs/example-run3/\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"What this function does is controlled by the settings in an input file, by default post_processing_input.toml.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"To run from the command line","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia --project run_makie_post_processing.jl dir1 [dir2 [dir3 ...]]","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"If multiple directories are passed, comparison plots will be made. This usually means that for line plots and animations the output for all the runs will be drawn on the same plot. For heatmap plots, the runs will be plotted side by side.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"If there is output from several restarts of the same run in a directory, by default they will all be read and plotted. A single restart can be started by passing the restart_id argument to makie_post_process().","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"To see all the options that can be set, makie_post_processing.generate_example_input_file can be used to create an example file containing all the options with their default values. The options are all commented out when the file is created.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"note: Viewing animations\nAnimations are produced in .gif format. Most utilities just play gifs, but provide no options to pause them, etc. One that provides a few more features is multigifview (developed by @johnomotani).","category":"page"},{"location":"post_processing_notes/#Interactive-use","page":"Post processing","title":"Interactive use","text":"","category":"section"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"The functions in makie_post_processing.makie_post_processing can be used interactively (or in standalone scripts). To do so, first get the 'info' for a run (file names, metadata, etc.) using makie_post_processing.get_run_info","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> using makie_post_processing\njulia> run_info = get_run_info(\"runs/example-run/\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"or to load from the distribution functions output file .dfns.h5","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> run_info_dfns = get_run_info(\"runs/example-run/\"; dfns=true)","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"Settings for post-processing are read from an input file, by default post_processing_input.toml (you can select a different one using the setup_input_file argument to get_run_info()). The relevant settings for interactive use are the default indices (iz0, ivpa0, etc.) that are used to select slices for 1D/2D plots and animations. The settings are read by setup_makie_post_processing!() which is called by default as part of get_run_info(). You might want to call it directly if you load both 'moments' and 'distribution functions' data, to get sensible settings for both at the same time.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"Then you can make 1d or 2d plots, e.g.","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> fig1 = plot_vs_z(run_info, \"phi\")\njulia> fig2 = plot_vs_r_t(run_info, \"density\"; outfile=\"density_vs_r_t.pdf\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"using makie_post_processing.plot_vs_t, etc. for 1d and makie_post_processing.plot_vs_r_t, etc. for 2d plots. The outfile argument can be used to save the plot. You can also change the default values used to select from the other dimensions","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> plot_vs_z(run_info, \"phi\"; outfile=\"phi_vs_z.pdf\", it=42, ir=7)","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"You can make animations in a similar way","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"julia> fig1 = animate_vs_z(run_info, \"phi\"; outfile=\"phi_vs_z.gif\", it=8:12, ir=1)\njulia> fig2 = animate_vs_z_r(run_info, \"density\"; outfile=\"density_vs_z_r.mp4\")","category":"page"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"using makie_post_processing.animate_vs_r, etc. for 1d and makie_post_processing.animate_vs_z_r, etc. for 2d animations. Note that outfile is required for animations.","category":"page"},{"location":"post_processing_notes/#API","page":"Post processing","title":"API","text":"","category":"section"},{"location":"post_processing_notes/","page":"Post processing","title":"Post processing","text":"See makie_post_processing.","category":"page"},{"location":"zz_chebyshev/#chebyshev","page":"chebyshev","title":"chebyshev","text":"","category":"section"},{"location":"zz_chebyshev/","page":"chebyshev","title":"chebyshev","text":"Modules = [moment_kinetics.chebyshev]","category":"page"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev","page":"chebyshev","title":"moment_kinetics.chebyshev","text":"\n\n\n\n","category":"module"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_base_info","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_base_info","text":"Chebyshev pseudospectral discretization\n\n\n\n\n\n","category":"type"},{"location":"zz_chebyshev/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Any, moment_kinetics.chebyshev.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, ff, adv_fac, spectral::chebyshev_info)\n\nChebyshev transform f to get Chebyshev spectral coefficients and use them to calculate f'.\n\nNote: Chebyshev derivative does not make use of upwinding information within each element.\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, moment_kinetics.chebyshev.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, ff, chebyshev::chebyshev_info)\n\nChebyshev transform f to get Chebyshev spectral coefficients and use them to calculate f'.\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.cheb_derivative_matrix_elementwise!-Tuple{Matrix{Float64}, Int64}","page":"chebyshev","title":"moment_kinetics.chebyshev.cheb_derivative_matrix_elementwise!","text":"derivative matrix for Gauss-Lobatto points using the analytical specification from  Chapter 8.2 from Trefethen 1994  https://people.maths.ox.ac.uk/trefethen/8all.pdf full list of Chapters may be obtained here  https://people.maths.ox.ac.uk/trefethen/pdetext.html\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.cheb_derivative_matrix_elementwise_radau_by_FFT!-Tuple{Matrix{Float64}, Vararg{Any, 5}}","page":"chebyshev","title":"moment_kinetics.chebyshev.cheb_derivative_matrix_elementwise_radau_by_FFT!","text":"Derivative matrix for Chebyshev-Radau grid using the FFT. Note that a similar function could be constructed for the  Chebyshev-Lobatto grid, if desired.\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_backward_transform!-NTuple{5, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_backward_transform!","text":"\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_derivative_single_element!-NTuple{7, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_derivative_single_element!","text":"\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_forward_transform!-NTuple{5, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_forward_transform!","text":"takes the real function ff on a Chebyshev grid in z (domain [-1, 1]), which corresponds to the domain [π, 2π] in variable theta = ArcCos(z). interested in functions of form f(z) = sumn cn Tn(z) using Tn(cos(theta)) = cos(ntheta) and z = cos(theta) gives f(z) = sumn cn cos(ntheta) thus a Chebyshev transform is equivalent to a discrete cosine transform doing this directly turns out to be slower than extending the domain from [0, 2pi] and using the fact that f(z) must be even (as cosines are all even) on this extended domain, can do a standard complex-to-complex fft fext is an array used to store f(theta) on the extended grid theta ∈ [0,2π) ff is f(theta) on the grid [π,2π] the Chebyshev coefficients of ff are calculated and stored in chebyf n is the number of grid points on the Chebyshev-Gauss-Lobatto grid transform is the plan for the complex-to-complex, in-place fft\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_interpolate_single_element!-Tuple{Any, Any, Any, Any, Any, Any, moment_kinetics.chebyshev.chebyshev_base_info}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_interpolate_single_element!","text":"\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_radau_backward_transform!-NTuple{5, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_radau_backward_transform!","text":"\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshev_spectral_derivative!-Tuple{Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshev_spectral_derivative!","text":"use Chebyshev basis to compute the first derivative of f\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshevmoments-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshevmoments","text":"compute and return modified Chebyshev moments of the first kind: ∫dx Tᵢ(x) over range [-1,1]\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.chebyshevpoints-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.chebyshevpoints","text":"returns the Chebyshev-Gauss-Lobatto grid points on an n point grid\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.clenshaw_curtis_weights-NTuple{6, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.clenshaw_curtis_weights","text":"returns wgts array containing the integration weights associated with all grid points for Clenshaw-Curtis quadrature\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.scaled_chebyshev_grid-NTuple{7, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.scaled_chebyshev_grid","text":"initialize chebyshev grid scaled to interval [-boxlength/2, boxlength/2] we no longer pass the boxlength to this function, but instead pass precomputed arrays elementscale and element_shift that are needed to compute the grid.\n\nngrid – number of points per element (including boundary points) nelementlocal – number of elements in the local (distributed memory MPI) grid n – total number of points in the local grid (excluding duplicate points) elementscale – the scale factor in the transform from the coordinates                   where the element limits are -1, 1 to the coordinate where                  the limits are Aj = coord.grid[imin[j]-1] and Bj = coord.grid[imax[j]]                  elementscale = 0.5*(Bj - Aj) elementshift – the centre of the element in the extended grid coordinate                  element_shift = 0.5*(Aj + Bj) imin – the array of minimum indices of each element on the extended grid.         By convention, the duplicated points are not included, so for element index j > 1         the lower boundary point is actually imin[j] - 1 imax – the array of maximum indices of each element on the extended grid.\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.setup_chebyshev_pseudospectral-Tuple{Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.setup_chebyshev_pseudospectral","text":"create arrays needed for explicit Chebyshev pseudospectral treatment and create the plans for the forward and backward fast Fourier transforms\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.update_df_chebyshev!-Tuple{Any, Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.update_df_chebyshev!","text":"compute the Chebyshev spectral coefficients of the spatial derivative of f\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.chebyshev.update_fcheby!-Tuple{Any, Any, Any}","page":"chebyshev","title":"moment_kinetics.chebyshev.update_fcheby!","text":"Chebyshev transform f to get Chebyshev spectral coefficients\n\n\n\n\n\n","category":"method"},{"location":"zz_chebyshev/#moment_kinetics.interpolation.interpolate_to_grid_1d!-Tuple{Any, Any, Any, Any, moment_kinetics.chebyshev.chebyshev_info}","page":"chebyshev","title":"moment_kinetics.interpolation.interpolate_to_grid_1d!","text":"Interpolation from a regular grid to a 1d grid with arbitrary spacing\n\nArguments\n\nresult : Array{mkfloat, 1}     Array to be overwritten with the result of the interpolation newgrid : Array{mkfloat, 1}     Grid of points to interpolate coord to f : Array{mkfloat}     Field to be interpolated coord : coordinate     coordinate struct giving the coordinate along which f varies chebyshev : chebyshev_info     struct containing information for Chebyshev transforms\n\nNote that this routine does not support Gauss-Chebyshev-Radau elements\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_constraints/#moment_constraints","page":"moment_constraints","title":"moment_constraints","text":"","category":"section"},{"location":"zz_moment_constraints/","page":"moment_constraints","title":"moment_constraints","text":"Modules = [moment_kinetics.moment_constraints]","category":"page"},{"location":"zz_moment_constraints/#moment_kinetics.moment_constraints","page":"moment_constraints","title":"moment_kinetics.moment_constraints","text":"Functions for enforcing integral constraints on the normalised distribution function. Ensures consistency of evolution split into moments and normalised distribution function.\n\n\n\n\n\n","category":"module"},{"location":"zz_moment_constraints/#moment_kinetics.moment_constraints.hard_force_moment_constraints!-Tuple{Any, Any, Any}","page":"moment_constraints","title":"moment_kinetics.moment_constraints.hard_force_moment_constraints!","text":"hard_force_moment_constraints!(f, moments, vpa)\n\nForce the moment constraints needed for the system being evolved to be applied to f. Not guaranteed to be a small correction, if f does not approximately obey the constraints to start with, but can be useful at initialisation to ensure a consistent initial state, and when applying boundary conditions.\n\nNote this function assumes the input is given at a single spatial position.\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_constraints/#moment_kinetics.moment_constraints.hard_force_moment_constraints_neutral!-Tuple{Any, Any, Any}","page":"moment_constraints","title":"moment_kinetics.moment_constraints.hard_force_moment_constraints_neutral!","text":"hard_force_moment_constraints_neutral!(f, moments, vz)\n\nForce the moment constraints needed for the system being evolved to be applied to f. Not guaranteed to be a small correction, if f does not approximately obey the constraints to start with, but can be useful at initialisation to ensure a consistent initial state, and when applying boundary conditions.\n\nNotes:\n\nthis function assumes the input is given at a single spatial position.\ncurrently only works with '1V' runs, where vz is the only velocity-space dimension\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#source_terms","page":"source_terms","title":"source_terms","text":"","category":"section"},{"location":"zz_source_terms/","page":"source_terms","title":"source_terms","text":"Modules = [moment_kinetics.source_terms]","category":"page"},{"location":"zz_source_terms/#moment_kinetics.source_terms","page":"source_terms","title":"moment_kinetics.source_terms","text":"\n\n\n\n","category":"module"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms!-NTuple{11, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms!","text":"calculate the source terms due to redefinition of the pdf to split off density, flow and/or pressure, and use them to update the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_evolve_density!-NTuple{12, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_density!","text":"\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_evolve_density_neutral!-NTuple{12, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_density_neutral!","text":"\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_collisions!-NTuple{13, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_collisions!","text":"update the evolved pdf to account for the charge exchange and ionization source terms in the kinetic equation arising due to the re-normalization of the pdf as g = f * vth / n\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_collisions_neutral!-NTuple{13, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_collisions_neutral!","text":"update the evolved pdf to account for the charge exchange and ionization source terms in the kinetic equation arising due to the re-normalization of the pdf as g = f * vth / n\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_no_collisions!-NTuple{16, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_no_collisions!","text":"update the evolved pdf to account for the collisionless source terms in the kinetic equation arising due to the re-normalization of the pdf as g = f * vth / n\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_evolve_ppar_no_collisions_neutral!-NTuple{16, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_evolve_ppar_no_collisions_neutral!","text":"update the evolved pdf to account for the collisionless source terms in the kinetic equation arising due to the re-normalization of the pdf as g = f * vth / n\n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_manufactured!-NTuple{13, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_manufactured!","text":"advance the dfn with an arbitrary source function \n\n\n\n\n\n","category":"method"},{"location":"zz_source_terms/#moment_kinetics.source_terms.source_terms_neutral!-NTuple{11, Any}","page":"source_terms","title":"moment_kinetics.source_terms.source_terms_neutral!","text":"calculate the source terms due to redefinition of the pdf to split off density, flow and/or pressure, and use them to update the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_constants/#constants","page":"constants","title":"constants","text":"","category":"section"},{"location":"zz_constants/","page":"constants","title":"constants","text":"Modules = [moment_kinetics.constants]","category":"page"},{"location":"zz_constants/#moment_kinetics.constants","page":"constants","title":"moment_kinetics.constants","text":"Some physical constants\n\n\n\n\n\n","category":"module"},{"location":"zz_force_balance/#force_balance","page":"force_balance","title":"force_balance","text":"","category":"section"},{"location":"zz_force_balance/","page":"force_balance","title":"force_balance","text":"Modules = [moment_kinetics.force_balance]","category":"page"},{"location":"zz_force_balance/#moment_kinetics.force_balance","page":"force_balance","title":"moment_kinetics.force_balance","text":"\n\n\n\n","category":"module"},{"location":"zz_force_balance/#moment_kinetics.force_balance.force_balance!-NTuple{12, Any}","page":"force_balance","title":"moment_kinetics.force_balance.force_balance!","text":"use the force balance equation d(nu)/dt + d(ppar + nuparupar)/dz = -(dens/2)dphi/dz + Rdensi*densn(uparn-upari) to update the parallel particle flux densupar for each species\n\n\n\n\n\n","category":"method"},{"location":"zz_krook_collisions/#krook_collisions","page":"krook_collisions","title":"krook_collisions","text":"","category":"section"},{"location":"zz_krook_collisions/","page":"krook_collisions","title":"krook_collisions","text":"Modules = [moment_kinetics.krook_collisions]","category":"page"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions","page":"krook_collisions","title":"moment_kinetics.krook_collisions","text":"\n\n\n\n","category":"module"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions.electron_krook_collisions!-NTuple{10, Any}","page":"krook_collisions","title":"moment_kinetics.krook_collisions.electron_krook_collisions!","text":"Add Krook collision operator for electrons\n\n\n\n\n\n","category":"method"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions.get_collision_frequency_ee-Tuple{Any, Any, Any}","page":"krook_collisions","title":"moment_kinetics.krook_collisions.get_collision_frequency_ee","text":"get_collision_frequency_ee(collisions, n, vthe)\n\nCalculate the electron-electron collision frequency, depending on the settings/parameters in collisions, for the given density n and electron thermal speed vthe.\n\nn and vthe may be scalars or arrays, but should have shapes that can be broadcasted together.\n\n\n\n\n\n","category":"method"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions.get_collision_frequency_ei-Tuple{Any, Any, Any}","page":"krook_collisions","title":"moment_kinetics.krook_collisions.get_collision_frequency_ei","text":"get_collision_frequency_ei(collisions, n, vthe)\n\nCalculate the electron-electron collision frequency, depending on the settings/parameters in collisions, for the given density n and electron thermal speed vthe.\n\nn and vthe may be scalars or arrays, but should have shapes that can be broadcasted together.\n\n\n\n\n\n","category":"method"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions.get_collision_frequency_ii-Tuple{Any, Any, Any}","page":"krook_collisions","title":"moment_kinetics.krook_collisions.get_collision_frequency_ii","text":"get_collision_frequency_ii(collisions, n, vth)\n\nCalculate the ion-ion collision frequency, depending on the settings/parameters in collisions, for the given density n and thermal speed vth.\n\nn and vth may be scalars or arrays, but should have shapes that can be broadcasted together.\n\n\n\n\n\n","category":"method"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions.krook_collisions!-NTuple{8, Any}","page":"krook_collisions","title":"moment_kinetics.krook_collisions.krook_collisions!","text":"Add collision operator\n\nCurrently Krook collisions\n\n\n\n\n\n","category":"method"},{"location":"zz_krook_collisions/#moment_kinetics.krook_collisions.setup_krook_collisions!-Tuple{Any, Any, Any}","page":"krook_collisions","title":"moment_kinetics.krook_collisions.setup_krook_collisions!","text":"Calculate normalized collision frequency at reference parameters for Coulomb collisions.\n\nCurrently valid only for hydrogenic ions (Z=1)\n\n\n\n\n\n","category":"method"},{"location":"zz_plot_MMS_sequence/#plot_MMS_sequence","page":"plot_MMS_sequence","title":"plot_MMS_sequence","text":"","category":"section"},{"location":"zz_plot_MMS_sequence/","page":"plot_MMS_sequence","title":"plot_MMS_sequence","text":"Modules = [plots_post_processing.plot_MMS_sequence]","category":"page"},{"location":"zz_plot_MMS_sequence/#plots_post_processing.plot_MMS_sequence","page":"plot_MMS_sequence","title":"plots_post_processing.plot_MMS_sequence","text":"\n\n\n\n","category":"module"},{"location":"zz_external_sources/#external_sources","page":"external_sources","title":"external_sources","text":"","category":"section"},{"location":"zz_external_sources/","page":"external_sources","title":"external_sources","text":"Modules = [moment_kinetics.external_sources]","category":"page"},{"location":"zz_external_sources/#moment_kinetics.external_sources","page":"external_sources","title":"moment_kinetics.external_sources","text":"Maxwellian source terms with spatially varying parameters representing external sources of particles and energy.\n\nNote there is no parallel momentum input from the external sources.\n\nThe sources can be controlled by a PI controller to set density to a target value or profile. Note that the PI controller should not be used with operator splitting - implementing it in a way that would be compatible with splitting is complicated because the source contributes to several terms.\n\n\n\n\n\n","category":"module"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_ion_source!-NTuple{7, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_ion_source!","text":"external_ion_source!(pdf, fvec, moments, ion_source_settings, vperp, vpa, dt)\n\nAdd external source term to the ion kinetic equation.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_ion_source_controller!-NTuple{4, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_ion_source_controller!","text":"external_ion_source_controller!(fvec_in, moments, ion_source_settings, dt)\n\nCalculate the amplitude when using a PI controller for the density to set the external source amplitude.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_neutral_source!-NTuple{8, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_neutral_source!","text":"external_neutral_source!(pdf, fvec, moments, neutral_source_settings, vzeta, vr,\n                        vz, dt)\n\nAdd external source term to the neutral kinetic equation.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.external_neutral_source_controller!-NTuple{6, Any}","page":"external_sources","title":"moment_kinetics.external_sources.external_neutral_source_controller!","text":"external_neutral_source_controller!(fvec_in, moments, neutral_source_settings, r,\n                                    z, dt)\n\nCalculate the amplitude when using a PI controller for the density to set the external source amplitude.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.get_source_profile-NTuple{4, Any}","page":"external_sources","title":"moment_kinetics.external_sources.get_source_profile","text":"get_source_profile(profile_type, width, min_val, coord)\n\nCreate a profile of type profile_type with width width for coordinate coord.\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.initialize_external_source_amplitude!-NTuple{6, Any}","page":"external_sources","title":"moment_kinetics.external_sources.initialize_external_source_amplitude!","text":"initialize_external_source_amplitude!(moments, external_source_settings, vperp,\n                                      vzeta, vr, n_neutral_species)\n\nInitialize the arrays moments.ion.external_source_amplitude, moments.ion.external_source_density_amplitude, moments.ion.external_source_momentum_amplitude, moments.ion.external_source_pressure_amplitude, moments.neutral.external_source_amplitude, moments.neutral.external_source_density_amplitude, moments.neutral.external_source_momentum_amplitude, and moments.neutral.external_source_pressure_amplitude, using the settings in external_source_settings\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.initialize_external_source_controller_integral!-Tuple{Any, Any, Any}","page":"external_sources","title":"moment_kinetics.external_sources.initialize_external_source_controller_integral!","text":"function initializeexternalsourcecontrollerintegral!(              moments, externalsourcesettings, nneutralspecies)\n\nInitialize the arrays moments.ion.external_source_controller_integral and moments.neutral.external_source_controller_integral, using the settings in external_source_settings\n\n\n\n\n\n","category":"method"},{"location":"zz_external_sources/#moment_kinetics.external_sources.setup_external_sources!-Tuple{Any, Any, Any}","page":"external_sources","title":"moment_kinetics.external_sources.setup_external_sources!","text":"setup_external_sources!(input_dict, r, z)\n\nSet up parameters for the external sources using settings in input_dict.\n\nUpdates input_dict with defaults for unset parameters.\n\nr and z are the coordinates.coordinate objects for the r- and z-coordinates.\n\nReturns a NamedTuple (ion=ion_source_settings, neutral=neutral_source_settings) containing two NamedTuples of settings.\n\n\n\n\n\n","category":"method"},{"location":"zz_clenshaw_curtis/#clenshaw_curtis","page":"clenshaw_curtis","title":"clenshaw_curtis","text":"","category":"section"},{"location":"zz_clenshaw_curtis/","page":"clenshaw_curtis","title":"clenshaw_curtis","text":"Modules = [moment_kinetics.clenshaw_curtis]","category":"page"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis","text":"\n\n\n\n","category":"module"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis.chebyshevpoints-Tuple{Any}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.chebyshevpoints","text":"\n\n\n\n","category":"method"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis.clenshawcurtisnodes-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.clenshawcurtisnodes","text":"Compute nodes of the Clenshaw—Curtis quadrature rule.\n\n\n\n\n\n","category":"method"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis.clenshawcurtisweights-Tuple{}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.clenshawcurtisweights","text":"Compute weights of the Clenshaw—Curtis quadrature rule with modified Chebyshev moments of the first kind (μ)\n\n\n\n\n\n","category":"method"},{"location":"zz_clenshaw_curtis/#moment_kinetics.clenshaw_curtis.plan_clenshawcurtis-Tuple{Any}","page":"clenshaw_curtis","title":"moment_kinetics.clenshaw_curtis.plan_clenshawcurtis","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing","page":"plots_post_processing","title":"plots_post_processing","text":"","category":"section"},{"location":"zz_plots_post_processing/","page":"plots_post_processing","title":"plots_post_processing","text":"Modules = [plots_post_processing, plots_post_processing.post_processing_input, plots_post_processing.shared_utils]","category":"page"},{"location":"zz_plots_post_processing/#plots_post_processing.plots_post_processing","page":"plots_post_processing","title":"plots_post_processing.plots_post_processing","text":"\n\n\n\n","category":"module"},{"location":"zz_plots_post_processing/#plots_post_processing.allocate_global_zr_fields-Tuple{Any, Any, Any}","page":"plots_post_processing","title":"plots_post_processing.allocate_global_zr_fields","text":"functions to allocate arrays that are used at run-time to postprocess data that is stored in the netcdf files\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.analyze_and_plot_data-Tuple","page":"plots_post_processing","title":"plots_post_processing.analyze_and_plot_data","text":"analyze_and_plot_data(prefix...; run_index=nothing)\n\nMake some plots for the simulation at prefix. If more than one argument is passed to prefix, plot all the simulations together.\n\nThe strings passed to prefix should be either a directory (which contains run output) or the prefix of output files, like <directory>/<prefix> where the output files are <directory>/<prefix>.moments.h5 and <directory>/<prefix>.dfns.h5.\n\nIf a single value is passed for prefix the plots/movies are created in the same directory as the run, and given names based on the name of the run. If multiple values are passed, the plots/movies are given names beginning with compare_ and are created in the comparison_plots/ subdirectory.\n\nBy default plots output from all restarts in a directory. To select a single run, pass the run_index argument - the value corresponds to the _<i> suffix given to output files when restarting. run_index can be an integer (which is applied to all directories in prefix...), or a tuple of integers (which should have the same length as the number of directories passed to prefix...). Use run_index=-1 to get the most recent run (which does not have a _<i> suffix). Note that run_index is only used when a directory (rather than the prefix of a specific output file) is passed to prefix...\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.calculate_differences-Tuple","page":"plots_post_processing","title":"plots_post_processing.calculate_differences","text":"Find the maximum difference, as a function of time, between two or more outputs for each variable.\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.compare_fields_symbolic_test-NTuple{13, Any}","page":"plots_post_processing","title":"plots_post_processing.compare_fields_symbolic_test","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.draw_v_parallel_zero!-Tuple{Plots.Plot, AbstractVector, Any, Any, Bool, Bool}","page":"plots_post_processing","title":"plots_post_processing.draw_v_parallel_zero!","text":"Add a thin, red, dashed line showing vparallel=(vth*wparallel+upar)=0 to a 2d plot with axes (z,vpa).\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.get_tuple_of_return_values-Tuple{Any, Vararg{Any}}","page":"plots_post_processing","title":"plots_post_processing.get_tuple_of_return_values","text":"get_tuple_of_return_values(func, arg_tuples...)\n\nSuppose func(args...) returns a tuple of return values, then get_tuple_of_return_values(func, arg_tuples...) returns a tuple (with an entry for each return value of func) of tuples (one for each argument in each of arg_tuples...) of return values.\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.init_postprocessing_options-NTuple{10, Any}","page":"plots_post_processing","title":"plots_post_processing.init_postprocessing_options","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_1D_1V_diagnostics-NTuple{52, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_1D_1V_diagnostics","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_dfns-NTuple{21, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_dfns","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_fields-NTuple{11, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_fields","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_ion_pdf-NTuple{21, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_ion_pdf","text":"plots various slices of the ion pdf (1d and 2d, stills and animations)\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_moments-NTuple{25, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_moments","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_neutral_pdf-NTuple{23, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_neutral_pdf","text":"plots various slices of the neutral pdf (1d and 2d, stills and animations)\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.plot_unnormalised_f2d-Tuple{Any, Any, Any}","page":"plots_post_processing","title":"plots_post_processing.plot_unnormalised_f2d","text":"Make a 2d plot of an unnormalised f on unnormalised coordinates, as returned from getunnormalisedf_coords()\n\nNote this function requires using the PyPlot backend to support 2d coordinates being passed to heatmap().\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.read_distributed_zwallr_data!-Union{Tuple{N}, Tuple{Array{Float64, N}, String, Tuple, String, Tuple, Int64, Int64, String}} where N","page":"plots_post_processing","title":"plots_post_processing.read_distributed_zwallr_data!","text":"Read data which is a function of (r,t) or (r,species,t) and associated to one of the wall boundaries\n\nrun_names is a tuple. If it has more than one entry, this means that there are multiple restarts (which are sequential in time), so concatenate the data from each entry together.\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.trygif-Tuple{Any, Any}","page":"plots_post_processing","title":"plots_post_processing.trygif","text":"Call gif, but catch the exception if there is an error\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.trysavefig-Tuple{Any}","page":"plots_post_processing","title":"plots_post_processing.trysavefig","text":"Call savefig, but catch the exception if there is an error\n\n\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.post_processing_input","page":"plots_post_processing","title":"plots_post_processing.post_processing_input","text":"\n\n\n\n","category":"module"},{"location":"zz_plots_post_processing/#plots_post_processing.shared_utils.calculate_and_write_frequencies-NTuple{9, Any}","page":"plots_post_processing","title":"plots_post_processing.shared_utils.calculate_and_write_frequencies","text":"\n\n\n\n","category":"method"},{"location":"zz_plots_post_processing/#plots_post_processing.shared_utils.get_composition-Tuple{Any}","page":"plots_post_processing","title":"plots_post_processing.shared_utils.get_composition","text":"\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#fokker_planck","page":"fokker_planck","title":"fokker_planck","text":"","category":"section"},{"location":"zz_fokker_planck/","page":"fokker_planck","title":"fokker_planck","text":"Modules = [moment_kinetics.fokker_planck]","category":"page"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck","page":"fokker_planck","title":"moment_kinetics.fokker_planck","text":"module for including the Full-F Fokker-Planck Collision Operator\n\nThe functions in this module are split into two groups. \n\nThe first set of functions implement the weak-form Collision operator using the Rosenbluth-MacDonald-Judd formulation in a divergence form. The Green's functions for the Rosenbluth potentials are used to obtain the Rosenbluth potentials at the boundaries. To find the potentials everywhere else elliptic solves of the PDEs for the Rosenbluth potentials are performed with Dirichlet boundary conditions. These routines provide the default collision operator used in the code.\n\nThe second set of functions are used to set up the necessary arrays to  compute the Rosenbluth potentials everywhere in vpa, vperp by direct integration of the Green's functions. These functions are  supported for the purposes of testing and debugging.\n\n\n\n\n\n","category":"module"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.allocate_fokkerplanck_arrays_direct_integration-Tuple{Any, Any}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.allocate_fokkerplanck_arrays_direct_integration","text":"allocate the required ancilliary arrays \n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.explicit_fokker_planck_collisions_weak_form!-Tuple{Any, Any, Any, Any, Any, Any, moment_kinetics.fokker_planck_calculus.fokkerplanck_weakform_arrays_struct, Vararg{Any, 7}}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.explicit_fokker_planck_collisions_weak_form!","text":"Function for advancing with the explicit, weak-form, self-collision operator\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.fokker_planck_collision_operator_weak_form!-Tuple{Any, Any, Any, Any, Any, moment_kinetics.fokker_planck_calculus.fokkerplanck_weakform_arrays_struct, Vararg{Any, 4}}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.fokker_planck_collision_operator_weak_form!","text":"Function for evaluating C_ss = C_ssF_sF_s\n\nThe result is stored in the array fkpl_arrays.CC.\n\nThe normalised collision frequency is defined by\n\nnu_ss = fracgamma_ss n_mathrmref2 m_s^2 c_mathrmref^3\n\nwith gamma_ss = 2 pi (Z_s Z_s)^2 e^4 ln Lambda_ss  (4 pi epsilon_0)^2.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.init_fokker_planck_collisions_direct_integration-Tuple{Any, Any}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.init_fokker_planck_collisions_direct_integration","text":"function that initialises the arrays needed to calculate the Rosenbluth potentials by direct integration. As this function is only supported to keep the testing of the direct integration method, the struct 'fka' created here does not contain all of the arrays necessary to compute the weak-form operator. This functionality could be ported if necessary.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck/#moment_kinetics.fokker_planck.init_fokker_planck_collisions_weak_form-NTuple{4, Any}","page":"fokker_planck","title":"moment_kinetics.fokker_planck.init_fokker_planck_collisions_weak_form","text":"function that initialises the arrays needed for Fokker Planck collisions using numerical integration to compute the Rosenbluth potentials only at the boundary and using an elliptic solve to obtain the potentials  in the rest of the velocity space domain.\n\n\n\n\n\n","category":"method"},{"location":"zz_reference_parameters/#reference_parameters","page":"reference_parameters","title":"reference_parameters","text":"","category":"section"},{"location":"zz_reference_parameters/","page":"reference_parameters","title":"reference_parameters","text":"Modules = [moment_kinetics.reference_parameters]","category":"page"},{"location":"zz_reference_parameters/#moment_kinetics.reference_parameters","page":"reference_parameters","title":"moment_kinetics.reference_parameters","text":"Reference parameters\n\nReference parameters are not needed or used by the main part of the code, but define the physical units of the simulation, and are needed for a few specific steps during setup (e.g. calculation of normalised collision frequency).\n\n\n\n\n\n","category":"module"},{"location":"zz_reference_parameters/#moment_kinetics.reference_parameters.setup_reference_parameters-Tuple{Any}","page":"reference_parameters","title":"moment_kinetics.reference_parameters.setup_reference_parameters","text":"\n\n\n\n","category":"method"},{"location":"zz_velocity_grid_transforms/#velocity_grid_transforms","page":"velocity_grid_transforms","title":"velocity_grid_transforms","text":"","category":"section"},{"location":"zz_velocity_grid_transforms/","page":"velocity_grid_transforms","title":"velocity_grid_transforms","text":"Modules = [moment_kinetics.velocity_grid_transforms]","category":"page"},{"location":"zz_velocity_grid_transforms/#moment_kinetics.velocity_grid_transforms","page":"velocity_grid_transforms","title":"moment_kinetics.velocity_grid_transforms","text":"\n\n\n\n","category":"module"},{"location":"zz_neutral_z_advection/#neutral_z_advection","page":"neutral_z_advection","title":"neutral_z_advection","text":"","category":"section"},{"location":"zz_neutral_z_advection/","page":"neutral_z_advection","title":"neutral_z_advection","text":"Modules = [moment_kinetics.neutral_z_advection]","category":"page"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection.adjust_advection_speed!-NTuple{5, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.adjust_advection_speed!","text":"\n\n\n\n","category":"method"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection.neutral_advection_z!-NTuple{14, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.neutral_advection_z!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection.unnormalize_pdf!-NTuple{6, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.unnormalize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"zz_neutral_z_advection/#moment_kinetics.neutral_z_advection.update_speed_neutral_z!-NTuple{11, Any}","page":"neutral_z_advection","title":"moment_kinetics.neutral_z_advection.update_speed_neutral_z!","text":"calculate the advection speed in the z-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"manual_setup/#Manual-setup","page":"Manual setup","title":"Manual setup","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"If you want or need to set up moment_kinetics without using machines/machine_setup.sh, you will need to follow at least the steps in the following sections.","category":"page"},{"location":"manual_setup/#Install-Julia","page":"Manual setup","title":"Install Julia","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"Download Julia from https://julialang.org/downloads/, and add it to your $PATH so you can execute it from the command line.","category":"page"},{"location":"manual_setup/#Add-moment_kinetics-packages","page":"Manual setup","title":"Add moment_kinetics packages","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"Create a 'project' in the top-level directory by creating an empty Project.toml file, e.g.","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"$ touch Project.toml","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"Without this Project.toml file, running julia --project will activate a global project, not one linked specificially to the repo you are in, which is likely to cause confusion if you have more than one copy of the moment_kinetics repo (experience suggests you are likely to end up with multiple copies eventually!).","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"To add the moment_kinetics package to your project, start Julia, enter 'Package mode' by pressing ']' at the prompt and use develop (to exit 'Package mode' and return to the usual julia> prompt, press backspace):","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"$ julia --project\njulia> ]\npkg> develop ./moment_kinetics/","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"To allow post-processing add one or both of the post processing packages","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> develop ./makie_post_processing/makie_post_processing/","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"and/or","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> develop ./plots_post_processing/plots_post_processing/","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"To use the run_moment_kinetics.jl script, you will need to install MPI into the top-level project","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> add MPI","category":"page"},{"location":"manual_setup/#Set-up-MPI","page":"Manual setup","title":"Set up MPI","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"You probably want to use your system's MPI rather than a Julia-provided version. To do this add (in 'Package mode') the MPIPreferences package (documentation here) and then use its use_system_binary() function.","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> add MPIPreferences\npkg> <press 'backspace'>\njulia> using MPIPreferences\njulia> MPIPreferences.use_system_binary()","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"Normally this should 'just work'. Sometimes, for example if the MPI library file is named something other than libmpi.so, you might have to pass some keyword arguments to use_system_binary() - see https://juliaparallel.org/MPI.jl/stable/reference/mpipreferences/#MPIPreferences.use_system_binary.","category":"page"},{"location":"manual_setup/#Link-HDF5","page":"Manual setup","title":"Link HDF5","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"To enable parallel I/O, you need to get HDF5.jl to use the system HDF5 library (which must be MPI-enabled and compiled using the same MPI as you run Julia with). To do this (see the HDF5.jl docs) add the HDF5 package and use its HDF5.API.set_libraries!() function","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> add HDF5\npkg> <press backspace>\njulia> using HDF5\njulia> HDF5.API.set_libraries!(\"/path/to/your/hdf5/directory/libhdf5.so\", \"/path/to/your/hdf5/directory/libhdf5_hl.so\")","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"JTO also found that (on a Linux laptop) it was necessary to compile HDF5 from source. The system-provided, MPI-linked libhdf5 depended on libcurl, and Julia links to an incompatible libcurl, causing an error. When compiled from source (enabling MPI!), HDF5 does not require libcurl (guess it is an optional dependency), avoiding the problem.","category":"page"},{"location":"manual_setup/#Enable-MMS-features","page":"Manual setup","title":"Enable MMS features","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"To enable the \"method of manufactured solutions\" (MMS) features, install the Symbolics package (for more explanation, see Optional dependencies)","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> add Symbolics","category":"page"},{"location":"manual_setup/#Enable-NetCDF-output","page":"Manual setup","title":"Enable NetCDF output","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"If you want the option to output to NetCDF instead of HDF5, install the NCDatasets package (for more explanation, see Optional dependencies)","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"pkg> add NCDatasets","category":"page"},{"location":"manual_setup/#Set-up-Plots-based-plotting-routines","page":"Manual setup","title":"Set up Plots-based plotting routines","text":"","category":"section"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"The plots_post_processing package has some functions that have to use PyPlot directly to access features not available through the Plots wrapper. This means that Julia has to be able to access an instance of Python which has matplotlib available. If you are going to use plots_post_processing you may well want to use the same Python that you use outside Julia (e.g. a system-provided Python) - to do so:","category":"page"},{"location":"manual_setup/","page":"Manual setup","title":"Manual setup","text":"Check that matplotlib is installed, e.g. check that\n$ python\n>>> import matplotlib\ncompletes without an error. If not, install matplotlib, for example with a command like\npip install --user matplotlib\nSet up Julia to use your chosen Python\n$ which python\n/your/python/location\n$ julia -O3 --project\njulia> ENV[\"PYTHON\"]=\"/your/python/location\"\njulia> using Pkg; Pkg.build(\"PyCall\")","category":"page"},{"location":"zz_manufactured_solns/#manufactured_solns","page":"manufactured_solns","title":"manufactured_solns","text":"","category":"section"},{"location":"zz_manufactured_solns/","page":"manufactured_solns","title":"manufactured_solns","text":"Modules = [moment_kinetics.manufactured_solns]","category":"page"},{"location":"zz_manufactured_solns/#moment_kinetics.manufactured_solns","page":"manufactured_solns","title":"moment_kinetics.manufactured_solns","text":"\n\n\n\n","category":"module"},{"location":"constraints_on_normalized_distribution_function/#Constraints-on-normalized-distribution-function","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Note: Equation references give the Excalibur/Neptune report number and equation number, e.g. (TN-04;1) is equation (1) from report TN-04.pdf.","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Constraints","page":"Constraints on normalized distribution function","title":"Constraints","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"The normalized particle distribution function that is evolved when using the moment-kinetic approach has to satisfy integral constraints related to particle number, momentum and energy conservation (TN-04;70-72)","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s  =1\n  frac1sqrtpiint dw_w_tildeg_s  =0\n  frac1sqrtpiint dw_w_^2tildeg_s  =frac12\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Old-algorithm","page":"Constraints on normalized distribution function","title":"Old algorithm","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"The algorithm described in TN-04 used the distribution function from the previous time step and also made use of a symmetrized distribution function tildeg_E(w_)=frac12left(tildeg(w_)+tildeg(-w_)right). These choices caused problems when in combination with the boundary conditions as: applying the boundary condition at the new timestep (with an updated tildeu_) to the old tildeg_s could mean that it no longer satisfied the moment constraints (e.g. if a grid point that was previously non-zero is now set to zero by the ion sheath boundary condition); the symmetrized tildeg_E will be non-zero at places where the boundary condition forces tildeg_s to be zero. It is possible to extend the algorithm to allow the constraints to be enforced using only the initial guess of the distribution function at the new timestep, as described below.","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Current-algorithm","page":"Constraints on normalized distribution function","title":"Current algorithm","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"After the time advance updates the distribution function, it will in general not obey the constraints, but the errors will be small, with the size depending on the accuracy of the spatial and temporal discretizations. We can take this updated value hatg_s as an initial guess, to be corrected to give the actual updated value tildeg_s, which does obey the constraints to machine precision.","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"We define the corrected distribution function as","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  tildeg_s=Ahatg_s+Bw_hatg_s+Cw_^2hatg_s\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"and define the moments of hatg_s","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  I_n=frac1sqrtpiint dw_w_^nhatg_s\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Then the moments of tildeg_s are","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s=1  =frac1sqrtpiint dw_left(Ahatg_s+Bw_hatg_s+Cw_^2hatg_sright)=AI_0+BI_1+CI_2\n  frac1sqrtpiint dw_w_tildeg_s=0  =frac1sqrtpiint dw_left(Aw_hatg_s+Bw_^2hatg_s+Cw_^3hatg_sright)=AI_1+BI_2+CI_3\n  frac1sqrtpiint dw_w_^2tildeg_s=frac12  =frac1sqrtpiint dw_left(Aw_^2hatg_s+Bw_^3hatg_s+Cw_^4hatg_sright)=AI_2+BI_3+CI_4\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Solving the simultaneous equations for A, B, C gives","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  C  =fracfrac12-AI_2-BI_3I_4\n  B  =fracleft(I_2I_3-I_1I_4right)A-fracI_32I_2I_4-I_3^2\n  A  =fracI_2I_4-fracI_2^22+I_3left(fracI_12-I_3right)I_0left(I_2I_4-I_3^2right)+I_1left(I_2I_3-I_1I_4right)+I_2left(I_1I_3-I_2^2right)\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"Note that there is no guarantee that tildeg_s is geq0 even if hatg_sgeq0, although if the violations of the integral constraints are small, it should be true that Aapprox1 while B and C are small.","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Evolving-u_\\parallel","page":"Constraints on normalized distribution function","title":"Evolving u_parallel","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"When evolving fewer moments separately, the constraints become simpler. When evolving n and u_parallel, only the first two constraints are needed. This corresponds to C=0 so that","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  1 = AI_0 + BI_1 \n  0 = AI_1 + BI_2 \n  Rightarrow B = -fracAI_1I_2 \n  AI_0 = 1 - BI_1 = 1 + fracAI_1^2I_2 \n  A = frac1I_0 - I_1^2I_2\nendalign","category":"page"},{"location":"constraints_on_normalized_distribution_function/#Evolving-n","page":"Constraints on normalized distribution function","title":"Evolving n","text":"","category":"section"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"When evolving only n separately, we only need one constraint and the correction is just a re-scaling. This corresponds to B=0C=0 so that","category":"page"},{"location":"constraints_on_normalized_distribution_function/","page":"Constraints on normalized distribution function","title":"Constraints on normalized distribution function","text":"beginalign\n  1 = AI_0 \n  A = frac1I_0\nendalign","category":"page"},{"location":"zz_command_line_options/#command_line_options","page":"command_line_options","title":"command_line_options","text":"","category":"section"},{"location":"zz_command_line_options/","page":"command_line_options","title":"command_line_options","text":"Modules = [moment_kinetics.command_line_options]","category":"page"},{"location":"zz_command_line_options/#moment_kinetics.command_line_options","page":"command_line_options","title":"moment_kinetics.command_line_options","text":"Parse command line arguments\n\nHave to include test options here too, because ArgParse errors on unrecognized options.\n\n\n\n\n\n","category":"module"},{"location":"zz_command_line_options/#moment_kinetics.command_line_options.get_options-Tuple{}","page":"command_line_options","title":"moment_kinetics.command_line_options.get_options","text":"\n\n\n\n","category":"method"},{"location":"zz_em_fields/#em_fields","page":"em_fields","title":"em_fields","text":"","category":"section"},{"location":"zz_em_fields/","page":"em_fields","title":"em_fields","text":"Modules = [moment_kinetics.em_fields]","category":"page"},{"location":"zz_em_fields/#moment_kinetics.em_fields","page":"em_fields","title":"moment_kinetics.em_fields","text":"\n\n\n\n","category":"module"},{"location":"zz_em_fields/#moment_kinetics.em_fields.setup_em_fields-NTuple{6, Any}","page":"em_fields","title":"moment_kinetics.em_fields.setup_em_fields","text":"\n\n\n\n","category":"method"},{"location":"zz_em_fields/#moment_kinetics.em_fields.update_phi!-NTuple{10, Any}","page":"em_fields","title":"moment_kinetics.em_fields.update_phi!","text":"update_phi updates the electrostatic potential, phi\n\n\n\n\n\n","category":"method"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for moment_kinetics.jl","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"getting_started.md\",\n         \"input_options.md\",\n         \"post_processing_notes.md\",\n         \"moment_kinetic_equations.md\",\n         \"moment_constraints_notes.md\",\n         \"boundary_conditions_notes.md\",\n         \"external_sources_notes.md\",\n         \"debugging-hints.md\",\n         \"parameter_scans.md\",\n         \"developing.md\",\n         \"manual_setup.md\",\n         \"machine_setup_notes.md\",\n        ]","category":"page"},{"location":"#Modules","page":"Home","title":"Modules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Order = [:module]","category":"page"},{"location":"zz_neutral_vz_advection/#neutral_vz_advection","page":"neutral_vz_advection","title":"neutral_vz_advection","text":"","category":"section"},{"location":"zz_neutral_vz_advection/","page":"neutral_vz_advection","title":"neutral_vz_advection","text":"Modules = [moment_kinetics.neutral_vz_advection]","category":"page"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.neutral_advection_vz!-NTuple{15, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.neutral_advection_vz!","text":"\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_constant_neutral!-NTuple{6, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_constant_neutral!","text":"update the advection speed dvpa/dt = constant\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_default_neutral!-NTuple{10, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_default_neutral!","text":"\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_linear_neutral-NTuple{6, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_linear_neutral","text":"update the advection speed dvpa/dt = const*(vpa + L/2)\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_n_p_evolution_neutral!-NTuple{10, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_n_p_evolution_neutral!","text":"update the advection speed in the parallel velocity coordinate for the case where density and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized velocity vpahat = vpa/vth\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_n_u_evolution_neutral!-NTuple{9, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_n_u_evolution_neutral!","text":"update the advection speed in the parallel velocity coordinate for the case where density and flow are evolved independently from the pdf; in this case, the parallel velocity coordinate is the peculiar velocity wpa = vpa-upar\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_n_u_p_evolution_neutral!-NTuple{9, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_n_u_p_evolution_neutral!","text":"update the advection speed (for the neutral distribution function) in the z-velocity coordinate for the case where density, flow and pressure are evolved independently from the pdf; in this case, the parallel velocity coordinate is the normalized peculiar velocity wpahat = (vpa - upar)/vth\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_vz_advection/#moment_kinetics.neutral_vz_advection.update_speed_neutral_vz!-NTuple{12, Any}","page":"neutral_vz_advection","title":"moment_kinetics.neutral_vz_advection.update_speed_neutral_vz!","text":"calculate the advection speed in the vz-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#advection","page":"advection","title":"advection","text":"","category":"section"},{"location":"zz_advection/","page":"advection","title":"advection","text":"Modules = [moment_kinetics.advection]","category":"page"},{"location":"zz_advection/#moment_kinetics.advection","page":"advection","title":"moment_kinetics.advection","text":"\n\n\n\n","category":"module"},{"location":"zz_advection/#moment_kinetics.advection.advection_info","page":"advection","title":"moment_kinetics.advection.advection_info","text":"structure containing the basic arrays associated with the advection terms appearing in the advection equation for each coordinate\n\n\n\n\n\n","category":"type"},{"location":"zz_advection/#moment_kinetics.advection.advance_f_local!-NTuple{9, Any}","page":"advection","title":"moment_kinetics.advection.advance_f_local!","text":"do all the work needed to update f(coord) at a single value of other coords\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.calculate_explicit_advection!-NTuple{4, Any}","page":"advection","title":"moment_kinetics.advection.calculate_explicit_advection!","text":"calculate the explicit advection terms on the rhs of the equation; i.e., -Δt⋅δv⋅f'\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.setup_advection-Tuple{Any, Vararg{Any}}","page":"advection","title":"moment_kinetics.advection.setup_advection","text":"create arrays needed to compute the advection term(s) for a 1D problem\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.setup_advection_per_species-Tuple","page":"advection","title":"moment_kinetics.advection.setup_advection_per_species","text":"create arrays needed to compute the advection term(s)\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.update_advection_factor!-NTuple{4, Any}","page":"advection","title":"moment_kinetics.advection.update_advection_factor!","text":"calculate the factor appearing in front of f' in the advection term at time level n in the frame moving with the approximate characteristic\n\n\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.update_f!-Tuple{Any, Any, Any}","page":"advection","title":"moment_kinetics.advection.update_f!","text":"\n\n\n\n","category":"method"},{"location":"zz_advection/#moment_kinetics.advection.update_rhs!-NTuple{8, Any}","page":"advection","title":"moment_kinetics.advection.update_rhs!","text":"update the righthand side of the equation to account for 1d advection in this coordinate\n\n\n\n\n\n","category":"method"},{"location":"debugging-hints/#Debugging","page":"Debugging","title":"Debugging","text":"","category":"section"},{"location":"debugging-hints/#Shared-memory-parallelism","page":"Debugging","title":"Shared-memory parallelism","text":"","category":"section"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"For information on race conditions and debugging, see Shared memory debugging.","category":"page"},{"location":"debugging-hints/#Dumping-state-of-physics-variables","page":"Debugging","title":"Dumping state of physics variables","text":"","category":"section"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"There is a function moment_kinetics.file_io.debug_dump provided in the moment_kinetics.file_io module that can be inserted to save the distribution function, moments, etc. These can include a label so that if there are several 'dumps' within a timestep, they can be easily identified.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"To use, first import the function","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"using ..file_io: debug_dump","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"then insert calls at the point where you want to save the variables, e.g.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"debug_dump(f, density, upar, ppar, phi, t, istage=istage, label=\"foo\")","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"where f, density, upar, ppar, and phi are arrays and t is an mk_float. istage is an optional mk_int, and can be used to identify the stage in the ssp_rk!() function. label is optional and can be any string, intended to distinguish different calls to debug_dump().","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"There is an alternative method (implementation) of the function that takes moment_kinetics.moment_kinetics_structs.scratch_pdf and moment_kinetics.moment_kinetics_structs.em_fields_struct arguments. This can be convenient within the functions in moment_kinetics.time_advance, e.g.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"debug_dump(fvec_out, fields, t, istage=istage, label=\"bar\")","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"Any of the positional arguments can be replaced by nothing if they are not available in a certain place, or just not needed. If nothing is passed, then arrays filled with 0.0 are written into the output.","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"The output is written into a NetCDF file debug_output.cdf in the current directory (the filename is currently hard-coded because that was simpler than adding more command line arguments, etc.).","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"For debugging, a script util/compare_debug_files.jl is provided to compare two output files, assumed to have similar structure (i.e. the same set of debug_dump() calls). An example workflow could be:","category":"page"},{"location":"debugging-hints/","page":"Debugging","title":"Debugging","text":"Checkout master branch.\nCreate new branch, git checkout -b newfeature.\nWork on newfeature...\nAt some point, a bug is introduced which breaks some test or example - i.e. changes its output. Commit the current state of the code.\nAdd debug_dump() calls before and after locations where the bug is likely to be.\nRun the broken case.\nmv debug_output.cdf debug_after.cdf, so the file does not get overwritten.\ngit stash to 'save' the debug_dump() statements.\ngit checkout a commit where the test/example was working.\ngit stash pop to add the debug_dump() statements on top of the working commit  (fingers crossed there are no merge conflicts).\nRun the test example again.\nmv debug_output.cdf debug_before.cdf\nRun the comparison script  julia util/compare_debug_files.jl debug_before.cdf debug_after.cdf\nThe script identifies the first point (by t, istage and label) where any  variable in the two output files has a maximum difference that is larger than some  very tight (1.e-14) absolute and relative tolerances, and reports which  variables were different and their maximum difference.","category":"page"},{"location":"zz_file_io/#file_io","page":"file_io","title":"file_io","text":"","category":"section"},{"location":"zz_file_io/","page":"file_io","title":"file_io","text":"Modules = [moment_kinetics.file_io]","category":"page"},{"location":"zz_file_io/#moment_kinetics.file_io","page":"file_io","title":"moment_kinetics.file_io","text":"\n\n\n\n","category":"module"},{"location":"zz_file_io/#moment_kinetics.file_io.debug_output_counter","page":"file_io","title":"moment_kinetics.file_io.debug_output_counter","text":"Global counter for calls to debug_dump\n\n\n\n\n\n","category":"constant"},{"location":"zz_file_io/#moment_kinetics.file_io.debug_output_file","page":"file_io","title":"moment_kinetics.file_io.debug_output_file","text":"An nc_info instance that may be initialised for writing debug output\n\nThis is a non-const module variable, so does cause type instability, but it is only used for debugging (from debug_dump()) so performance is not critical.\n\n\n\n\n\n","category":"constant"},{"location":"zz_file_io/#moment_kinetics.file_io.ascii_ios","page":"file_io","title":"moment_kinetics.file_io.ascii_ios","text":"structure containing the various input/output streams\n\n\n\n\n\n","category":"type"},{"location":"zz_file_io/#moment_kinetics.file_io.io_dfns_info","page":"file_io","title":"moment_kinetics.file_io.io_dfns_info","text":"structure containing the data/metadata needed for binary file i/o distribution function data only\n\n\n\n\n\n","category":"type"},{"location":"zz_file_io/#moment_kinetics.file_io.io_initial_electron_info","page":"file_io","title":"moment_kinetics.file_io.io_initial_electron_info","text":"structure containing the data/metadata needed for binary file i/o for electron initialization\n\n\n\n\n\n","category":"type"},{"location":"zz_file_io/#moment_kinetics.file_io.io_moments_info","page":"file_io","title":"moment_kinetics.file_io.io_moments_info","text":"structure containing the data/metadata needed for binary file i/o moments & fields only\n\n\n\n\n\n","category":"type"},{"location":"zz_file_io/#moment_kinetics.file_io.add_attribute!","page":"file_io","title":"moment_kinetics.file_io.add_attribute!","text":"Add an attribute to a file, group or variable\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.add_vspace_coordinates!-NTuple{7, Any}","page":"file_io","title":"moment_kinetics.file_io.add_vspace_coordinates!","text":"Add to coords group in output file information about vspace coordinate grids\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.append_to_dynamic_var","page":"file_io","title":"moment_kinetics.file_io.append_to_dynamic_var","text":"append_to_dynamic_var(io_var, data, t_idx, parallel_io, coords...)\n\nAppend data to the dynamic variable io_var. The time-index of the data being appended is t_idx. parallel_io indicates whether parallel I/O is being used. coords... is used to get the ranges to write from/to (needed for parallel I/O) - the entries in the coords tuple can be either coordinate instances or integers (for an integer n the range is 1:n).\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.check_io_implementation-Tuple{Any}","page":"file_io","title":"moment_kinetics.file_io.check_io_implementation","text":"check_io_implementation(binary_format)\n\nCheck that an implementation is available for binary_format, raising an error if not.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.create_dynamic_variable!","page":"file_io","title":"moment_kinetics.file_io.create_dynamic_variable!","text":"create_dynamic_variable!(file_or_group, name, type, coords::coordinate...;\n                         nspecies=1, description=nothing, units=nothing)\n\nCreate a time-evolving variable in file_or_group named name of type type. coords are the coordinates corresponding to the dimensions of the array, in the order of the array dimensions. The species dimension does not have a coordinate, so the number of species is passed as nspecies. A description and/or units can be added with the keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.debug_dump","page":"file_io","title":"moment_kinetics.file_io.debug_dump","text":"debug_dump(ff, dens, upar, ppar, phi, t; istage=0, label=\"\")\ndebug_dump(fvec::scratch_pdf, fields::em_fields_struct, t; istage=0, label=\"\")\n\nDump variables into a NetCDF file for debugging\n\nIntended to be called more frequently than write_data_to_binary(), possibly several times within a timestep, so includes a label argument to identify the call site.\n\nWrites to a file called debug_output.h5 in the current directory.\n\nCan either be called directly with the arrays to be dumped (fist signature), or using scratch_pdf and em_fields_struct structs.\n\nnothing can be passed to any of the positional arguments (if they are unavailable at a certain point in the code, or just not interesting). t=nothing will set t to the value saved in the previous call (or 0.0 on the first call). Passing nothing to the other arguments will set that array to 0.0 for this call (need to write some value so all the arrays have the same length, with an entry for each call to debug_dump()).\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_dfn_variables!-NTuple{14, Any}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_dfn_variables!","text":"define dynamic (time-evolving) distribution function variables for writing to the output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_electron_moment_variables!-Tuple{Any, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate, Vararg{Any, 5}}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_electron_moment_variables!","text":"define dynamic (time-evolving) electron moment variables for writing to the hdf5 file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_em_field_variables!-Tuple{Any, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate, Any}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_em_field_variables!","text":"define dynamic (time-evolving) electromagnetic field variables for writing to the hdf5 file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_ion_moment_variables!-Tuple{Any, Any, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate, Vararg{Any, 5}}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_ion_moment_variables!","text":"define dynamic (time-evolving) ion moment variables for writing to the hdf5 file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_moment_variables!-Tuple{Any, Any, Any, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate, Vararg{Any, 5}}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_moment_variables!","text":"define dynamic (time-evolving) moment variables for writing to the hdf5 file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_dynamic_neutral_moment_variables!-Tuple{Any, Any, moment_kinetics.coordinates.coordinate, moment_kinetics.coordinates.coordinate, Vararg{Any, 5}}","page":"file_io","title":"moment_kinetics.file_io.define_dynamic_neutral_moment_variables!","text":"define dynamic (time-evolving) neutral moment variables for writing to the hdf5 file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_io_coordinate!-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.define_io_coordinate!","text":"define a sub-group for each code coordinate and write to output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.define_spatial_coordinates!-NTuple{4, Any}","page":"file_io","title":"moment_kinetics.file_io.define_spatial_coordinates!","text":"Define coords group for coordinate information in the output file and write information about spatial coordinate grids\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.finish_file_io-Tuple{Union{Nothing, moment_kinetics.file_io.ascii_ios}, Union{Nothing, Tuple, moment_kinetics.file_io.io_moments_info}, Union{Nothing, Tuple, moment_kinetics.file_io.io_dfns_info}}","page":"file_io","title":"moment_kinetics.file_io.finish_file_io","text":"close all opened output files\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.finish_initial_electron_io-Tuple{Union{Nothing, Tuple, moment_kinetics.file_io.io_initial_electron_info}}","page":"file_io","title":"moment_kinetics.file_io.finish_initial_electron_io","text":"close output files for electron initialization\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.get_group","page":"file_io","title":"moment_kinetics.file_io.get_group","text":"Get a (sub-)group from a file or group\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.get_subgroup_keys","page":"file_io","title":"moment_kinetics.file_io.get_subgroup_keys","text":"Get names of all subgroups\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.get_variable_keys","page":"file_io","title":"moment_kinetics.file_io.get_variable_keys","text":"Get names of all variables\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.hdf5_get_dynamic_dim_sizes-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.hdf5_get_dynamic_dim_sizes","text":"given a tuple, fixed_coords, containing all dimensions except the time dimension, get the dimension sizes and chunk sizes\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.hdf5_get_fixed_dim_sizes-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.hdf5_get_fixed_dim_sizes","text":"Get sizes of fixed dimensions and chunks (i.e. everything but time) for I/O\n\ncoords should be a tuple whose elements are coordinate structs or integers (e.g. number of species).\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.input_option_error-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.input_option_error","text":"accepts an option name which has been identified as problematic and returns an appropriate error message\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.io_has_parallel","page":"file_io","title":"moment_kinetics.file_io.io_has_parallel","text":"io_has_parallel(Val(binary_format))\n\nTest if the backend supports parallel I/O.\n\nbinary_format should be one of the values of the binary_format_type enum\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.is_group","page":"file_io","title":"moment_kinetics.file_io.is_group","text":"Test if a member of a (sub-)group is a group\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.open_ascii_output_file-Tuple{Any, Any}","page":"file_io","title":"moment_kinetics.file_io.open_ascii_output_file","text":"opens an output file with the requested prefix and extension and returns the corresponding io stream (identifier)\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.open_output_file-NTuple{4, Any}","page":"file_io","title":"moment_kinetics.file_io.open_output_file","text":"Open an output file, selecting the backend based on io_option\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.open_output_file_implementation","page":"file_io","title":"moment_kinetics.file_io.open_output_file_implementation","text":"Low-level function to open a binary output file\n\nEach implementation (HDF5, NetCDF, etc.) defines a method of this function to open a file of the corresponding type.\n\n\n\n\n\n","category":"function"},{"location":"zz_file_io/#moment_kinetics.file_io.reopen_dfns_io-Tuple{Any}","page":"file_io","title":"moment_kinetics.file_io.reopen_dfns_io","text":"Reopen an existing distribution-functions output file to append more data\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.reopen_initial_electron_io-Tuple{Any}","page":"file_io","title":"moment_kinetics.file_io.reopen_initial_electron_io","text":"Reopen an existing initial electron output file to append more data\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.reopen_moments_io-Tuple{Any}","page":"file_io","title":"moment_kinetics.file_io.reopen_moments_io","text":"Reopen an existing moments output file to append more data\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.reopen_output_file-Tuple{Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.reopen_output_file","text":"Re-open an existing output file, selecting the backend based on io_option\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.setup_dfns_io-NTuple{23, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_dfns_io","text":"setup file i/o for distribution function variables\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.setup_file_io-NTuple{19, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_file_io","text":"open the necessary output files\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.setup_initial_electron_io-NTuple{17, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_initial_electron_io","text":"open output file to save the initial electron pressure and distribution function\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.setup_moments_io-NTuple{17, Any}","page":"file_io","title":"moment_kinetics.file_io.setup_moments_io","text":"setup file i/o for moment variables\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_Dict_to_section-Tuple{Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_Dict_to_section","text":"write_Dict_to_section(section_io, section_dict, parallel_io)\n\nWrite the contents of section_dict into the I/O group section_io.\n\nAny nested Dicts in section_dict are written to subsections.\n\nAll the keys in section_dict (and any nested Dicts) should be Strings.\n\nparallel_io is a Bool indicating whether parallel I/O is being used.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_all_dfns_data_to_binary-NTuple{16, Any}","page":"file_io","title":"moment_kinetics.file_io.write_all_dfns_data_to_binary","text":"write time-dependent distribution function data for ions, electrons and neutrals to the binary output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_all_moments_data_to_binary-NTuple{10, Any}","page":"file_io","title":"moment_kinetics.file_io.write_all_moments_data_to_binary","text":"write time-dependent moments data for ions, electrons and neutrals to the binary output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_boundary_distributions!-NTuple{10, Any}","page":"file_io","title":"moment_kinetics.file_io.write_boundary_distributions!","text":"Write the distributions that may be used for boundary conditions to the output file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_electron_dfns_data_to_binary-Tuple{Any, Union{moment_kinetics.file_io.io_dfns_info, moment_kinetics.file_io.io_initial_electron_info}, Vararg{Any, 5}}","page":"file_io","title":"moment_kinetics.file_io.write_electron_dfns_data_to_binary","text":"write time-dependent distribution function data for electrons to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_electron_moments_data_to_binary-Tuple{Any, Union{moment_kinetics.file_io.io_initial_electron_info, moment_kinetics.file_io.io_moments_info}, Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_electron_moments_data_to_binary","text":"write time-dependent moments data for electrons to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_em_fields_data_to_binary-Tuple{Any, moment_kinetics.file_io.io_moments_info, Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_em_fields_data_to_binary","text":"write time-dependent EM fields data to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_f_ascii-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.write_f_ascii","text":"write the function f(z,vpa) at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_fields_ascii-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.write_fields_ascii","text":"write electrostatic potential at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_initial_electron_state-NTuple{9, Any}","page":"file_io","title":"moment_kinetics.file_io.write_initial_electron_state","text":"write_initial_electron_state(pdf, moments, io_initial_electron, t_idx, r, z,\n                             vperp, vpa)\n\nWrite the electron state to an output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_input!-Tuple{Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_input!","text":"Save info from the dict with input settings to the output file\n\nNote: assumes all keys in input_dict are strings.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_ion_dfns_data_to_binary-Tuple{Any, Any, moment_kinetics.file_io.io_dfns_info, Vararg{Any, 5}}","page":"file_io","title":"moment_kinetics.file_io.write_ion_dfns_data_to_binary","text":"write time-dependent distribution function data for ions to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_ion_moments_data_to_binary-Tuple{Any, Any, moment_kinetics.file_io.io_moments_info, Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_ion_moments_data_to_binary","text":"write time-dependent moments data for ions to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_moments_electron_ascii-NTuple{5, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_electron_ascii","text":"write moments of the ion species distribution function f at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_moments_ion_ascii-NTuple{6, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_ion_ascii","text":"write moments of the ion species distribution function f at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_moments_neutral_ascii-NTuple{6, Any}","page":"file_io","title":"moment_kinetics.file_io.write_moments_neutral_ascii","text":"write moments of the neutral species distribution function f_neutral at this time slice\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_neutral_dfns_data_to_binary-Tuple{Any, Any, moment_kinetics.file_io.io_dfns_info, Vararg{Any, 6}}","page":"file_io","title":"moment_kinetics.file_io.write_neutral_dfns_data_to_binary","text":"write time-dependent distribution function data for neutrals to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_neutral_moments_data_to_binary-Tuple{Any, Any, moment_kinetics.file_io.io_moments_info, Any, Any, Any}","page":"file_io","title":"moment_kinetics.file_io.write_neutral_moments_data_to_binary","text":"write time-dependent moments data for neutrals to the binary output file\n\nNote: should only be called from within a function that (re-)opens the output file.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_overview!-NTuple{8, Any}","page":"file_io","title":"moment_kinetics.file_io.write_overview!","text":"write some overview information for the simulation to the binary file\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_provenance_tracking_info!-NTuple{6, Any}","page":"file_io","title":"moment_kinetics.file_io.write_provenance_tracking_info!","text":"Write provenance tracking information, to allow runs to be reproduced.\n\n\n\n\n\n","category":"method"},{"location":"zz_file_io/#moment_kinetics.file_io.write_single_value!","page":"file_io","title":"moment_kinetics.file_io.write_single_value!","text":"write_single_value!(file_or_group, name, value; description=nothing, units=nothing)\n\nWrite a single variable to a file or group. If a description or units are passed, add as attributes of the variable.\n\n\n\n\n\n","category":"function"},{"location":"zz_velocity_moments/#velocity_moments","page":"velocity_moments","title":"velocity_moments","text":"","category":"section"},{"location":"zz_velocity_moments/","page":"velocity_moments","title":"velocity_moments","text":"Modules = [moment_kinetics.velocity_moments]","category":"page"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments","page":"velocity_moments","title":"moment_kinetics.velocity_moments","text":"\n\n\n\n","category":"module"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.calculate_electron_moment_derivatives!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_electron_moment_derivatives!","text":"Pre-calculate spatial derivatives of the electron moments that will be needed for the time advance\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.calculate_ion_moment_derivatives!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_ion_moment_derivatives!","text":"Pre-calculate spatial derivatives of the moments that will be needed for the time advance\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.calculate_neutral_moment_derivatives!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.calculate_neutral_moment_derivatives!","text":"Pre-calculate spatial derivatives of the neutral moments that will be needed for the time advance\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.create_moments_electron-NTuple{4, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.create_moments_electron","text":"create a moment struct containing information about the electron moments\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.create_moments_ion-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.create_moments_ion","text":"\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.get_pressure-Tuple{Float64, Float64}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.get_pressure","text":"compute the isotropic pressure from the already computed ppar and pperp\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.integrate_over_negative_vpa-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_negative_vpa","text":"computes the integral over vpa <= 0 of the integrand, using the input vpa_wgts this could be made more efficient for the case that dz/dt = vpa is time-independent, but it has been left general for the cases where, e.g., dz/dt = wpa*vth + upar varies in time\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.integrate_over_positive_vpa-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_positive_vpa","text":"computes the integral over vpa >= 0 of the integrand, using the input vpa_wgts this could be made more efficient for the case that dz/dt = vpa is time-independent, but it has been left general for the cases where, e.g., dz/dt = wpa*vth + upar varies in time\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.integrate_over_vspace-Tuple","page":"velocity_moments","title":"moment_kinetics.velocity_moments.integrate_over_vspace","text":"computes the integral over vpa of the integrand, using the input vpa_wgts\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.reset_moments_status!-Tuple{Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.reset_moments_status!","text":"\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_chodura_integral_species!-NTuple{14, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_chodura_integral_species!","text":"compute the integral needed for the generalised Chodura condition\n\nIChodura = (Z^2 vBohm^2 / cref^2) * int ( f bz^2 / vz^2 + dfdr*rhostar/vz )  vBohm = sqrt(Z Te/mi)  with Z = 1 and mref = mi  cref = sqrt(2Ti/mi) and normalise to the local ion density, appropriate to assessing the  Chodura condition \n\nIChodura <= (Te/e)d ne / dphi |(sheath entrance) = ni\n\nto a single species plasma with Z = 1\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_density!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_density!","text":"NB: if this function is called and if dens_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_density_species!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_density_species!","text":"calculate the updated density (dens) for a given species; should only be called when evolvedensity = false, in which case the vpa coordinate is vpa/cs\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_moments!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_moments!","text":"calculate the updated density (dens) and parallel pressure (ppar) for all species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_moments_neutral!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_moments_neutral!","text":"update velocity moments of the evolved neutral pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_density!-NTuple{9, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_density!","text":"calculate the neutral density from the neutral pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_density_species!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_density_species!","text":"calculate the updated density (dens) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_pr_species!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_pr_species!","text":"calculate the updated pressure in the rr direction (pr) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_pz_species!-NTuple{11, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_pz_species!","text":"calculate the updated pressure in zz direction (pz) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_pzeta_species!-NTuple{7, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_pzeta_species!","text":"calculate the updated pressure in the zeta zeta direction (pzeta) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_qz_species!-NTuple{13, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_qz_species!","text":"calculate the updated heat flux zzz direction (qz) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_ur_species!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_ur_species!","text":"calculate the updated ur (mean velocity in r) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_uz_species!-NTuple{11, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_uz_species!","text":"calculate the updated uz (mean velocity in z) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_neutral_uzeta_species!-NTuple{8, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_neutral_uzeta_species!","text":"calculate the updated uzeta (mean velocity in zeta) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_ppar!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_ppar!","text":"NB: if this function is called and if ppar_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_ppar_species!-NTuple{10, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_ppar_species!","text":"calculate the updated energy density (or parallel pressure, ppar) for a given species; which of these is calculated depends on the definition of the vpa coordinate\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_pperp_species!-NTuple{6, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_pperp_species!","text":"calculate the updated perpendicular pressure (pperp) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_qpar!-NTuple{14, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_qpar!","text":"NB: the incoming pdf is the normalized pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_qpar_species!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_qpar_species!","text":"calculate the updated parallel heat flux (qpar) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_upar!-NTuple{12, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_upar!","text":"NB: if this function is called and if upar_updated is false, then the incoming pdf is the un-normalized pdf that satisfies int dv pdf = density\n\n\n\n\n\n","category":"method"},{"location":"zz_velocity_moments/#moment_kinetics.velocity_moments.update_upar_species!-NTuple{10, Any}","page":"velocity_moments","title":"moment_kinetics.velocity_moments.update_upar_species!","text":"calculate the updated parallel flow (upar) for a given species\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#coordinates","page":"coordinates","title":"coordinates","text":"","category":"section"},{"location":"zz_coordinates/","page":"coordinates","title":"coordinates","text":"Modules = [moment_kinetics.coordinates]","category":"page"},{"location":"zz_coordinates/#moment_kinetics.coordinates","page":"coordinates","title":"moment_kinetics.coordinates","text":"\n\n\n\n","category":"module"},{"location":"zz_coordinates/#moment_kinetics.coordinates.coordinate","page":"coordinates","title":"moment_kinetics.coordinates.coordinate","text":"structure containing basic information related to coordinates\n\n\n\n\n\n","category":"type"},{"location":"zz_coordinates/#moment_kinetics.coordinates.define_coordinate","page":"coordinates","title":"moment_kinetics.coordinates.define_coordinate","text":"create arrays associated with a given coordinate, setup the coordinate grid, and populate the coordinate structure containing all of this information\n\n\n\n\n\n","category":"function"},{"location":"zz_coordinates/#moment_kinetics.coordinates.elemental_to_full_grid_map-Tuple{Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.elemental_to_full_grid_map","text":"returns imin and imax, which contain the minimum and maximum indices on the full grid for each element\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.equally_spaced_grid-NTuple{4, Any}","page":"coordinates","title":"moment_kinetics.coordinates.equally_spaced_grid","text":"setup an equally spaced grid with n_global grid points between [-L/2,L/2]\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.equally_spaced_grid_shifted-NTuple{4, Any}","page":"coordinates","title":"moment_kinetics.coordinates.equally_spaced_grid_shifted","text":"setup an equally spaced grid with n_global grid points between [0,L]\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.full_to_elemental_grid_map-Tuple{Any, Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.full_to_elemental_grid_map","text":"setup arrays containing a map from the unpacked grid point indices to the element index and the grid point index within each element\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.grid_spacing-Tuple{Any, Any}","page":"coordinates","title":"moment_kinetics.coordinates.grid_spacing","text":"given a set of grid point locations calculate and return the length associated with the cell between adjacent grid points\n\n\n\n\n\n","category":"method"},{"location":"zz_coordinates/#moment_kinetics.coordinates.init_grid-NTuple{13, Any}","page":"coordinates","title":"moment_kinetics.coordinates.init_grid","text":"setup a grid with n_global grid points on the interval [-L/2,L/2]\n\n\n\n\n\n","category":"method"},{"location":"zz_type_definitions/#type_definitions","page":"type_definitions","title":"type_definitions","text":"","category":"section"},{"location":"zz_type_definitions/","page":"type_definitions","title":"type_definitions","text":"Modules = [moment_kinetics.type_definitions]","category":"page"},{"location":"zz_type_definitions/#moment_kinetics.type_definitions","page":"type_definitions","title":"moment_kinetics.type_definitions","text":"\n\n\n\n","category":"module"},{"location":"zz_type_definitions/#moment_kinetics.type_definitions.mk_float","page":"type_definitions","title":"moment_kinetics.type_definitions.mk_float","text":"\n\n\n\n","category":"type"},{"location":"zz_type_definitions/#moment_kinetics.type_definitions.mk_int","page":"type_definitions","title":"moment_kinetics.type_definitions.mk_int","text":"\n\n\n\n","category":"type"},{"location":"zz_communication/#communication","page":"communication","title":"communication","text":"","category":"section"},{"location":"zz_communication/","page":"communication","title":"communication","text":"Modules = [moment_kinetics.communication]","category":"page"},{"location":"zz_communication/#moment_kinetics.communication","page":"communication","title":"moment_kinetics.communication","text":"Communication functions and setup\n\nSplit the grid into 'blocks'. Each block can use shared memory (MPI shared memory arrays). At the moment only works with a single 'block' containing the whole grid - eventually add more MPI communication functions to communicate between blocks. A block should probably be a 'NUMA region' for maximum efficiency.\n\nNote: charge-exchange collisions loop over neutral species for each ion species. At the moment this loop is not parallelised (although it could be, by introducing some more loop ranges), as at the moment we only run with 1 ion species and 1 neutral species.\n\n\n\n\n\n","category":"module"},{"location":"zz_communication/#moment_kinetics.communication.anyv_isubblock_index","page":"communication","title":"moment_kinetics.communication.anyv_isubblock_index","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.anyv_nsubblocks_per_block","page":"communication","title":"moment_kinetics.communication.anyv_nsubblocks_per_block","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.anyv_subblock_rank","page":"communication","title":"moment_kinetics.communication.anyv_subblock_rank","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.anyv_subblock_size","page":"communication","title":"moment_kinetics.communication.anyv_subblock_size","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.block_rank","page":"communication","title":"moment_kinetics.communication.block_rank","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.block_size","page":"communication","title":"moment_kinetics.communication.block_size","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.comm_anyv_subblock","page":"communication","title":"moment_kinetics.communication.comm_anyv_subblock","text":"Communicator for the local velocity-space subset of a shared-memory block in a 'anyv' region\n\nThe 'anyv' region is used to parallelise the collision operator. See moment_kinetics.looping.get_best_anyv_split.\n\nMust use a Ref{MPI.Comm} to allow a non-const MPI.Comm to be stored. Need to actually assign to this and not just copy a pointer into the .val member because otherwise the MPI.Comm object created by MPI.Comm_split() would be deleted, which probably makes MPI.jl delete the communicator.\n\n\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.comm_block","page":"communication","title":"moment_kinetics.communication.comm_block","text":"Communicator connecting a shared-memory region\n\nMust use a Ref{MPI.Comm} to allow a non-const MPI.Comm to be stored. Need to actually assign to this and not just copy a pointer into the .val member because otherwise the MPI.Comm object created by MPI.Comm_split() would be deleted, which probably makes MPI.jl delete the communicator.\n\n\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.comm_inter_block","page":"communication","title":"moment_kinetics.communication.comm_inter_block","text":"Communicator connecting the root processes of each shared memory block\n\nMust use a Ref{MPI.Comm} to allow a non-const MPI.Comm to be stored. Need to actually assign to this and not just copy a pointer into the .val member because otherwise the MPI.Comm object created by MPI.Comm_split() would be deleted, which probably makes MPI.jl delete the communicator.\n\n\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.comm_world","page":"communication","title":"moment_kinetics.communication.comm_world","text":"Can use a const MPI.Comm for comm_world and just copy the pointer from MPI.COMM_WORLD because MPI.COMM_WORLD is never deleted, so pointer stays valid.\n\n\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.global_Win_store","page":"communication","title":"moment_kinetics.communication.global_Win_store","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.global_rank","page":"communication","title":"moment_kinetics.communication.global_rank","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.global_size","page":"communication","title":"moment_kinetics.communication.global_size","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.iblock_index","page":"communication","title":"moment_kinetics.communication.iblock_index","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.n_blocks","page":"communication","title":"moment_kinetics.communication.n_blocks","text":"\n\n\n\n","category":"constant"},{"location":"zz_communication/#moment_kinetics.communication.MPISharedArray","page":"communication","title":"moment_kinetics.communication.MPISharedArray","text":"\n\n\n\n","category":"type"},{"location":"zz_communication/#moment_kinetics.communication.__init__-Tuple{}","page":"communication","title":"moment_kinetics.communication.__init__","text":"\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication._anyv_subblock_synchronize-Tuple{}","page":"communication","title":"moment_kinetics.communication._anyv_subblock_synchronize","text":"Call an MPI Barrier for all processors in an 'anyv' sub-block.\n\nThe 'anyv' region is used to parallelise the collision operator. See moment_kinetics.looping.get_best_anyv_split.\n\nUsed to synchronise processors that are working on the same shared-memory array(s) between operations, to avoid race conditions. Should be even cheaper than _block_synchronize because it only requires communication on a smaller communicator.\n\nNote: _anyv_subblock_synchronize() may be called different numbers of times on different sub-blocks, depending on how the species and spatial dimensions are split up. @debug_detect_redundant_block_synchronize is not implemented (yet?) for _anyv_subblock_synchronize().\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication._block_synchronize-Tuple{}","page":"communication","title":"moment_kinetics.communication._block_synchronize","text":"Call an MPI Barrier for all processors in a block.\n\nUsed to synchronise processors that are working on the same shared-memory array(s) between operations, to avoid race conditions. Should be (much) cheaper than a global MPI Barrier because it only requires communication within a single node.\n\nNote: some debugging code currently assumes that if blocksynchronize() is called on one block, it is called simultaneously on all blocks. It seems likely that this will always be true, but if it ever changes (i.e. different blocks doing totally different work), the debugging routines need to be updated.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.allocate_shared-Tuple{Any, Any}","page":"communication","title":"moment_kinetics.communication.allocate_shared","text":"Get a shared-memory array of mk_float (shared by all processes in a 'block')\n\nCreate a shared-memory array using MPI.Win_allocate_shared(). Pointer to the memory allocated is wrapped in a Julia array. Memory is not managed by the Julia array though. A reference to the MPI.Win needs to be freed - this is done by saving the MPI.Win into a Vector in the Communication module, which has all its entries freed by the finalize_comms!() function, which should be called when moment_kinetics is done running a simulation/test.\n\nArguments\n\ndims - mkint or Tuple{mkint}     Dimensions of the array to be created. Dimensions passed define the size of the     array which is being handled by the 'block' (rather than the global array, or a     subset for a single process). comm - MPI.Comm, default comm_block[]     MPI communicator containing the processes that share the array. maybe_debug - Bool     Can be set to false to force not creating a DebugMPISharedArray when debugging is     active. This avoids recursion when including a shared-memory array as a member of a     DebugMPISharedArray for debugging purposes.\n\nReturns\n\nArray{mk_float}\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.finalize_comms!-Tuple{}","page":"communication","title":"moment_kinetics.communication.finalize_comms!","text":"Clean up from communications\n\nDo any needed clean-up for MPI, etc. Does not call MPI.Finalize() - this is called anyway when Julia exits, and we do not want to call it explicitly so that multiple runs can be done in a single Julia session.\n\nFrees any shared-memory arrays.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.free_shared_arrays-Tuple{}","page":"communication","title":"moment_kinetics.communication.free_shared_arrays","text":"\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.initialize_comms!-Tuple{}","page":"communication","title":"moment_kinetics.communication.initialize_comms!","text":"Set up communications\n\nCheck that global variables are in the correct state (i.e. caches were emptied correctly if they were used before).\n\nAlso does some set up for debugging routines, if they are active.\n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.setup_distributed_memory_MPI-NTuple{4, Any}","page":"communication","title":"moment_kinetics.communication.setup_distributed_memory_MPI","text":"Function to take information from user about r z grids and  number of processes allocated to set up communicators notation definitions:     - block: group of processes that share data with shared memory     - z group: group of processes that need to communicate data for z derivatives     - r group: group of processes that need to communicate data for r derivatives This routine assumes that the number of processes is selected by the user to match exactly the number the ratio \n\nnblocks = (rnelementglobal/rnelementlocal)*(znelementglobal/znelementlocal)\n\nThis guarantees perfect load balancing. Shared memory is used to parallelise the other dimensions within each distributed-memory parallelised rz block.   \n\n\n\n\n\n","category":"method"},{"location":"zz_communication/#moment_kinetics.communication.setup_distributed_memory_MPI_for_weights_precomputation-NTuple{5, Any}","page":"communication","title":"moment_kinetics.communication.setup_distributed_memory_MPI_for_weights_precomputation","text":"Function to take information from user about vpa vperp grids and  number of processes allocated to set up communicators for  precomputation of the Rosenbluth potential integration weights notation definitions:     - block: group of processes that share data with shared memory     - vpa group: group of processes that need to communicate data for vpa derivatives/integrals     - vperp group: group of processes that need to communicate data for vperp derivatives/integrals This routine assumes that the number of processes is selected by the user to match or be larger than the ratio \n\nnblocks = (vpanelementglobal/vpanelementlocal)*(vperpnelementglobal/vperpnelementlocal)\n\nWe also need to know (from user input) the maximum number of cores per shared memory region. A fraction of the cores will not contribute to the calculation, as we cannot guarantee that  the same number of cores is required for the rz parallelisation as the vpa vperp parallelisation \n\n\n\n\n\n","category":"method"},{"location":"geometry/#Magnetic-Geometry","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"","category":"section"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"We take the magnetic field mathbfB to have the form ","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"beginequation\nmathbfB = B_z hatmathbfz + B_zeta hatmathbfzeta\nendequation","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"with B_zeta = B(rz) b_zeta, B_z = B(rz) b_z and b_z and b_zeta the direction cosines of the magnetic field vector. Here the basis vectors are those of cylindrical geometry (rzzeta), i.e., hatmathbfr = nabla r  hatmathbfz = nabla z,  and hatmathbfzeta = r nabla zeta. The unit vectors hatmathbfr, hatmathbfz, and hatmathbfzeta form a right-handed orthonormal basis.","category":"page"},{"location":"geometry/#Supported-options","page":"Magnetic Geometry","title":"Supported options","text":"","category":"section"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"To choose the type of geometry, set the value of \"option\" in the geometry namelist. The namelist will have the following appearance in the TOML file.","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"[geometry]\noption=\"constant-helical\" # ( or \"1D-mirror\" )\npitch = 1.0\nrhostar = 1.0\nDeltaB = 0.0","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"If rhostar is not set then it is computed from reference parameters.","category":"page"},{"location":"geometry/#[geometry]-option-\"constant-helical\"","page":"Magnetic Geometry","title":"[geometry] option = \"constant-helical\"","text":"","category":"section"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"Here b_zeta = sqrt1 - b_z^2 is a constant, b_z is a constant input parameter (\"pitch\") and B is taken to be 1 with respect to the reference value B_rm ref.","category":"page"},{"location":"geometry/#[geometry]-option-\"1D-mirror\"","page":"Magnetic Geometry","title":"[geometry] option = \"1D-mirror\"","text":"","category":"section"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"Here b_zeta = sqrt1 - b_z^2 is a constant, b_z is a constant input parameter (\"pitch\") and B = B(z) is taken to be  the function ","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"beginequation\nfracB(z)B_rm ref = \n    1 + Delta B left( 2left(frac2zL_zright)^2 - left(frac2zL_zright)^4right)\nendequation","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"where Delta B  is an input parameter (DeltaB) that must satisfy Delta B  -1. Recalling that the coordinate z runs from  z = -L_z2 to L_z2, if Delta B  0 than the field represents a magnetic mirror which traps particles, whereas if Delta B  0 then the magnetic field accelerates particles by the mirror force as they approach the wall. Note that this field does not satisfy nabla cdot mathbfB = 0, and is only used to test the implementation of the magnetic mirror terms. 2D simulations with a radial domain andmathbfEtimesmathbfB drifts are supported in the \"1D-mirror\" geometry option.","category":"page"},{"location":"geometry/#Geometric-coefficients","page":"Magnetic Geometry","title":"Geometric coefficients","text":"","category":"section"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"Here, we write the geometric coefficients appearing in the characteristic equations explicitly.","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"The z component of the mathbfEtimesmathbfB drift is given by","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"beginequation fracmathbfEtimesmathbfBB^2 cdot nabla z = fracE_r B_zetaB^2 nabla r times hatmathbfzeta cdot nabla z \n= - J fracE_r B_zetaB^2\nendequation","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"where we have defined J = r nabla r times nabla z cdot nabla zeta. Note that J is dimensionless. The r component of the mathbfEtimesmathbfB drift is given by","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"beginequation fracmathbfEtimesmathbfBB^2 cdot nabla r = fracE_z B_zetaB^2 nabla z times hatmathbfzeta cdot nabla r \n=  J fracE_z B_zetaB^2\nendequation","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"Due to the axisymmetry of the system, the differential operator  mathbfb cdot nabla (cdot)  = b_z partial (cdot)partial z,  and the convective derivative","category":"page"},{"location":"geometry/","page":"Magnetic Geometry","title":"Magnetic Geometry","text":"beginequation\nfracd Bd t = fracd zd t fracpartial B partial z + fracdrdtfracpartial Bpartial r\nendequation","category":"page"},{"location":"zz_looping/#looping","page":"looping","title":"looping","text":"","category":"section"},{"location":"zz_looping/","page":"looping","title":"looping","text":"Modules = [moment_kinetics.looping]","category":"page"},{"location":"zz_looping/#moment_kinetics.looping","page":"looping","title":"moment_kinetics.looping","text":"Provides convenience macros for shared-memory-parallel loops\n\n\n\n\n\n","category":"module"},{"location":"zz_looping/#moment_kinetics.looping.loop_ranges","page":"looping","title":"moment_kinetics.looping.loop_ranges","text":"module variable that we can access by giving fully-qualified name in loop macros\n\n\n\n\n\n","category":"constant"},{"location":"zz_looping/#moment_kinetics.looping.loop_ranges_store","page":"looping","title":"moment_kinetics.looping.loop_ranges_store","text":"module variable used to store LoopRanges that are swapped into the loopranges variable in begin*_region() functions\n\n\n\n\n\n","category":"constant"},{"location":"zz_looping/#moment_kinetics.looping.LoopRanges","page":"looping","title":"moment_kinetics.looping.LoopRanges","text":"LoopRanges structs contain information on which points should be included on this process in loops over shared-memory arrays.\n\nMembers\n\nparalleldims::Tuple{Vararg{Symbol}}        Indicates which dimensions are (or might be) parallelized when using        this LoopRanges. Provided for information for developers, to make it        easier to tell (when using a Debugger, or printing debug informatino)        which LoopRanges instance is active in looping.loopranges at any point        in the code. rank0::Bool        Is this process the one with rank 0 in the 'block' which work in        parallel on shared memory arrays. <d>::UnitRange{mkint}        Loop ranges for each dimension <d> in looping.alldimensions.\n\n\n\n\n\n","category":"type"},{"location":"zz_looping/#moment_kinetics.looping.begin_anyv_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_anyv_region","text":"Begin 'anyv' sub-region in which () velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the beginanyv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anyv_subblock_synchronize() to synchronize the processes operating on an 'anyv' shared-memory sub-block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_anyv_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_anyv_vpa_region","text":"Begin 'anyv' sub-region in which (:vpa,) velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the beginanyv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anyv_subblock_synchronize() to synchronize the processes operating on an 'anyv' shared-memory sub-block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_anyv_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_anyv_vperp_region","text":"Begin 'anyv' sub-region in which (:vperp,) velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the beginanyv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anyv_subblock_synchronize() to synchronize the processes operating on an 'anyv' shared-memory sub-block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_anyv_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_anyv_vperp_vpa_region","text":"Begin 'anyv' sub-region in which (:vperp, :vpa) velocity space dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the beginanyv*region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _anyv_subblock_synchronize() to synchronize the processes operating on an 'anyv' shared-memory sub-block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_region","text":"Begin region in which (:r,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vpa_region","text":"Begin region in which (:r, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vperp_region","text":"Begin region in which (:r, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vperp_vpa_region","text":"Begin region in which (:r, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vr_region","text":"Begin region in which (:r, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vr_vz_region","text":"Begin region in which (:r, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vz_region","text":"Begin region in which (:r, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vzeta_region","text":"Begin region in which (:r, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vzeta_vr_region","text":"Begin region in which (:r, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vzeta_vr_vz_region","text":"Begin region in which (:r, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_vzeta_vz_region","text":"Begin region in which (:r, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_region","text":"Begin region in which (:r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vpa_region","text":"Begin region in which (:r, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vperp_region","text":"Begin region in which (:r, :z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vperp_vpa_region","text":"Begin region in which (:r, :z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vr_region","text":"Begin region in which (:r, :z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vr_vz_region","text":"Begin region in which (:r, :z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vz_region","text":"Begin region in which (:r, :z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vzeta_region","text":"Begin region in which (:r, :z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vzeta_vr_region","text":"Begin region in which (:r, :z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vzeta_vr_vz_region","text":"Begin region in which (:r, :z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_r_z_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_r_z_vzeta_vz_region","text":"Begin region in which (:r, :z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_region","text":"Begin region in which (:s, :r) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_vpa_region","text":"Begin region in which (:s, :r, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_vperp_region","text":"Begin region in which (:s, :r, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_vperp_vpa_region","text":"Begin region in which (:s, :r, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_z_anyv_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_anyv_region","text":"Begin region in which (:s,:r,:z) dimensions and velocity dimensions are parallelized by being split between processes, and which velocity dimensions are parallelized can be switched within the outer loop over (:s,:r,:z). This parallelization scheme is intended for use in the collision operator.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_region","text":"Begin region in which (:s, :r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_vpa_region","text":"Begin region in which (:s, :r, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_z_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_vperp_region","text":"Begin region in which (:s, :r, :z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_r_z_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_r_z_vperp_vpa_region","text":"Begin region in which (:s, :r, :z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_region","text":"Begin region in which (:s,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_vpa_region","text":"Begin region in which (:s, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_vperp_region","text":"Begin region in which (:s, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_vperp_vpa_region","text":"Begin region in which (:s, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_region","text":"Begin region in which (:s, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_vpa_region","text":"Begin region in which (:s, :z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_z_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_vperp_region","text":"Begin region in which (:s, :z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_s_z_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_s_z_vperp_vpa_region","text":"Begin region in which (:s, :z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_serial_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_serial_region","text":"Begin region in which only rank-0 in each group of processes operating on a shared-memory block operates on shared-memory arrays.\n\nReturns immediately if loopranges[] is already set for a serial region. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_region","text":"Begin region in which (:sn, :r) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vr_region","text":"Begin region in which (:sn, :r, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vr_vz_region","text":"Begin region in which (:sn, :r, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vz_region","text":"Begin region in which (:sn, :r, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vzeta_region","text":"Begin region in which (:sn, :r, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vzeta_vr_region","text":"Begin region in which (:sn, :r, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vzeta_vr_vz_region","text":"Begin region in which (:sn, :r, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_vzeta_vz_region","text":"Begin region in which (:sn, :r, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_region","text":"Begin region in which (:sn, :r, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vr_region","text":"Begin region in which (:sn, :r, :z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vr_vz_region","text":"Begin region in which (:sn, :r, :z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vz_region","text":"Begin region in which (:sn, :r, :z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vzeta_region","text":"Begin region in which (:sn, :r, :z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vzeta_vr_region","text":"Begin region in which (:sn, :r, :z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vzeta_vr_vz_region","text":"Begin region in which (:sn, :r, :z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_r_z_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_r_z_vzeta_vz_region","text":"Begin region in which (:sn, :r, :z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_region","text":"Begin region in which (:sn,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vr_region","text":"Begin region in which (:sn, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vr_vz_region","text":"Begin region in which (:sn, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vz_region","text":"Begin region in which (:sn, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vzeta_region","text":"Begin region in which (:sn, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vzeta_vr_region","text":"Begin region in which (:sn, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vzeta_vr_vz_region","text":"Begin region in which (:sn, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_vzeta_vz_region","text":"Begin region in which (:sn, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_region","text":"Begin region in which (:sn, :z) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vr_region","text":"Begin region in which (:sn, :z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vr_vz_region","text":"Begin region in which (:sn, :z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vz_region","text":"Begin region in which (:sn, :z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vzeta_region","text":"Begin region in which (:sn, :z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vzeta_vr_region","text":"Begin region in which (:sn, :z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vzeta_vr_vz_region","text":"Begin region in which (:sn, :z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_sn_z_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_sn_z_vzeta_vz_region","text":"Begin region in which (:sn, :z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vpa_region","text":"Begin region in which (:vpa,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vperp_region","text":"Begin region in which (:vperp,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vperp_vpa_region","text":"Begin region in which (:vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vr_region","text":"Begin region in which (:vr,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vr_vz_region","text":"Begin region in which (:vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vz_region","text":"Begin region in which (:vz,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vzeta_region","text":"Begin region in which (:vzeta,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vzeta_vr_region","text":"Begin region in which (:vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vzeta_vr_vz_region","text":"Begin region in which (:vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_vzeta_vz_region","text":"Begin region in which (:vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_region","text":"Begin region in which (:z,) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vpa_region","text":"Begin region in which (:z, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vperp_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vperp_region","text":"Begin region in which (:z, :vperp) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vperp_vpa_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vperp_vpa_region","text":"Begin region in which (:z, :vperp, :vpa) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vr_region","text":"Begin region in which (:z, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vr_vz_region","text":"Begin region in which (:z, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vz_region","text":"Begin region in which (:z, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vzeta_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vzeta_region","text":"Begin region in which (:z, :vzeta) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vzeta_vr_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vzeta_vr_region","text":"Begin region in which (:z, :vzeta, :vr) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vzeta_vr_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vzeta_vr_vz_region","text":"Begin region in which (:z, :vzeta, :vr, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.begin_z_vzeta_vz_region-Tuple{}","page":"looping","title":"moment_kinetics.looping.begin_z_vzeta_vz_region","text":"Begin region in which (:z, :vzeta, :vz) dimensions are parallelized by being split between processes.\n\nReturns immediately if loopranges[] is already set to the parallel dimensions being requested. This allows the begin*_region() calls to be placed where they make logical sense, with no cost if a call happens to be repeated (e.g. in different functions).\n\nCalls _block_synchronize() to synchronize the processes operating on a shared-memory block, unless no_synchronize=true is passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.debug_setup_loop_ranges_split_one_combination!-Tuple{Any, Any, Tuple{Vararg{Symbol, N}} where N, Vararg{Symbol}}","page":"looping","title":"moment_kinetics.looping.debug_setup_loop_ranges_split_one_combination!","text":"For debugging the shared-memory parallelism, create ranges where only the loops for a single combinations of variables (given by combination_to_split) are parallelised, and which dimensions are parallelised can be set with the dims_to_split... arguments.\n\nArguments\n\nKeyword arguments dim=n are required for each dim in all_dimensions where n is an integer giving the size of the dimension.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.dims_string-Tuple{Tuple}","page":"looping","title":"moment_kinetics.looping.dims_string","text":"Construct a string composed of the dimension names given in the Tuple dims, separated by underscores\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_anyv_ranges-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.get_anyv_ranges","text":"\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_best_anyv_split-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_best_anyv_split","text":"Find the numbers of processes for each dimension that optimize load balance for 'anyv' type loops for a certain block_size.\n\nThe 'anyv' parallelisation patterns are designed for use in the collision operator. They all share the same parallelisation in species and spatial dimensions so that the region type can be switched between 'anyv' types within a loop over species and spatial dimensions (@loopsr_z). It is only defined for ions, not for neutrals.\n\nParts of the collision operator cannot conveniently be parallelised over velocity dimensions, so this function aims to assign as much parallelism as possible to the species and spatial dimensions.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_best_ranges-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.get_best_ranges","text":"Find the ranges for loop variables that optimize load balance for a certain block_size\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_local_range-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.get_local_range","text":"Get local range of indices when splitting a loop over processes in a sub-block\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_max_work-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_max_work","text":"Calculate the maximum number of grid points on any process\n\nThis is a measure of the maximum amount of work to do on a single process. Minimising this will make the parallelisation as efficient as possible.\n\nArguments\n\nnprocslist : Vector{mkint}     Number of processes for each dimension sizes : Vector{mk_int}     Size of each dimension\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_ranges_from_split-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.get_ranges_from_split","text":"\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_splits-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_splits","text":"Find possible divisions of each number less than or equal to block_size into n factors.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_splits_and_max_work_from_sizes-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_splits_and_max_work_from_sizes","text":"\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.get_subblock_splits-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.get_subblock_splits","text":"Find possible divisions of subblocksize into n factors\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.setup_loop_ranges!-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.setup_loop_ranges!","text":"Create ranges for loops with different combinations of variables\n\nArguments\n\nKeyword arguments dim=n are required for each dim in [:s, :r, :z, :vperp, :vpa, :sn, :vzeta, :vr, :vz] where n is an integer giving the size of the dimension.\n\n\n\n\n\n","category":"method"},{"location":"zz_looping/#moment_kinetics.looping.@anyv_serial_region-Tuple{Any}","page":"looping","title":"moment_kinetics.looping.@anyv_serial_region","text":"Run a block of code on only anyv-subblock-rank-0 of each group of processes operating on an 'anyv' shared-memory subblock\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r","text":"Loop over (:r,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vpa","text":"Loop over (:r, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vperp-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vperp","text":"Loop over (:r, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vperp_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vperp_vpa","text":"Loop over (:r, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vr","text":"Loop over (:r, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vr_vz","text":"Loop over (:r, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vz","text":"Loop over (:r, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vzeta-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta","text":"Loop over (:r, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vzeta_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta_vr","text":"Loop over (:r, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vzeta_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta_vr_vz","text":"Loop over (:r, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_vzeta_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_vzeta_vz","text":"Loop over (:r, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z","text":"Loop over (:r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vpa","text":"Loop over (:r, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vperp-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vperp","text":"Loop over (:r, :z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vperp_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vperp_vpa","text":"Loop over (:r, :z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vr","text":"Loop over (:r, :z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vr_vz","text":"Loop over (:r, :z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vz","text":"Loop over (:r, :z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vzeta-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta","text":"Loop over (:r, :z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vzeta_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta_vr","text":"Loop over (:r, :z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vzeta_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta_vr_vz","text":"Loop over (:r, :z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_r_z_vzeta_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_r_z_vzeta_vz","text":"Loop over (:r, :z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s","text":"Loop over (:s,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r","text":"Loop over (:s, :r) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vpa","text":"Loop over (:s, :r, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_vperp-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vperp","text":"Loop over (:s, :r, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_vperp_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_vperp_vpa","text":"Loop over (:s, :r, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_z-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z","text":"Loop over (:s, :r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_z_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vpa","text":"Loop over (:s, :r, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_z_vperp-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vperp","text":"Loop over (:s, :r, :z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_r_z_vperp_vpa-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_r_z_vperp_vpa","text":"Loop over (:s, :r, :z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vpa","text":"Loop over (:s, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_vperp-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vperp","text":"Loop over (:s, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_vperp_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_vperp_vpa","text":"Loop over (:s, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z","text":"Loop over (:s, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_z_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vpa","text":"Loop over (:s, :z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_z_vperp-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vperp","text":"Loop over (:s, :z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_s_z_vperp_vpa-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_s_z_vperp_vpa","text":"Loop over (:s, :z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn","text":"Loop over (:sn,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r","text":"Loop over (:sn, :r) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vr","text":"Loop over (:sn, :r, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vr_vz","text":"Loop over (:sn, :r, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vz","text":"Loop over (:sn, :r, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vzeta-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta","text":"Loop over (:sn, :r, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vzeta_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta_vr","text":"Loop over (:sn, :r, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vzeta_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta_vr_vz","text":"Loop over (:sn, :r, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_vzeta_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_vzeta_vz","text":"Loop over (:sn, :r, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z","text":"Loop over (:sn, :r, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vr","text":"Loop over (:sn, :r, :z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vr_vz","text":"Loop over (:sn, :r, :z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vz","text":"Loop over (:sn, :r, :z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta","text":"Loop over (:sn, :r, :z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta_vr-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta_vr","text":"Loop over (:sn, :r, :z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta_vr_vz-NTuple{7, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta_vr_vz","text":"Loop over (:sn, :r, :z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_r_z_vzeta_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_r_z_vzeta_vz","text":"Loop over (:sn, :r, :z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vr","text":"Loop over (:sn, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vr_vz","text":"Loop over (:sn, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vz","text":"Loop over (:sn, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vzeta-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta","text":"Loop over (:sn, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vzeta_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta_vr","text":"Loop over (:sn, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vzeta_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta_vr_vz","text":"Loop over (:sn, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_vzeta_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_vzeta_vz","text":"Loop over (:sn, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z","text":"Loop over (:sn, :z) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vr","text":"Loop over (:sn, :z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vr_vz","text":"Loop over (:sn, :z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vz","text":"Loop over (:sn, :z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vzeta-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta","text":"Loop over (:sn, :z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vzeta_vr-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta_vr","text":"Loop over (:sn, :z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vzeta_vr_vz-NTuple{6, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta_vr_vz","text":"Loop over (:sn, :z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_sn_z_vzeta_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_sn_z_vzeta_vz","text":"Loop over (:sn, :z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vpa-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vpa","text":"Loop over (:vpa,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vperp-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vperp","text":"Loop over (:vperp,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vperp_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vperp_vpa","text":"Loop over (:vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vr-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vr","text":"Loop over (:vr,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vr_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vr_vz","text":"Loop over (:vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vz-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vz","text":"Loop over (:vz,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vzeta-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta","text":"Loop over (:vzeta,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vzeta_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta_vr","text":"Loop over (:vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vzeta_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta_vr_vz","text":"Loop over (:vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_vzeta_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_vzeta_vz","text":"Loop over (:vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z-Tuple{Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z","text":"Loop over (:z,) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vpa-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vpa","text":"Loop over (:z, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vperp-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vperp","text":"Loop over (:z, :vperp) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vperp_vpa-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vperp_vpa","text":"Loop over (:z, :vperp, :vpa) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vr-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vr","text":"Loop over (:z, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vr_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vr_vz","text":"Loop over (:z, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vz-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vz","text":"Loop over (:z, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vzeta-Tuple{Any, Any, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta","text":"Loop over (:z, :vzeta) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vzeta_vr-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta_vr","text":"Loop over (:z, :vzeta, :vr) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vzeta_vr_vz-NTuple{5, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta_vr_vz","text":"Loop over (:z, :vzeta, :vr, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@loop_z_vzeta_vz-NTuple{4, Any}","page":"looping","title":"moment_kinetics.looping.@loop_z_vzeta_vz","text":"Loop over (:z, :vzeta, :vz) dimensions\n\n\n\n\n\n","category":"macro"},{"location":"zz_looping/#moment_kinetics.looping.@serial_region-Tuple{Any}","page":"looping","title":"moment_kinetics.looping.@serial_region","text":"Run a block of code on only rank-0 of each group of processes operating on a shared-memory block\n\n\n\n\n\n","category":"macro"},{"location":"zz_geo/#geo","page":"geo","title":"geo","text":"","category":"section"},{"location":"zz_geo/","page":"geo","title":"geo","text":"Modules = [moment_kinetics.geo]","category":"page"},{"location":"zz_geo/#moment_kinetics.geo","page":"geo","title":"moment_kinetics.geo","text":"module for including axisymmetric geometry in coordinates (z,r), with z the vertical  coordinate and r the radial coordinate\n\n\n\n\n\n","category":"module"},{"location":"zz_geo/#moment_kinetics.geo.geometric_coefficients","page":"geo","title":"moment_kinetics.geo.geometric_coefficients","text":"struct containing the geometric data necessary for  non-trivial axisymmetric geometries, to be passed  around the inside of the code, replacing the  geometry_input struct from input_structs.jl\n\nThe arrays of 2 dimensions are functions of (z,r)\n\n\n\n\n\n","category":"type"},{"location":"zz_geo/#moment_kinetics.geo.init_magnetic_geometry-Tuple{moment_kinetics.input_structs.geometry_input, Any, Any}","page":"geo","title":"moment_kinetics.geo.init_magnetic_geometry","text":"function to initialise the geometry coefficients inputdata – geometryinput type z – coordinate type r – coordinate type\n\n\n\n\n\n","category":"method"},{"location":"zz_geo/#moment_kinetics.geo.setup_geometry_input-Tuple{Dict, Any}","page":"geo","title":"moment_kinetics.geo.setup_geometry_input","text":"function to read the geometry input data from the TOML file\n\nthe TOML namelist should be structured like\n\n[geometry] pitch = 1.0 rhostar = 1.0 DeltaB = 0.0 option = \"\"\n\n\n\n\n\n","category":"method"},{"location":"zz_bgk/#bgk","page":"bgk","title":"bgk","text":"","category":"section"},{"location":"zz_bgk/","page":"bgk","title":"bgk","text":"Modules = [moment_kinetics.bgk]","category":"page"},{"location":"zz_bgk/#moment_kinetics.bgk","page":"bgk","title":"moment_kinetics.bgk","text":"\n\n\n\n","category":"module"},{"location":"zz_bgk/#moment_kinetics.bgk.allowed_wave_amplitude!-NTuple{5, Any}","page":"bgk","title":"moment_kinetics.bgk.allowed_wave_amplitude!","text":"\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.init_bgk_pdf!-NTuple{6, Any}","page":"bgk","title":"moment_kinetics.bgk.init_bgk_pdf!","text":"\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.passing_pdf!-NTuple{5, Any}","page":"bgk","title":"moment_kinetics.bgk.passing_pdf!","text":"inputs\n\npdf is the particle distribution function, with the passing part of phase space not filled in\nphi_max is the maximum value that e * phi / Te takes\ntau = Ti/Te is the ion-electron temperature ratio\nx = mvpa^2/2Te + ephi/Te is 1D array containing the total parallel energy (conserved)\n\noutput\n\npdf = particle distribution function; this function fills in the part of phase space where x > e*phi_max/T\n\n\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.setup_dummy_integrals-Tuple{}","page":"bgk","title":"moment_kinetics.bgk.setup_dummy_integrals","text":"\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.total_energy_grid-Tuple{Any, Any}","page":"bgk","title":"moment_kinetics.bgk.total_energy_grid","text":"inputs:\n\nvpa = parallel velocity normalized by vts = sqrt(2*Te/ms)\nphi = electrostatic potential normalized by Te/e\n\noutput: x = vpa^2 + phi is the total parallel energy\n\n\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.trapped_passing_boundary-Tuple{Any, Any}","page":"bgk","title":"moment_kinetics.bgk.trapped_passing_boundary","text":"\n\n\n\n","category":"method"},{"location":"zz_bgk/#moment_kinetics.bgk.trapped_pdf!-NTuple{8, Any}","page":"bgk","title":"moment_kinetics.bgk.trapped_pdf!","text":"inputs\n\nphi_max is the maximum value that e * phi / Te takes\ntau = Ti/Te is the ion-electron temperature ratio\nx = vpa^2 + e*phi is a 2D array containing the total parallel energy on the (z,vpa) grid\ny = dummy coordinate for the necessary integrals in the function\nintegrand = dummy array used to hold integrands defined and integrated in this function\nwgts = integration weights associated with y integrals\n\noutput\n\npdf is the particle distribution function for all of phase space, with this function filling in only the part with x < e*phi_max/T\n\n\n\n\n\n","category":"method"},{"location":"zz_continuity/#continuity","page":"continuity","title":"continuity","text":"","category":"section"},{"location":"zz_continuity/","page":"continuity","title":"continuity","text":"Modules = [moment_kinetics.continuity]","category":"page"},{"location":"zz_continuity/#moment_kinetics.continuity","page":"continuity","title":"moment_kinetics.continuity","text":"\n\n\n\n","category":"module"},{"location":"zz_continuity/#moment_kinetics.continuity.continuity_equation!-NTuple{9, Any}","page":"continuity","title":"moment_kinetics.continuity.continuity_equation!","text":"use the continuity equation dn/dt + d(n*upar)/dz to update the density n for all ion species\n\n\n\n\n\n","category":"method"},{"location":"zz_continuity/#moment_kinetics.continuity.neutral_continuity_equation!-NTuple{9, Any}","page":"continuity","title":"moment_kinetics.continuity.neutral_continuity_equation!","text":"use the continuity equation dn/dt + d(n*upar)/dz to update the density n for all neutral species\n\n\n\n\n\n","category":"method"},{"location":"zz_debugging/#debugging","page":"debugging","title":"debugging","text":"","category":"section"},{"location":"zz_debugging/","page":"debugging","title":"debugging","text":"Modules = [moment_kinetics.debugging]","category":"page"},{"location":"zz_debugging/#moment_kinetics.debugging","page":"debugging","title":"moment_kinetics.debugging","text":"Define debugging levels that can be used to include extra debugging steps\n\nProvides a bunch of macros (see the macronames Vector) that can be used to surround code in other modules so that it only runs if the 'debug level' passed to the --debug or -d command line argument is high enough.\n\nAlso provides macro *_ifelse whose names are taken from macronames, which can be used to switch definitions, etc. For example, if debug_shared_array is in macronames, then\n\nconst MPISharedArray = @debug_shared_array_ifelse(DebugMPISharedArray, Array)\n\ncan be used to make the type represented by MPISharedArray depend on the debug level.\n\n\n\n\n\n","category":"module"},{"location":"zz_debugging/#moment_kinetics.debugging._debug_level","page":"debugging","title":"moment_kinetics.debugging._debug_level","text":"\n\n\n\n","category":"constant"},{"location":"zz_debugging/#moment_kinetics.debugging.macronames","page":"debugging","title":"moment_kinetics.debugging.macronames","text":"\n\n\n\n","category":"constant"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_block_synchronize-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_block_synchronize","text":"Check blocksynchronize() was called from the same place on every process.  Activated at _debug_level >= 4  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_block_synchronize_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_block_synchronize_ifelse","text":"Evaluate first expression if debugblocksynchronize is active, second expression if not  debugblocksynchronize is inactive (_debug_level = 0 < 4).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_detect_redundant_block_synchronize-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_detect_redundant_block_synchronize","text":"Check if any blocksynchronize() call could have been skipped without resulting in an error.  Activated at _debug_level >= 5  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_detect_redundant_block_synchronize_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_detect_redundant_block_synchronize_ifelse","text":"Evaluate first expression if debugdetectredundantblocksynchronize is active, second expression if not  debugdetectredundantblocksynchronize is inactive (_debug_level = 0 < 5).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_initialize_NaN-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_initialize_NaN","text":"Initialize arrays with NaN.  Activated at _debug_level >= 1  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_initialize_NaN_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_initialize_NaN_ifelse","text":"Evaluate first expression if debuginitializeNaN is active, second expression if not  debuginitializeNaN is inactive (_debug_level = 0 < 1).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_shared_array-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array","text":"Check for incorrect reads/writes to shared-memory arrays  Activated at _debug_level >= 2  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_shared_array_allocate-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_allocate","text":"Check that allocateshared() was called from the same place on every process.  Activated at `debuglevel >= 4Currently inactive (debug_level = 0`).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_shared_array_allocate_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_allocate_ifelse","text":"Evaluate first expression if debugsharedarrayallocate is active, second expression if not  debugsharedarrayallocate is inactive (_debug_level = 0 < 4).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_shared_array_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_shared_array_ifelse","text":"Evaluate first expression if debugsharedarray is active, second expression if not  debugsharedarray is inactive (_debug_level = 0 < 2).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_track_array_allocate_location-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_array_allocate_location","text":"Record where every array was allocated.  Activated at _debug_level >= 3  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_track_array_allocate_location_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_array_allocate_location_ifelse","text":"Evaluate first expression if debugtrackarrayallocatelocation is active, second expression if not  debugtrackarrayallocatelocation is inactive (_debug_level = 0 < 3).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_track_initialized-Tuple{Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_initialized","text":"Check that every array is initialized before being used.  Activated at _debug_level >= 3  Currently inactive (_debug_level = 0).\n\n\n\n\n\n","category":"macro"},{"location":"zz_debugging/#moment_kinetics.debugging.@debug_track_initialized_ifelse-Tuple{Any, Any}","page":"debugging","title":"moment_kinetics.debugging.@debug_track_initialized_ifelse","text":"Evaluate first expression if debugtrackinitialized is active, second expression if not  debugtrackinitialized is inactive (_debug_level = 0 < 3).\n\n\n\n\n\n","category":"macro"},{"location":"zz_time_advance/#time_advance","page":"time_advance","title":"time_advance","text":"","category":"section"},{"location":"zz_time_advance/","page":"time_advance","title":"time_advance","text":"Modules = [moment_kinetics.time_advance]","category":"page"},{"location":"zz_time_advance/#moment_kinetics.time_advance","page":"time_advance","title":"moment_kinetics.time_advance","text":"\n\n\n\n","category":"module"},{"location":"zz_time_advance/#moment_kinetics.time_advance.euler_time_advance!-NTuple{27, Any}","page":"time_advance","title":"moment_kinetics.time_advance.euler_time_advance!","text":"eulertimeadvance! advances the vector equation dfvec/dt = G[f] that includes the kinetic equation + any evolved moment equations using the forward Euler method: fvecout = fvecin + dt*fvecin, with fvecin an input and fvec_out the output\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.normalize_pdf!-Tuple{Any, Any, Any}","page":"time_advance","title":"moment_kinetics.time_advance.normalize_pdf!","text":"if evolving the density via continuity equation, redefine the normalised f → f/n if evolving the parallel pressure via energy equation, redefine f -> f * vth / n 'scratch' should be a (nz,nspecies) array\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.rk_update!-NTuple{22, Any}","page":"time_advance","title":"moment_kinetics.time_advance.rk_update!","text":"use information obtained from the Runge-Kutta stages to compute the updated pdf; for the quantities (density, upar, ppar, vth, qpar and phi) that are derived from the 'true', un-modified pdf, either: update them using info from Runge Kutta stages, if the quantities are evolved separately from the modified pdf; or update them by taking the appropriate velocity moment of the evolved pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.rk_update_evolved_moments!-NTuple{4, Any}","page":"time_advance","title":"moment_kinetics.time_advance.rk_update_evolved_moments!","text":"use Runge Kutta to update any ion velocity moments evolved separately from the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.rk_update_evolved_moments_neutral!-NTuple{4, Any}","page":"time_advance","title":"moment_kinetics.time_advance.rk_update_evolved_moments_neutral!","text":"use Runge Kutta to update any neutral-particle velocity moments evolved separately from the pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.setup_advance_flags-NTuple{15, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_advance_flags","text":"create the 'advance_info' struct to be used in later Euler advance to indicate which parts of the equations are to be advanced concurrently. if no splitting of operators, all terms advanced concurrently; else, will advance one term at a time.\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.setup_runge_kutta_coefficients-Tuple{Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_runge_kutta_coefficients","text":"given the number of Runge Kutta stages that are requested, returns the needed Runge Kutta coefficients; e.g., if f is the function to be updated, then f^{n+1}[stage+1] = rkcoef[1,stage]*f^{n} + rkcoef[2,stage]f^{n+1}[stage] + rk_coef[3,stage](f^{n}+dt*G[f^{n+1}[stage]]\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.setup_time_advance!-NTuple{31, Any}","page":"time_advance","title":"moment_kinetics.time_advance.setup_time_advance!","text":"create arrays and do other work needed to setup the main time advance loop. this includes creating and populating structs for Chebyshev transforms, velocity space moments, EM fields, and advection terms\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.ssp_rk!-NTuple{27, Any}","page":"time_advance","title":"moment_kinetics.time_advance.ssp_rk!","text":"\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.time_advance!-NTuple{29, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance!","text":"solve ∂f/∂t + v(z,t)⋅∂f/∂z + dvpa/dt ⋅ ∂f/∂vpa= 0 define approximate characteristic velocity v₀(z)=vⁿ(z) and take time derivative along this characteristic df/dt + δv⋅∂f/∂z = 0, with δv(z,t)=v(z,t)-v₀(z) for prudent choice of v₀, expect δv≪v so that explicit time integrator can be used without severe CFL condition\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.time_advance_no_splitting!-NTuple{27, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance_no_splitting!","text":"\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.time_advance_split_operators!-NTuple{18, Any}","page":"time_advance","title":"moment_kinetics.time_advance.time_advance_split_operators!","text":"\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.update_derived_moments!-NTuple{7, Any}","page":"time_advance","title":"moment_kinetics.time_advance.update_derived_moments!","text":"update velocity moments that are calculable from the evolved ion pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.update_derived_moments_neutral!-NTuple{8, Any}","page":"time_advance","title":"moment_kinetics.time_advance.update_derived_moments_neutral!","text":"update velocity moments that are calculable from the evolved neutral pdf\n\n\n\n\n\n","category":"method"},{"location":"zz_time_advance/#moment_kinetics.time_advance.update_solution_vector!-NTuple{8, Any}","page":"time_advance","title":"moment_kinetics.time_advance.update_solution_vector!","text":"update the vector containing the pdf and any evolved moments of the pdf for use in the Runge-Kutta time advance\n\n\n\n\n\n","category":"method"},{"location":"zz_energy_equation/#energy_equation","page":"energy_equation","title":"energy_equation","text":"","category":"section"},{"location":"zz_energy_equation/","page":"energy_equation","title":"energy_equation","text":"Modules = [moment_kinetics.energy_equation]","category":"page"},{"location":"zz_energy_equation/#moment_kinetics.energy_equation","page":"energy_equation","title":"moment_kinetics.energy_equation","text":"\n\n\n\n","category":"module"},{"location":"zz_energy_equation/#moment_kinetics.energy_equation.energy_equation!-NTuple{9, Any}","page":"energy_equation","title":"moment_kinetics.energy_equation.energy_equation!","text":"evolve the parallel pressure by solving the energy equation\n\n\n\n\n\n","category":"method"},{"location":"zz_energy_equation/#moment_kinetics.energy_equation.neutral_energy_equation!-NTuple{9, Any}","page":"energy_equation","title":"moment_kinetics.energy_equation.neutral_energy_equation!","text":"evolve the neutral parallel pressure by solving the energy equation\n\n\n\n\n\n","category":"method"},{"location":"zz_charge_exchange/#charge_exchange","page":"charge_exchange","title":"charge_exchange","text":"","category":"section"},{"location":"zz_charge_exchange/","page":"charge_exchange","title":"charge_exchange","text":"Modules = [moment_kinetics.charge_exchange]","category":"page"},{"location":"zz_charge_exchange/#moment_kinetics.charge_exchange","page":"charge_exchange","title":"moment_kinetics.charge_exchange","text":"\n\n\n\n","category":"module"},{"location":"zz_charge_exchange/#moment_kinetics.charge_exchange.charge_exchange_collisions_1V!-NTuple{11, Any}","page":"charge_exchange","title":"moment_kinetics.charge_exchange.charge_exchange_collisions_1V!","text":"update the evolved pdf for each ion and electron species to account for charge exchange collisions between ions and neutrals\n\n\n\n\n\n","category":"method"},{"location":"zz_charge_exchange/#moment_kinetics.charge_exchange.charge_exchange_collisions_single_species!-NTuple{14, Any}","page":"charge_exchange","title":"moment_kinetics.charge_exchange.charge_exchange_collisions_single_species!","text":"update the evolved pdf for a single species to account for charge exchange collisions with a single species of the opposite type; e.g., ions with neutrals or neutrals with ions\n\n\n\n\n\n","category":"method"},{"location":"zz_plot_sequence/#plot_sequence","page":"plot_sequence","title":"plot_sequence","text":"","category":"section"},{"location":"zz_plot_sequence/","page":"plot_sequence","title":"plot_sequence","text":"Modules = [plots_post_processing.plot_sequence]","category":"page"},{"location":"zz_plot_sequence/#plots_post_processing.plot_sequence","page":"plot_sequence","title":"plots_post_processing.plot_sequence","text":"\n\n\n\n","category":"module"},{"location":"zz_finite_differences/#finite_differences","page":"finite_differences","title":"finite_differences","text":"","category":"section"},{"location":"zz_finite_differences/","page":"finite_differences","title":"finite_differences","text":"Modules = [moment_kinetics.finite_differences]","category":"page"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences","page":"finite_differences","title":"moment_kinetics.finite_differences","text":"\n\n\n\n","category":"module"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.finite_difference_info","page":"finite_differences","title":"moment_kinetics.finite_differences.finite_difference_info","text":"Finite difference discretization\n\n\n\n\n\n","category":"type"},{"location":"zz_finite_differences/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, Any, moment_kinetics.finite_differences.finite_difference_info}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, adv_fac, not_spectral::finite_difference_info)\n\nCalculate the derivative of f using finite differences, with particular scheme specified by coord.fdoption; result stored in coord.scratch2d.\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.calculus.elementwise_derivative!-Tuple{Any, Any, moment_kinetics.finite_differences.finite_difference_info}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_derivative!","text":"elementwise_derivative!(coord, f, not_spectral::finite_difference_info)\n\nCalculate the derivative of f using 4th order centered finite differences; result stored in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.calculus.elementwise_second_derivative!-Tuple{Any, Any, moment_kinetics.finite_differences.finite_difference_info}","page":"finite_differences","title":"moment_kinetics.calculus.elementwise_second_derivative!","text":"elementwise_second_derivative!(coord, f, not_spectral::finite_difference_info)\n\nCalculate the second derivative of f using 2nd order centered finite differences; result stored in coord.scratch_2d.\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.centered_fourth_order!-Tuple{Matrix{Float64}, Vararg{Any, 5}}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_fourth_order!","text":"take the derivative of input function f and return as df using fourth-order, centered differences. input/output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.centered_second_order!-Tuple{Matrix{Float64}, Vararg{Any, 5}}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_second_order!","text":"take the derivative of input function f and return as df using second-order, centered differences. input/output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.centered_second_order!-Tuple{Vector{Float64}, Vararg{Any, 5}}","page":"finite_differences","title":"moment_kinetics.finite_differences.centered_second_order!","text":"take the derivative of input function f and return as df using second-order, centered differences. input/output df is 1D array of size n (full grid)\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.derivative_finite_difference!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.derivative_finite_difference!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.derivative_finite_difference!-NTuple{8, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.derivative_finite_difference!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.fd_check_option-Tuple{Any, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.fd_check_option","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.second_derivative_finite_difference!-Tuple{Matrix{Float64}, Vararg{Any, 5}}","page":"finite_differences","title":"moment_kinetics.finite_differences.second_derivative_finite_difference!","text":"Take the second derivative of input function f and return as df using second-order, centered differences. output array df is 2D array of size ngrid x nelement\n\n\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.upwind_first_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_first_order!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.upwind_second_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_second_order!","text":"\n\n\n\n","category":"method"},{"location":"zz_finite_differences/#moment_kinetics.finite_differences.upwind_third_order!-NTuple{7, Any}","page":"finite_differences","title":"moment_kinetics.finite_differences.upwind_third_order!","text":"\n\n\n\n","category":"method"},{"location":"external_sources_notes/#External-sources","page":"External sources","title":"External sources","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"Sometimes it is useful to have a source term for the plasma or neutrals (the S_i and S_n of Moment kinetic equations). The currently-implemented source term has the form of a Maxwellian with constant temperature and spatially-varying amplitude","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\nS_i = A_i(rz) frac1(pi)^32 (2 T_mathrmsourcei  m_i)^32 expleft( -frac(v_perp^2 + v_parallel^2)T_mathrmsourcei right) \nS_n = A_n(rz) frac1(pi)^32 (2 T_mathrmsourcen  m_n)^32 expleft( -frac(v_zeta^2 + v_r^2 + v_z^2)T_mathrmsourcen right)\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"or in 1V simulations that do not include v_perp, v_zeta, v_r dimensions","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\nS_i = A_i(rz) frac1sqrtpi sqrt2 T_mathrmsourcei  m_i expleft( -fracv_perp^2T_mathrmsourcei right) \nS_n = A_n(rz) frac1sqrtpi sqrt2 T_mathrmsourcen  m_n expleft( -fracv_z^2T_mathrmsourcen right)\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The sources are controlled by options in the [ion_source] and [neutral_source] sections of the input file. The source terms are enabled by setting active = true. The constant temperature is set with the source_T option (default is 1 for ions and T_mathrmwall for neutrals). The amplitude can be set or controlled in various ways depending on the source_type setting, as explained in the following subsection.","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"Note that all the settings mentioned below have values given in normalised units (in the same way as the settings for initial profiles, etc.).","category":"page"},{"location":"external_sources_notes/#Amplitude","page":"External sources","title":"Amplitude","text":"","category":"section"},{"location":"external_sources_notes/#Fixed-amplitude-(default)","page":"External sources","title":"Fixed amplitude (default)","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"When source_type = \"Maxwellian\" (the default), the amplitude of the source is fixed in time and controled by the profile options. The profile has the form","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"A(rz) = A_0 R(r) Z(z)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"where A_0 is given by the source_strength option. R(r) and Z(z) are controlled by the r_profile and z_profile options respectively. The available options for either are the same, so letting x stand for either of r or z, and X for the corresponding R or Z:","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"x_profile = \"constant\" (the default) means X(x)=1.\nx_profile = \"gaussian\" means   X(x) = (1 - X_mathrmmin) expleft( -left(fracxwright)^2 right) + X_mathrmmin   where X_mathrmmin is set by x_relative_minimum and w is set by   x_width.\nx_profile = \"parabolic\" means   P(x) = left( 1 - left(frac2xwright)^2 right),    X(x) = (1 - X_mathrmmin) H(P(x)) P(x) + X_mathrmmin   where X_mathrmmin is set by x_relative_minimum and w is set by   x_width. The effect of the step function H is to let the profile be a   quadratic in the range -w2  x  w2, but equal to a floor (by default   0, so that the source is just not allowed to become negative) outside that   range.","category":"page"},{"location":"external_sources_notes/#Midpoint-density-controller","page":"External sources","title":"Midpoint density controller","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"When source_type = \"density_midpoint_control\" a PI controller (Wikipedia) is used to control the ion/neutral density. The 'midpoint' for the purposes of this controller is the point on the grid where r=0 and z=0 (there must be a grid point there).","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The spatial profile of the source (R(r) and Z(z)) is set in the same way as for the 'Fixed amplitude' source (see above), but now the prefactor changes with time","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"A(rz) = A_0(t) R(r) Z(z)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The prefactor A_0(t) is controlled to set the midpoint density to some value n(r=0z=0)rightarrow n_mathrmPI where n_mathrmPI is set by PI_density_target_amplitude. Specifically,","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\n  A_0(t) = mathttmaxleft(P(n_mathrmPI - n(r=0z=0)) + iota(t) 0right) \n  fracpartial iotapartial t = I(n_mathrmPI - n(r=0z=0))\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The 'proportional' coefficient P is set by PI_density_controller_P and the 'integral' coefficient I is set by PI_density_controller_I. The mathrmmax(ldots0) is to ensure that the 'source term' is never negative (i.e. a sink), to avoid the possibility of driving the system towards negative density.","category":"page"},{"location":"external_sources_notes/#Density-profile-controller","page":"External sources","title":"Density profile controller","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"When source_type = \"density_profile_control\" a PI controller (Wikipedia) is used to control the ion/neutral density profile.","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The target profile is","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"n_mathrmPI(rz) = n_mathrmPI0 R(r) Z(z)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"where n_mathrmPI0 is set by PI_density_target_amplitude and R(r) and Z(z) are set as described in Fixed amplitude (default).","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The source amplitude A(rz) is controlled to set the density profile to n(rz)rightarrow n_mathrmPI(rz). Specifically,","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\n  A(rz) = mathttmaxleft(P(n_mathrmPI(rz) - n(rz)) + iota(trz) 0right) \n  fracpartial iota(trz)partial t = I(n_mathrmPI(rz) - n(rz))\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The 'proportional' coefficient P is set by PI_density_controller_P and the 'integral' coefficient I is set by PI_density_controller_I. The mathrmmax(ldots0) is to ensure that the 'source term' is never negative (i.e. a sink), to avoid the possibility of driving the system towards negative density.","category":"page"},{"location":"external_sources_notes/#Recycling","page":"External sources","title":"Recycling","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The source of neutrals can be set so that some fraction of the flux of ions to the walls is recycled into the volume of the domain as neutrals by using the source_type = \"recycling\" option.","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"The profile is set up whose spatial integral is 1","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"A(rz) = A_0 R(r) Z(z)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"where A_0 = leftint drdz R(r) Z(z)right^-1 and R(r) and Z(z) are set as described in Fixed amplitude (default). The source is","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"S_n(trz) = F(t) A(rz)","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"where F(t) is the sum of the integrated ion flux to the lower and upper targets.","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"warning: Warning\nThe target flux calculated for this controller does not account for magnetic field lines that are not perpendicular to the wall, or for drifts to the target, so needs updating (within moment_kinetics.external_sources.external_neutral_source_controller!) to be used in 2D simulations.","category":"page"},{"location":"external_sources_notes/#Energy-source","page":"External sources","title":"Energy source","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"When source_type = \"energy\", rather than just adding particles with temperature T_mathrmsources, the existing plasma or neutrals in the domain are swapped with plasma/neutrals from a Maxwellian with T_mathrmsources, so that the density is unchanged, but energy is added (or potentially removed if the plasma/neutrals are hotter than T_mathrmsources).","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\nS_i = A_i(rz) left frac1(pi)^32 (2 T_mathrmsourcei  m_i)^32 expleft( -frac(v_perp^2 + v_parallel^2)T_mathrmsourcei - f_i(v_perp v_parallel) right) right \nS_n = A_n(rz) left frac1(pi)^32 (2 T_mathrmsourcen  m_n)^32 expleft( -frac(v_zeta^2 + v_r^2 + v_z^2)T_mathrmsourcen - f_n(v_zeta v_r v_z) right) right\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"or in 1V simulations","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"beginalign\nS_i = A_i(rz) left frac1sqrtpi sqrt2 T_mathrmsourcei  m_i expleft( -fracv_perp^2T_mathrmsourcei - f_i(v_parallel) right) right \nS_n = A_n(rz) left frac1sqrtpi sqrt2 T_mathrmsourcen  m_n expleft( -fracv_z^2T_mathrmsourcen - f_n(v_z) right) right\nendalign","category":"page"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"Note that this source does not give a fixed power input (although that might be a nice feature to have), it just swaps plasma/neutral particles at a constant rate.","category":"page"},{"location":"external_sources_notes/#API","page":"External sources","title":"API","text":"","category":"section"},{"location":"external_sources_notes/","page":"External sources","title":"External sources","text":"See external_sources.","category":"page"},{"location":"zz_r_advection/#r_advection","page":"r_advection","title":"r_advection","text":"","category":"section"},{"location":"zz_r_advection/","page":"r_advection","title":"r_advection","text":"Modules = [moment_kinetics.r_advection]","category":"page"},{"location":"zz_r_advection/#moment_kinetics.r_advection","page":"r_advection","title":"moment_kinetics.r_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_r_advection/#moment_kinetics.r_advection.adjust_advection_speed!-NTuple{5, Any}","page":"r_advection","title":"moment_kinetics.r_advection.adjust_advection_speed!","text":"\n\n\n\n","category":"method"},{"location":"zz_r_advection/#moment_kinetics.r_advection.r_advection!-NTuple{14, Any}","page":"r_advection","title":"moment_kinetics.r_advection.r_advection!","text":"do a single stage time advance (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"zz_r_advection/#moment_kinetics.r_advection.unnormalize_pdf!-NTuple{6, Any}","page":"r_advection","title":"moment_kinetics.r_advection.unnormalize_pdf!","text":"\n\n\n\n","category":"method"},{"location":"zz_r_advection/#moment_kinetics.r_advection.update_speed_r!-NTuple{11, Any}","page":"r_advection","title":"moment_kinetics.r_advection.update_speed_r!","text":"calculate the advection speed in the r-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"moment_kinetic_equations/#Moment-kinetic-equations","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The following are partial notes on the derivation of the equations being solved by moment_kinetics. It would be useful to expand them with more details from the Excalibur/Neptune reports. Equation references give the report number and equation number, e.g. (TN-04;1) is equation (1) from report TN-04.pdf.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The drift kinetic equation (DKE), marginalised over v_perp, for ions is, adding ionization and a source term to the form in (TN-04;1),","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial f_ipartial t\n  +v_fracpartial f_ipartial z\n  -fracemfracpartialphipartial zfracpartial f_ipartial v_\n  = -R_mathrminleft(n_nf_i-n_if_nright)+R_mathrmionn_if_n\n    + S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and for neutrals, adding ionization and a source term to (TN-04;2)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial f_npartial t\n  +v_fracpartial f_npartial z\n  = -R_mathrminleft(n_if_n-n_nf_iright)-R_mathrmionn_if_n\n    + S_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Using the normalizations (TN04;5-11)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  tildef_s  doteq f_sfracc_ssqrtpiN_e\n  tildet  doteq tfracc_sL_z\n  tildez  doteqfraczL_z\n  tildev_  doteqfracv_c_s\n  tilden_s  doteqfracn_sN_e\n  tildephi  doteqfracephiT_e\n  tildeR_mathrmin  doteq R_mathrminfracN_eL_zc_s\n  tildeR_mathrmion  doteq R_mathrmionfracN_eL_zc_s\n  tildeS_i = S_i fracc_ssqrtpiN_e fracL_zc_s = S_i fracL_zsqrtpiN_e\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"with c_sdoteqsqrt2T_em_s where L_z, N_e and T_e are constant reference parameters, the ion DKE is","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartialtildef_ipartialtildet\n  + tildev_fracpartialtildef_ipartialtildez\n  - frac12fracpartialtildephipartialtildez\n    fracpartialtildef_ipartialtildev_\n  = -tildeR_inleft(tilden_ntildef_i-tilden_itildef_nright)\n    + tildeR_mathrmiontilden_itildef_n\n    + tildeS_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and the neutral DKE is","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartialtildef_npartialtildet\n  + v_fracpartialtildef_npartialtildez\n  = -tildeR_inleft(tilden_itildef_n-tilden_ntildef_iright)\n    - tildeR_mathrmiontilden_itildef_n\n    + tildeS_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/#Moment-equations","page":"Moment kinetic equations","title":"Moment equations","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Recalling the definitions (TN-04;15,29,63-66), but writing the integral in the energy equation over tildev_ instead of w_,","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  tilden_s\n   = frac1sqrtpiint dtildev_tildef_s\n\n  tilden_stildeu_s\n   = frac1sqrtpiint dtildev_tildev_tildef_s\n\n  tildep_s\n   = frac1sqrtpiint dtildev_left(tildev_\n      - tildeu_sright)^2tildef_s\n    = int dtildev_tildev_^2tildef_s\n      - tilden_stildeu_s^2\n\n  tildeq_s\n   = frac1sqrtpiint dtildev_\n      left(tildev_-tildeu_sright)^3tildef_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  tildeq_s\n    = frac1sqrtpiint dtildev_tildev_^3tildef_s\n       - 3tildeu_sfrac1sqrtpiint dv_v_^2f_s\n       + 3u_s^2frac1sqrtpiint dv_v_f_s\n       - u_s^3frac1sqrtpiint dv_f_s \n\n    = frac1sqrtpiint dtildev_tildev_^3tildef_s\n       - 3tildeu_sleft(tildep_s+tilden_stildeu_s^2right)\n       + 3tildeu_s^2tilden_stildeu_s-tildeu_s^3tilden_s\nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  tildeq_s\n    = frac1sqrtpiint dtildev_tildev_^3tildef_s\n       - 3tildeu_stildep_s\n       - tilden_stildeu_s^3\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"we can take moments of the ion DKE to give ion moment equations (dropping tildes from here on)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial n_ipartial t+fracpartialleft(n_iu_iright)partial z\n   = -R_inleft(n_nn_i-n_in_nright)+R_mathrmionn_in_n\n      + int dv_parallel S_i\n\n   = R_mathrmionn_in_n + int dv_parallel S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartialleft(n_iu_iright)partial t + fracpartialleft(p_i\n  + n_iu_i^2right)partial z + frac12fracpartialphipartial zn_i\n  = -R_inleft(n_nn_iu_i - n_in_nu_nright)\n    + R_mathrmionn_in_nu_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  n_ifracpartial u_ipartial t + u_ifracpartial n_ipartial t\n  + fracpartial p_ipartial z\n  + u_ifracpartialleft(n_iu_iright)partial z\n  + n_iu_ifracpartial u_ipartial z\n  + frac12fracpartialphipartial zn_i\n   = -R_inleft(n_nn_iu_i - n_in_nu_nright)\n      + R_mathrmionn_in_nu_n \n\n  n_ifracpartial u_ipartial t\n  + u_ileft(R_mathrmionn_in_n + int dv_parallel S_iright)\n  + fracpartial p_ipartial z + n_iu_ifracpartial u_ipartial z\n  + frac12fracpartialphipartial zn_i\n   = -R_inleft(n_nn_iu_i - n_in_nu_nright)\n      + R_mathrmionn_in_nu_n \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial u_ipartial t + frac1n_ifracpartial p_ipartial z\n  + u_ifracpartial u_ipartial z + frac12fracpartialphipartial z\n  = -R_inn_nleft(u_i-u_nright)\n    + R_mathrmionfracn_in_nn_sleft(u_n-u_iright)\n    - fracu_in_i int dv_parallel S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartialleft(p_i + n_iu_i^2right)partial t\n    + fracpartialleft(q_i + 3u_ip_i\n    + n_iu_i^3right)partial z + fracpartialphipartial zn_iu_i \n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n      - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n+n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial p_ipartial t\n  + frac1n_ifracpartialleft(n_iu_iright)^2partial t\n  - fracleft(n_iu_iright)^2n_i^2fracpartial n_ipartial t\n  + fracpartialleft(q_i + 3u_ip_i\n  + n_iu_i^3right)partial z + fracpartialphipartial zn_iu_i\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n                   - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_i \n\n  fracp_ipartial t + 2u_ifracpartial n_iu_ipartial t\n  - u_i^2fracpartial n_ipartial t + fracpartialleft(q_i\n  + 3u_ip_i + n_iu_i^3right)partial z\n  + fracpartialphipartial zn_iu_i\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n      - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_i \n\n  fracpartial p_ipartial t + 2u_ileft(-fracpartial p_ipartial z\n  - fracpartialleft(n_iu_i^2right)partial z\n  - frac12fracpartialphipartial zn_i\n  - R_inleft(n_nn_iu_i - n_in_nu_nright)\n  + R_mathrmionn_in_nu_nright) \n  -u_i^2left(-fracpartialleft(n_iu_iright)partial z\n  + R_mathrmionn_in_n + int dv_parallel S_iright)\n  + fracpartial q_ipartial z\n  + fracpartialleft(3u_ip_iright)partial z\n  + fracpartialleft(n_iu_i^3right)partial z\n  + fracpartialphipartial zn_iu_i\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right)\n      - n_ileft(p_n + n_nu_n^2right)right)\n      + R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_i \n\n  fracpartial p_ipartial t + u_ifracpartial p_ipartial z\n  + 3p_ifracpartial u_ipartial z + fracpartial q_ipartial z\n   = -R_inleft(n_nleft(p_i + n_iu_i^2right) - n_ileft(p_n\n      + n_nu_n^2right) - 2u_ileft(n_nn_iu_i - n_in_nu_nright)right) \n       quad + R_mathrmionn_ileft(p_n + n_nu_n^2 + n_nu_i^2\n      - 2n_nu_iu_nright)\n      + int dv_parallel v_parallel^2 S_i + u_i^2 int dv_parallel S_i \n\n  fracpartial p_ipartial t + u_ifracpartial p_ipartial z\n  + 3p_ifracpartial u_ipartial z + fracpartial q_ipartial z\n   = -R_inleft(n_np_i - n_ip_n - n_in_nleft(u_i^2 + u_n^2\n      - 2u_iu_nright)right) + R_mathrmionn_ileft(p_n + n_nleft(u_n\n      - u_iright)^2right) \n       quad + int dv_parallel v_parallel^2 S_i + u_i^2 int dv_parallel S_i \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial p_ipartial t + u_ifracpartial p_ipartial z\n    + 3p_ifracpartial u_ipartial z + fracpartial q_ipartial z \n   = -R_inleft(n_np_i - n_ip_n\n      - n_in_nleft(u_i - u_nright)^2right)\n      + R_mathrmionn_ileft(p_n + n_nleft(u_n - u_iright)^2right) \n       quad + int dv_parallel v_parallel^2 S_i + u_i^2 int dv_parallel S_i \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and of the neutral DKE to give neutral moment equations","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial n_npartial t + fracpartialleft(n_nu_nright)partial z\n   = -R_ileft(n_in_n - n_nn_iright) - R_mathrmionn_in_n\n      + int dv_parallel S_n \n\n   =-R_mathrmionn_in_n + int dv_parallel S_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartialleft(n_nu_nright)partial t\n  + fracpartialleft(p_n + n_nu_n^2right)partial z\n  = -R_inleft(n_in_nu_n - n_nn_iu_iright)\n    - R_mathrmionn_in_nu_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  n_nfracpartial u_npartial t + u_nfracpartial n_npartial t\n  + fracpartial p_npartial z\n  + u_nfracpartialleft(n_nu_nright)partial z\n  + n_nu_nfracpartial u_npartial z\n   = -R_inleft(n_in_nu_n - n_nn_iu_iright)\n      - R_mathrmionn_in_nu_n \n\n  n_nfracpartial u_npartial t\n  + u_nleft(-R_mathrmionn_in_n + int dv_parallel S_nright)\n  + fracpartial p_npartial z\n  + n_nu_sfracpartial u_npartial z\n   = -R_inleft(n_in_nu_n - n_nn_iu_iright)\n      - R_mathrmionn_in_nu_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial u_npartial t + frac1n_nfracpartial p_npartial z\n  + u_nfracpartial u_npartial z\n  = -R_inn_ileft(u_n - u_iright) - fracu_nn_n int dv_parallel S_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartialleft(p_n + n_nu_n^2right)partial t\n    + fracpartialleft(q_n + 3u_np_n\n    + n_nu_n^3right)partial z + q_nfracpartialphipartial zn_nu_n \n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right)right)\n      - R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial p_npartial t\n  + frac1n_nfracpartialleft(n_nu_nright)^2partial t\n  - fracleft(n_nu_nright)^2n_n^2fracpartial n_npartial t\n  + fracpartialleft(q_n + 3u_np_n + n_nu_n^3right)partial z\n  + q_nfracpartialphipartial zn_nu_n\n   =-R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right)right)\n      - R_mathrmionn_ileft(p_n + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_n \n\n  fracpartial p_npartial t + 2u_nfracpartial n_nu_npartial t\n  - u_n^2fracpartial n_npartial t + fracpartialleft(q_n\n  + 3u_np_n + n_nu_n^3right)partial z\n  + q_nfracpartialphipartial zn_nu_n\n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right)right) - R_mathrmionn_ileft(p_n\n      + n_nu_n^2right)\n      + int dv_parallel v_parallel^2 S_n \n\n  fracpartial p_npartial t\n  + 2u_nleft(-fracpartial p_npartial z\n  - fracpartialleft(n_nu_n^2right)partial z\n  - fracq_n2fracpartialphipartial zn_n\n  - R_inleft(n_in_nu_n - n_nn_iu_iright)\n  - R_mathrmionn_in_nu_nright) \n  - u_n^2left(-fracpartialleft(n_nu_nright)partial z\n  - R_mathrmionn_in_n + int dv_parallel S_nright)\n  + fracpartial q_npartial z\n  + fracpartialleft(3u_np_nright)partial z\n  + fracpartialleft(n_nu_n^3right)partial z\n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n  + n_iu_i^2right)right)\n  - R_mathrmionn_ileft(p_n + n_nu_n^2right)\n  + int dv_parallel v_parallel^2 S_n \n\n  fracpartial p_npartial t + u_nfracpartial p_npartial z\n  + 3p_nfracpartial u_npartial z + fracpartial q_npartial z\n   = -R_inleft(n_ileft(p_n + n_nu_n^2right) - n_nleft(p_i\n      + n_iu_i^2right) - 2u_nleft(n_in_nu_n\n      - n_nn_iu_iright)right) - R_mathrmionn_ileft(p_n\n      + n_nu_n^2 + n_nu_n^2 - 2n_nu_nu_nright)\n      + int dv_parallel v_parallel^2 S_n + u_n^2int dv_parallel S_n \n\n  fracpartial p_npartial t + u_nfracpartial p_npartial z\n  + 3p_nfracpartial u_npartial z + fracpartial q_npartial z\n   = -R_inleft(n_ip_n - n_np_i - n_nn_ileft(u_n^2 + u_i^2\n      - 2u_nu_iright)right) - R_mathrmionn_ip_n\n      + int dv_parallel v_parallel^2 S_n + u_n^2int dv_parallel S_n \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial p_npartial t + u_nfracpartial p_npartial z\n    + 3p_nfracpartial u_npartial z + fracpartial q_npartial z \n   = -R_inleft(n_ip_n - n_np_i\n      - n_nn_ileft(u_n - u_iright)^2right) - R_mathrmionn_ip_n \n       quad + int dv_parallel v_parallel^2 S_n + u_n^2int dv_parallel S_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/#Kinetic-equation","page":"Moment kinetic equations","title":"Kinetic equation","text":"","category":"section"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"For the moment-kinetic equation for the normalized distribution function","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\ng_s(w_s) = fracv_mathrmthsn_sf_s(v_(w_s))\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"we transform to the normalized velocity coordinate","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\nw_s = fracv_ - u_sv_mathrmths\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"The derivatives transform as","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  leftfracpartial f_spartial tright_zv\n   rightarrowleftfracpartial f_spartial tright_zw\n               - frac1v_mathrmthsfracpartial u_spartial tleftfracpartial f_spartial w_sright_zw\n               - fracw_sv_mathrmthsfracpartial v_mathrmthspartial tleftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial zright_zv\n   rightarrowleftfracpartial f_spartial zright_zw\n               - frac1v_mathrmthsfracpartial u_spartial zleftfracpartial f_spartial w_sright_zw\n               - fracw_sv_mathrmthsfracpartial v_mathrmthspartial zleftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial v_right_zv\n   rightarrowfrac1v_mathrmthsleftfracpartial f_spartial w_sright_zw\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"We use an energy equation that evolves p_s not v_mathrmths, so use","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  v_mathrmths^2  = 2fracp_sn_s \n\n  Rightarrow v_mathrmthsfracpartial v_mathrmthspartial t\n   = frac1n_sfracpartial p_spartial t\n      - fracp_sn_s^2fracpartial n_spartial t\n\n  v_mathrmthsfracpartial v_mathrmthspartial z\n   = frac1n_sfracpartial p_spartial z\n      - fracp_sn_s^2fracpartial n_spartial z\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"to convert the transformations above to","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  leftfracpartial f_spartial tright_zv\n   rightarrowleftfracpartial f_spartial tright_zw\n    - frac1v_mathrmthsfracpartial u_spartial tleftfracpartial f_spartial w_sright_zw\n    - fracw_sv_mathrmths^2left(frac1n_sfracpartial p_spartial t\n    - fracp_sn_s^2fracpartial n_spartial tright)leftfracpartial f_spartial w_sright_zw\n\n   = leftfracpartial f_spartial tright_zw\n      - frac1v_mathrmthsfracpartial u_spartial tleftfracpartial f_spartial w_sright_zw\n      - fracw_s2left(frac1p_sfracpartial p_spartial t\n      - frac1n_sfracpartial n_spartial tright)leftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial zright_zv\n   rightarrowleftfracpartial f_spartial zright_zw\n    - frac1v_mathrmthsfracpartial u_spartial zleftfracpartial f_spartial w_sright_zw\n    - fracw_sv_mathrmths^2left(frac1n_sfracpartial p_spartial z\n    - fracp_sn_s^2fracpartial n_spartial zright)leftfracpartial f_spartial w_sright_zw\n\n   = leftfracpartial f_spartial zright_zw\n      - frac1v_mathrmthsfracpartial u_spartial zleftfracpartial f_spartial w_sright_zw\n      - fracw_s2left(frac1p_sfracpartial p_spartial z\n      - frac1n_sfracpartial n_spartial zright)leftfracpartial f_spartial w_sright_zw\n\n  leftfracpartial f_spartial v_right_zv\n   rightarrowfrac1v_mathrmthsleftfracpartial f_spartial w_sright_zw\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Using these transformations gives the ion DKE in a form similar to (TN-04;55) (but writing out dotw_ in full here, and not using the moment equations for the moment)","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_ipartial t\n    - frac1v_mathrmthifracpartial u_ipartial tfracpartial f_ipartial w_i\n    - fracw_i2left(frac1p_ifracpartial p_ipartial t\n    - frac1n_ifracpartial n_ipartial tright)fracpartial f_ipartial w_i \n   + left(v_mathrmthiw_i + u_iright)left(fracpartial f_ipartial z\n    - frac1v_mathrmthifracpartial u_ipartial zfracpartial f_ipartial w_i\n    - fracw_i2left(frac1p_ifracpartial p_ipartial z\n    - frac1n_ifracpartial n_ipartial zright)fracpartial f_ipartial w_iright) \n   - frac12v_mathrmthifracpartialphipartial zfracpartial f_ipartial w_i \n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n + S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial f_ipartial t + left(v_mathrmthiw_i\n  + u_iright)fracpartial f_ipartial z\n  - frac1v_mathrmthifracpartial u_ipartial tfracpartial f_ipartial w_i\n  - fracw_i2left(frac1p_ifracpartial p_ipartial t\n  - frac1n_ifracpartial n_ipartial tright)fracpartial f_ipartial w_i\n  + left(v_mathrmthiw_i\n  + u_iright)left(-frac1v_mathrmthifracpartial u_ipartial zfracpartial f_ipartial w_i\n  - fracw_i2left(frac1p_ifracpartial p_ipartial z\n  - frac1n_ifracpartial n_ipartial zright)fracpartial f_ipartial w_iright)\n  - frac12v_mathrmthifracpartialphipartial zfracpartial f_ipartial w_i\n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n + S_i \n\n  fracpartial f_ipartial t + left(v_mathrmthiw_i\n  + u_iright)fracpartial f_ipartial z\n  + left-frac1v_mathrmthifracpartial u_ipartial t\n  - fracw_i2left(frac1p_ifracpartial p_ipartial t\n  - frac1n_ifracpartial n_ipartial tright)\n  + left(v_mathrmthiw_i\n  + u_iright)left(-frac1v_mathrmthifracpartial u_ipartial z\n  - fracw_i2left(frac1p_ifracpartial p_ipartial z\n  - frac1n_ifracpartial n_ipartial zright)right)\n  - frac12v_mathrmthifracpartialphipartial zrightfracpartial f_ipartial w_i\n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n + S_i \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_ipartial t + left(v_mathrmthiw_i\n    + u_iright)fracpartial f_ipartial z \n   + left-frac1v_mathrmthileft(fracpartial u_ipartial t\n    + left(v_mathrmthiw_i + u_iright)fracpartial u_ipartial z\n    + frac12fracpartialphipartial zright)right \n   qquad - fracw_i2frac1p_ileft(fracpartial p_ipartial t\n          + left(v_mathrmthiw_i + u_iright)fracpartial p_ipartial zright) \n   qquad + fracw_i2frac1n_ileft(fracpartial n_ipartial t\n          + left(v_mathrmthiw_i\n          + leftu_iright)fracpartial n_ipartial zright)rightfracpartial f_ipartial w_i \n   = -R_inleft(n_nf_i - n_if_nright) + R_mathrmionn_if_n + S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and the neutral DKE","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_npartial t\n    - frac1v_mathrmthnfracpartial u_npartial tfracpartial f_npartial w_n\n    - fracw_n2left(frac1p_nfracpartial p_npartial t\n    - frac1n_nfracpartial n_npartial tright)fracpartial f_npartial w_n \n   + left(v_mathrmthnw_n + u_nright)left(fracpartial f_npartial z\n    - frac1v_mathrmthnfracpartial u_npartial zfracpartial f_npartial w_n\n    - fracw_n2left(frac1p_nfracpartial p_npartial z\n    - frac1n_nfracpartial n_npartial zright)fracpartial f_npartial w_nright) \n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n + S_n \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial f_npartial t + left(v_mathrmthnw_n\n  + u_nright)fracpartial f_npartial z\n  - frac1v_mathrmthnfracpartial u_npartial tfracpartial f_npartial w_n\n  - fracw_n2left(frac1p_nfracpartial p_npartial t\n  - frac1n_nfracpartial n_npartial tright)fracpartial f_npartial w_n\n  + left(v_mathrmthnw_n\n  + u_nright)left(-frac1v_mathrmthnfracpartial u_npartial zfracpartial f_npartial w_n\n  - fracw_n2left(frac1p_nfracpartial p_npartial z\n  - frac1n_nfracpartial n_npartial zright)fracpartial f_npartial w_nright)\n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n + S_n \n\n  fracpartial f_npartial t + left(v_mathrmthnw_n\n  + u_nright)fracpartial f_npartial z\n  + left-frac1v_mathrmthnfracpartial u_npartial t\n  - fracw_n2left(frac1p_nfracpartial p_npartial t\n  - frac1n_nfracpartial n_npartial tright) + left(v_mathrmthnw_n\n  + u_nright)left(-frac1v_mathrmthnfracpartial u_npartial z\n  - fracw_n2left(frac1p_nfracpartial p_npartial z\n  - frac1n_nfracpartial n_npartial zright)right)rightfracpartial f_npartial w_n\n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n + S_n \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial f_npartial t + left(v_mathrmthnw_n\n    + u_nright)fracpartial f_npartial z \n   + left-frac1v_mathrmthnleft(fracpartial u_npartial t\n    + left(v_mathrmthnw_n+u_nright)fracpartial u_npartial zright)right \n   qquad - fracw_n2frac1p_nleft(fracpartial p_npartial t\n           + left(v_mathrmthnw_n + u_nright)fracpartial p_npartial zright) \n   qquad + leftfracw_n2frac1n_nleft(fracpartial n_npartial t\n           + left(v_mathrmthnw_n\n           + u_nright)fracpartial n_npartial zright)rightfracpartial f_npartial w_n \n   = -R_inleft(n_if_n - n_nf_iright) - R_mathrmionn_if_n + S_n\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"We also normalise f and write the DKEs for","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  g_s  =fracv_mathrmthsn_sf_s \n\n  Rightarrowfracpartial f_spartial t\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n  + fracg_sv_mathrmthsfracpartial n_spartial t\n  - fracn_sg_sv_mathrmths^2fracpartial v_mathrmthspartial t \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracpartial f_spartial t\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n      + fracg_sv_mathrmthsfracpartial n_spartial t\n      - fracn_sg_sv_mathrmths^3left(frac1n_sfracpartial p_spartial t\n      - fracp_sn_s^2fracpartial n_spartial tright) \n\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n      + fracg_sv_mathrmthsfracpartial n_spartial t\n      - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial t\n      + fracg_s2v_mathrmthsfracpartial n_spartial t \nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  fracpartial f_spartial t\n   = fracn_sv_mathrmthsfracpartial g_spartial t\n      + frac3g_s2v_mathrmthsfracpartial n_spartial t\n      - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial t \n\n  fracpartial f_spartial w_s\n   = fracn_sv_mathrmthsfracpartial g_spartial w_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"For brevity, do the following manipulations for g_s rather than for ions and neutrals separately by using q_i=1, q_n=0 and with the +'ve sign for the ion DKE and -'ve sign for the neutral DKE.","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracn_sv_mathrmthsfracpartial g_spartial t\n  + frac3g_s2v_mathrmthsfracpartial n_spartial t\n  - fracg_sn_s2v_mathrmthsp_sfracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial f_spartial z \n   + left-frac1v_mathrmthsleft(fracpartial u_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial u_spartial z\n  + fracq_s2fracpartialphipartial zright)right \n   qquad - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright) \n   qquad + leftfracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracn_sv_mathrmthsfracpartial g_spartial w_s \n   = -R_ssleft(n_sfracn_sv_mathrmthsg_s\n      - n_sfracn_sv_mathrmthsg_sright)\n      pm R_mathrmionn_ifracn_nv_mathrmthng_n\n      + S_s \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t \n   + left-frac1v_mathrmthsleft(fracpartial u_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial u_spartial z\n  + fracq_s2fracpartialphipartial zright)\n  - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright)\n  + fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s \n\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t \n   + left-frac1v_mathrmthsleft(fracn_sn_sfracpartial u_spartial t\n  + fracn_sn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial u_spartial z\n  + fracu_sn_sleft(fracpartial npartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial npartial zright)\n  + fracq_s2fracpartialphipartial zright)\n  + fracu_sn_sv_mathrmthsleft(fracpartial npartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial npartial zright)\n  - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright)\n  + fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t \n   + left-frac1n_sv_mathrmthsleft(fracpartial n_su_spartial t\n  + left(v_mathrmthsw_s + u_sright)left(n_sfracpartial u_spartial z\n  + u_sfracpartial n_spartial zright)\n  + fracq_s2n_sfracpartialphipartial zright)right \n   qquad + fracu_sn_sv_mathrmthsleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial n_spartial zright)\n  - fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + left(v_mathrmthsw_s + u_sright)fracpartial p_spartial zright) \n   qquad left+ fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + left(v_mathrmthsw_s\n  + u_sright)fracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"So then if we use the moment equations we can rewrite the DKE as","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sfracpartial n_spartial t\n  - fracg_s2p_sfracpartial p_spartial t \n   + left-frac1n_sv_mathrmthsleft(fracpartial n_su_spartial t\n  + u_sleft(n_sfracpartial u_spartial z\n  + u_sfracpartial n_spartial zright)\n  - frac12n_sE_\n  + v_mathrmthsw_sleft(n_sfracpartial u_spartial z\n  + u_sfracpartial n_spartial zright)right)right \n   qquad + fracu_sn_sv_mathrmthsleft(fracpartial n_spartial t\n  + u_sfracpartial n_spartial z\n  + v_mathrmthsw_sfracpartial n_spartial zright) \n   qquad-fracw_s2frac1p_sleft(fracpartial p_spartial t\n  + u_sfracpartial p_spartial z\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   qquadleft + fracw_s2frac1n_sleft(fracpartial n_spartial t\n  + u_sfracpartial n_spartial z\n  + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s \nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  - u_sfracpartial n_spartial z\n  - n_sfracpartial u_spartial zright) \n   -fracg_s2p_sleft(-u_sfracpartial p_spartial z\n  - fracpartial q_spartial z\n  - 3p_sfracpartial u_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n - u_sright)^2right)\n  + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s right) \n   + left-frac1n_sv_mathrmthsleft(-underbracecanceln_su_sfracpartial u_spartial z_A\n  - fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)\n  pm R_mathrmionn_in_nu_n\n  + v_mathrmthsw_sleft(underbracecanceln_sfracpartial u_spartial z_B\n  + underbracecancelu_sfracpartial n_spartial z_Cright)right)right \n   quad + fracu_sn_sv_mathrmthsleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  - underbracecanceln_sfracpartial u_spartial z_A\n  + underbracecancelv_mathrmthsw_sfracpartial n_spartial z_Cright) \n   quad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - underbracecancel3p_sfracpartial u_spartial z_B\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n\n  - u_sright)^2right) + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   quadleft + fracw_s2frac1n_sleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  - underbracecanceln_sfracpartial u_spartial z_B\n  + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s \n\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + frac3g_s2n_sleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  - u_sfracpartial n_spartial z - n_sfracpartial u_spartial zright) \n   -fracg_s2p_sleft(-u_sfracpartial p_spartial z\n  - fracpartial q_spartial z - 3p_sfracpartial u_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n - u_sright)^2right)\n  + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_sright) \n   + left-frac1n_sv_mathrmthsleft(-fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)pm R_mathrmionn_in_nu_nright)right \n   quad + fracu_sn_sv_mathrmthsleft(pm R_mathrmionn_in_n + int dv_parallel S_sright) \n   quad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - m_sn_sn_sleft(u_s - u_sright)^2right)\n  pm R_mathrmionn_ileft(p_n + m_sn_nleft(u_n\n  - u_sright)^2right) + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   quadleft + fracw_s2frac1n_sleft(pm R_mathrmionn_in_n + int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n\n      + fracv_mathrmthsn_s S_s\n\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + g_sleft(pmfrac32R_mathrmionn_ifracn_nn_s\n  + frac32n_sint dv_parallel S_s\n  - frac3u_s2n_sfracpartial n_spartial zright) \n   + g_sleft(fracu_s2p_sfracpartial p_spartial z\n  + frac12p_sfracpartial q_spartial z\n  + frac12p_sR_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right)\n  mpfrac12R_mathrmionfracn_ip_sleft(p_n\n  + n_nleft(u_n - u_sright)^2right)\n  - frac12p_parallelsint dv_parallel v_parallel^2 S_s - fracu_s^22p_parallelsint dv_parallel S_sright) \n   + left-frac1n_sv_mathrmthsleft(-fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)\n  pm R_mathrmionn_in_nleft(u_n - u_sright) - u_sint dv_parallel S_sright)right \n   quad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right)\n  + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   quadmpfracw_s2R_mathrmionn_ileft(fracp_np_s\n  - fracn_nn_s + fracn_np_sleft(u_n - u_sright)^2right) \n   quadleft + fracw_s2frac1n_sleft(int dv_parallel S_s + v_mathrmthsw_sfracpartial n_spartial zright)rightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n + fracv_mathrmthsn_s S_s\nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and finally using","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign*\n  fracu_sv_mathrmthsfracpartial v_mathrmthspartial z\n   =u_ssqrtfracn_sp_sfracpartialpartial zsqrtfracp_sn_s \n   = fracu_s2left(frac1p_sfracpartial p_spartial z\n      - frac1n_sfracpartial n_spartial zright)\nendalign*","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"gives","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"</details>","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_spartial t\n  + fracv_mathrmthsn_sleft(v_mathrmthsw_s\n  + u_sright)fracpartial f_spartial z\n  + left(pmfrac32R_mathrmionn_ifracn_nn_s\n  + frac32n_s int dv_parallel S_s\n  - fracu_sn_sfracpartial n_spartial zright)g_s \n   + left(fracu_sv_mathrmthsfracpartial v_mathrmthspartial z\n  + frac12p_sfracpartial q_spartial zright \n   qquad + frac12p_sR_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right) \n   qquad leftmpfrac12R_mathrmionfracn_ip_sleft(p_n\n  + n_nleft(u_n - u_sright)^2right)\n  - frac12p_parallelsint dv_parallel v_parallel^2 S_s - fracu_s^22p_parallelsint dv_parallel S_sright)g_s \n   + left-frac1n_sv_mathrmthsleft(-fracpartial p_spartial z\n  + R_ssn_sn_sleft(u_s - u_sright)\n  pm R_mathrmionn_in_nleft(u_n - u_sright) - u_sint dv_parallel S_sright)right \n   qquad-fracw_s2frac1p_sleft(-fracpartial q_spartial z\n  - R_ssleft(n_sp_s - n_sp_s\n  - n_sn_sleft(u_s - u_sright)^2right)\n  + int dv_parallel v_parallel^2 S_s + u_s^2 int dv_parallel S_s\n  + v_mathrmthsw_sfracpartial p_spartial zright) \n   qquadmpfracw_s2R_mathrmionn_ileft(fracp_np_s\n  - fracn_nn_s + fracn_np_sleft(u_n - u_sright)^2right) \n   qquadleft + fracw_parallels2frac1n_sint dv_parallel S_s\n  + fracw_s^22fracv_mathrmthsn_sfracpartial n_spartial zrightfracpartial g_spartial w_s \n   = -R_ssn_sleft(g_s - fracv_mathrmthsv_mathrmthsg_sright)\n      pm R_mathrmionfracv_mathrmthsn_sn_ifracn_nv_mathrmthng_n + fracv_mathrmthsn_s S_s\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"Writing out the final result fully for ions","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n   fracpartial g_ipartial t\n  + fracv_mathrmthin_ileft(v_mathrmthiw_i\n  + u_iright)fracpartial f_ipartial z\n  + left(frac32R_mathrmionn_n + frac32n_iint dv_parallel S_i\n  - fracu_in_ifracpartial n_ipartial zright)g_i \n   + left(fracu_iv_mathrmthifracpartial v_mathrmthipartial z\n  + frac12p_ifracpartial q_ipartial zright \n   qquad + frac12p_iR_inleft(n_np_i - n_ip_n\n  - n_in_nleft(u_i - u_nright)^2right) \n   qquad left - frac12R_mathrmionfracn_ip_ileft(p_n\n  + n_nleft(u_n - u_iright)^2right)\n  - frac12p_paralleliint dv_parallel v_parallel^2 S_i - fracu_i^22p_paralleliint dv_parallel S_iright)g_i \n   + left-frac1n_iv_mathrmthileft(-fracpartial p_ipartial z\n  + R_inn_in_nleft(u_n - u_iright)\n  + R_mathrmionn_in_nleft(u_n - u_iright) - u_iint dv_parallel S_iright)right \n   qquad-fracw_i2frac1p_ileft(-fracpartial q_ipartial z\n  - R_inleft(n_np_i - n_ip_n\n  - n_in_nleft(u_i - u_nright)^2right)\n  + int dv_parallel v_parallel^2 S_i + u_i^2 int dv_parallel S_i\n  + v_mathrmthiw_ifracpartial p_ipartial zright) \n   qquad - fracw_i2R_mathrmionn_ileft(fracp_np_i\n  - fracn_nn_i + fracn_np_ileft(u_n - u_iright)^2right) \n   qquadleft + fracw_paralleli2 frac1n_iint dv_parallel S_i\n  + fracw_i^22fracv_mathrmthin_ifracpartial n_ipartial zrightfracpartial g_ipartial w_i \n   = -R_inn_nleft(g_i - fracv_mathrmthiv_mathrmthng_nright)\n      + R_mathrmionv_mathrmthifracn_nv_mathrmthng_n + fracv_mathrmthin_i S_i\nendalign","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"and for neutrals where several of the ionization terms cancel","category":"page"},{"location":"moment_kinetic_equations/","page":"Moment kinetic equations","title":"Moment kinetic equations","text":"beginalign\n  Rightarrow  fracpartial g_npartial t\n  + fracv_mathrmthnn_nleft(v_mathrmthnw_n\n  + u_nright)fracpartial f_npartial z\n  + left(-frac32R_mathrmionn_i + frac32n_nint dv_parallel S_n\n  - fracu_nn_nfracpartial n_npartial zright)g_n \n   + left(fracu_nv_mathrmthnfracpartial v_mathrmthnpartial z\n  + frac12p_nfracpartial q_npartial zright \n   qquad left + frac12p_nR_inleft(n_ip_n - n_np_i\n  - n_nn_ileft(u_n - u_iright)^2right)\n  + frac12R_mathrmionn_i\n  - frac12p_parallelnint dv_parallel v_parallel^2 S_n - fracu_n^22p_parallelnint dv_parallel S_nright)g_n \n   + left-frac1n_nv_mathrmthnleft(-fracpartial p_npartial z\n  + R_inn_nn_ileft(u_i - u_nright) - u_nint dv_parallel S_nright)right \n   qquad-fracw_n2frac1p_nleft(-fracpartial q_npartial z\n  - R_inleft(n_ip_n - n_np_i\n  - n_nn_ileft(u_n - u_iright)^2right)\n  + int dv_parallel S_n + u_n^2int dv_parallel v_parallel^2 S_n\n  + v_mathrmthnw_nfracpartial p_npartial zright) \n   qquadleft + fracw_paralleln2frac1n_nint dv_parallel S_n\n  + fracw_n^22fracv_mathrmthnn_nfracpartial n_npartial zrightfracpartial g_npartial w_n \n   = -R_inn_ileft(g_n - fracv_mathrmthnv_mathrmthig_iright)\n      - R_mathrmionn_ig_n + fracv_mathrmthnn_n S_n\nendalign","category":"page"},{"location":"zz_ionization/#ionization","page":"ionization","title":"ionization","text":"","category":"section"},{"location":"zz_ionization/","page":"ionization","title":"ionization","text":"Modules = [moment_kinetics.ionization]","category":"page"},{"location":"zz_ionization/#moment_kinetics.ionization","page":"ionization","title":"moment_kinetics.ionization","text":"\n\n\n\n","category":"module"},{"location":"zz_moment_kinetics_input/#moment_kinetics_input","page":"moment_kinetics_input","title":"moment_kinetics_input","text":"","category":"section"},{"location":"zz_moment_kinetics_input/","page":"moment_kinetics_input","title":"moment_kinetics_input","text":"Modules = [moment_kinetics.moment_kinetics_input]","category":"page"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input","text":"\n\n\n\n","category":"module"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_coordinate_input-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_coordinate_input","text":"Check input for a coordinate\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input-NTuple{14, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input","text":"check various input options to ensure they are all valid/consistent\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input_initialization-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input_initialization","text":"\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.check_input_time_advance-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.check_input_time_advance","text":"\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.get_default_rhostar-Tuple{Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.get_default_rhostar","text":"function get_default_rhostar(reference_params)\n\nCalculate the normalised ion gyroradius at reference parameters\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.load_defaults-Tuple{Any, Any, Any}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.load_defaults","text":"\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.mk_input","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.mk_input","text":"Process user-supplied inputs\n\nsave_inputs_to_txt should be true when actually running a simulation, but defaults to false for other situations (e.g. when post-processing).\n\nignore_MPI should be false when actually running a simulation, but defaults to true for other situations (e.g. when post-processing).\n\n\n\n\n\n","category":"function"},{"location":"zz_moment_kinetics_input/#moment_kinetics.moment_kinetics_input.read_input_file-Tuple{String}","page":"moment_kinetics_input","title":"moment_kinetics.moment_kinetics_input.read_input_file","text":"Read input from a TOML file\n\n\n\n\n\n","category":"method"},{"location":"developing/#Developing","page":"Developing","title":"Developing","text":"","category":"section"},{"location":"developing/#Dependencies","page":"Developing","title":"Dependencies","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"If you need to add a dependency, start the REPL with the moment_kinetics package activated (see above), enter pkg> mode (press ]) and then to add, for example, the FFTW.jl package enter","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"(moment_kinetics) pkg> add FFTW","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"This should take care of adding the package (FFTW) to the Project.toml and Manifest.toml files.","category":"page"},{"location":"developing/#Revise.jl","page":"Developing","title":"Revise.jl","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"When working on the code, one way to avoid waiting for everything to recompile frequently is to load the Revise.jl package","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> using Revise","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Revise.jl will recompile each edited function/method as needed, so it is possible to keep a REPL session open and avoid long recompilation. moment_kinetics can be run fairly conveniently from the REPL","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> using moment_kinetics\njulia> run_moment_kinetics(input)","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"where input is a Dict() containing any non-default options desired. Input can also be loaded from a TOML file passing the filaname as a String to the second argument, e.g.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"julia> run_moment_kinetics(\"input.toml\")","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It might be convenient to add using Revise to your startup.jl file (~/julia/config/startup.jl) so it's always loaded.","category":"page"},{"location":"developing/#Parallelization","page":"Developing","title":"Parallelization","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"The code is parallelized at the moment using MPI and shared-memory arrays. Arrays representing the pdf, moments, etc. are shared between all processes. Using shared memory means, for example, we can take derivatives along one dimension while parallelising the other for any dimension without having to communicate to re-distribute the arrays. Using shared memory instead of (in future as well as) distributed memory parallelism has the advantage that it is easier to split up the points within each element between processors, giving a finer-grained parallelism which should let the code use larger numbers of processors efficiently.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It is possible to use a REPL workflow with parallel code:","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Recommended option is to use tmpi. This utility (it's a bash script that uses tmux) starts an mpi program with each process in a separate pane in a single terminal, and mirrors input to all processes simultaneously (which is normally what you want, there are also commands to 'zoom in' on a single process).\nAnother 'low-tech' possibilty is to use something like mpirun -np 4 xterm -e julia --project, but that will start each process in a separate xterm and you would have to enter commands separately in each one. Occasionally useful for debugging when nothing else is available.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"There is no restriction on the number of processes or number of grid points, although load-balancing may be affected - if there are only very few points per process, and a small fraction of processes have an extra grid point (e.g. splitting 5 points over 4 processes, so 3 process have 1 point but 1 process has 2 points), many processes will spend time waiting for the few with an extra point.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Parallelism is implemented through macros that get the local ranges of points that each process should handle. The inner-most level of nested loops is typically not parallelized, to allow efficient FFTs for derivatives, etc. A loop over one (possibly parallelized) dimension can be written as, for example,","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s is begin\n    f[is] = ...\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"These macros can be nested as needed for relatively complex loops","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s is begin\n    some_setup(is)\n    @loop_z iz begin\n        @views do_something(f[:,iz,is])\n    end\n    @loop_z iz begin\n        @views do_something_else(f[:,iz,is])\n    end\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Simpler nested loops can (optionally) be written more compactly","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@loop_s_z_vpa is iz ivpa begin\n    f[ivpa,iz,is] = ...\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Which dimensions are actually parallelized by these macros is controlled by the 'region' that the code is currently in, as set by the begin_<dims>_region() functions, where <dims> are the dimensions that will be parallelized in the following region. For example, after calling begin_s_z_region() loops over species and z will be divided up over the processes in a 'block' (currently there is only one block, which contains the whole grid and all the processes being used, as we have not yet implemented distributed-memory parallelism). Every process will loop over all points in the remaining dimensions if the loop macros for those dimensions are called.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The recommended place to put begin_*_region() calls is at the beginning of a function whose contents should use loops parallelised according to the settings for that region.\nEach begin_*_region() function checks if the region it would set is already active, and if so returns immediately (doing nothing). This means that begin_*_region() can (and should) be used to mark a block of code as belonging to that region, and if moment_kinetics is already in that region type, the call will have essentially zero cost.\nIn some places it may be necessary to change the region type half way through a function, etc. This is fine.\nWhen choosing which region type to select, note that all 'parallelised dimensions' must be looped over for each operation (otherwise some points may be written more than once), unless some special handling is used (e.g. species dimension s is parallelised, but a conditional like if 1 in loop_ranges[].s is wrapped around code to be executed so that only processes which should handle the point at s=1 do anything). It may be more optimal in some places to choose region types that do not parallelise all possible dimensions, to reduce the number of synchronisations that are needed.\nAs a matter of style, it is recommended to place begin_*_region() calls within functions where the loops are (or at most one level above), so that it is not necessary to search back along the execution path of the code to find the most recent begin_*_region() call, and therefore know what region type is active.\nIn a region after begin_serial_region(), the rank 0 process in each block will loop over all points in every dimension, and all other ranks will not loop over any.\nInside serial regions, the macro @serial_region can also be used to wrap blocks of code so that they only run on rank 0 of the block. This is useful for example to allow the use of array-broadcast expressions during initialization where performance is not critical.\nTo help show how these macros work, a script is provided that print a set of examples where the loop macros are expanded. It can be run from the Julia REPL\n$ julia --project\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.7.0 (2021-11-30)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia> include(\"util/print-macros.jl\")\nor on the command line\n$ julia --project util/print-macros.jl","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The ranges used are stored in a LoopRanges struct in the Ref variable loop_ranges (which is exported by the looping module). The range for each dimension is stored in a member with the same name as the dimension, e.g. loop_ranges[].s for the species. Occasionally it is useful to access the range directly. There are different LoopRanges instances for different parallelization patterns - the instance stored in loop_ranges is updated when begin_*_region() is called. It is possible to find out the current region type (i.e. which dimensions are being parallelized) by looking at loop_ranges[].parallel_dims.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"note: Note\nThe square brackets [] after loop_ranges[] are needed because loop_ranges is a reference to a LoopRanges object Ref{LoopRanges} (a bit like a pointer) - it allows loop_ranges to be a const variable, so its type is always known at compile time, but the actual LoopRanges can be set/modified at run-time.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"It is also possible to run a block of code in serial (on just the rank-0 member of each block of processes) by wrapping it in a @serial_region macro. This is mostly useful for initialization or file I/O where performance is not critical. For example","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"@serial_region begin\n    # Do some initialization\n    f .= 0.0\nend","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Internally, when the begin_*_region() functions need to change the region type (i.e. the requested region is not already active), they call _block_synchronize(), which calls MPI.Barrier(). They also switch over the LoopRanges struct contained in looping.loop_ranges as noted above. For optimization, the _block_synchronize() call can be skipped - when it is correct to do so - by passing the argument no_synchronize=true (or some more complicated conditional expression if synchronization is necessary when using some options but not for others).","category":"page"},{"location":"developing/#Collision-operator-and-anyv-region","page":"Developing","title":"Collision operator and anyv region","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"The Fokker-Planck collision operator requires a special approach to shared-memory parallelisation. There is an outer loop over spatial points (and potentially over species). Inside that outer loop there are operations that can benefit from parallelisation over v_perp, or over v_parallel, or over both v_perp and v_parallel, as well as some that do not parallelise over velocity space at all. To deal with this, it is beneficial to parallelise the outer loop over species and spatial dimensions as much as possible, and then within that allow changes between different ways of parallelizing over velocity space.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The mechanism introduced to allow the type of parallelization just described is the 'anyv' (read any-v) region. Before the outer loop of the collision operator begin_s_r_z_anyv_region() is used to start the 'anyv' parallelization. Then within the @loop is ir iz begin... the functions begin_anyv_region() (for no parallelization over velocity space), begin_anyv_vperp_region(), begin_anyv_vpa_region() and begin_anyv_vperp_vpa_region() can be used to parallelize over neither velocity space dimension, either velocity space dimension individually, or over both velocity space dimensions together. This is possible because 'subblocks' of processes are defined. Each subblock shares the same range of species and spatial indices, which stay the same throughout the begin_s_r_z_anyv_region() section, and are not shared with any other subblock of processes. Because the subblock has an independent set of species- and spatial-indices, when changing the velocity-space parallelization only the processes in the sub-block need to be synchronized which is done by moment_kinetics.communication._anyv_subblock_synchronize, which is called when necessary within the begin_anyv*_region() functions (the whole shared-memory block does not need to be synchronized at once, as would be done by moment_kinetics.communication._block_synchronize). The processes that share an anyv subblock are all part of the comm_anyv_subblock[] communicator (which is a subset of the processes in the full block, whose communicator is comm_block[]).","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"See also notes on debugging the 'anyv' parallelisation: Collision operator and 'anyv' region.","category":"page"},{"location":"developing/#Package-structure","page":"Developing","title":"Package structure","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"The structure of the packages in the moment_kinetics repo is set up so that some features, which depend on 'heavy' external packages (such as Makie, Plots, and Symbolics, which take a long time to precompile and load) can be optional.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The structure is set up by the machines/machine_setup.sh script, which prompts the user for input to decide which optional components to include (as well as some settings related to batch job submission on HPC clusters). machine_setup.sh calls several other scripts to do the setup (written as far as possible in Julia). The structure of these scripts is explained in machine_setup notes.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The intention is that a top-level 'project' (defined by a Project.toml file, which is created and populated by machines/machine_setup.sh) is set up in the top-level directory of the repository. The moment_kinetics package itself (which is in the moment_kinetics/ subdirectory, defined by its own Project.toml file which is tracked by git), and optionally other post-processing packages, are added to this top-level project using Pkg.develop().","category":"page"},{"location":"developing/#Optional-dependencies","page":"Developing","title":"Optional dependencies","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"Some capabilities that require optional dependencies are provided using 'package extensions' (a new feature of Julia in v1.9.0).","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The way we use package extensions is a bit of a hack. Extensions are intended to be activated when an optional dependency (called a 'weakdep' by Julia) is loaded, e.g. using moment_kinetics, NCDatasets. This usage pattern is not the most convenient for the way we use moment_kinetics where we would rather just load moment_kinetics and then specify for example binary_format = \"netcdf\" in the input TOML file. To work around this, the optional dependencies are loaded automatically if they are installed (by calling Base.requires() in the __init__() function of an appropriate sub-module). This is not the way package extensions were intended to be used, and it may be a bit fragile - at the time of writing in January 2024 there would be an error on precompilation if the optional dependencies were added in one order, which went away when the order was reversed. If this causes problems, we might need to consider an alternative, for example adding the optional dependencies to the startup.jl file, instead of trying to auto-load them from within the moment_kinetics package.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"The optional capabilities at the moment are:","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"Method of manufactured solutions (MMS) testing - this requires the Symbolics package which is heavy and has a large number of dependencies. It is convenient not to require Symbolics when MMS capability is not being used. The functionality is provided by the manufactured_solns_ext extension. The extension also requires the IfElse package, which is not needed elsewhere in moment_kinetics and so is included as a 'weakdep' although IfElse is not a heavy dependency.\nNetCDF output - this requires the NCDatasets package. Although not as heavy as Symbolics or the plotting packages, NetCDF output is not required and not used by default, so it does not hurt to make the dependency optional. As a bonus, importing NCDatasets can sometimes cause linking errors when a local or system installation of HDF5 (i.e. one not provided by the Julia package manager) is used, as NCDatasets (sometimes?) seems to try to link a different version of the library. These errors can be avoided by not enabling NetCDF outut (when HDF5 output is preferred), or allowing Julia to use the HDF5 library provided by its package manager (when NetCDF is preferred, although this would mean that parallel I/O functionality is not available).","category":"page"},{"location":"developing/#Post-processing-packages","page":"Developing","title":"Post processing packages","text":"","category":"section"},{"location":"developing/","page":"Developing","title":"Developing","text":"Post processing functionality is provided by separate packages (makie_post_processing and plots_post_processing) rather than by extensions. Extensions are not allowed to define new modules, functions, etc. within the main package, they can only add new methods (i.e. new implementations of the function for a different number of arguments, or different types of the arguments) to functions already defined in the main package. For post-processing, we want to add a lot of new functions, so to use extensions instead of separate packages we would need to define all the function names in the main package, and then separately the implementations in the extension, which would be inconvenient and harder to maintain.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"There are two suggested ways of setting up the post-processing packages:","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"For interactive use/development on a local machine, one or both post-processing packages can be added to the top-level project using Pkg.develop(). This is convenient as there is only one project to deal with. Both simulations and post-processing are run using\n$ bin/julia --project -O3 <...>\nFor optimized use on an HPC cluster it is better to set up a separate project for the post-processing package(s). This allows different optimization flags to be used for running simulations (-O3 --check-bounds=no) and for post-processing (-O3). [Note, in particular Makie.jl can have performance problems if run with --check-bounds=no, see here.] Simulations should be run with\n$ bin/julia --project -O3 --check-bounds=no <...>\nand post-processing with\n$ bin/julia --project=makie_post_processing -O3 <...>\nor\n$ bin/julia --project=plots_post_processing -O3 <...>\nThis option can also be used on a local machine, if you want to optimise your simulation runs as much as possible by using the --check-bounds=no flag. To do this answer y to the prompt \"Would you like to set up separate packages for post processing...\" from machines/machine_setup.sh.","category":"page"},{"location":"developing/","page":"Developing","title":"Developing","text":"To support option 2, the post-processing packages are located in sub-sub-directories (makie_post_processing/makie_post_processing/ and plots_post_processing/plots_post_processing/), so that the separate projects can be created in the sub-directories (makie_post_processing/ and plots_post_processing). moment_kinetics and the other dependencies must also be added to the separate projects (the machine_setup.sh script takes care of this).","category":"page"},{"location":"parameter_scans/#Parameter-scans","page":"Parameter scans","title":"Parameter scans","text":"","category":"section"},{"location":"parameter_scans/#Running-a-scan","page":"Parameter scans","title":"Running a scan","text":"","category":"section"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"Parameter scans can be run using the run_parameter_scan.jl script. To run from the REPL","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"$ julia -p 8 --project -O3\njulia> include(\"run_parameter_scan.jl\")\njulia> run_parameter_scan(\"path/to/an/input/file.toml\")","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"or to run a single scan from the command line","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"$ julia -p 8 --project -O3 run_parameter_scan.jl path/to/an/input/file.toml","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"The -p 8 argument passed to julia in these examples is optional. It indicates that julia should use 8 processes for parallelism. In this case we are not using MPI - each run in the scan is run in serial, but up to 8 (in this example) runs from the scan can be performed simultaneously (using the @distributed macro).","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"The runs can use MPI - in this case call julia using mpirun, etc. as usual but do not pass the -p argument. Mixing MPI and @distributed would cause oversubscription and slow everything down. The runs will run one after the other, and each run will be MPI parallelised.","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"The inputs (see moment_kinetics.parameter_scans.get_scan_inputs) can be passed to the function in a Dict, or read from a TOML file.","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"run_parameter_scan can also be passed a directory (either as an argument to the function or from the command line), in which case it will perform a run for every input file contained in that directory.","category":"page"},{"location":"parameter_scans/#Post-processing-a-scan","page":"Parameter scans","title":"Post processing a scan","text":"","category":"section"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"makie_post_processing.makie_post_process can be called for each run in a scan. For example to post process the scan in runs/scan_example from the REPL","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"$ julia -p 8 --project -O3\njulia> include(\"post_process_parameter_scan.jl\")\njulia> post_process_parameter_scan(\"runs/scan_example/\")","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"or to from the command line","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"$ julia -p 8 --project -O3 post_process_parameter_scan.jl runs/scan_example/","category":"page"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"Again the -p 8 argument passed to julia in these examples is optional. It indicates that julia should use 8 processes for parallelism. Each run in the scan is post-processed in serial, but up to 8 (in this example) runs from the scan can be post-processed simultaneously (using the @distributed macro).","category":"page"},{"location":"parameter_scans/#API","page":"Parameter scans","title":"API","text":"","category":"section"},{"location":"parameter_scans/","page":"Parameter scans","title":"Parameter scans","text":"Modules = [moment_kinetics.parameter_scans]","category":"page"},{"location":"parameter_scans/#moment_kinetics.parameter_scans.generate_scan_input_files","page":"Parameter scans","title":"moment_kinetics.parameter_scans.generate_scan_input_files","text":"generate_scan_input_files(filename::AbstractString, dirname=nothing)\n\nRead inputs for a scan from a TOML file and call generate_scan_input_files(scan_input::AbstractDict, dirname::AbstractString).\n\nBy default, dirname will be set to filename with the .toml extension removed.\n\n\n\n\n\n","category":"function"},{"location":"parameter_scans/#moment_kinetics.parameter_scans.generate_scan_input_files-Tuple{AbstractDict, AbstractString}","page":"Parameter scans","title":"moment_kinetics.parameter_scans.generate_scan_input_files","text":"generate_scan_input_files(scan_input::AbstractDict, dirname::AbstractString)\n\nGenerate individual input files for each run in the scan specified by scan_input, saving the generated files in dirname\n\nInputs are generated by calling get_scan_inputs(scan_inputs::AbstractDict).\n\n\n\n\n\n","category":"method"},{"location":"parameter_scans/#moment_kinetics.parameter_scans.get_scan_inputs-Tuple{AbstractDict}","page":"Parameter scans","title":"moment_kinetics.parameter_scans.get_scan_inputs","text":"get_scan_inputs(scan_inputs::AbstractDict)\n\nMake a set of inputs for a parameter scan.\n\nscan_inputs is like a Dict of inputs for run_moment_kinetics, except that any value may be an array instead of a scalar. The values passed as arrays will be combined as follows.\n\nA special, extra, setting combine_outer can be passed, with the names of options to combine using an 'outer product'\n\nBy default, inputs are combined with an 'inner product', i.e. inputs a,b,c are combined as (a[1],b[1],c[1]), (a[2],b[2],c[2]), etc. Any inputs named in 'combine_outer' are instead combined with an 'outer product', i.e. an entry is created for every value of those inputs combined with every combination of the other inputs.\n\nReturns a Vector{OrderedDict} whose entries are the input for a single run in the parameter scan.\n\n\n\n\n\n","category":"method"},{"location":"parameter_scans/#moment_kinetics.parameter_scans.get_scan_inputs-Tuple{AbstractString}","page":"Parameter scans","title":"moment_kinetics.parameter_scans.get_scan_inputs","text":"get_scan_inputs(file_or_dir::AbstractString)\n\nIf file_or_dir is a file, read input from it using TOML , and call get_scan_inputs(scan_inputs::AbstractDict).\n\nIf file_or_dir is a directory, read input from all the .toml files in the directory, returning the inputs as a Vector{OrderedDict}.\n\n\n\n\n\n","category":"method"},{"location":"parameter_scans/#moment_kinetics.parameter_scans.get_scan_inputs-Tuple{}","page":"Parameter scans","title":"moment_kinetics.parameter_scans.get_scan_inputs","text":"get_scan_inputs()\n\nGet input file name from command line options, and call get_scan_inputs(filename::AbstractString)\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics","page":"moment_kinetics","title":"moment_kinetics","text":"","category":"section"},{"location":"zz_moment_kinetics/","page":"moment_kinetics","title":"moment_kinetics","text":"Modules = [moment_kinetics.moment_kinetics]","category":"page"},{"location":"zz_moment_kinetics/#moment_kinetics.moment_kinetics","page":"moment_kinetics","title":"moment_kinetics.moment_kinetics","text":"\n\n\n\n","category":"module"},{"location":"zz_moment_kinetics/#moment_kinetics.check_so_newer_than_code","page":"moment_kinetics","title":"moment_kinetics.check_so_newer_than_code","text":"check_so_newer_than_code(so_filename=nothing)\n\nUtility function that checks if so_filename is newer than the source code in moment_kinetics/src. If it is, prints an error message and returns false; otherwise returns true.\n\nIf so_filename is nothing, use the name of the system image of the current julia session for so_filename.\n\nIf so_filename is \"makie_postproc.so\", also checks against the source code in makie_post_processing/makie_post_processing/src/.\n\nIf so_filename is \"plots_postproc.so\", also checks against the source code in plots_post_processing/plots_post_processing/src/.\n\n\n\n\n\n","category":"function"},{"location":"zz_moment_kinetics/#moment_kinetics.cleanup_moment_kinetics!-Tuple{Any, Any, Any}","page":"moment_kinetics","title":"moment_kinetics.cleanup_moment_kinetics!","text":"Clean up after a run\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.run_moment_kinetics","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"main function that contains all of the content of the program\n\n\n\n\n\n","category":"function"},{"location":"zz_moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{Any}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload with no TimerOutput arguments\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{Union{Nothing, TimerOutputs.TimerOutput}, String}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload which takes a filename and loads input\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.run_moment_kinetics-Tuple{}","page":"moment_kinetics","title":"moment_kinetics.run_moment_kinetics","text":"overload which gets the input file name from command line arguments\n\n\n\n\n\n","category":"method"},{"location":"zz_moment_kinetics/#moment_kinetics.setup_moment_kinetics-Tuple{AbstractDict}","page":"moment_kinetics","title":"moment_kinetics.setup_moment_kinetics","text":"Perform all the initialization steps for a run.\n\nIf backup_filename is nothing, set up for a regular run; if a filename is passed, reload data from time index given by restart_time_index for a restart.\n\ndebug_loop_type and debug_loop_parallel_dims are used to force specific set ups for parallel loop ranges, and are only used by the tests in debug_test/.\n\n\n\n\n\n","category":"method"},{"location":"wall_boundary_conditions/#Wall-boundary-conditions-with-moment-constraints","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"","category":"section"},{"location":"wall_boundary_conditions/#Ions","page":"Wall boundary conditions with moment constraints","title":"Ions","text":"","category":"section"},{"location":"wall_boundary_conditions/#Boundary-conditions","page":"Wall boundary conditions with moment constraints","title":"Boundary conditions","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"The sheath-edge boundary conditions for the ions is that no ions leave from the sheath edge. So at the lower boundary z=-L_z2","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  f(z=-L2v_parallel0) = 0\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and at the upper boundary z=L_z2","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  f(z=L2v_parallel0) = 0\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Moment-constraints","page":"Wall boundary conditions with moment constraints","title":"Moment constraints","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"At the sheath-entrance boundary, the constraints need to be enforced slightly differently to how they are done in the bulk of the domain (see Constraints on normalized distribution function). For compatibility with the boundary condition, the corrections which are added to impose the constraints should go to zero at v_parallel=0. Note that the constraints are imposed after the boundary condition is applied by setting f(v_parallel0)=0 on the lower sheath boundary or f(v_parallel0)=0 on the upper sheath boundary.","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"The form of the correction that we choose is","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\ntildeg_s = Ahatg_s + Bw_parallel fracv_parallel1+v_parallelhatg_s + Cw_parallel^2 fracv_parallel1+v_parallelhatg_s\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"We have the same set of constraints","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s  =1\n  frac1sqrtpiint dw_w_tildeg_s  =0\n  frac1sqrtpiint dw_w_^2tildeg_s  =frac12\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Defining the integrals","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  I_n=frac1sqrtpiint dw_w_^nhatg_s\n  J_n=frac1sqrtpiint dw_w_^nfracv_parallel1+v_parallelhatg_s\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"We can write the constraints as","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dw_tildeg_s=1  =frac1sqrtpiint dw_left(Ahatg_s+Bw_fracv_parallel1+v_parallelhatg_s+Cw_^2fracv_parallel1+v_parallelhatg_sright) \n  =AI_0+BJ_1+CJ_2\n  frac1sqrtpiint dw_w_tildeg_s=0  =frac1sqrtpiint dw_left(Aw_hatg_s+Bw_^2fracv_parallel1+v_parallelhatg_s+Cw_^3fracv_parallel1+v_parallelhatg_sright) \n  =AI_1+BJ_2+CJ_3\n  frac1sqrtpiint dw_w_^2tildeg_s=frac12  =frac1sqrtpiint dw_left(Aw_^2hatg_s+Bw_^3fracv_parallel1+v_parallelhatg_s+Cw_^4fracv_parallel1+v_parallelhatg_sright) \n  =AI_2+BJ_3+CJ_4\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and solving these simultaneous equations","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracleft( frac12 - A I_2 - B J_3 right)J_4  \n  B = -fracA I_1 + C J_3J_2 \n    = -fracI_1J_2 A - fracJ_3J_2 left( frac12J_4 - fracI_2J_4 A - fracJ_3J_4 B right) \n  left( 1 - fracJ_3^2J_2 J_4 right) B = -fracJ_32 J_2 J_4 + left( fracI_2 J_3J_2 J_4 - fracI_1J_2 right) A \n  B = fracleft( fracI_2 J_3J_2 J_4 - fracI_1J_2 right) A - fracJ_32 J_2 J_4left( 1 - fracJ_3^2J_2 J_4 right) \n  = fracleft( I_2 J_3 - I_1 J_4 right) A - fracJ_32J_2 J_4 - J_3^2 \n  1 = A I_0 + B J_1 + C J_2 \n  = A I_0 + B J_1 + fracJ_2J_4left( frac12 - A I_2 - B J_3 right) \n  1 - fracJ_22 J_4 = left( I_0 - fracI_2 J_2J_4 right) A + left( J_1 - fracJ_2 J_3J_4 right) B \n  1 - fracJ_22 J_4 = left( I_0 - fracI_2 J_2J_4 right) A - fracleft( J_1 - fracJ_2 J_3J_4 right) J_32left( J_2 J_4 - J_3^2 right) + fracleft( J_1 - fracJ_2 J_3J_4 right)left( I_2 J_3 - I_1 J_4 right)left( J_2 J_4 - J_3^2 right) A \n  left( 1 - fracJ_22J_4 right) left( J_2 J_4 - J_3^2 right) = left( J_2 J_4 - J_3^2 right) left( I_0 - fracI_2 J_2J_4 right) A - fracleft( J_1 - fracJ_2 J_3J_4 right) J_32 + left( J_1 - fracJ_2 J_3J_4 right) left( I_2 J_3 - I_1 J_4 right) A \n  left( 1 - fracJ_22 J_4 right)left( J_2 J_4 - J_3^2 right) + fracleft( J_1 - fracJ_2 J_3J_4 right) J_32 = left left( J_2 J_4 - J_3^2 right)left( I_0 - fracI_2 J_2J_4 right) + left( J_1 - fracJ_2 J_3J_4 right)left( I_2 J_3 - I_1 J_4 right) right A \n  J_2 J_4 - fracJ_2^22 - J_3^2 + cancelfracJ_2 J_3^22 J_4 + fracJ_1 J_32 - cancelfracJ_2 J_3^22 J_4 = left I_0 J_2 J_4 - I_2 J_2^2 - I_0 J_3^2 + cancelfracI_2 J_2 J_3^2J_4 + I_2 J_1 J_3 - I_1 J_1 J_4 - cancelfracI_2 J_2 J_3^2J_4 + I_1 J_2 J_3 right A \n  J_2 J_4 - fracJ_2^22 + J_3left( fracJ_12 - J_3 right) = left I_0left( J_2 J_4 - J_3^2 right) + I_1left( J_2 J_3 - J_1 J_4 right) + I_2left( J_1 J_3 - J_2^2 right) right A \n  A =fracJ_2 J_4 - fracJ_2^22 + J_3left( fracJ_12 - J_3 right)I_0left( J_2 J_4 - J_3^2 right) + I_1 left( J_2 J_3 - J_1 J_4 right) + I_2left( J_1 J_3 - J_2^2 right)\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"</details>","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracfrac12 - A I_2 - B J_3J_4  \n  B = fracfrac12 J_3 + A (I_1 J_4 - I_2 J_3)J_3^2 - J_2 J_4 \n  A = fracJ_3^2 - J_2 J_4 + frac12 (J_2^2 - J_1 J_3)I_0 (J_3^2 - J_2 J_4) + I_1 (J_1 J_4 - J_2 J_3) + I_2 (J_2^2 - J_1 J_3)\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Evolving-u_\\parallel","page":"Wall boundary conditions with moment constraints","title":"Evolving u_parallel","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When evolving only u_parallel and n separately, we only need two constraints. This corresponds to C=0 so that","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  1 = A I_0 + B J_1 \n  0 = A I_1 + B J_2 \n  B = -fracA I_1J_2 \n  A I_0 = 1 - B J_1 = 1 + fracA I_1 J_1J_2 \n  A = frac1I_0 - fracI_1 J_1J_2\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Evolving-n","page":"Wall boundary conditions with moment constraints","title":"Evolving n","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When only evolving n separately, the constraint is the same as in the bulk of the domain","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  1 = AI_0 \n  A = frac1I_0\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Neutrals","page":"Wall boundary conditions with moment constraints","title":"Neutrals","text":"","category":"section"},{"location":"wall_boundary_conditions/#Boundary-conditions-2","page":"Wall boundary conditions with moment constraints","title":"Boundary conditions","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Ions and neutrals that reach the wall are both recycled as neutrals. The neutrals are emitted from the wall with a 'Knudsen cosine' distribution characterised by a specified temperature T_mathrmwall (see Excalibur report TN-05). The Knudsen distribution is given – here assuming that the magnetic field is perpendicular to the wall (so that v_parallel is the velocity normal to the wall) – by","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"f_Kw(v_zetav_rv_z) = frac34pi left(fracm_iT_mathrmwallright)^2 fracv_zsqrtv_zeta^2 + v_r^2 + v_z^2 expleft( -fracm_i(v_zeta^2 + v_r^2 + v_z^2)2T_mathrmwall right)","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Note that f_Kw is normalised so that it has unit flux int d^3vv_z f_Kw(v_zetav_rv_z) = 1.","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"The boundary condition for the neutrals at the lower target is then (for the neutrals leaving whe wall)","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"f_n(rz=-fracL_z2v_zetav_rv_z0) = Gamma_mathrmlower(r) f_Kw(v_zetav_rv_z)","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and at the upper target","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"f_n(rz=fracL_z2v_zetav_rv_z0) = Gamma_mathrmupper(r) f_Kw(v_zetav_rv_z)","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"A 'recycling fraction' is included, defined so that a fraction 0 leq R_mathrmrecycle leq 1 of the ions hitting the wall are recycled as neutrals, while the whole flux of neutrals hitting the wall is always recycled. (Recycling the 100% of the neutral flux means that the net flux of neutrals - hitting the wall plus recycled - is R_mathrmrecycle times the ion flux, which makes applying boundary conditions in the moment-kinetic approach simpler, see the next section.) This results in","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  Gamma_mathrmlower(r) = R_mathrmrecycle fracB_zB 2pi int_0^infty dv_perp int_-infty^0 dv_parallel v_parallel f_i(r-L2v_perpv_parallel) \n                           quad + int dv_zetadv_r int_-infty^0 dv_z v_z f_n(r-L2v_zetav_rv_z) \n  Gamma_mathrmupper(r) = R_mathrmrecycle fracB_zB 2pi int_0^infty dv_perp int_0^infty dv_parallel v_parallel f_i(rL2v_perpv_parallel) \n                           quad + int dv_zetadv_r int_0^infty dv_z v_z f_n(rL2v_zetav_rv_z)\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"For 1D1V, we 'marginalise' – i.e. integrate over v_perp, assuming that v_parallel=v_z (i.e. the magnetic field is perpendicular to the wall so B_zB = 1) – (see Excalibur report TN-08) which gives","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  f_Kw1V(v_parallel) = int dv_zeta dv_r f_Kw(v_zetav_rv_parallel) = 2pi int dv_perpv_perp f_Kw(v_perpv_parallel) \n                         = 3sqrtpi left(fracm_i2T_mathrmwallright)^32v_parallelmathrmerfcleft(sqrtfracm_i2T_mathrmwallv_parallelright)\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Moment-constraints-2","page":"Wall boundary conditions with moment constraints","title":"Moment constraints","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When using the moment kinetic approach, we first need to apply a boundary condition to the moments so that the net flux of neutrals leaving the wall matches the recycling fraction R_mathrmrecycle times the flux of ions reaching the wall","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  u_paralleln(z=pm L2) = -R_mathrmrecycle fracn_i(z=pm L2) u_paralleli(z=pm L2)n_n(z=pm L2)\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Having enforced the boundary condition on the flux, we need to impose that the outgoing neutrals have the shape of a Knudsen cosine distribution, and ensure that the constraints (Constraints on normalized distribution function) are satisfied. To impose three constraints we need three free parameters. Taking as before the updated, incoming part of the neutral distribution function before moment corrections to be","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  hatg_mathrmin(w_parallel) =\n    begincases\n      H(-w_parallel v_mathrmthn - u_paralleln)hatg(zw_parallel)  textat  z = -L2 \n      H(w_parallel v_mathrmthn + u_paralleln)hatg(zw_parallel)  textat  z = +L2\n    endcases\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"and the shape for the Knudsen distribution to be","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  hatg_Kw(w_parallel) =\n    begincases\n      H(w_parallel v_mathrmthn + u_paralleln)f_Kw1V(w_parallel v_mathrmthn + u_paralleln)  textat  z = -L2 \n      H(-w_parallel v_mathrmthn - u_paralleln)f_Kw1V(w_parallel v_mathrmthn + u_paralleln)  textat  z = +L2\n    endcases\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"we define the final updated distribution function to be","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  tildeg_n(w_parallel) = N_mathrmout hatg_Kw + N_mathrmin hatg_mathrmin + C w_parallel hatg_mathrmin\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"(note that if we chose to use v_parallel = w_parallel v_mathrmthn + u_paralleln instead of w_parallel in the final term with the C coefficient, this is just a shift by a constant and scale by another constant, so would have the same form, just with different (but equivalent) values of the N_mathrmin and C coefficients).","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"Defining the integrals","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  I_n = int dw_parallel w_parallel^n hatg_mathrmin(w_parallel)\n  K_n = int dw_parallel w_parallel^n hatg_Kw(w_parallel)\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"the constraints are","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dw_tildeg_n=1  =frac1sqrtpiint dw_left(N_mathrmout hatg_Kw + N_mathrmin hatg_mathrmin + C w_parallel hatg_mathrminright) \n  = N_mathrmout K_0 + N_mathrmin I_0 + C I_1 \n  frac1sqrtpiint dw_w_tildeg_n=0  =frac1sqrtpiint dw_left(N_mathrmout w_ hatg_Kw + N_mathrmin w_ hatg_mathrmin + C w_parallel^2 hatg_mathrminright) \n  = N_mathrmout K_1 + N_mathrmin I_1 + C I_2 \n  frac1sqrtpiint dw_w_^2tildeg_n=frac12  =frac1sqrtpiint dw_left(N_mathrmout w_^2 hatg_Kw + N_mathrmin w_^2 hatg_mathrmin + C w_parallel^3 hatg_mathrminright) \n  = N_mathrmout K_2 + N_mathrmin I_2 + C I_3\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"which can be solved to find","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"<details>\n<summary style=\"text-align:center\">[ intermediate steps ]</summary>","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracleft(frac12 - N_mathrmout K_2 - N_mathrmin I_2right)I_3 \n  N_mathrmout = fracleft(-N_mathrmin I_1 - C I_2 right)K_1 \n                 = -fracN_mathrmin I_1K_1 - fracI_2 left(frac12 - N_mathrmout K_2 - N_mathrmin I_2right)K_1 I_3 \n  N_mathrmout K_1 I_3 = -N_mathrmin I_1 I_3 - I_2 left(frac12 - N_mathrmout K_2 - N_mathrmin I_2right) \n  N_mathrmout = -fracleft(N_mathrmin left(I_1 I_3 - I_2^2right) + frac12 I_2right)left(K_1 I_3 - K_2 I_2right) \n  N_mathrmin = fracleft(1 - N_mathrmout K_0 - C I_1right)I_0 \n                = fracleft(1 - N_mathrmout K_0right)I_0 - fracC I_1I_0 \n                = fracleft(1 - N_mathrmout K_0right)I_0 - fracI_1 left(frac12 - N_mathrmout K_2 - N_mathrmin I_2right)I_0 I_3 \n  N_mathrmin I_0 I_3 = left(1 - N_mathrmout K_0right)I_3 - I_1 left(frac12 - N_mathrmout K_2 - N_mathrmin I_2right) \n  N_mathrmin left(I_0 I_3 - I_1 I_2right) = I_3 - frac12 I_1 - N_mathrmout left(K_0 I_3 - I_1 K_2right) \n  N_mathrmin left(I_0 I_3 - I_1 I_2right) = I_3 - frac12 I_1 + left(K_0 I_3 - I_1 K_2right) fracleft(N_mathrmin left(I_1 I_3 - I_2^2right) + frac12 I_2right)left(K_1 I_3 - K_2 I_2right) \n  N_mathrmin left(I_0 I_3 - I_1 I_2right) left(K_1 I_3 - K_2 I_2right) = left(I_3 - frac12 I_1right) left(K_1 I_3 - K_2 I_2right) + left(K_0 I_3 - I_1 K_2right) left(N_mathrmin left(I_1 I_3 - I_2^2right) + frac12 I_2right) \n  N_mathrmin left( left(I_0 I_3 - I_1 I_2right) left(K_1 I_3 - K_2 I_2right) - left(K_0 I_3 - I_1 K_2right) left(I_1 I_3 - I_2^2right) right) = left(I_3 - frac12 I_1right) left(K_1 I_3 - K_2 I_2right) + left(K_0 I_3 - I_1 K_2right) frac12 I_2 \n  N_mathrmin left( K_0 I_3 left(I_2^2 - I_1 I_3right) + K_1 I_3 left(I_0 I_3 - I_1 I_2right) + K_2 left(cancelI_1 I_2^2 - I_0 I_2 I_3 + I_1^2 I_3 - cancelI_1 I_2^2right)right) = frac12 K_0 I_2 I_3 + K_1 I_3 left(I_3 - frac12 I_1right) + K_2 left(cancelfrac12 I_1 I_2 - I_2 I_3 - cancelfrac12 I_1 I_2 right) \n  N_mathrmin left( K_0 left(I_2^2 - I_1 I_3right) + K_1 left(I_0 I_3 - I_1 I_2right) + K_2 left(I_1^2 - I_0 I_2right)right) = frac12 K_0 I_2 + K_1 left(I_3 - frac12 I_1right) - K_2 I_2 \n  N_mathrmin = fracleft(frac12 K_0 I_2 + K_1 left(I_3 - frac12 I_1right) - K_2 I_2right)left( K_0 left(I_2^2 - I_1 I_3right) + K_1 left(I_0 I_3 - I_1 I_2right) + K_2 left(I_1^2 - I_0 I_2right)right) \nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"</details>","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  C = fracleft(frac12 - N_mathrmout K_2 - N_mathrmin I_2right)I_3 \n  N_mathrmout = -fracleft(N_mathrmin left(I_1 I_3 - I_2^2right) + frac12 I_2right)left(K_1 I_3 - K_2 I_2right) \n  N_mathrmin = fracleft(frac12 K_0 I_2 + K_1 left(I_3 - frac12 I_1right) - K_2 I_2right)left( K_0 left(I_2^2 - I_1 I_3right) + K_1 left(I_0 I_3 - I_1 I_2right) + K_2 left(I_1^2 - I_0 I_2right)right)\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Evolving-u_\\parallel-2","page":"Wall boundary conditions with moment constraints","title":"Evolving u_parallel","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When evolving only u_parallel and n separately, we only need two constraints. This corresponds to C=0 so that","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  N_mathrmout = -fracI_1K_1 N_mathrmin \n  N_mathrmin = frac1I_0 - fracK_0 I_1K_1\nendalign","category":"page"},{"location":"wall_boundary_conditions/#Evolving-n-2","page":"Wall boundary conditions with moment constraints","title":"Evolving n","text":"","category":"section"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"When only evolving n separately, we still have C=0, but N_mathrmin and N_mathrmout must be adjusted to impose the density-moment constraint and the flux boundary condition.","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  frac1sqrtpiint dv_tildeg_n=1 = frac1sqrtpiint dv_left(N_mathrmout hatg_Kw + N_mathrmin hatg_mathrminright) \n  = N_mathrmout K_0 + N_mathrmin I_0 \n  frac1sqrtpiint dv_v_tildeg_n = u_n = frac1sqrtpiint dv_left(N_mathrmout v_ hatg_Kw + N_mathrmin v_ hatg_mathrmin right) \n  = N_mathrmout K_1 + N_mathrmin I_1\nendalign","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"where u_n is calculated from the ion flux as above, which can be solved to give","category":"page"},{"location":"wall_boundary_conditions/","page":"Wall boundary conditions with moment constraints","title":"Wall boundary conditions with moment constraints","text":"beginalign\n  N_mathrmout = fracleft(u_n - N_mathrmin I_1right)K_1 \n  1 = N_mathrmin I_0 + fracK_0 left(u_n - N_mathrmin I_1right)K_1 \n  Rightarrow N_mathrmin = fracleft(1 - fracK_0 u_nK_1right)left(I_0 - fracK_0 I_1K_1right)\nendalign","category":"page"},{"location":"zz_fokker_planck_test/#fokker_planck_test","page":"fokker_planck_test","title":"fokker_planck_test","text":"","category":"section"},{"location":"zz_fokker_planck_test/","page":"fokker_planck_test","title":"fokker_planck_test","text":"Modules = [moment_kinetics.fokker_planck_test]","category":"page"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test","text":"module for including functions used  in testing the implementation of the  the Full-F Fokker-Planck Collision Operator\n\n\n\n\n\n","category":"module"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.Cssp_fully_expanded_form-NTuple{17, Any}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.Cssp_fully_expanded_form","text":"Function calculating the fully expanded form of the collision operator taking floats as arguments. This function is designed to be used at the  lowest level of a coordinate loop, with derivatives and integrals all previously calculated.\n\n\n\n\n\n","category":"method"},{"location":"zz_fokker_planck_test/#moment_kinetics.fokker_planck_test.calculate_collisional_fluxes-NTuple{10, Any}","page":"fokker_planck_test","title":"moment_kinetics.fokker_planck_test.calculate_collisional_fluxes","text":"calculates the collisional fluxes given input Fs and Gsp, H_sp\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_r_advection/#neutral_r_advection","page":"neutral_r_advection","title":"neutral_r_advection","text":"","category":"section"},{"location":"zz_neutral_r_advection/","page":"neutral_r_advection","title":"neutral_r_advection","text":"Modules = [moment_kinetics.neutral_r_advection]","category":"page"},{"location":"zz_neutral_r_advection/#moment_kinetics.neutral_r_advection","page":"neutral_r_advection","title":"moment_kinetics.neutral_r_advection","text":"\n\n\n\n","category":"module"},{"location":"zz_neutral_r_advection/#moment_kinetics.neutral_r_advection.neutral_advection_r!-NTuple{13, Any}","page":"neutral_r_advection","title":"moment_kinetics.neutral_r_advection.neutral_advection_r!","text":"do a single stage time advance in r (potentially as part of a multi-stage RK scheme)\n\n\n\n\n\n","category":"method"},{"location":"zz_neutral_r_advection/#moment_kinetics.neutral_r_advection.update_speed_neutral_r!-NTuple{6, Any}","page":"neutral_r_advection","title":"moment_kinetics.neutral_r_advection.update_speed_neutral_r!","text":"calculate the advection speed in the r-direction at each grid point\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#utils","page":"utils","title":"utils","text":"","category":"section"},{"location":"zz_utils/","page":"utils","title":"utils","text":"Modules = [moment_kinetics.utils]","category":"page"},{"location":"zz_utils/#moment_kinetics.utils","page":"utils","title":"moment_kinetics.utils","text":"Utility functions\n\n\n\n\n\n","category":"module"},{"location":"zz_utils/#moment_kinetics.utils.get_backup_filename-Tuple{Any}","page":"utils","title":"moment_kinetics.utils.get_backup_filename","text":"Append a number to the filename, to get a new, non-existing filename to backup the file to.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_default_restart_filename-Tuple{Any, Any}","page":"utils","title":"moment_kinetics.utils.get_default_restart_filename","text":"get_default_restart_filename(io_input, prefix; error_if_no_file_found=true)\n\nGet the default name for the file to restart from, using the input from io_input.\n\nprefix gives the type of file to open, e.g. \"moments\", \"dfns\", or \"initial_electron\".\n\nIf no matching file is found, raise an error unless error_if_no_file_found=false is passed, in which case no error is raised and instead the function returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_prefix_iblock_and_move_existing_file-Tuple{Any, Any}","page":"utils","title":"moment_kinetics.utils.get_prefix_iblock_and_move_existing_file","text":"get_prefix_iblock_and_move_existing_file(restart_filename, output_dir)\n\nMove restart_filename to a backup location (if it is in output_dir), returning a prefix and block-index (which might be nothing) which can be used to open the file for reloading variables.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.get_unnormalized_parameters","page":"utils","title":"moment_kinetics.utils.get_unnormalized_parameters","text":"get_unnormalized_parameters(input::Dict)\nget_unnormalized_parameters(input_filename::String)\n\nGet many parameters for the simulation setup given by input or in the file input_filename, in SI units and eV, returned as an OrderedDict.\n\n\n\n\n\n","category":"function"},{"location":"zz_utils/#moment_kinetics.utils.print_unnormalized_parameters-Tuple","page":"utils","title":"moment_kinetics.utils.print_unnormalized_parameters","text":"print_unnormalized_parameters(input)\n\nPrint many parameters for the simulation setup given by input (a Dict of parameters or a String giving a filename), in SI units and eV.\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.to_hours-Tuple{T} where T<:Dates.TimePeriod","page":"utils","title":"moment_kinetics.utils.to_hours","text":"to_hours(x::T) where {T<:TimePeriod}\n\nConvert a time period x to seconds\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.to_minutes-Tuple{T} where T<:Dates.TimePeriod","page":"utils","title":"moment_kinetics.utils.to_minutes","text":"to_minutes(x::T) where {T<:TimePeriod}\n\nConvert a time period x to seconds\n\n\n\n\n\n","category":"method"},{"location":"zz_utils/#moment_kinetics.utils.to_seconds-Tuple{T} where T<:Dates.TimePeriod","page":"utils","title":"moment_kinetics.utils.to_seconds","text":"to_seconds(x::T) where {T<:TimePeriod}\n\nConvert a time period x to seconds\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The full documentation is online at https://mabarnes.github.io/moment_kinetics.","category":"page"},{"location":"getting_started/#Setup","page":"Getting started","title":"Setup","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"First clone this git repository, e.g. (to clone it into a directory with the default name moment_kinetics)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ git clone git@github.com:mabarnes/moment_kinetics","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The command above assumes that you have an account on Github.com, and that account has ssh keys set up. If that is not the case you can clone using https instead","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ git clone https://github.com/mabarnes/moment_kinetics","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When using https some things (e.g. pushing to the remote repository) may require you to use 2-factor authentication, see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"warning: Warning\nDo not download the zip-file from the Github.com page. This gives you the source code files but does not create a git repository. We get some version information from git when running the code, so without the git repository you will not be able to run a simulation.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you have already installed Julia, ensure that the Julia version is >=  1.9.0 by doing  $ julia --version  at command line. The setup script in step 2 can also download a Julia  binary if you have not already installed Julia.\nIf you are running on a desktop/laptop (rather than an HPC cluster) ensure  that you have an MPI implementation installed (using whatever the usual way  of installing software is on your system). It should not matter which MPI  implementation - openmpi is often a good choice if you have no reason to  prefer a particular one. Check that the MPI compiler wrapper mpicc is  available, e.g.  $ mpicc --version  should run without an error.\nRun the setup script  $ machines/machine_setup.sh  This script will prompt you for various options. The default choices should  be sensible in most cases. On a laptop/desktop the 'name of machine to set  up' will be 'generic-pc' and will set up for interactive use. On supported  clusters, 'name of machine' will be the name of the cluster. On other  clusters 'generic-batch' can be used, but requires some manual setup (see  machines/generic-batch-template/README.md).\nFor more information, see  machine_setup notes.\nIf you want or need to set up 'by hand' without using  machines/machine_setup.sh, see  Manual setup.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Some other notes that might sometimes be useful:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To speed up running scripts or the first call of run_moment_kinetics in a   REPL session, it is possible to compile a 'system image'   (moment_kinetics.so). By running   $ julia --project -O3 precompile.jl   and then start Julia by running for example   $ julia --project -O3 -Jmoment_kinetics.so   this significantly decreases the load time but prevents code changes from   taking effect when moment_kinetics.so is used until you repeat the   compilation of the system image. Note that this also prevents the Revise   package from updating moment_kinetics when you edit the code during and   interactive session.\nSystem images are created by default on HPC clusters, and are required to   use the provided jobscript-*.template submission scripts (used by   submit-run.sh and submit-restart.sh). This is to try and minimise the   compilation that has to be replicated on all the (possibly thousands of)   processes in a parallel run. After changing source code, you should run   $ precompile-submit.sh   (to re-compile the moment_kinetics.so system image).\nIn the course of development, it is sometimes helpful to upgrade the Julia   version. Upgrading the version of Julia or upgrading packages may require a   fresh installation of moment_kinetics. To make a fresh install with the   latest package versions you should be able to just run   julia   pkg> update   (to enter 'Package mode' enter ']' at the julia> prompt). It might   sometimes necessary or helpful to instead remove (or rename) the   Manifest.jl file in the main directory, and re-run the setup from step 2)   above. It can sometimes be necessary to remove or rename the .julia/   directory (located by default in your home directory) to force all the   dependencies to be rebuilt.\nWhen using the Plots-based post-processing library, one may have to set an   environment variable to avoid error messages from the Qt library. If you   execute the command   $ julia --project run_post_processing.jl runs/your_run_dir/   and see the error message   qt.qpa.xcb: could not connect to display   qt.qpa.plugin: Could not load the Qt platform plugin \"xcb\" in \"\" even though it was found.   This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.   this can be suppressed by setting   export QT_QPA_PLATFORM=offscreen   in your .bashrc or .bash_profile files.","category":"page"},{"location":"getting_started/#Run-a-simulation","page":"Getting started","title":"Run a simulation","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To run julia with optimization, type","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project run_moment_kinetics.jl input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Note that the middle character in -O3 is a capital letter 'O', not a zero. (On HPC clusters, or if you selected the \"set up separate packages for post processing\" option from machines/machine_setup.sh, you should use -O3 --check-bounds=no instead of just -O3, and the same in the Restarting section.)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Options are specified in a TOML file, e.g. input.toml here. The defaults are specified in moment_kinetics_input.jl.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To run in parallel, just put mpirun -np <n> in front of the call you would normally use, with <n> the number of processes to use.\nIt may be more convenient when running moment_kinetics more than once to work from the Julia REPL, e.g.   $ julia -O3 --project   julia> using moment_kinetics   julia> run_moment_kinetics(\"input.toml\")   where input is the name of a TOML file containing the desired options. It   is also possible to pass a Dict() containing any non-default options   desired, which might sometimes be useful in tests or scripts   julia> run_moment_kinetics(input)   Especially when developing the code, a lot of compilation time can be saved   by using Revise.jl, and   re-running a test case in the REPL (without restarting julia) - this is   enabled by default when setting up using machines/machine_setup.sh for   'generic-pc'.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"On an HPC cluster, you can submit a simulation (using the input file input.toml) to the batch queue using the convenience script","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-run.sh input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"See the help text","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-run.sh -h","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"for various command line options to change parameters (e.g. number of nodes, etc.).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you need to rebuild the system images moment_kinetics.so and makie_postproc.so or plots_postproc.so because you have updated the code since they were built, it may be convenient to use","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-precompile-and-run.sh input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"which will submit jobs for compilation, to run the simulation, and to do post processing. The simulation job will wait for the compilation job creating moment_kinetics.so to finish before starting. The post processing job will wait for the compilation job creating makie_postproc.so or plots_postproc.so to finish before starting.","category":"page"},{"location":"getting_started/#Stopping-a-run","page":"Getting started","title":"Stopping a run","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When running in the REPL (especially with MPI) interrupting a run using Ctrl-C can mess things up, and require you to restart Julia. There is also a chance that you might interrupt while writing the output files and corrupt them. To avoid these problems, you can stop the run cleanly (including writing the distribution functions at the last time point, so that it is possible to restart the run from where you stopped it), by creating an empty file called stop in the run directory. For example, if the name of your run is 'my_example'","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ touch runs/my_example/stop","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"moment_kinetics checks for this file when it is going to write output, and if it is present writes all output and then returns cleanly. The 'stop file' is deleted when a run is (re-)started, if present, so you do not have to manually delete it before (re-)starting the run again.","category":"page"},{"location":"getting_started/#Restarting","page":"Getting started","title":"Restarting","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To restart a simulation using input.toml from the last time point in the existing run directory,","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project run_moment_kinetics --restart input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"or to restart from a specific output file - either from the same run or (if the settings are compatible, see below) a different one - here runs/example/example.dfns.h5","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project run_moment_kinetics input.toml runs/example/example.dfns.h5","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The output file must include distribution functions. When not using parallel I/O there will be multiple output files from different MPI ranks - any one of these can be passed.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To do the same from the Julia REPL","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project\njulia> run_moment_kinetics(\"input.toml\", restart=true)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"or","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> run_moment_kinetics(\"input.toml\", restart=\"runs/example/example.dfns.h5\")","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When calling the run_moment_kinetics() function you can also choose a particular time index to restart from, e.g.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> run_moment_kinetics(\"input.toml\", restart=\"runs/example/example.dfns.h5\", restart_time_index=42)","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"On an HPC cluster, you can submit a restart (using the input file input.toml) to the batch queue using the convenience script","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-restart.sh input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"or to restart from a particular output file","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-restart.sh -r runs/example/example.dfns.h5 input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"See the help text","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-restart.sh -h","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"for various other command line options to change parameters (e.g. number of nodes, etc.).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you need to rebuild the system images moment_kinetics.so and makie_postproc.so or plots_postproc.so because you have updated the code since they were built, it may be convenient to use","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ ./submit-precompile-and-restart.sh [-r runs/example/example.dfns.h5] input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"which will submit jobs for compilation, to restart the simulation, and to do post processing. The simulation job will wait for the compilation job creating moment_kinetics.so to finish before starting. The post processing job will wait for the compilation job creating makie_postproc.so or plots_postproc.so to finish before starting.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"It is possible to restart a run from another output file with different resolution settings or different moment-kinetic options. This is done by interpolating variables from the old run onto the new grid.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When interpolating in spatial dimensions it is not recommended to change the length of the domain.\nFor velocity space dimensions, changing the size of the domain should be OK. Points outside the original domain will be filled with propto exp(-v^2) decreasing values.\nWhen changing from 1D (no r-dimension) to 2D (with r-dimension), the interpolated values will be constant in r.\nWhen changing from 1V to 2V or 3V, the interpolated values will be proportional to exp(-v_j^2) in the new dimension(s).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"When running in parallel, both the old and the new grids must be compatible with the distributed-MPI parallelisation. When not using Parallel I/O, the distributed-MPI domain decomposition must be identical in the old and new runs (as each block only reads from a single file).","category":"page"},{"location":"getting_started/#Post-processing-with-makie_post_processing","page":"Getting started","title":"Post-processing with makie_post_processing","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The default post-processing module, written to be a bit more generic and flexible than the original Plots-based one, and able to be used interactively, is provided in makie_post_processing, see Post processing.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"On an HPC cluster, when you call ./submit-run.sh or ./submit-restart.sh, a job will (by default) be submitted to run makie_post_processing.makie_post_process or plots_post_processing.analyze_and_plot_data (depending on which you have set up, or on whether you pass the -o argument when both are set up) on the output after the run is finished. You can skip this by passing the -a argument to ./submit-run.sh or ./submit-restart.sh.","category":"page"},{"location":"getting_started/#Original,-Plots-based-post-processing-quickstart","page":"Getting started","title":"Original, Plots-based post processing quickstart","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This post-processing functionality is now disabled by default, but you can enable it by entering y at the \"Would you like to set up plots_post_processing?\" prompt in machines/machine_setup.sh.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To make plots and calculate frequencies/growth rates, run","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia --project -O3 run_post_processing.jl runs/<directory to process>","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"passing the directory to process as a command line argument. Input options for post-processing can be specified in post_processing_input.jl. Note that even when running interactively, it is necessary to restart Julia after modifying post_processing_input.jl.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Post processing can be done for several directories at once using","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia --project -O3 post_processing_driver.jl runs/<directory1> runs/<directory2> ...","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"passing the directories to process as command line arguments. Optionally pass a number as the first argument to parallelise post processing of different directories.","category":"page"},{"location":"getting_started/#Parallel-I/O","page":"Getting started","title":"Parallel I/O","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To enable parallel I/O, HDF5.jl needs to be configured to use an HDF5 library which has MPI enabled and is compiled using the same MPI as you run Julia with. To ensure this happens, machines/machine_setup.sh will download the HDF5 source code and compile a local copy of the library under machines/artifacts, unless you enter n at the \"Do you want to download, and compile a local version of HDF5\" prompt (except on known HPC clusters where an MPI-enabled HDF5 is provided by a module - this is currently true on ARCHER2 - where the module-provided HDF5 is used).","category":"page"},{"location":"getting_started/#Running-parameter-scans","page":"Getting started","title":"Running parameter scans","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Parameter scans (see Parameter scans) can be performed by running","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -O3 --project run_parameter_scan.jl path/to/scan/input.toml","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If running a scan, it can be parallelised by passing the -p argument to julia, e.g. to run on 8 processes","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"$ julia -p 8 -O3 --project run_parameter_scan.jl path/to/scan/input.toml","category":"page"},{"location":"getting_started/#Tests","page":"Getting started","title":"Tests","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"There is a test suite in the test/ subdirectory. It can be run in a few ways:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Execute some or all of the tests as a script. For example in the terminal run   $ julia -O3 --project moment_kinetcs/test/runtests.jl   or in the REPL run   julia> include(\"moment_kinetcs/test/runtests.jl\")   Individual test files can also be used instead of runtests.jl, which runs all the tests.\nYou can also run the tests using Pkg. Either using pkg> mode   $ julia -O3 --project   julia> <press ']' to enter pkg mode>   (moment_kinetics) pkg> test moment_kinetics   using Pkg in the REPL   $ julia -O3 --project   julia> import Pkg   julia> Pkg.test(\"moment_kinetics\")   or run on the command line   julia -O3 --project -e \"import Pkg; Pkg.test(\"moment_kinetics\")`   The downside of this method is that it will cause NCDatasets to be   installed if you did not install it already, which might sometimes cause   linking errors (related to the HDF5 library, see Optional   dependencies).","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"By default the test suite should run fairly quickly (in a few minutes). To do so, it skips many cases. To run more comprehensive tests, you can activate the --long option:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In the REPL, run   julia> push!(ARGS, \"--long\")   before running the tests.\nRunning from the terminal, pass as a command line argument, e.g.   $ julia -O3 --project --long moment_kinetics/test/runtests.jl\nUsing test_args argument   julia> Pkg.test(\"moment_kinetics\"; test_args=[\"--long\"])   Note the semicolon is necessary.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"To get more output on what tests were successful, an option --verbose (or -v) can be passed in a similar way to --long (if any tests fail, the output is printed by default).","category":"page"},{"location":"machine_setup_notes/#machine_setup-notes","page":"machine_setup notes","title":"machine_setup notes","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"The machines subdirectory provides scripts to set up Julia and moment_kinetics to run on laptops/desktops or on clusters. If the cluster is not one of the currently supported machines, then some additional manual setup is required.","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"Currently supported:","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"\"generic-pc\" - A generic personal computer (i.e. laptop or desktop machine). Set up for interactive use, rather than for submitting jobs to a batch queue.\n\"generic-batch\" - A generic cluster using a batch queue. Requires some manual setup first, see machines/generic-batch-template/README.md.\n\"archer\" - the UK supercomputer ARCHER2\n\"marconi\" - the EUROfusion supercomputer Marconi","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"The usage is described in Getting started. This page contains some extra technical information.","category":"page"},{"location":"machine_setup_notes/#Notes-on-some-prompts-from-the-script","page":"machine_setup notes","title":"Notes on some prompts from the script","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"You will be prompted to enter a location for your .julia directory. If you are installing on a personal computer or on a cluster which allows access to your home directory from compute nodes, it is fine to leave this as the default. If not (e.g. on ARCHER2), you need to set a path which is accessible from the compute nodes.  If you want to create a completely self-contained install (e.g. for reproducibility or for debugging some dependency conflicts), you might want to put .julia within the moment_kinetics directory (i.e. enter .julia at the prompt).","category":"page"},{"location":"machine_setup_notes/#Defaults-for-prompts","page":"machine_setup notes","title":"Defaults for prompts","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"The default value for each of the settings that the user is prompted for interactively are first taken from some sensible, machine-specific defaults. When machines/machine_setup.sh is run, the values chosen by the user are saved in the [moment_kinetics] section of LocalPreferences.toml, and these values are used as the defaults next time machines/machine_setup.sh is run, in order to make it easier to re-run the setup, e.g. because some dependencies need updating, or to change just one or a few settings.","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"A few settings (which are needed before Julia can be started for the first time) are saved into hidden files (.julia_default.txt, .this_machine_name.txt, and .julia_directory_default.txt) instead of into LocalPreferences.toml, to avoid needing to parse a TOML file using bash.","category":"page"},{"location":"machine_setup_notes/#bin/julia","page":"machine_setup notes","title":"bin/julia","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"A symlink or script is created at bin/julia to call the chosen julia executable. On HPC systems we create a file julia.env which must be source'd (to load the right modules, etc.) before julia can be used - in this case julia.env can be used to set up any environment variables, etc. so a symlink is sufficient. On laptops/desktops that will be used interactively, it is inconvenient to have to remember to source julia.env, especially if you have multiple instances of moment_kinetics, so instead the necessary setup (of the JULIA_DEPOT_PATH environment variable, if needed, and a Python venv if the Plots-based post processing is enabled) is done by making bin/julia a   small bash script, which does that setup and then calls the chosen julia   executable, passing through to it any command line arguments.","category":"page"},{"location":"machine_setup_notes/#julia.env","page":"machine_setup notes","title":"julia.env","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"A julia.env file is used on HPC systems to set up the environment (modules and environment variables). On laptop/desktop systems this would be inconvenient (especially if there are multiple instances of moment_kinetics) so a julia.env is not used for these.","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"The julia.env is created from a template julia.env which is located in the subdirectory of machines/ for the specific machine being set up.","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"If you need to run julia interactively (for moment_kinetics) on a machine that uses julia.env, either run source julia.env in each terminal session where you want to use moment_kinetics, or add it to your .bashrc (if this does not conflict with any other projects).","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"warning: Warning\nNote that julia.env runs module purge to remove any already loaded modules (to get a clean environment). It is therefore very likely to interfere with other projects.","category":"page"},{"location":"machine_setup_notes/#Setup-of-post-processing-packages","page":"machine_setup notes","title":"Setup of post processing packages","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"See Post processing packages.","category":"page"},{"location":"machine_setup_notes/#Use-of-system-images","page":"machine_setup notes","title":"Use of system images","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"On HPC clusters, creating system images moment_kinetics.so and for post processing makie_postproc.so and/or plots_postproc.so is required. This is to avoid (as far as practical) wasting CPU hours doing identical compilation in large parallel jobs. If you wanted to remove this requirement for some reason (although this is not recommended), you would need to go to the subdirectory of machines/ for the machine you are working on, and edit the jobscript-run.template, jobscript-restart.template, jobscript-postprocess.template, and jobscript-postprocess-plotsjl.template files to remove the -J*.so argument.  If you do do this, please do not commit those changes and merge them to the master branch of moment_kinetics.","category":"page"},{"location":"machine_setup_notes/#Operations-done-by-machines/machine_setup.sh","page":"machine_setup notes","title":"Operations done by machines/machine_setup.sh","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"The convenience script machine_setup.sh is provide because the actual setup happens in multiple stages, with Julia being restarted in between (as this is required on some machines), and because the script is able to download Julia if Julia is not already installed.","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"The steps done by machines/machine_setp.sh are:","category":"page"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"Get the name of the 'machine' ('generic-pc', 'archer', etc.) so that machine-dependent setup can be done and machine-specific defaults can be used. ()\nDownload a Julia executable, or prompt the user for the location of one (defaulting to any julia found in $PATH).\nGet the location of the .julia directory to be used by (this copy of) moment_kinetics. At this point we have enough setup to start using julia. Export JULIA_DEPOT_PATH so that this is used any time julia is run in the rest of the script.\nRun machines/shared/machine_setup.jl. This script (whose functions are documented in API documentation):\nprompts the user for most of the settings (and saves them to LocalPreferences.toml from where they can be accessed by other scripts later and used as defaults if machines/machine_setup is re-run)\ncreates the julia.env file (from the template for the given machine) on HPC systems\ncreates the bin/julia symlink or script (see bin/julia)\ncreates a link to the compile_dependencies.sh script for the machine (if there is one).\ninstalls the Revise package and adds using Revise to the startup.jl file (on laptop/desktop systems, and if the user did not de-select this).\nIt is necessary to restart julia after this script has been run, so that we can first source julia.env (if it exists) or use the script at bin/julia in order to use the environment settings in them.\nIf julia.env exists, run source julia.env to load modules, etc.\nSet the optimization flags that will be used for running simulations or for running post processing. These need to be set the same as will be used eventually so that precompilation of dependencies and packages that happens while running machines/machine_setup.sh does not need to be overwritten (due to different optimization flags) later, as this would be a waste of time (although it should work fine).\nAdd various dependencies to the top-level project, by calling machines/shared/add_dependencies_to_project.jl. This will set up MPI and HDF5 to link to the correct libraries. julia needs to be restarted after the setup of MPI and HDF5 is done, which is why this is a separate script from the following one (this separation also allows add_dependencies_to_project.jl to be re-used in makie_post_processing_setup.jl and plots_post_processing_setup.jl if these are to be set up as separate projects from the top-level one).\nComplete the setup by running machines/shared/machine_setup_stage_two.jl, which creates a Python venv with matplotlib installed (if plots_post_processing is enabled), creates symlinks at the top level to scripts to submit batch jobs (if setting up for an HPC cluster), and submits a job to compile a system image for moment_kinetics (if setting up for an HPC cluster, and if the user did not de-select this).\nSet up makie_post_processing (if enabled) by running machines/shared/makie_post_processing_setup.jl and/or plots_post_processing (if enabled) by running machines/shared/plots_post_processing_setup.jl. These scripts also submit jobs to create system images for makie_post_processing or plots_post_processing (if setting up for an HPC cluster, and if the user did not de-select this).\nPrint a message indicating which optimization flags to use for running simulations or for post-processing.","category":"page"},{"location":"machine_setup_notes/#machine_setup_api_documentation","page":"machine_setup notes","title":"API documentation","text":"","category":"section"},{"location":"machine_setup_notes/","page":"machine_setup notes","title":"machine_setup notes","text":"Modules = [moment_kinetics.machine_setup]","category":"page"},{"location":"machine_setup_notes/#moment_kinetics.machine_setup","page":"machine_setup notes","title":"moment_kinetics.machine_setup","text":"Functions to help setting up on known machines\n\n\n\n\n\n","category":"module"},{"location":"machine_setup_notes/#moment_kinetics.machine_setup.get_setting","page":"machine_setup notes","title":"moment_kinetics.machine_setup.get_setting","text":"get_setting(setting_name, message, machine, local_defaults,\n            possible_values=nothing)\n\nPrompt the user to set a setting called setting_name after printing message. Default value is read from local_defaults if it exists there (which it will do if it has been set before, as then it is stored in LocalPreferences.toml), or from sensible defaults in the machine section of default_settings otherwise.\n\n\n\n\n\n","category":"function"},{"location":"machine_setup_notes/#moment_kinetics.machine_setup.get_user_input-Tuple{Any, Any}","page":"machine_setup notes","title":"moment_kinetics.machine_setup.get_user_input","text":"get_user_input(possible_values, default_value)\n\nPrompt for user input. If the user enters nothing, return default_value. Check that the entered value is one of possible_values, if not prompt again.\n\n\n\n\n\n","category":"method"},{"location":"machine_setup_notes/#moment_kinetics.machine_setup.machine_setup_moment_kinetics-Tuple{String}","page":"machine_setup notes","title":"moment_kinetics.machine_setup.machine_setup_moment_kinetics","text":"machine_setup_moment_kinetics(machine::String; ; no_force_exit::Bool=false,\n                              interactive::Bool=true)\n\nDo setup for a known machine, prompting the user for various settings (with defaults set to sensible values - if the script has been run before, the defaults are the previously used values):\n\nOn clusters that use a module system, provide julia.env at the top level of the moment_kinetics repo.\nCall\nsource julia.env\nto get the correct modules for running moment_kinetics, either on the command line (to get them for the current session) or in your .bashrc (to get them by default). Note that this calls module purge so will remove any currently loaded modules when it is run.\nMakes a symlink to, or a bash script that calls, the Julia executable used to run this command at bin/julia under the moment_kinetics repo, so that setup and job submission scripts can use a known relative path.\nnote: Note\nIf you change the Julia executable, e.g. to update to a new verison, you will need to either replace the symlink <moment_kinetics>/bin/julia or edit the bash script at <moment_kinetics>/bin/julia by hand, or re-run this function using the new executable.\n\nUsually it is necessary for Julia to be restarted after running this function to run Julia with the correct JULIA_DEPOT_PATH, etc. so the function will force Julia to exit. If for some reason this is not desired (e.g. when debugging), pass no_force_exit=true.\n\nThe interactive argument exists so that when this function is called from another script, terminal output with instructions for the next step can be disabled.\n\nCurrently supported machines:\n\n\"generic-pc\" - A generic personal computer (i.e. laptop or desktop machine).. Set up   for interactive use, rather than for submitting jobs to a batch queue.\n\"generic-batch\" - A generic cluster using a batch queue. Requires some manual setup   first, see machines/generic-batch-template/README.md.\n\"archer\" - the UK supercomputer ARCHER2\n\"marconi\" - the EUROfusion supercomputer   Marconi\n\nnote: Note\nThe settings created by this function are saved in LocalPreferences.toml. It might sometimes be useful to edit these by hand (e.g.  the account setting if this needs to be changed.): it is fine to do this.\n\n\n\n\n\n","category":"method"}]
}
