<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Timestepping · moment_kinetics</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">moment_kinetics</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../constraints_on_normalized_distribution_function/">Constraints on normalized distribution function</a></li><li><a class="tocitem" href="../debugging-hints/">Debugging</a></li><li><a class="tocitem" href="../developing/">Developing</a></li><li><a class="tocitem" href="../external_sources_notes/">External sources</a></li><li><a class="tocitem" href="../geometry/">Magnetic Geometry</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../input_options/">Input Options</a></li><li><a class="tocitem" href="../machine_setup_notes/"><code>machine_setup</code> notes</a></li><li><a class="tocitem" href="../manual_setup/">Manual setup</a></li><li><a class="tocitem" href="../moment_kinetic_equations/">Moment kinetic equations</a></li><li><a class="tocitem" href="../parameter_scans/">Parameter scans</a></li><li><a class="tocitem" href="../post_processing_notes/">Post processing</a></li><li><a class="tocitem" href="../shared_memory_debugging/">Shared memory debugging</a></li><li class="is-active"><a class="tocitem" href>Timestepping</a><ul class="internal"><li><a class="tocitem" href="#Fixed-timestep-schemes"><span>Fixed-timestep schemes</span></a></li><li><a class="tocitem" href="#Adaptive-timestep-schemes"><span>Adaptive-timestep schemes</span></a></li><li><a class="tocitem" href="#timestepping-input-parameters"><span>Input parameters</span></a></li><li><a class="tocitem" href="#Diagnostics"><span>Diagnostics</span></a></li><li><a class="tocitem" href="#Developing"><span>Developing</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../wall_boundary_conditions/">Wall boundary conditions with moment constraints</a></li><li><a class="tocitem" href="../zz_advection/"><code>advection</code></a></li><li><a class="tocitem" href="../zz_analysis/"><code>analysis</code></a></li><li><a class="tocitem" href="../zz_array_allocation/"><code>array_allocation</code></a></li><li><a class="tocitem" href="../zz_bgk/"><code>bgk</code></a></li><li><a class="tocitem" href="../zz_calculus/"><code>calculus</code></a></li><li><a class="tocitem" href="../zz_charge_exchange/"><code>charge_exchange</code></a></li><li><a class="tocitem" href="../zz_chebyshev/"><code>chebyshev</code></a></li><li><a class="tocitem" href="../zz_clenshaw_curtis/"><code>clenshaw_curtis</code></a></li><li><a class="tocitem" href="../zz_command_line_options/"><code>command_line_options</code></a></li><li><a class="tocitem" href="../zz_communication/"><code>communication</code></a></li><li><a class="tocitem" href="../zz_constants/"><code>constants</code></a></li><li><a class="tocitem" href="../zz_continuity/"><code>continuity</code></a></li><li><a class="tocitem" href="../zz_coordinates/"><code>coordinates</code></a></li><li><a class="tocitem" href="../zz_debugging/"><code>debugging</code></a></li><li><a class="tocitem" href="../zz_derivatives/"><code>derivatives</code></a></li><li><a class="tocitem" href="../zz_em_fields/"><code>em_fields</code></a></li><li><a class="tocitem" href="../zz_energy_equation/"><code>energy_equation</code></a></li><li><a class="tocitem" href="../zz_external_sources/"><code>external_sources</code></a></li><li><a class="tocitem" href="../zz_file_io/"><code>file_io</code></a></li><li><a class="tocitem" href="../zz_finite_differences/"><code>finite_differences</code></a></li><li><a class="tocitem" href="../zz_fokker_planck/"><code>fokker_planck</code></a></li><li><a class="tocitem" href="../zz_fokker_planck_calculus/"><code>fokker_planck_calculus</code></a></li><li><a class="tocitem" href="../zz_fokker_planck_test/"><code>fokker_planck_test</code></a></li><li><a class="tocitem" href="../zz_force_balance/"><code>force_balance</code></a></li><li><a class="tocitem" href="../zz_gauss_legendre/"><code>gauss_legendre</code></a></li><li><a class="tocitem" href="../zz_geo/"><code>geo</code></a></li><li><a class="tocitem" href="../zz_initial_conditions/"><code>initial_conditions</code></a></li><li><a class="tocitem" href="../zz_input_structs/"><code>input_structs</code></a></li><li><a class="tocitem" href="../zz_interpolation/"><code>interpolation</code></a></li><li><a class="tocitem" href="../zz_ionization/"><code>ionization</code></a></li><li><a class="tocitem" href="../zz_krook_collisions/"><code>krook_collisions</code></a></li><li><a class="tocitem" href="../zz_load_data/"><code>load_data</code></a></li><li><a class="tocitem" href="../zz_looping/"><code>looping</code></a></li><li><a class="tocitem" href="../zz_makie_post_processing/"><code>makie_post_processing</code></a></li><li><a class="tocitem" href="../zz_manufactured_solns/"><code>manufactured_solns</code></a></li><li><a class="tocitem" href="../zz_moment_constraints/"><code>moment_constraints</code></a></li><li><a class="tocitem" href="../zz_moment_kinetics/"><code>moment_kinetics</code></a></li><li><a class="tocitem" href="../zz_moment_kinetics_input/"><code>moment_kinetics_input</code></a></li><li><a class="tocitem" href="../zz_moment_kinetics_structs/"><code>moment_kinetics_structs</code></a></li><li><a class="tocitem" href="../zz_neutral_r_advection/"><code>neutral_r_advection</code></a></li><li><a class="tocitem" href="../zz_neutral_vz_advection/"><code>neutral_vz_advection</code></a></li><li><a class="tocitem" href="../zz_neutral_z_advection/"><code>neutral_z_advection</code></a></li><li><a class="tocitem" href="../zz_numerical_dissipation/"><code>numerical_dissipation</code></a></li><li><a class="tocitem" href="../zz_plot_MMS_sequence/"><code>plot_MMS_sequence</code></a></li><li><a class="tocitem" href="../zz_plot_sequence/"><code>plot_sequence</code></a></li><li><a class="tocitem" href="../zz_plots_post_processing/"><code>plots_post_processing</code></a></li><li><a class="tocitem" href="../zz_quadrature/"><code>quadrature</code></a></li><li><a class="tocitem" href="../zz_r_advection/"><code>r_advection</code></a></li><li><a class="tocitem" href="../zz_reference_parameters/"><code>reference_parameters</code></a></li><li><a class="tocitem" href="../zz_runge_kutta/"><code>runge_kutta</code></a></li><li><a class="tocitem" href="../zz_source_terms/"><code>source_terms</code></a></li><li><a class="tocitem" href="../zz_time_advance/"><code>time_advance</code></a></li><li><a class="tocitem" href="../zz_type_definitions/"><code>type_definitions</code></a></li><li><a class="tocitem" href="../zz_utils/"><code>utils</code></a></li><li><a class="tocitem" href="../zz_velocity_grid_transforms/"><code>velocity_grid_transforms</code></a></li><li><a class="tocitem" href="../zz_velocity_moments/"><code>velocity_moments</code></a></li><li><a class="tocitem" href="../zz_vpa_advection/"><code>vpa_advection</code></a></li><li><a class="tocitem" href="../zz_z_advection/"><code>z_advection</code></a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Timestepping</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Timestepping</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mabarnes/moment_kinetics/blob/master/docs/src/timestepping.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Timestepping"><a class="docs-heading-anchor" href="#Timestepping">Timestepping</a><a id="Timestepping-1"></a><a class="docs-heading-anchor-permalink" href="#Timestepping" title="Permalink"></a></h1><p>Timestepping in <code>moment_kinetics</code> can be done with various explicit Runge-Kutta (RK) schemes. The default is a fixed-timestep 3rd-order, 4-stage, strong stability preserving (SSP) RK scheme.</p><p>Several schemes (including all the fixed-timestep schemes) use a &#39;low storage&#39; option, where only values from the first stage and previous stage are required for each stage update<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><h2 id="Fixed-timestep-schemes"><a class="docs-heading-anchor" href="#Fixed-timestep-schemes">Fixed-timestep schemes</a><a id="Fixed-timestep-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-timestep-schemes" title="Permalink"></a></h2><p>The fixed timestep schemes use a constant <code>dt</code>, specified in the input file, for the whole simulation. The available types are:</p><ul><li>&quot;SSPRK1&quot; - forward Euler method</li><li>&quot;SSPRK2&quot; - Heun&#39;s method</li><li>&quot;SSPRK3&quot; - a 3-stage, 3rd order method, see <a href="https://en.wikipedia.org/wiki/List_of_Runge%E2%80%93Kutta_methods">this Wikipedia list</a></li><li>&quot;SSPRK4&quot; - the default, a 4-stage, 3rd order method, see [R.J. Spiteri, and S.J.  Ruuth. &quot;A new class of optimal high-order strong-stability-preserving time discretization methods.&quot; SIAM Journal on Numerical Analysis 40.2 (2002): 469-491., referenced in Dale E. Durran, “Numerical Methods for Fluid Dynamics”, Springer. Second Edition].</li></ul><h2 id="Adaptive-timestep-schemes"><a class="docs-heading-anchor" href="#Adaptive-timestep-schemes">Adaptive-timestep schemes</a><a id="Adaptive-timestep-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-timestep-schemes" title="Permalink"></a></h2><p>Several SSP schemes are included from [Fekete, Conde and Shadid, &quot;Embedded pairs for optimal explicit strong stability preserving Runge-Kutta methods&quot;, Journal of Computational and Applied Mathematics 421 (2022) 114325, <a href="https://doi.org/10.1016/j.cam.2022.114325">https://doi.org/10.1016/j.cam.2022.114325</a>]:</p><ul><li>&quot;Fekete4(3)&quot; a 4-stage, 3rd order method, the recommended 3rd order method in Fekete et al. Identical to the default &quot;SSPRK4&quot; fixed-step method, but with an embedded 2nd order method used to provide error control for adaptive timestepping. This is probably a good first choice for an adaptive timestep method.</li><li>&quot;Fekete4(2)&quot; a 4-stage, 2nd order method, the recommended 2nd order method in Fekete et al.</li><li>&quot;Fekete10(4)&quot; a 10-stage, 4th order method, the recommended 4th order method in Fekete et al. May allow longer timesteps than &quot;Fekete4(3)&quot;, but probably not any faster as more stages are required per timestep. However, if very high accuracy is required (very tight <code>rtol</code> and <code>atol</code> tolerances), the higher accuracy may be an advantage.</li><li>&quot;Fekete6(4)&quot; a 6-stage, 4th order method.</li></ul><p>The classic &quot;Runge-Kutta-Fehlberg&quot; method [<a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method">https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method</a>, &#39;COEFFICIENTS FOR RK4(5), FORMULA 2 Table III in Fehlberg&#39; - note the Wikipedia page seems to have a typo in one of the error coefficients, see comment in <code>utils/calculate_rk_coeffs.jl</code>] is also provided as &quot;RKF5(4)&quot;. This method seems to require a significantly smaller timestep to be stable than the SSP methods from Fekete et al., but might be useful if very high accuracy is required as it is a 5th-order accurate method. It uses 6 stages per step.</p><h3 id="Algorithm-for-choosing-the-next-timestep"><a class="docs-heading-anchor" href="#Algorithm-for-choosing-the-next-timestep">Algorithm for choosing the next timestep</a><a id="Algorithm-for-choosing-the-next-timestep-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-for-choosing-the-next-timestep" title="Permalink"></a></h3><p>These adaptive timestepping methods use several criteria to set or limit the timestep:</p><ul><li>Truncation error, which is estimated by the difference between the higher and lower order methods of an &#39;embedded pair&#39;. The timestep size needed to maintain a specified accuracy can be estimated from the size of the trucation error (knowing the order of accuracy of the method), as described for example in Fehlberg et al. This estimate is used unless it is larger than any of the following limits. The error limit is set by relative tolerance &quot;rtol&quot; and absolute tolerance &quot;atol&quot; parameters. For each variable <span>$X$</span> the error metric (calculated in <a href="../zz_runge_kutta/#moment_kinetics.runge_kutta.local_error_norm"><code>moment_kinetics.time_advance.local_error_norm</code></a> is the root-mean-square (RMS, or &#39;L2 norm&#39;) of <span>$\epsilon$</span>:<p class="math-container">\[\epsilon = \frac{E_{X}}{(\mathtt{rtol}*|X| + \mathtt{atol})}\]</p>where <span>$E_{X}$</span> is the truncation error estimate for <span>$X$</span>. If the RMS of <span>$\epsilon$</span>, averaged over all evolved variables, is greater than 1, then the step is considered &#39;failed&#39; and is re-done with a shorter timestep (set by the lower of half of the failed timestep, or the timestep calculated using the estimate based on <span>$\epsilon$</span>).</li><li>CFL criteria [<a href="https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition">https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition</a>]. These are estimated for the spatial advection and velocity-space advection terms in the kinetic equation(s), using the methods <a href="../zz_utils/#moment_kinetics.utils.get_minimum_CFL_z-Tuple{AbstractArray{T, 4} where T, Any}"><code>moment_kinetics.utils.get_minimum_CFL_z</code></a>, <a href="../zz_utils/#moment_kinetics.utils.get_minimum_CFL_vpa-Tuple{AbstractArray{T, 4} where T, Any}"><code>moment_kinetics.utils.get_minimum_CFL_vpa</code></a>, <a href="../zz_utils/#moment_kinetics.utils.get_minimum_CFL_neutral_z-Tuple{AbstractArray{T, 5} where T, Any}"><code>moment_kinetics.utils.get_minimum_CFL_neutral_z</code></a>, <a href="../zz_utils/#moment_kinetics.utils.get_minimum_CFL_neutral_vz-Tuple{AbstractArray{T, 5} where T, Any}"><code>moment_kinetics.utils.get_minimum_CFL_neutral_vz</code></a>. These estimates are multiplied by a user-set prefactor - the correct value for the prefactor depends on both the timestepping scheme and the spatial discretisation, so to be pragmatic we tune the value by trial and error. [CFL limits associated with other terms in the equations could be added in a similar way if it is useful.]</li><li>At each step, the timestep is allowed to increase by at most a (user-set) factor, to avoid large jumps that might cause numerical instability.</li><li>There is an option to set a minimum timestep, which may be useful to push the simulation through initial transients where there is some numerical instability which would make the truncation error estimate push the timestep to ridiculously small values. Since we might not care about accuracy too much during these initial transients, it can be useful to set a minimum to stop the timestep getting too small (as long as the minimum is small enough that the simulation does not crash).</li></ul><p>The estimates and limits just described are controlled by various tuning parameters, described in <a href="#timestepping-input-parameters">timestepping-input-parameters</a>, that may need to be set appropriately to get good performance from the adaptive timestepping methods.  The timestep achievable may be limited by accuracy or by stability. If the <code>CFL_prefactor</code> is set too high (or the relevant CFL limit is not being checked) then the timestep will try to increase too high for stability - when this happens, the step will also become inaccurate, causing timestep failures and reducing the timestep. So the simulation should continue without crashing, however it will be inefficient as the truncation error estimate will not &#39;see&#39; the stability limit until the limit is exceeded, resulting in a cycle of increasing timestep followed by (probably repeated) timestep failures. The aim should probably be to set the <code>CFL_limit_prefactor</code> and <code>max_increase_factor</code> to the highest values that do not lead to too many timestep failures (a few failures are OK, especially during the initial transient phase of simulations). <code>step_update_prefactor</code> can also be decreased to use a bigger margin in the timestep estimated from the error metric <span>$\epsilon$</span> - using a smaller <code>step_update_prefactor</code> will make the timestep smaller when it is limited by accuracy, but this can (sometimes!) help avoid timestep failures, which <em>might</em> decrease the total number of steps. </p><p>Special treatment is needed for the time points where output is to be written. When the next timestep would take the simulation time beyond the next time where output is to be written, the timestep is set instead to take the simulation to the output time. Then output is written and the timestep is reset to the last full timestep value from before the output.</p><h3 id="Alternative-algorithm-for-choosing-the-next-timestep"><a class="docs-heading-anchor" href="#Alternative-algorithm-for-choosing-the-next-timestep">Alternative algorithm for choosing the next timestep</a><a id="Alternative-algorithm-for-choosing-the-next-timestep-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-algorithm-for-choosing-the-next-timestep" title="Permalink"></a></h3><p>It might turn out that the particular CFL limits that are included in the algorithm described in <a href="#Algorithm-for-choosing-the-next-timestep">Algorithm for choosing the next timestep</a> are not a complete set of the things that set the stability limit for the explicit RK timestep. If that is the case, it may be useful to have a more generic algorithm that can still fairly robustly choose a good timestep size, without a large number of timestep failures. One option is described in this subsection. For the parameters discussed, see again <a href="#timestepping-input-parameters">timestepping-input-parameters</a>.</p><p>If we assume that <code>dt</code> that last failed the timestep truncation error test is a good estimate of the <code>dt</code> that is the boundary between stable and unstable timstep values, then it makes sense to try to keep timesteps close to that (to avoid failures), although we also want to allow the timestep to increase past that value in case it was a bad estimate (e.g. during some sort of transient) or because the stability limits have changed (e.g. parallel gradients in the simulation have changed significantly). We would like to stay close to a marginally stable (rather than marginally unstable) timestep, so take as the estimate the last successful timestep before the most recent failed timestep (this is stored in the code as <code>t_params.dt_before_last_fail[]</code>). When <code>dt</code> is within a factor <code>last_fail_proximity_factor</code> of this value, we limit the increase in timestep to <code>max_increase_factor_near_last_fail</code>, rather than <code>max_increase_factor</code>. Suggested setup (which of course is likely to need adjusting depending on the simulation!):</p><ul><li>Set <code>max_increase_factor_near_last_fail</code> to a value very close to 1, say 1.001. This means that the timestep can only very slowly approach and exceed <code>t_params.dt_before_last_fail[]</code>. Setting this value closer to 1 should decrease the number of timestep failures.</li><li>Set <code>max_increase_factor</code> to a relatively large value, say 1.5 or 2, so that when a timestep does fail, <code>dt</code> quickly recovers to a value close to the last successful value before the failure.</li><li>Set <code>step_update_prefactor</code> to a relatively small value, say 0.5. <code>step_update_prefactor</code> controls how far <code>dt</code> is set below the value needed to comply with the requested tolerances. Setting a smallish value (so a large margin below the value that would trigger a timestep failure) seems to help - current guess (JTO 20/3/2024) is that: when <code>dt</code> is close to (or maybe just above) the value that would be unstable, the error starts to grow; with some margin, and with the factor by which <code>dt</code> increases limited to a small value, so that <code>dt</code> is at worst very marginally unstable, the truncation error estimate can feel the error and decrease <code>dt</code> (modestly) back to a stable value, before the error becomes big enough to cause a timestep failure. Once <code>dt</code> has been decreased (but not too much) it is again only allowed to increase slowly, so as long as these decreases happen often enough, <code>dt</code> can stay around the stability boundary without causing timestep failures. Decreasing this value should decrease the number of timestep failures.</li><li><code>last_fail_proximity_factor</code> - current guess (JTO 20/3/2024) is that the default value of 1.05 is reasonable. Increasing this value should decrease the number of timestep failures, but will also increase the number of steps needed before the timestep can increase past a too-low value (from a bad estimate, transient, changed simulation conditions, etc.).</li><li>As a rough guideline, more than one timestep failures on average per 100 timesteps is probably too many to be efficient, while around or less than this many is probably acceptable. If there are too many failures, try tweaking parameters as indicated above.</li></ul><p>In at least one case JTO has been able to use this method to get a simulation to run without imposing CFL restrictions explicitly, in a similar number of steps as when using (well-tuned) explicit CFL restrictions.</p><h2 id="timestepping-input-parameters"><a class="docs-heading-anchor" href="#timestepping-input-parameters">Input parameters</a><a id="timestepping-input-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#timestepping-input-parameters" title="Permalink"></a></h2><table><tr><th style="text-align: left">Option name</th><th style="text-align: left">Default value</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>nstep</code></td><td style="text-align: left">5</td><td style="text-align: left"><code>nstep*dt</code> is the total length of the run. For fixed-step timestepping, <code>nstep</code> is the total number of timesteps</td></tr><tr><td style="text-align: left"><code>dt</code></td><td style="text-align: left"><span>$0.00025/T$</span></td><td style="text-align: left">For fixed-step, gives the length of the timestep. For adaptive-step gives the initial guess for the timestep. <span>$T$</span> in the default value is the initial temperature of the ions</td></tr><tr><td style="text-align: left"><code>CFL_prefactor</code></td><td style="text-align: left"><code>-1.0</code></td><td style="text-align: left">Prefactor that the CFL limits from <a href="../zz_utils/#moment_kinetics.utils.get_minimum_CFL_z-Tuple{AbstractArray{T, 4} where T, Any}"><code>moment_kinetics.utils.get_minimum_CFL_z</code></a>, <a href="../zz_utils/#moment_kinetics.utils.get_minimum_CFL_vpa-Tuple{AbstractArray{T, 4} where T, Any}"><code>moment_kinetics.utils.get_minimum_CFL_vpa</code></a>, <a href="../zz_utils/#moment_kinetics.utils.get_minimum_CFL_neutral_z-Tuple{AbstractArray{T, 5} where T, Any}"><code>moment_kinetics.utils.get_minimum_CFL_neutral_z</code></a>, <a href="../zz_utils/#moment_kinetics.utils.get_minimum_CFL_neutral_vz-Tuple{AbstractArray{T, 5} where T, Any}"><code>moment_kinetics.utils.get_minimum_CFL_neutral_vz</code></a> are multiplied by to set the timestep limit. If no value is given, a default is set according to which timestepping scheme is chosen (see <a href="../zz_runge_kutta/#moment_kinetics.runge_kutta.setup_runge_kutta_coefficients!-Tuple{Any, Any, Any}"><code>moment_kinetics.runge_kutta.setup_runge_kutta_coefficients!</code></a>).</td></tr><tr><td style="text-align: left"><code>nwrite</code></td><td style="text-align: left"><code>1</code></td><td style="text-align: left">Output of moment quantities is written every <code>nwrite*dt</code> time units.</td></tr><tr><td style="text-align: left"><code>nwrite_dfns</code></td><td style="text-align: left"><code>nothing</code></td><td style="text-align: left">Output of distribution function quantities is written every <code>nwrite_dfns*dt</code> time units. By default distribution function quantities are written only at the beginning and end of the simulation.</td></tr><tr><td style="text-align: left"><code>type</code></td><td style="text-align: left"><code>&quot;SSPRK4&quot;</code></td><td style="text-align: left">Timestepping method, see <a href="#Fixed-timestep-schemes">Fixed-timestep schemes</a> and <a href="#Adaptive-timestep-schemes">Adaptive-timestep schemes</a>.</td></tr><tr><td style="text-align: left"><code>split_operators</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">If true, use operator splitting. Operator splitting is currently only partially implemented.</td></tr><tr><td style="text-align: left"><code>stopfile_name</code></td><td style="text-align: left"><code>&quot;stop&quot;</code></td><td style="text-align: left">Name of the file that can be created in the output directory to stop the simulation cleanly after the next output is written.</td></tr><tr><td style="text-align: left"><code>steady_state_residual</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">Set to <code>true</code> to print out the maximum residual <span>$r(t) = \frac{\left| n(t)-n(t-\delta t)\right| }{\delta t}$</span> of the density for each species at each output step</td></tr><tr><td style="text-align: left"><code>converged_residual_value</code></td><td style="text-align: left">-1.0</td><td style="text-align: left">If <code>steady_state_residual = true</code> and <code>converged_residual_value</code> is set to a positive value, then the simulation will be stopped if all the density residuals are less than <code>converged_residual_value</code>. Note the residuals are only calculated and checked at time steps where output for moment variables is written.</td></tr><tr><td style="text-align: left"><code>rtol</code></td><td style="text-align: left"><code>1.0e-5</code></td><td style="text-align: left">Relative tolerance used for the truncation error metric.</td></tr><tr><td style="text-align: left"><code>atol</code></td><td style="text-align: left"><code>1.0e-12</code></td><td style="text-align: left">Absolute tolerance used for the truncation error metric.</td></tr><tr><td style="text-align: left"><code>atol_upar</code></td><td style="text-align: left"><code>1.0e-2*rtol</code></td><td style="text-align: left">Absolute tolerance used parallel flow moment variables in the truncation error metric. This is separate from <code>atol</code> as the flow moments are expected to pass through zero somewhere, unlike distribution functions, densities, or pressures that should always be positive.</td></tr><tr><td style="text-align: left"><code>step_update_prefactor</code></td><td style="text-align: left"><code>0.9</code></td><td style="text-align: left">When timestep is limited by accuracy (rather than something else), it is set to <code>step_update_prefactor</code> times the estimated timestep which would give an RMS error metric <code>$\epsilon$</code> of 1 at the next step. This value should always be less than 1. Smaller values give a bigger margin under the failure threshold, so may help reduce the number of timestep failures.</td></tr><tr><td style="text-align: left"><code>max_increase_factor</code></td><td style="text-align: left"><code>1.05</code></td><td style="text-align: left">Timestep can be increased by at most this factor at each step.</td></tr><tr><td style="text-align: left"><code>max_increase_factor_near_last_fail</code></td><td style="text-align: left"><code>Inf</code></td><td style="text-align: left">If set to finite value, replaces <code>max_increase_factor</code> when the timestep is near the last failed <code>dt</code> value (defined as within <code>last_fail_proximity_factor</code> of the last successful <code>dt</code> value before a timestep failure). If set, must be less than <code>max_increase_factor</code>.</td></tr><tr><td style="text-align: left"><code>last_fail_proximity_factor</code></td><td style="text-align: left"><code>1.05</code></td><td style="text-align: left">Defines the range considered &#39;near to&#39; the last failed <code>dt</code> value: <code>dt_before_last_fail/last_fail_proximity_factor &lt; dt &lt; dt_before_last_fail*last_fail_proximity_factor</code>.</td></tr><tr><td style="text-align: left"><code>minimum_dt</code></td><td style="text-align: left"><code>0.0</code></td><td style="text-align: left">Timestep is not allowed to decrease below this value, regardless of accuracy or stability limits.</td></tr><tr><td style="text-align: left"><code>maximum_dt</code></td><td style="text-align: left"><code>Inf</code></td><td style="text-align: left">Timestep is not allowed to increase above this value.</td></tr><tr><td style="text-align: left"><code>high_precision_error_sum</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">If this is set to <code>true</code>, then quad-precision values (<code>Float128</code> from the <code>Quadmath</code> package) are used to calculate the sum in the truncation error estimates. When different numbers of processes are used, the sums are calculated in different orders, so the rounding errors will be different. When adaptive timestepping is used this means that different timesteps will be used when different numbers of processes are used, so results will not be exactly the same (although they should be consistent within the timestepper tolerances and discretisation errors). When comparing &#39;identical&#39; simulations run on different numbers of processes (e.g. for debugging), these differences can be inconvenient. The differences can be avoided (or at least massively reduced) by using a higher precision for the sum, so that the order of the addition operations does not matter (at least until there are so many contributions to the sum that the rounding errors reduce the precision of the quad-precision result to less than double-precision, which would take a very large number!). This feature was originally added in an attempt to make adaptive-timestepping tests give consistent results (at a level <span>$\sim 10^{-14}$</span>) on the CI servers. However, rounding errors change randomly on different systems (operating system, compiler, hardware, etc.), not only because of the different order of terms in the sum in the truncation error norm, so consistency is not possible between different systems even with this feature.</td></tr></table><h2 id="Diagnostics"><a class="docs-heading-anchor" href="#Diagnostics">Diagnostics</a><a id="Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Diagnostics" title="Permalink"></a></h2><p>To help tune the settings for adaptive timestepping methods, several diagnostics are written to the output files:</p><ul><li><code>step_counter</code> is the cumulative number of time steps taken to reach each output.</li><li><code>dt</code> is the most recent timestep size at each output.</li><li><code>failure_counter</code> is the cumulative number of timestep failures.</li><li><code>failure_caused_by</code> counts the (cumulative) number of times each evolved variable (distribution functions or, for moment-kinetic simulations, moment variables) caused a timestep failure. <code>failure_caused_by</code> is a 2d array - the second dimension is time, the index of the first indicates the variable (see below for plotting of the diagnostics).</li><li><code>limit_caused_by</code> counts the (cumulative) number of times each factor (accuracy, CFL limits, maximum timestep increase factor, minimum timestep) set the timestep limit. <code>limit_caused_by</code> is a 2d array - the second dimension is time, the index of the first indicates the factor (see below for plotting of the diagnostics).</li></ul><p>These diagnostics (after being converted from cumulative counts to counts per output step) as well as the CFL limits are plotted and/or animated by <a href="../zz_makie_post_processing/#makie_post_processing.timestep_diagnostics-Tuple{Any}"><code>makie_post_processing.timestep_diagnostics</code></a>. This function will be called when running <a href="../zz_makie_post_processing/#makie_post_processing.makie_post_process-Tuple"><code>makie_post_processing.makie_post_process</code></a> if options in the <code>[timestep_diagnostics]</code> section of the post processing input are set: <code>plot=true</code> for plots or <code>animate_CFL=true</code> to make animations of the CFL limits for various terms.</p><h2 id="Developing"><a class="docs-heading-anchor" href="#Developing">Developing</a><a id="Developing-1"></a><a class="docs-heading-anchor-permalink" href="#Developing" title="Permalink"></a></h2><p>The script <code>utils/calculate_rk_coeffs.jl</code> provides some functions to convert a &#39;Butcher tableau&#39; to the <code>rk_coefs</code> array used internally in <code>moment_kinetics</code>. To add more RK methods (adaptive or fixed-step) it may be useful to add them in this script, to get the <code>rk_coefs</code> values, which can be copied into <a href="../zz_runge_kutta/#moment_kinetics.runge_kutta.setup_runge_kutta_coefficients!-Tuple{Any, Any, Any}"><code>moment_kinetics.runge_kutta.setup_runge_kutta_coefficients!</code></a>.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><p>See <a href="../zz_time_advance/#moment_kinetics.time_advance"><code>moment_kinetics.time_advance</code></a>, <a href="../zz_runge_kutta/#moment_kinetics.runge_kutta"><code>moment_kinetics.runge_kutta</code></a>.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>At present, we take advantage of this property to reduce the number of computations in the RK update step, but do not actually reduce the memory usage - we still store the results from every RK stage. It would be fairly straightforward to save memory, but would only reduce from 4 copies to 3 for the standard cases, so not a big saving.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../shared_memory_debugging/">« Shared memory debugging</a><a class="docs-footer-nextpage" href="../wall_boundary_conditions/">Wall boundary conditions with moment constraints »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 25 April 2024 14:51">Thursday 25 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
