<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Shared memory debugging · moment_kinetics</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">moment_kinetics</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../advection/"><code>advection</code></a></li><li><a class="tocitem" href="../analysis/"><code>analysis</code></a></li><li><a class="tocitem" href="../array_allocation/"><code>array_allocation</code></a></li><li><a class="tocitem" href="../bgk/"><code>bgk</code></a></li><li><a class="tocitem" href="../boundary_conditions_notes/">Wall boundary conditions with moment constraints</a></li><li><a class="tocitem" href="../calculus/"><code>calculus</code></a></li><li><a class="tocitem" href="../charge_exchange/"><code>charge_exchange</code></a></li><li><a class="tocitem" href="../chebyshev/"><code>chebyshev</code></a></li><li><a class="tocitem" href="../clenshaw_curtis/"><code>clenshaw_curtis</code></a></li><li><a class="tocitem" href="../command_line_options/"><code>command_line_options</code></a></li><li><a class="tocitem" href="../communication/"><code>communication</code></a></li><li><a class="tocitem" href="../continuity/"><code>continuity</code></a></li><li><a class="tocitem" href="../coordinates/"><code>coordinates</code></a></li><li><a class="tocitem" href="../debugging-hints/">Debugging</a></li><li><a class="tocitem" href="../debugging/"><code>debugging</code></a></li><li><a class="tocitem" href="../derivatives/"><code>derivatives</code></a></li><li><a class="tocitem" href="../developing/">Developing</a></li><li><a class="tocitem" href="../em_fields/"><code>em_fields</code></a></li><li><a class="tocitem" href="../energy_equation/"><code>energy_equation</code></a></li><li><a class="tocitem" href="../file_io/"><code>file_io</code></a></li><li><a class="tocitem" href="../finite_differences/"><code>finite_differences</code></a></li><li><a class="tocitem" href="../force_balance/"><code>force_balance</code></a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../initial_conditions/"><code>initial_conditions</code></a></li><li><a class="tocitem" href="../input_options/">Input Options</a></li><li><a class="tocitem" href="../input_structs/"><code>input_structs</code></a></li><li><a class="tocitem" href="../interpolation/"><code>interpolation</code></a></li><li><a class="tocitem" href="../ionization/"><code>ionization</code></a></li><li><a class="tocitem" href="../load_data/"><code>load_data</code></a></li><li><a class="tocitem" href="../looping/"><code>looping</code></a></li><li><a class="tocitem" href="../machine_setup/">Setup for <code>moment_kinetics</code> on known clusters</a></li><li><a class="tocitem" href="../makie_post_processing/">Post processing</a></li><li><a class="tocitem" href="../manufactured_solns/"><code>manufactured_solns</code></a></li><li><a class="tocitem" href="../moment_constraints/"><code>moment_kinetics</code></a></li><li><a class="tocitem" href="../moment_constraints_notes/">Constraints on normalized distribution function</a></li><li><a class="tocitem" href="../moment_kinetic_equations/">Moment kinetic equations</a></li><li><a class="tocitem" href="../moment_kinetics/"><code>moment_kinetics</code></a></li><li><a class="tocitem" href="../moment_kinetics_input/"><code>moment_kinetics_input</code></a></li><li><a class="tocitem" href="../moment_kinetics_structs/"><code>moment_kinetics_structs</code></a></li><li><a class="tocitem" href="../neutral_r_advection/"><code>neutral_r_advection</code></a></li><li><a class="tocitem" href="../neutral_vz_advection/"><code>neutral_vz_advection</code></a></li><li><a class="tocitem" href="../neutral_z_advection/"><code>neutral_z_advection</code></a></li><li><a class="tocitem" href="../numerical_dissipation/"><code>numerical_dissipation</code></a></li><li><a class="tocitem" href="../plot_MMS_sequence/"><code>plot_MMS_sequence</code></a></li><li><a class="tocitem" href="../plot_sequence/"><code>plot_sequence</code></a></li><li><a class="tocitem" href="../post_processing/"><code>post_processing</code></a></li><li><a class="tocitem" href="../post_processing_input/"><code>post_processing_input</code></a></li><li><a class="tocitem" href="../quadrature/"><code>quadrature</code></a></li><li><a class="tocitem" href="../r_advection/"><code>r_advection</code></a></li><li><a class="tocitem" href="../scan_input/"><code>scan_input</code></a></li><li class="is-active"><a class="tocitem" href>Shared memory debugging</a><ul class="internal"><li><a class="tocitem" href="#Finding-race-conditions"><span>Finding race conditions</span></a></li></ul></li><li><a class="tocitem" href="../source_terms/"><code>source_terms</code></a></li><li><a class="tocitem" href="../time_advance/"><code>time_advance</code></a></li><li><a class="tocitem" href="../type_definitions/"><code>type_definitions</code></a></li><li><a class="tocitem" href="../utils/"><code>utils</code></a></li><li><a class="tocitem" href="../velocity_grid_transforms/"><code>velocity_grid_transforms</code></a></li><li><a class="tocitem" href="../velocity_moments/"><code>velocity_moments</code></a></li><li><a class="tocitem" href="../vpa_advection/"><code>vpa_advection</code></a></li><li><a class="tocitem" href="../z_advection/"><code>z_advection</code></a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Shared memory debugging</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Shared memory debugging</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mabarnes/moment_kinetics/blob/master/debug_test/README.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Shared-memory-debugging"><a class="docs-heading-anchor" href="#Shared-memory-debugging">Shared memory debugging</a><a id="Shared-memory-debugging-1"></a><a class="docs-heading-anchor-permalink" href="#Shared-memory-debugging" title="Permalink"></a></h1><p>This <code>debug_test</code> directory contains scripts for running a set of short runs, intended to be used with the <code>--debug</code> flag to check for bugs (e.g. race conditions). The output is not checked - the intention is just to catch errors raised by the debugging checks.</p><p>The inputs only have 3 time-steps, and very few grid points, because the debug checks are very slow. The actual output is not important, so it does not matter that the runs are badly under-resolved.</p><p>It may be necessary to use the <code>--compiled-modules=no</code> flag to Julia for changes to the <code>--debug</code> setting to be picked up correctly. This setting means that all precompilation is redone each time Julia is started, which can be slow. An alternative workaround is to hard-code the <a href="../debugging/#moment_kinetics.debugging._debug_level"><code>moment_kinetics.debugging._debug_level</code></a> variable in <code>debugging.jl</code> to the desired value.</p><p>To run the debug tests, call (from the top-level <code>moment_kinetics</code> directory) something like</p><pre><code class="nohighlight hljs">julia --project --check-bounds=yes --compiled-modules=no debug_test/runtests.jl --debug 99</code></pre><h2 id="Finding-race-conditions"><a class="docs-heading-anchor" href="#Finding-race-conditions">Finding race conditions</a><a id="Finding-race-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-race-conditions" title="Permalink"></a></h2><p>The code is parallelized using MPI with shared memory arrays. &#39;Race conditions&#39; can occur if a shared array is accessed incorrectly. All the processes sharing an array can be synchronized, ensuring they pass through the following code block with a consistent state, by using the <code>_block_synchronize()</code> function (which calls <code>MPI.Barrier()</code> to synchronize the processes). Race conditions occur if between consecutive calls to <code>_block_synchronize()</code> any array is:</p><ol><li>written by 2 or more processes at the same position</li><li>written by one process at a certain position, and read by one or more other processes at the same position.</li></ol><p>If a race condition occurs, it can result in errors in the results. These are sometimes small, but often show inconsistent results between runs (because results erroneously depend on the execution order on different processes). They are undefined behaviour though, and so can also cause anything up to segfaults.</p><p>The provided debugging routines can help to pin down where either of these errors happen.</p><p>The <code>@debug_shared_array</code> macro (activated at <code>--debug 2</code> or higher) counts all reads and writes to shared arrays by each process, and checks at each <code>_block_synchronize()</code> call whether either pattern has occurred since the previous <code>_block_synchronize()</code>. If they have and in addition <code>@debug_track_array_allocate_location</code> is active (<code>--debug 3</code> or higher), then the array for which the error occured is identified by printing a stack-trace of the location where it was allocated, and the stack-trace for the exception shows the location of the <code>_block_synchronize()</code> call where the error occured.</p><p><code>@debug_block_synchronize</code> (activated at <code>--debug 4</code>)checks that all processes called <code>_block_synchronize()</code> from the same place - i.e. the same line in the code, checked by comparing stack traces.</p><p><code>@debug_detect_redundant_block_synchronize</code> (activated at <code>--debug 5</code>) aims to find any unnecessary calls to <code>_block_synchronize()</code>. These calls can be somewhat expensive (for large numbers of processes at least), so it is good to minimise the number. When this mode is active, at each <code>_block_synchronize()</code> a check is made whether there would be a race-condition error if the previous <code>_block_synchronize()</code> call was removed. If there would not be, then the previous call was unnecessary and could be removed. The tricky part is that whether it was necessary or not could depend on the options being used... Detecting redundant <code>block_synchronize()</code> calls requires that all dimensions that could be split over processes are actually split over processes, which demands a large number of processes are used. The <code>@debug_detect_redundant_block_synchronize</code> flag, when activated, modifies the splitting algorithm to force every dimension to be split if possible, and raise an error if not.</p><p>Suggested debugging strategy for race conditions is:</p><ul><li>Look at the loop types and ensure that there is an appropriate <code>begin_*_region()</code> call before each new loop type.</li><li>Run <code>debug_test/runtests.jl</code> with <code>@debug_shared_array</code> activated, but not <code>@debug_detect_redundant_block_synchronize</code>. It will be faster to first run without <code>@debug_track_array_allocate_location</code> to find failing tests, then with <code>@debug_track_array_allocate_location</code> to help identify the cause of the failure. Usually a failure should indicate where there is a missing <code>begin_*_region()</code> call. There may be places though where synchronization is required even though the type of loop macros used does not change (for example when <code>phi</code> is calculated contributions from all charged species need to be summed, resulting in an unusual pattern of array accesses); in this case <code>_block_synchronize()</code> can be called directly.<ul><li>The function <code>debug_check_shared_memory()</code> can be inserted between <code>begin_*_region()</code> calls when debugging to narrow down the location where the incorrect array access occured. It is defined when <code>@debug_shared_array</code> is active, and can be imported with <code>using ..communication: debug_check_shared_memory()</code>. The function runs the same error checks as are added by <code>@debug_shared_array</code> in <code>_block_synchronize()</code>.</li><li>The tests in <code>debug_test/</code> check for correctness by looping over the dimensions and forcing each to be split over separate processes in turn. This allows the correctness checks to be run using only 2 processes, which would not be possible if all dimensions had to be split at the same time.</li></ul></li><li>[This final level of checking only looks for minor optimizations rather than finding bugs, so it is much less important than the checks above.] Run <code>debug_test/debug_redundant_synchronization/runtests.jl</code> with <code>@debug_detect_redundant_block_synchronize</code> activated. This should show if any call to <code>_block_synchronize()</code> (including the ones inside <code>begin_*_region()</code> calls) was &#39;unnecessary&#39; - i.e. there would be no incorrect array accesses if it was removed. This test needs to be run on a suitable combination of grid sizes and numbers of processes so that all dimensions are split across multiple processes to avoid false positives.  Any redundant calls which appear in all tests can be deleted.  Redundant calls that appear in only some tests (unless they are in some code block that is just not called in all the other tests) should preferably be moved inside a conditional block, so that they are called only when necessary, if a suitable one exists. If there is no conditional block that the call can be moved to, it may sometimes be necessary to just test one or more options before calling, e.g.<pre><code class="nohighlight hljs">moments.evolve_upar &amp;&amp; _block_synchronize()</code></pre><ul><li>The checks for redundant <code>_block_synchronize()</code> calls have been separated from the correctness checks so that the correctness checks can be run in the CI using only 2 processes, while the redundancy checks can be run manually on a machine with enough memory and cpu cores.</li></ul></li></ul><p>You can find out what loop type is currently active by looking at <code>loop_ranges[].parallel_dims</code>. This variable is a Tuple containing Symbols for each dimension currently being parallelized.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../scan_input/">« <code>scan_input</code></a><a class="docs-footer-nextpage" href="../source_terms/"><code>source_terms</code> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 30 October 2023 21:00">Monday 30 October 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
