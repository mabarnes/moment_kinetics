# Chebyshev transform f to get Chebyshev spectral coefficients and use them to calculate f'
function derivative!(df, f, coord, adv_fac, spectral::chebyshev_info)
    # get the derivative at each grid point within each element and store in df
    chebyshev_derivative!(coord.scratch2d, f, spectral, coord)
    # map the derivative from the elemental grid to the full grid;
    # at element boundaries, use the derivative from the upwind element.
    derivative_elements_to_full_grid!(df, coord.scratch2d, coord, adv_fac)
end
# Chebyshev transform f to get Chebyshev spectral coefficients and use them to calculate f'
function derivative!(df, f, coord, spectral::chebyshev_info)
    # get the derivative at each grid point within each element and store in df
    chebyshev_derivative!(coord.scratch2d, f, spectral, coord)
    # map the derivative from the elemental grid to the full grid;
    # at element boundaries, use the average of the derivatives from neighboring elements.
    derivative_elements_to_full_grid!(df, coord.scratch2d, coord)
end
# calculate the derivative of f using finite differences, with particular scheme
# specifiied by coord.fd_option; stored in df
function derivative!(df, f, coord, adv_fac, not_spectral::Bool)
    # get the derivative at each grid point within each element and store in df
    derivative_finite_difference!(coord.scratch2d, f, coord.cell_width, adv_fac,
        coord.bc, coord.fd_option, coord.igrid, coord.ielement)
    # map the derivative from the elemental grid to the full grid;
    # at element boundaries, use the derivative from the upwind element.
    derivative_elements_to_full_grid!(df, coord.scratch2d, coord, adv_fac)
end
# calculate the derivative of f using centered differences; stored in df
function derivative!(df, f, coord, not_spectral::Bool)
    # get the derivative at each grid point within each element and store in df
    derivative_finite_difference!(coord.scratch2d, f, coord.cell_width,
        coord.bc, "fourth_order_centered", coord.igrid, coord.ielement)
    # map the derivative from the elemental grid to the full grid;
    # at element boundaries, use the average of the derivatives from neighboring elements.
    derivative_elements_to_full_grid!(df, coord.scratch2d, coord)
end
function derivative_elements_to_full_grid!(df1d, df2d, coord, adv_fac::Array{Float64,1})
    # no changes need to be made for the derivative at points away from element boundaries
    elements_to_full_grid_interior_pts!(df1d, df2d, coord)
    # resolve the multi-valued nature of the derivative at element boundaries
    # by using the derivative from the upwind element
    reconcile_element_boundaries_upwind!(df1d, df2d, coord, adv_fac)
    return nothing
end
function derivative_elements_to_full_grid!(df1d, df2d, coord)
    # no changes need to be made for the derivative at points away from element boundaries
    elements_to_full_grid_interior_pts!(df1d, df2d, coord)
    # resolve the multi-valued nature of the derivative at element boundaries
    # by using the derivative from the upwind element
    reconcile_element_boundaries_centered!(df1d, df2d, coord)
    return nothing
end
# maps the derivative at points away from element boundaries
# from the grid/element representation to the full grid representation
function elements_to_full_grid_interior_pts!(df1d, df2d, coord)
    # for efficiency, define ngm1 to be ngrid-1, as it will be used repeatedly
    ngm1 = coord.ngrid-1
    # treat the first element
    @. df1d[2:ngm1] = df2d[2:ngm1,1]
    # deal with any additional elements
    if coord.nelement > 1
        for ielem ∈ 2:coord.nelement
            @. df1d[coord.imin[ielem]:coord.imax[ielem]-1] = df2d[2:ngm1,ielem]
        end
    end
    return nothing
end
# if at the boundary point within the element, must carefully
# choose which value of df to use; this is because
# df is multi-valued at the overlapping point at the boundary
# between neighboring elements.
# here we choose to use the value of df from the upwind element.
function reconcile_element_boundaries_upwind!(df1d, df2d, coord, adv_fac::Array{Float64,1})
    # note that the first ngrid points are classified as belonging to the first element
    # and the next ngrid-1 points belonging to second element, etc.

    # first deal with domain boundaries
    if coord.bc == "periodic"
        # consider left domain boundary
        if adv_fac[1] > 0.0
            # adv_fac > 0 corresponds to negative advection speed, so
            # use derivative information from upwind element at larger coordinate value
            df1d[1] = df2d[1,1]
        elseif adv_fac[1] < 0.0
            # adv_fac < 0 corresponds to positive advection speed, so
            # use derivative information from upwind element at smaller coordinate value
            df1d[1] = df2d[coord.ngrid,coord.nelement]
        else
            # adv_fac = 0, so no upwinding required;
            # use average value
            df1d[1] = 0.5*(df2d[1,1]+df2d[coord.ngrid,coord.nelement])
        end
        # consider right domain boundary
        if adv_fac[coord.n] > 0.0
            # adv_fac > 0 corresponds to negative advection speed, so
            # use derivative information from upwind element at larger coordinate value
            df1d[coord.n] = df2d[1,1]
        elseif adv_fac[coord.ngrid] < 0.0
            # adv_fac < 0 corresponds to positive advection speed, so
            # use derivative information from upwind element at smaller coordinate value
            df1d[coord.n] = df2d[coord.ngrid,coord.nelement]
        else
            # adv_fac = 0, so no upwinding required;
            # use average value
            df1d[coord.n] = 0.5*(df2d[1,1]+df2d[coord.ngrid,coord.nelement])
        end
    else
        df1d[1] = df2d[1,1]
        df1d[coord.n] = df2d[coord.ngrid,coord.nelement]
    end
    # next consider remaining elements, if any.
    # only need to consider interior element boundaries
    if coord.nelement > 1
        for ielem ∈ 2:coord.nelement
            im1 = ielem-1
            # consider left element boundary
            if adv_fac[coord.imax[im1]] > 0.0
                # adv_fac > 0 corresponds to negative advection speed, so
                # use derivative information from upwind element at larger coordinate value
                df1d[coord.imax[im1]] = df2d[1,ielem]
            elseif adv_fac[coord.imax[im1]] < 0.0
                # adv_fac < 0 corresponds to positive advection speed, so
                # use derivative information from upwind element at smaller coordinate value
                df1d[coord.imax[im1]] = df2d[coord.ngrid,im1]
            else
                # adv_fac = 0, so no upwinding required;
                # use average value
                df1d[coord.imax[im1]] = 0.5*(df2d[1,ielem]+df2d[coord.ngrid,im1])
            end
        end
    end
    return nothing
end
# if at the boundary point within the element, must carefully
# choose which value of df to use; this is because
# df is multi-valued at the overlapping point at the boundary
# between neighboring elements.
# here we choose to use the value of df from the upwind element.
function reconcile_element_boundaries_centered!(df1d, df2d, coord)
    # note that the first ngrid points are classified as belonging to the first element
    # and the next ngrid-1 points belonging to second element, etc.

    # first deal with domain boundaries
    if coord.bc == "periodic"
        # consider left domain boundary
        df1d[1] = 0.5*(df2d[1,1]+df2d[coord.ngrid,coord.nelement])
        # consider right domain boundary
        df1d[coord.n] = df1d[1]
    else
        df1d[1] = df2d[1,1]
        df1d[coord.n] = df2d[coord.ngrid,coord.nelement]
    end
    # next consider remaining elements, if any.
    # only need to consider interior element boundaries
    if coord.nelement > 1
        for ielem ∈ 2:coord.nelement
            im1 = ielem-1
            # consider left element boundary
            df1d[coord.imax[im1]] = 0.5*(df2d[1,ielem]+df2d[coord.ngrid,im1])
        end
    end
    return nothing
end

# computes the integral of the integrand, using the input wgts
function integral(integrand, wgts)
    # n is the number of grid points
    n = length(wgts)
    # initialize 'integral' to zero before sum
    integral = 0.0
    @boundscheck n == length(integrand) || throw(BoundsError(integrand))
    @boundscheck n == length(wgts) || throw(BoundsError(wgts))
    @inbounds for i ∈ 1:n
        integral += integrand[i]*wgts[i]
    end
    return integral
end
