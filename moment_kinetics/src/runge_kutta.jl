"""
Runge Kutta timestepping
"""
module runge_kutta

export setup_runge_kutta_coefficients!, rk_update_evolved_moments!,
       rk_update_evolved_moments_electron!, rk_update_evolved_moments_neutral!,
       rk_update_variable!, rk_error_variable!, local_error_norm

using ..array_allocation: allocate_float
using ..communication
using ..input_structs
using ..looping
using ..type_definitions: mk_float

using MPI
using StatsBase: mean

"""
given the number of Runge Kutta stages that are requested,
returns the needed Runge Kutta coefficients;
e.g., if f is the function to be updated, then
f^{n+1}[stage+1] = rk_coef[1,stage]*f^{n} + rk_coef[2,stage]*f^{n+1}[stage] + rk_coef[3,stage]*(f^{n}+dt*G[f^{n+1}[stage]]
"""
function setup_runge_kutta_coefficients!(type, input_CFL_prefactor, split_operators)

    rk_coefs_implicit = nothing
    implicit_coefficient_is_zero = nothing

    if type == "RKF5(4)"
        # Embedded 5th order / 4th order Runge-Kutta-Fehlberg method.
        # Note uses the 5th order solution for the time advance, even though the error
        # estimate is for the 4th order solution.
        #
        # Coefficients originate here:
        # https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method,
        # 'COEFFICIENTS FOR RK4(5), FORMULA 2 Table III in Fehlberg'
        #
        # Coefficients converted to the format for moment_kinetics time-stepper using
        # `util/calculate_rk_coeffs.jl`
        rk_coefs = mk_float[3//4 5//8   10469//2197  115//324        121//240    641//1980  11//36   ;
                            1//4 3//32  17328//2197  95//54          33//10      232//165   4//3     ;
                            0    9//32 -32896//2197 -95744//29241   -1408//285  -512//171  -512//171 ;
                            0    0      7296//2197   553475//233928  6591//1520  2197//836  2197//836;
                            0    0      0           -845//4104      -77//40     -56//55    -1        ;
                            0    0      0            0              -11//40      34//55     8//11    ;
                            0    0      0            0               0           2//55      0        ]
        n_rk_stages = 6
        rk_order = 5
        adaptive = true
        low_storage = false
        if input_CFL_prefactor ≤ 0.0
            CFL_prefactor = 1.0
        else
            CFL_prefactor = input_CFL_prefactor
        end
    elseif type == "Fekete10(4)"
        # Fekete 10-stage 4th-order SSPRK (see comments in util/calculate_rk_coeffs.jl.
        # Note that a 'low storage' implementation of the main method (if not the
        # truncation error estimate) is possible [D.I. Ketcheson, Highly efficient strong
        # stability-preserving Runge–Kutta methods with low-storage implementations, SIAM
        # J. Sci. Comput. 30 (2008) 2113–2136, https://doi.org/10.1137/07070485X,
        # https://www.davidketcheson.info/assets/papers/2008_explicit_ssp.pdf] but
        # would require a particular implementation that does not fit in with the
        # currently-implemented moment_kinetics 'low_storage' code, so we do not take
        # advantage of it yet. If this timestepping scheme turns out to be particularly
        # efficient, a low-storage version could be implemented (which might be
        # particularly important given the large number of stages in this scheme which
        # will lead to high memory usage), with one extra buffer for the truncation error
        # estimate which would need to be updated incrementally at each stage, rather than
        # calculated only at the end of the RK step.
        rk_coefs = mk_float[5//6 0    0    0    3//5  0    0    0    0    -1//2  -1//5;
                            1//6 5//6 0    0    0     0    0    0    0     0      6//5;
                            0    1//6 5//6 0    0     0    0    0    0     0      0   ;
                            0    0    1//6 5//6 0     0    0    0    0     0     -9//5;
                            0    0    0    1//6 1//3  0    0    0    0     0      9//5;
                            0    0    0    0    1//15 5//6 0    0    0     9//10  0   ;
                            0    0    0    0    0     1//6 5//6 0    0     0     -6//5;
                            0    0    0    0    0     0    1//6 5//6 0     0      6//5;
                            0    0    0    0    0     0    0    1//6 5//6  0     -9//5;
                            0    0    0    0    0     0    0    0    1//6  1//2   9//5;
                            0    0    0    0    0     0    0    0    0     1//10  0   ]
        n_rk_stages = 10
        rk_order = 4
        adaptive = true
        low_storage = false
        if input_CFL_prefactor ≤ 0.0
            CFL_prefactor = 12.0
        else
            CFL_prefactor = input_CFL_prefactor
        end
    elseif type == "Fekete6(4)"
        # Fekete 6-stage 4th-order SSPRK (see comments in util/calculate_rk_coeffs.jl.
        # Note Fekete et al. recommend the 10-stage method rather than this one.
        #rk_coefs = mk_float[0.6447024483081 0.23869944753332645  0.5474858792272213     0.3762853856474131     -6.304828384656085e-17  -0.1813232670344333     -1.0017300417984671 ;
        #                    0.3552975516919 0.4295138541066736  -6.460461358323626e-14 -1.1868936325049587e-13  3.608184516786869e-18   2.9392365006883485e-14 -0.18902907903375094;
        #                    0.0             0.33178669836        0.25530138316744333   -3.3545605887402925e-14 -1.0929532856876731e-17  0.20598080026766677     0.2504712436879622 ;
        #                    0.0             0.0                  0.1972127376054        0.3518900216285391      7.036963218665071e-17   0.47926701162417157    -0.939747918037452  ;
        #                    0.0             0.0                  0.0                    0.2718245927242         0.5641843457422999      9.97599117309567e-14    1.1993626679930303 ;
        #                    0.0             0.0                  0.0                    0.0                     0.4358156542577         0.34165678726956566    -0.5310335716309745 ;
        #                    0.0             0.0                  0.0                    0.0                     0.0                     0.1544186678729         1.2117066988196523 ]
        # Might as well set to 0 the entries that look like they should be 0 apart from
        # rounding errors.
        rk_coefs = mk_float[0.6447024483081 0.23869944753332645 0.5474858792272213  0.3762853856474131 0.0                -0.1813232670344333  -0.0017300417984673633 ;
                            0.3552975516919 0.4295138541066736  0.0                 0.0                0.0                 0.0                 -0.18902907903375094   ;
                            0.0             0.33178669836       0.25530138316744333 0.0                0.0                 0.20598080026766677  0.2504712436879622    ;
                            0.0             0.0                 0.1972127376054     0.3518900216285391 0.0                 0.47926701162417157 -0.939747918037452     ;
                            0.0             0.0                 0.0                 0.2718245927242    0.5641843457422999  0.0                  1.1993626679930303    ;
                            0.0             0.0                 0.0                 0.0                0.4358156542577     0.34165678726956566 -0.5310335716309745    ;
                            0.0             0.0                 0.0                 0.0                0.0                 0.1544186678729      1.2117066988196523    ]
        n_rk_stages = 6
        rk_order = 4
        adaptive = true
        low_storage = false
        if input_CFL_prefactor ≤ 0.0
            CFL_prefactor = 8.0
        else
            CFL_prefactor = input_CFL_prefactor
        end
    elseif type == "Fekete4(3)"
        # Fekete 4-stage, 3rd-order SSPRK (see comments in util/calculate_rk_coeffs.jl).
        # Note this is the same as moment_kinetics original 4-stage SSPRK method, with
        # the addition of a truncation error estimate.
        rk_coefs = mk_float[1//2 0    2//3 0    -1//2;
                            0    1//2 1//6 1//2  1   ;
                            1//2 1//2 1//6 1//2  1//2]
        n_rk_stages = 4
        rk_order = 3
        adaptive = true
        low_storage = true
        if input_CFL_prefactor ≤ 0.0
            CFL_prefactor = 6.0
        else
            CFL_prefactor = input_CFL_prefactor
        end
    elseif type == "Fekete4(2)"
        # Fekete 4-stage 2nd-order SSPRK (see comments in util/calculate_rk_coeffs.jl.
        rk_coefs = mk_float[2//3 0    0    1//4 -1//8 ;
                            1//3 2//3 0    0     3//16;
                            0    1//3 2//3 0     0    ;
                            0    0    1//3 1//2  3//16;
                            0    0    0    1//4  3//4 ]
        n_rk_stages = 4
        rk_order = 2
        adaptive = true
        low_storage = false
        if input_CFL_prefactor ≤ 0.0
            CFL_prefactor = 7.0
        else
            CFL_prefactor = input_CFL_prefactor
        end
    elseif type == "KennedyCarpenterARK437"
        # 7-stage 4th-order IMEX scheme from Kennedy & Carpenter 2019
        # (https://doi.org/10.1016/j.apnum.2018.10.007)
        rk_coefs = mk_float[1259//2000 5290646302898597//8373961392408000 8423019873483076625875775070651744355694385798609904937007939962921//150521175132586175452031742950672295931748410227157096692266429460000 2994513382955822485521046980912234681324963183189745389014355133307701665733190659992515397312853494866472292886256590592494915387//2965873493603904869657209592263579672060858985048910013379293383705776295507221134405229631810912000404727243855383598634762065000 30539970275135679633584632348554217845550139791434491473433065741424255490119246194598789137339313385221967019548261328863657459815753917023734449603158284970462973658597410429650430702665200563167161539643//13704862650330987205714124331836761942666326434854101824180425078097998709961464232104783253918380815197539403091139963512106850869604383687916916407395432488294630299106508922071626689111782004817881600000 -19040678234218442267791957547085949877261833393218769774490211844357442495720928310803217673452945114307858653570770743722530691547161857714592037194448292737108135956064173232077902035051756906315290249323391199215452093288761543466155072487019283153040605640582545353//434460620365086227275365613595785689037684119561551447866399563678359364964304766160588180361574468026545002066358107854844508866339943817889423954205635510933928478885046494597924763194047299856692216836659998842171053550088349173699526518609668649583153524558000000 288731630022162319869438999191684090646040643450899591816164044389835222770755887620657396004427344292026826164251174295940084430575464251867753391273329991428766006962036541371088185016838939694742825762143476610215112259310775986858990019786106138952556466469818422670975238869429118972933807274018940951589368081351548344612945911//20973003965589548708434314855006387742137826247026382293972477180137413647707040377066768697931519202069488796547924545511172033369848624623987910615835501364546356391125295257989950347130885375821004661709022933531613399512675984933594553629478794041110851618556180635106168633352649598677887127603362572483995718065757513848000000 84926642764971243894475134943962931810444673911735634915100592292957077949431848662551468317687921438318511523760815574702789503485398620028309816648298294834153366303807932815889792557943196419058598328094000505490239045609005350465572648576161106088544859912831113322833512972633007203117374432262835343768993715225884506359744564475587764680843945362752279138159903160761204959//260972014540685732500941228716594401253697451754294212135043621433819057442875621317591319960743124933373694568320156829732345991594970230575152480441468737290148399986074743051568390414584640252689524964664950956646999867002330201896464020174989429698298196815004391658613009073755531263975373728451196159059154355539770936746765576373862915582488531900995626740195393587760000000;
                            247//1000 -989824741407403//1034184231962388 12030115115653867750152716618470210758833187291724517144940796943//75260587566293087726015871475336147965874205113578548346133214730 -38294840366277686210014997045193699763084799480894125070642047208039500243910125715098952557814588229683929175932575120507758//2965873493603904869657209592263579672060858985048910013379293383705776295507221134405229631810912000404727243855383598634762065 295295570231675996693315167776780747152571140671795256274243785364473032721842828048391983319277155679830435409182467618416827429676745188054309175736589897273331671973890410913992022974171287068414179//61733615542031473899613172665931360102100569526369828036848761613054048243069658703174699341974688356745672986897026862667147976890109836432058182015294740938264100446425715865187507608611630652332800 -103607762222490505420853358572242884724507274765889279862093763910463346807234121781702833150902639990159657168588480823754779677586383897844592436246137396292078029780455443152811826226940327856890549206867400186099307876348070477253089682709554337188513182823809//1957029821464352375114259520701737338007586124151132648046844881434051193532904352074721533160245351470923432731342828174975265163693440621123531325250610409612290445428137363053715149522735584940055030795765760550320061036434005286934804137881390313437628489000 1756980287380270661909883701400719407931186906833821727133555062583564555413167571820171278734011901786553078780566040820580897865510288379254954688057860520817526060415179421086733406546370539399123710022886030886680529570815674651094279571160030365101231973109840311106887692153830760503248639774555086269823425452980789521983//94472990835988958146100517364893638478098316428046767089966113424042403818500181878679138278970807216529228813278939394194468618783101912720666264035295051191650254014077906567522298860949934125319840818509112313205465763570612544745921412745399973158156989272775588446424183033120043237287779854069200776954935666962871684000 4497481478618828357902975315180513548695118296897040369787574112992144752316100046645078788641717287509607925626450106980120209292833281864629468608251949921103739384618553805425857887380202308238545540652588351850372157487811335028912567342994696086555165285879240439813676160036107905425561960935961331946051968043421127130927398396885118470213706720569254204159456782778143//10579946535433205371659779542564637888663410206255170762231498166235907734170633296659107565976072632434068698715682033637797810470066360698992668126005489349600610810246273366955475287077755685919845606675606119864067562175770143320126919736823895798579656627635313175349176043530629645836839475477751195637533284684044767705949955798940388469560345887878201084061975415720000;
                            0 2694949928731//7487940209513 8998324425985185229752164921843556928418//6879911577066686708082765415963101392005 -1113749691734484577393721387476449364293695591499248096021365233437237262190376983790684968//614723064777942345300673611647494298409492630748950625564212151899381047684846341907434565 3232749502455777147099949130361796695276166220371216781206693407480970206448819780667318974467270737609589333827843458744644740168302532466186611141754331//189582997729714290713265545572615912994127195399317804061465277614709498987796247842084387314678472277548705650701196377776893051375514851341440850875200 -4870194067553746005392433554393767454323970473452014417195456308395019908797901907202628017224416587814584976946420122287071436281684631404642172500643426697814174404515180399709158516683162105836131515362388110129683638667528993//21343197949358935830336366563982013835567480844791522290459133182821516998314822953834142105584655472803157904439421128859575015047441788494355858675117408374452309707414448855197609419898595868573273357109375195601907874661750 1133640531577714301094463790230570404584859296215495398405151332049144471525210024993808359315202761280905403079519602164500478641718437221313878517301376096168046994391334699315934152212733388857744580032179121377464302776620604944135207945388255432571250499946633194518861052173//15269743319892007455140684408468757761408687980991560114683247369534160706810144792488732725360073361204871896366796514755108037806954494436799836307013539397248756798832458082570495407212986994247502838542705261851137819990892696985793851053928235797745833864984886152117549000 2893818794357948608396224652970468062472459880296424811982545951332742248161861507594854114831155818553085130655146195415611877204165404047936261527497967416640034320042470107097161887686354604209343668647869967015394820299208885831731185499722116534661350732567244113640955295285049989870219686790318194239544599451563105257133//1710045024558522147077712925318040863324335720844158150953699472338859250480805706497840549035944636590651925322772241392509045721953834946328464956986918939857303509645058517346927758905551129327891825404013534181813392627174511472243186476068520859982949529412273255989549686977234401171431731307352748128089844902467651170000;
                            0 0 -952945855348//12294611323341 -22073573743301541610712262679571236673//102497573414903811687310385575877661106 -1721410795387108339409971682021950898460420032371617016873094528434128927392613849754588339//87137142052407093121638255236903751954999399574863919133666611538546309140586170055319680 16313517457306668499040607903231659478959795579778899115572743239581171711329724761584530868990247993612666499584567250035429887343299192678690030002344049//62416302275874709124142209806047948969179330019834923487644841352294781949250993050168150304800088551996355377414194373918898008246028356490083758823900 -3522114925398586688095375690918293852014330258883220414302055832172071373253315487145747264610273932349849350380058343538480611104076920529217826992141264292169120822384426292339080424329190906960608882147//40700967645824834858910387658090999284501829591792512374361650786103602925853405179284205837319813016693834232729849885086983845902959918661378045151742047433271863508697358129908893348972361198906999600 -2964615015014179805295172754296611663749294757017026824055697955567711725761450449626912955847752550279125632083736465384517105390439711240732035285328566095702816892096481374832505284217977117233570295284209999214909138342054284123934619995605076214529//1519355101116665488160320486425332596410766015376101261032729360600325388596256808357121832346062378794250401199007985315934407267758119256854060437954663211883904942752463071332521831780921316532009162049372788856501274262524564791159730973728017956000;
                            0 0 0 1723805262919//4571918432560 -25876943084012456170678693260966349907000//5680618296291396887153903820876753773137 48844701120434798505257977500359380914524723337647143148599611849985789938064739097674693920//866184382793087165443239722235018033562332770654938221330767289744734883576318512798157591 -10439201328524415451101705838850752098522244583730511249035532393853115936152097267231153987129654894580734726923948255514483695320//517179273612462951325391504144113415822567772911339018044947272294653098377564085323877210889868378806161859809936951216035085879 -31792106067067045818112260837108131508726364490393328197498519784851127422528513551342159965127955715285413010230702025548328167661456142039693351348408082614337262676//66396651076396923064500150569526548836429014778004208000488845377413771691299301838459832995249234003843920958668478089089157501642918765520740904300173384489982847721;
                            0 0 0 0 -1428733748635//8843423958496 45167606322154409493844473095934856651372//7158213738657143615497509498481377893535 -1615099588584428850432566812602172779484150467417635643452543010181911434924813//328599571910176348051406456035570993083111686686639606428802520754094008735795 -4034687914592733378429707314152809369441595752859107808382503309002756873129991192828401438988938141477//34345686420160340136137214349452622351601924975531611734364160909677419579508067395379029901259679245150;
                            0 0 0 0 0 11565764226357//8513123442827 -25809210976654570172323689//32261698729236896469921844 31493257163953445767383915813738522959//6188068127939952207906691591618012272168;
                            0 0 0 0 0 0 247//2000 2441//2470]
        rk_coefs_implicit = mk_float[1 247//2000 989824741407403//8373961392408000 -12030115115653867750152716618470210758833187291724517144940796943//609397470172413665797699364172762331707483442215210917782455180000 19147420183138843105007498522596849881542399740447062535321023604019750121955062857549476278907294114841964587966287560253879//12007584994347792994563601588111658591339510060926761187770418557513264354280247507713480290732437248602134590507625905403895000 -295295570231675996693315167776780747152571140671795256274243785364473032721842828048391983319277155679830435409182467618416827429676745188054309175736589897273331671973890410913992022974171287068414179//499867332324141489065693705797015061555470198594087676411730863263595532332547843750402423821657395601179538355441513058033586857409796246413426575022629481281490691873892436155364434077826968844800000 103607762222490505420853358572242884724507274765889279862093763910463346807234121781702833150902639990159657168588480823754779677586383897844592436246137396292078029780455443152811826226940327856890549206867400186099307876348070477253089682709554337188513182823809//15846395315500828948293599357908804356336729750211600389043278392178552174355500826515963831257047380331363827784152454858099313066343648754036690892717493195241218181604351117843847364556563440810162192678265267613927619728210569124978171156934334521762174000000 -1756980287380270661909883701400719407931186906833821727133555062583564555413167571820171278734011901786553078780566040820580897865510288379254954688057860520817526060415179421086733406546370539399123710022886030886680529570815674651094279571160030365101231973109840311106887692153830760503248639774555086269823425452980789521983//764963488550517879725510262063916101037233331401188397489604157279695577477734266224122577157658358028576751524525825054206223633871270548345475822148138066329151854365003292044714970534007563767771990433272164479396483915551518580938634921015384398041756998160126222238252494195303993824192549425661544752671543862047544000000 -4497481478618828357902975315180513548695118296897040369787574112992144752316100046645078788641717287509607925626450106980120209292833281864629468608251949921103739384618553805425857887380202308238545540652588351850372157487811335028912567342994696086555165285879240439813676160036107905425561960935961331946051968043421127130927398396885118470213706720569254204159456782778143//85667583282859962523560967955988970758408179807734176212400794868306945215956544912219494461344717671530920637373943592208889153603776199991843466607331897567616281864342294469275103539091139157245713414377377488777874997374657030932201779245537617802264426134698892108090494279600240047261858101034422636741160199870807835675708144120974805421541262250025919709003849520000000;
                                     0 247//2000 1640162795743102475350151093//1935977423638871147963949261 -669520662365112558836337514177765438740501906951800//3434894046659157185836586522283340462482027689855253 3946917245375300099117028390196313070898965018251827990344948235886761188759982607841249401044014800//8731687803837463597851852204375440308270070845281864536173093106185812052200062608725343371330114879 -205400344379039456236889403418786715948678188681075725573409873825666119392008156332013686312028931603996403696782121273525274842696005527984325836413553777161305//89363383017861228225303962341868491699836686835444580475507268771312849840752079176917079323598733222511329293960320776917936050196860239819503153329236587045136 30687505472431132535398127411347221742615518129027192717809570222837123760440722268522243759249777774158885828261806787110459137168616203275440545863270163627249417471268646467826870981867030746658885027755639865911983778862//1133170665462309851631677012105217332859851084790774917074074021640837762020794312552555302543238883393727692629571220902396774550231187040084644756043645934216506528391671558626974497474800652364423277959876832348439939747 -6283525646833647454002892632282410246801087091050293278650123969383191268291122461341921080069123066751425002628983740840429970668280064678807240424673718814438405438302314529802406401591711043517178423219353227983220474197585457883457827139444416354631995314601988204663707433738723579//636073193374428113494435816226054457408386696306335042416362660226889698324156499448503155209934236569286275656030656961509515881881917957453625064846593883601537604025882329382852749987796068169486806444822362282067831972375349383462186775277444140348881039842682407991538426680968962 -5111399490648784623505405906880770861485683214132379586079815455918757228788561547090828993593721487763199937324034708336117675901305459316990878813671055951639549111107993366169146620054742699199566402315746577078472396338683439114520127236419852170565949886333950618992185026169588984547653272289747956394678487224897575893472996553//23744424443337318051143623666623532897092042087880269588186878183995047296072436550183424467565368665201724952138208425897034422691189645477159617431842320555598909677789228593651627069755898900855393242632756026860305068214302197202618797165584108476518318651533651241430264302060599862244313590743654489782747825300717170452010145820;
                                     0 0 247//2000 -2972678418645402786341338364//12838151569953855298061689287 -14177902844174227269025142717297051203475652491333500//11971105784073717652462253600880425542713752681105087 -100148767553896799794460313449068596317708839495767869203993116264461768408264073121941920171989860225//16896980983343158542755332581698141314998069944341701280946967597382042773067583208093579816862254704 8120587802228218371525098119582199057503340092685175907611832343053507998800789197285606422127482797666378809500665961580494440814493887170697877672294810170691010//77414698954417744943691534221904770957339164270679599444552137006106151217420120158205166736460436330696537591532832275880234436981438762980759441700502891030827 -773431832654955771723705915527504690565625557946561612427689605734312849813109402940104692058813867875775302143309398169386342513814875087912054850684653412041387124455620214615519952957068564604440450567357722605//27692724047854711512168597950120181690998527229673939994235410614905537717037560897782708599532214026735280560758431733216205801827405703523808488247547552157893603286263272072905320930368075417471639053737763218 -1303404354434948517428356388978807213640989814097796284872851954122942850939247373256252247771849635395296815861618930858082321997548690453745717952318803556064569049629447371161223768908840614968332185016381909654224705552772116843629887797345246826110167236923//1860770177301487311499340868274363903273885901513548551661642580585076571165583837547959561673448191237064888114034470178211592939044370653201543317609208350146901593536799945407827170076630727738853296085239724937440199422317066971204713970176240621839897829164;
                                     0 0 0 247//2000 538260754703221409274894839//225772174112649072819826640 53717436927136847537872396533404737469775216052354000//7927277355078818621920036006972820247636839819935349 -1772830339659539491048538392985299701647037422231103660763419873677962619701225032539957600128007666810800//15721979495129036484463918711394582943772656542660620350548585102102545643714934169988943899054128147359 23300798642481300915550244810330608079712179111290003575082920574543585477524931007510835130377963055801601626441651388811757948939347006283700//721721356793285693541681937242605189550706405472415761047580279465244653002939927725991664966944137182650520997040379092802938837804294847283 7898475573277855254317959379657908427305225639249224806096111567367259892230833277244398214475361481979103570897581069354516256084225361210253104267762350814757343118967653292590//10295136532244819865134216418581425896312845076778105967882093451812315373150919833368240666957561175670654409595846292949450822030580980616104277250108095432715677497120580742213;
                                     0 0 0 0 247//2000 109149106916529224225613938235//31652606811075124885796735456 -1471402139169815526549951787477624798736224552941321200//56440086799582050350922834838054057420026494337598863 5412580004078613161687981458637008030233366457113868199883389551037522158772900//455213269145024092215621169612878312797315768577504391565569423807316058315843 3820395190970937465086284368007694267392689261092114936550556797062450867925288189416331303649552143230//14273858093118406255740963176533941671573423886510381570104226394395061792966349825149357548274393367193;
                                     0 0 0 0 0 247//2000 3702251939282354375344210899//4399061605898178118260737311 7335745460336671146051037364344432719375//4167718263865310401834285721625989602073 11934751738672605596266458500552561610251142174626625//266467933294598164559149808395021381193202692438810102;
                                     0 0 0 0 0 0 247//2000 1753//2000 0]
        implicit_coefficient_is_zero = Bool[true, false, false, false, false, false, false]
        n_rk_stages = 7
        rk_order = 4
        adaptive = true
        low_storage = false
        if input_CFL_prefactor ≤ 0.0
            CFL_prefactor = 4.0
        else
            CFL_prefactor = input_CFL_prefactor
        end
    elseif type == "KennedyCarpenterARK324"
        # 4-stage 3th-order IMEX scheme from Kennedy & Carpenter 2003
        # (https://doi.org/10.1016/S0168-9274(02)00138-1,
        # https://ntrs.nasa.gov/api/citations/20010075154/downloads/20010075154.pdf)
        rk_coefs = mk_float[-1247523335473//4055673282236 79264835984649679285542915383850087029//197703563163588166433309052703741041388 143374873327169165072944877723054563796993634825533873250938500977412076430225058147123297//48164537938468181360053681019221391245537623484212879143241031703829399581257519267114308 183533876663877280630903815242772717891981696485790726248876227532653907716433834740782318700703430625849345155700369934729507//152774769284679137140932574224840322584566969939460270285400962599369488056766613240926963620623994179069278241372235976473942 -674269476752868162123858074951153786574711903849607589191198931851708688548176820435148552544391865584341865043692699736944296248896158605451212237381612962268906411298755093339964390670721//2546134965897308089555580666805701115486032970876088660128805677838927216400319783331222992194057059091619325472569216389983265703597042520242784079940164596262272590600818697485927109390800;
                            1767732205903//2027836641118 104089650763298376775517283594005205634//126974577376103704518428054341484614367 402649974715726257110381944227129692139788970635058928062257578119864655690737612569045525//59412386975052518972493036127105554419479894359642287241033487141332226598183812678018467 14364246105178652475593341035586171289599000967514280222073651706570666894470602049892875371222508981379602016199819025473080098//7260819418426986996892762999677651302312472577052165412779166595718930645183114458002425346612148056054055237577670620367624747 -592205887440399614308635936680843507009892739451509439144512297133172235516402369571203494065187197645330486644003505743504146737687284998414220824119624619321360424932079759986667400688521//924270765882147767919737706090852676802697317279651422141773866515771469294827079989551846085654584104864692146726487859057882031810152027557213168580198324425357042783589702576114965490700;
                            0 788022342437//10882634858940 -1296455210574762780005510449066529142309392831329604//156723304220428565752393692055114250106676689860589 -99673073274892040508947928240745592597410069006658308475742716315333750923451055334466588//36786590455936249721221951824053931878290276425173065614254196079782580911623834181388539 1168350732453084113921674966113208169458618576839040713544125474188024763720251037296265456175894768135827904089264712977423236877161701237//1613695686286088606494807246788767988268387847524889706258074110760741418740305745483456939972126277819165534580240908885870858409423997925;
                            0 0 10755448449292//10357097424841 -2001365002799665343288696//31172749426290664269423183 -82906599394091874511049578920146826651351968733949252229257729//3202722135068822020151439455680372156253901385805112449655312300;
                            0 0 0 1767732205903//4055673282236 2223734833661311464443869//2412892370833855116699825]
        rk_coefs_implicit = mk_float[1 1767732205903//4055673282236 -687399076962262115744047//111840222463218881928454996 -1336358764442892755444059056266228090581151350208390996588040500539220614055//27246512666133488484210277154496662561525905554882950399821293911874378720636 285200943189932567138799198875705878963855729946875982791861565057705737765121043333532449390223175098959890725739//3197693884094627611809027664829775477382158476704304256365487708404699034948521210742881159797768179105035102983218 349906153740531530807086677680742934068250971081202838415859967794240267241728221444895340256117278121084468557470142822774574506555702945441070832822061777207585555333938753//13983881081032778505142889772097359302066194326597505729957247063227579945322705391794876798087456494699396393914333627777048370428560157989974144628536010494017605716344421200;
                                     0 1767732205903//4055673282236 -37790740941101883580610910860591527247//131693372088198837795836211504917271540 -1855100908631287514752342850534478233437898769154169242982744248//696821012189129201178283337188250633903779865345141334346955981 -13864927788667680976894941132472814614486628394925655027069496971358505136846849603294768//21721826807945957279896846558408676329589122800041876081057713354971012403885490761907523 3279440794571605320352156805403819083072967867568566199921530274858816688510719259249438840491831638733833253082509394728011722335821499666//12387161495243534653846823539531835409482524701416597408671153384101508978692879955207371459557771903678231566977186207593669409183236242425;
                                     0 0 1767732205903//4055673282236 252818125219158362337262316052985694732//212256555723208031266376853558764309283 91446741129505469383144040723161877446754697117568//638848912416080950914803563396305008955201041811429 -64974104611006292878697003397814574642940098342186996399489269962607827562729361752864//16409007790583358079608534742015990629506873866141219637841130600794261103005884731491225;
                                     0 0 0 1767732205903//4055673282236 2287941076333//4055673282236 0]
        implicit_coefficient_is_zero = Bool[true, false, false, false]
        n_rk_stages = 4
        rk_order = 3
        adaptive = true
        low_storage = false
        if input_CFL_prefactor ≤ 0.0
            CFL_prefactor = 4.0
        else
            CFL_prefactor = input_CFL_prefactor
        end
    elseif type == "PareschiRusso2(2,2,2)"
        # 2nd-order, 2-stage IMEX method 'IMEX-SSP2(2,2,2)' from Pareschi & Russo 2005, Table II
        # (https://doi.org/10.1007/s10915-004-4636-4)
        rk_coefs = mk_float[-0.4142135623730950488016887242096980785696718753769480731766797379907324784621711 -0.5                                                                             ;
                             0.9999999999999999999999999999999999999999999999999999999999999999999999999999827 -1.207106781186547524400844362104849039284835937688474036588339868995366239231094;
                            -0.0                                                                                0.5                                                                             ]
        rk_coefs_implicit = mk_float[ 0.2928932188134524755991556378951509607151640623115259634116601310046337607689404 0.4142135623730950488016887242096980785696718753769480731766797379907324784621883 1.0;
                                     -0.0                                                                               0.2928932188134524755991556378951509607151640623115259634116601310046337607689404 1.207106781186547524400844362104849039284835937688474036588339868995366239231094]
        implicit_coefficient_is_zero = Bool[false, false]
        n_rk_stages = 2
        rk_order = 2
        adaptive = false
        low_storage = false
        CFL_prefactor = NaN
    elseif type == "PareschiRusso2(3,2,2)"
# 2nd-order, 3-stage IMEX method 'IMEX-SSP2(3,2,2)' from Pareschi & Russo 2005, Table III
# (https://doi.org/10.1007/s10915-004-4636-4)
        rk_coefs = mk_float[2 -1 -1//2;
                            0  0  0   ;
                            0  1 -1//2;
                            0  0  1//2]
        rk_coefs_implicit = mk_float[1//2 -1    1    1//2;
                                     0     1//2 0    1//2;
                                     0     0    1//2 1//2]
        implicit_coefficient_is_zero = Bool[false, false, false]
        n_rk_stages = 3
        rk_order = 2
        adaptive = false
        low_storage = false
        CFL_prefactor = NaN
    elseif type == "PareschiRusso2(3,3,2)"
        # 2nd-order, 3-stage IMEX method 'IMEX-SSP2(3,2,2)' from Pareschi & Russo 2005, Table III
        # (https://doi.org/10.1007/s10915-004-4636-4)
        rk_coefs = mk_float[1    -4//3 -1//9;
                            1//2 -1//3 -4//9;
                            0     1//2 -1//3;
                            0     0     1//3]
        rk_coefs_implicit = mk_float[1//4 -1//2 4//3 4//9;
                                     0     1//4 5//6 4//9;
                                     0     0    1//3 2//3]
        implicit_coefficient_is_zero = Bool[false, false, false]
        n_rk_stages = 3
        rk_order = 2
        adaptive = false
        low_storage = false
        CFL_prefactor = NaN
    elseif type == "PareschiRusso3(4,3,3)"
        # 3rd-order, 4-stage IMEX method 'IMEX-SSP3(4,3,3)' from Pareschi & Russo 2005, Table VI
        # (https://doi.org/10.1007/s10915-004-4636-4)
        rk_coefs = mk_float[ 2.0 -5.27491721763532  0.9999999999999688     -0.1666666666666453;
                            -0.0  0.0               1.4589197899688663e-17  0.0               ;
                            -0.0  1.0              -0.0343646522044047     -0.500000000000007 ;
                            -0.0 -0.0               0.25                   -2.091639072545107 ;
                            -0.0 -0.0              -0.0                     0.6666666666666664]
        rk_coefs_implicit = mk_float[ 0.24169426078821 -1.0               3.13745860881766  1.0436096431476471e-14 0.16666666666665975;
                                     -0.0               0.24169426078821  2.13745860881766 -0.24999999999997924    0.3333333333333193 ;
                                     -0.0              -0.0               0.24169426078821  0.034364652204404655   0.500000000000007  ;
                                     -0.0              -0.0              -0.0               0.24169426078821       2.0916390725451066 ]
        implicit_coefficient_is_zero = Bool[false, false, false, false]
        n_rk_stages = 4
        rk_order = 3
        adaptive = false
        low_storage = false
        CFL_prefactor = NaN
    elseif type == "SSPRK4"
        n_rk_stages = 4
        rk_coefs = allocate_float(3, n_rk_stages)
        rk_coefs .= 0.0
        rk_coefs[1,1] = 0.5
        rk_coefs[3,1] = 0.5
        rk_coefs[2,2] = 0.5
        rk_coefs[3,2] = 0.5
        rk_coefs[1,3] = 2.0/3.0
        rk_coefs[2,3] = 1.0/6.0
        rk_coefs[3,3] = 1.0/6.0
        rk_coefs[2,4] = 0.5
        rk_coefs[3,4] = 0.5
        n_rk_stages = 4
        rk_order = 3
        adaptive = false
        low_storage = true
        CFL_prefactor = NaN
    elseif type == "SSPRK3"
        n_rk_stages = 3
        rk_coefs = allocate_float(3, n_rk_stages)
        rk_coefs .= 0.0
        rk_coefs[3,1] = 1.0
        rk_coefs[1,2] = 0.75
        rk_coefs[3,2] = 0.25
        rk_coefs[1,3] = 1.0/3.0
        rk_coefs[3,3] = 2.0/3.0
        rk_order = 3 # ? Not sure about this order
        adaptive = false
        low_storage = true
        CFL_prefactor = NaN
    elseif type == "SSPRK2"
        n_rk_stages = 2
        rk_coefs = allocate_float(3, n_rk_stages)
        rk_coefs .= 0.0
        rk_coefs[3,1] = 1.0
        rk_coefs[1,2] = 0.5
        rk_coefs[3,2] = 0.5
        rk_order = 2
        adaptive = false
        low_storage = true
        CFL_prefactor = NaN
    elseif type == "SSPRK1"
        n_rk_stages = 1
        rk_coefs = allocate_float(3, n_rk_stages)
        rk_coefs .= 0.0
        rk_coefs[3,1] = 1.0
        rk_order = 1
        adaptive = false
        low_storage = true
        CFL_prefactor = NaN
    else
        error("Unsupported RK timestep method, type=$type\n"
              * "Valid methods are: SSPRK4, SSPRK3, SSPRK2, SSPRK1, RKF5(4), Fekete10(4), "
              * "Fekete6(4), Fekete4(3), Fekete4(2), KennedyCarpenterARK437, "
              * "KennedyCarpenterARK324")
    end

    if split_operators && adaptive
        error("Adaptive timestepping not supported with operator splitting")
    end

    # Sanity check size of rk_coefs arrays
    if low_storage
        correct_size = (3, n_rk_stages + adaptive)
        if size(rk_coefs) != correct_size
            error("Size of rk_coefs, $(size(rk_coefs)) is not "
                  * "(n_rk_stages+1, n_rk_stages+1)=$correct_size")
        end

        correct_size_implicit = (3, n_rk_stages + 1 + adaptive)
        if rk_coefs_implicit !== nothing && size(rk_coefs_implicit) != correct_size_implicit
            error("Size of rk_coefs_implicit, $(size(rk_coefs_implicit)) is not "
                  * "(3, n_rk_stages+2)=$correct_size_implicit")
        end
    else
        correct_size = (n_rk_stages + 1, n_rk_stages + adaptive)
        if size(rk_coefs) != correct_size
            error("Size of rk_coefs, $(size(rk_coefs)) is not "
                  * "(n_rk_stages+1, n_rk_stages+1)=$correct_size")
        end

        correct_size_implicit = (n_rk_stages, n_rk_stages + 1 + adaptive)
        if rk_coefs_implicit !== nothing && size(rk_coefs_implicit) != correct_size_implicit
            error("Size of rk_coefs_implicit, $(size(rk_coefs_implicit)) is not "
                  * "(n_rk_stages, n_rk_stages+2)=$correct_size_implicit")
        end
    end

    correct_size = (n_rk_stages,)
    if implicit_coefficient_is_zero !== nothing &&
            size(implicit_coefficient_is_zero) != correct_size
        error("Size of implicit_coefficient_is_zero, $(size(implicit_coefficient_is_zero)) "
              * "is not (n_rk_stages,)=$correct_size")
    end

    return rk_coefs, rk_coefs_implicit, implicit_coefficient_is_zero, n_rk_stages,
           rk_order, adaptive, low_storage, CFL_prefactor
end

"""
use Runge Kutta to update any ion velocity moments evolved separately from
the pdf
"""
function rk_update_evolved_moments!(scratch, scratch_implicit, moments, t_params, istage)
    # if separately evolving the particle density, update using RK
    if moments.evolve_density
        rk_update_variable!(scratch, scratch_implicit, :density, t_params, istage)
    end

    # if separately evolving the parallel flow, update using RK
    if moments.evolve_upar
        rk_update_variable!(scratch, scratch_implicit, :upar, t_params, istage)
    end

    # if separately evolving the parallel pressure, update using RK;
    if moments.evolve_p
        rk_update_variable!(scratch, scratch_implicit, :p, t_params, istage)
    end

    rk_update_variable!(scratch, scratch_implicit,
                        :ion_external_source_controller_integral, t_params, istage;
                        controller_integrals=true)
end

"""
use Runge Kutta to update any electron velocity moments evolved separately from
the pdf
"""
function rk_update_evolved_moments_electron!(scratch, scratch_implicit, moments, t_params,
                                             istage)
    # For now, electrons always fully moment kinetic, and ppar is the only evolving moment
    # (density and upar are calculated from quasineutrality and ambipolarity constraints).
    rk_update_variable!(scratch, scratch_implicit, :p_electron, t_params, istage)

    #rk_update_variable!(scratch, scratch_implicit,
    #                    :electron_external_source_controller_integral, t_params, istage;
    #                    controller_integrals=true)
end

"""
use Runge Kutta to update any neutral-particle velocity moments evolved separately from
the pdf
"""
function rk_update_evolved_moments_neutral!(scratch, scratch_implicit, moments, t_params,
                                            istage)
    # if separately evolving the particle density, update using RK
    if moments.evolve_density
        rk_update_variable!(scratch, scratch_implicit, :density_neutral, t_params, istage;
                            neutrals=true)
    end

    # if separately evolving the parallel flow, update using RK
    if moments.evolve_upar
        rk_update_variable!(scratch, scratch_implicit, :uz_neutral, t_params, istage;
                            neutrals=true)
    end

    # if separately evolving the parallel pressure, update using RK;
    if moments.evolve_p
        rk_update_variable!(scratch, scratch_implicit, :p_neutral, t_params, istage;
                            neutrals=true)
    end

    rk_update_variable!(scratch, scratch_implicit,
                        :neutral_external_source_controller_integral, t_params, istage;
                        controller_integrals=true)
end

"""
Update the variable named `var_symbol` in `scratch` to the current Runge-Kutta stage
`istage`. The current value in `scratch[istage+1]` is the result of the forward-Euler
update, which needs to be corrected using values from previous stages with the Runge-Kutta
coefficients. `scratch_implicit` contains the results of backward-Euler updates, which are
needed for IMEX timestepping schemes.
"""
function rk_update_variable!(scratch, scratch_implicit, var_symbol::Symbol, t_params,
                             istage; neutrals=false, controller_integrals=false, ir=nothing)
    if t_params.low_storage
        var_arrays = (getfield(scratch[istage+1], var_symbol),
                      getfield(scratch[istage], var_symbol),
                      getfield(scratch[1], var_symbol))
        if scratch_implicit === nothing
            var_arrays_implicit = (nothing, nothing, nothing)
        else
            var_arrays_implicit = (getfield(scratch_implicit[istage+1], var_symbol),
                                   getfield(scratch_implicit[istage], var_symbol),
                                   getfield(scratch_implicit[1], var_symbol))
        end
    else
        var_arrays = Tuple(getfield(scratch[i], var_symbol) for i ∈ 1:istage+1)
        if scratch_implicit === nothing
            var_arrays_implicit = nothing
        else
            var_arrays_implicit = Tuple(getfield(scratch_implicit[i], var_symbol)
                                        for i ∈ 1:istage)
        end
    end
    rk_coefs = @view t_params.rk_coefs[:,istage]
    if t_params.rk_coefs_implicit === nothing
        rk_coefs_implicit = nothing
    else
        rk_coefs_implicit = @view t_params.rk_coefs_implicit[:,istage+1]
    end

    if neutrals
        if t_params.low_storage
            rk_update_loop_neutrals_low_storage!(rk_coefs, rk_coefs_implicit,
                                                 var_arrays..., var_arrays_implicit...;
                                                 ir=ir)
        else
            rk_update_loop_neutrals!(rk_coefs, rk_coefs_implicit, var_arrays,
                                     var_arrays_implicit; ir=ir)
        end
    elseif controller_integrals
        if t_params.low_storage
            rk_update_loop_low_storage_controller_integrals!(
                rk_coefs, rk_coefs_implicit, var_arrays..., var_arrays_implicit...; ir=ir)
        else
            rk_update_loop_controller_integrals!(
                rk_coefs, rk_coefs_implicit, var_arrays, var_arrays_implicit; ir=ir)
        end
    else
        if t_params.low_storage
            rk_update_loop_low_storage!(rk_coefs, rk_coefs_implicit, var_arrays...,
                                        var_arrays_implicit...; ir=ir)
        else
            rk_update_loop!(rk_coefs, rk_coefs_implicit, var_arrays, var_arrays_implicit;
                            ir=ir)
        end
    end

    return nothing
end

"""
Calculate a lower-order approximation for the variable named `var_symbol`, which can be
used to calculate an error estimate for adaptive timestepping methods.

The lower-order approximation is stored in `var_symbol` in `scratch[2]` (as this entry
should not be needed again after the lower-order approximation is calculated).
"""
function rk_loworder_solution!(scratch, scratch_implicit, var_symbol::Symbol, t_params;
                               neutrals=false, ir=nothing)
    if !t_params.adaptive
        error("rk_lowerder_solution!() should only be called when using adaptive "
              * "timestepping")
    end
    if t_params.low_storage
        var_arrays = (getfield(scratch[end], var_symbol),
                      getfield(scratch[end-1], var_symbol),
                      getfield(scratch[1], var_symbol))
        if scratch_implicit === nothing
            var_arrays_implicit = (nothing, nothing, nothing)
        else
            var_arrays_implicit = (getfield(scratch_implicit[end], var_symbol),
                                   getfield(scratch_implicit[end-1], var_symbol),
                                   getfield(scratch_implicit[1], var_symbol))
        end
    else
        var_arrays = Tuple(getfield(scratch[i], var_symbol) for i ∈ 1:length(scratch))
        if scratch_implicit === nothing
            var_arrays_implicit = nothing
        else
            var_arrays_implicit = Tuple(getfield(scratch_implicit[i], var_symbol)
                                        for i ∈ 1:length(scratch_implicit))
        end
    end

    loworder_coefs = @view t_params.rk_coefs[:,end]
    if t_params.rk_coefs_implicit === nothing
        loworder_coefs_implicit = nothing
    else
        loworder_coefs_implicit = @view t_params.rk_coefs_implicit[:,end]
    end

    # The second element of `scratch` is not needed any more for the RK update, so we can
    # overwrite it with the lower-order approximation.
    output = getfield(scratch[2], var_symbol)

    if neutrals
        if t_params.low_storage
            rk_update_loop_neutrals_low_storage!(loworder_coefs, loworder_coefs_implicit,
                                                 var_arrays..., var_arrays_implicit...;
                                                 output=output, ir=ir)
        else
            rk_update_loop_neutrals!(loworder_coefs, loworder_coefs_implicit, var_arrays,
                                     var_arrays_implicit; output=output, ir=ir)
        end
    else
        if t_params.low_storage
            rk_update_loop_low_storage!(loworder_coefs, loworder_coefs_implicit,
                                        var_arrays..., var_arrays_implicit...;
                                        output=output, ir=ir)
        else
            rk_update_loop!(loworder_coefs, loworder_coefs_implicit, var_arrays,
                            var_arrays_implicit; output=output, ir=ir)
        end
    end

    return nothing
end

# Ion distribution function
function rk_update_loop_low_storage!(rk_coefs, rk_coefs_implicit,
                                     new::AbstractArray{mk_float,5},
                                     old::AbstractArray{mk_float,5},
                                     first::AbstractArray{mk_float,5}, new_implicit,
                                     old_implicit, first_implicit; output=new, ir)
    @boundscheck length(rk_coefs) == 3

    if ir !== nothing
        error("`ir` argument not supported in ion RK update loop")
    end

    @begin_s_r_z_vperp_vpa_region()
    if rk_coefs_implicit === nothing
        @loop_s_r_z_vperp_vpa is this_ir iz ivperp ivpa begin
            output[ivpa,ivperp,iz,this_ir,is] = rk_coefs[1]*first[ivpa,ivperp,iz,this_ir,is] +
                                                rk_coefs[2]*old[ivpa,ivperp,iz,this_ir,is] +
                                                rk_coefs[3]*new[ivpa,ivperp,iz,this_ir,is]
        end
    else
        @loop_s_r_z_vperp_vpa is this_ir iz ivperp ivpa begin
            output[ivpa,ivperp,iz,this_ir,is] = rk_coefs[1]*first[ivpa,ivperp,iz,this_ir,is] +
                                                rk_coefs[2]*old[ivpa,ivperp,iz,this_ir,is] +
                                                rk_coefs[3]*new[ivpa,ivperp,iz,this_ir,is] +
                                                rk_coefs_implicit[1]*first_implicit[ivpa,ivperp,iz,this_ir,is] +
                                                rk_coefs_implicit[2]*old_implicit[ivpa,ivperp,iz,this_ir,is]
        end
    end

    return nothing
end
function rk_update_loop!(rk_coefs, rk_coefs_implicit,
                         var_arrays::NTuple{N,AbstractArray{mk_float,5}},
                         var_arrays_implicit; output=var_arrays[N], ir) where N
    @boundscheck length(rk_coefs) ≥ N

    if ir !== nothing
        error("`ir` argument not supported in ion RK update loop")
    end

    @begin_s_r_z_vperp_vpa_region()
    if rk_coefs_implicit === nothing
        @loop_s_r_z_vperp_vpa is this_ir iz ivperp ivpa begin
            output[ivpa,ivperp,iz,this_ir,is] =
                sum(rk_coefs[i] * var_arrays[i][ivpa,ivperp,iz,this_ir,is] for i ∈ 1:N)
        end
    else
        @loop_s_r_z_vperp_vpa is this_ir iz ivperp ivpa begin
            output[ivpa,ivperp,iz,this_ir,is] =
                sum(rk_coefs[i] * var_arrays[i][ivpa,ivperp,iz,this_ir,is] for i ∈ 1:N) +
                sum(rk_coefs_implicit[i] * var_arrays_implicit[i][ivpa,ivperp,iz,this_ir,is] for i ∈ 1:N-1)
        end
    end

    return nothing
end

# Ion moments
function rk_update_loop_low_storage!(rk_coefs, rk_coefs_implicit,
                                     new::AbstractArray{mk_float,3},
                                     old::AbstractArray{mk_float,3},
                                     first::AbstractArray{mk_float,3}, new_implicit,
                                     old_implicit, first_implicit; output=new, ir)
    @boundscheck length(rk_coefs) == 3

    if ir !== nothing
        error("`ir` argument not supported in ion RK update loop")
    end

    @begin_s_r_z_region()
    if rk_coefs_implicit === nothing
        @loop_s_r_z is this_ir iz begin
            output[iz,this_ir,is] = rk_coefs[1]*first[iz,this_ir,is] +
                                    rk_coefs[2]*old[iz,this_ir,is] +
                                    rk_coefs[3]*new[iz,this_ir,is]
        end
    else
        @loop_s_r_z is this_ir iz begin
            output[iz,this_ir,is] = rk_coefs[1]*first[iz,this_ir,is] +
                                    rk_coefs[2]*old[iz,this_ir,is] +
                                    rk_coefs[3]*new[iz,this_ir,is] +
                                    rk_coefs_implicit[1]*first_implicit[iz,this_ir,is] +
                                    rk_coefs_implicit[2]*old_implicit[iz,this_ir,is]
        end
    end

    return nothing
end
function rk_update_loop!(rk_coefs, rk_coefs_implicit,
                         var_arrays::NTuple{N,AbstractArray{mk_float,3}},
                         var_arrays_implicit; output=var_arrays[N], ir) where N
    @boundscheck length(rk_coefs) ≥ N

    if ir !== nothing
        error("`ir` argument not supported in ion RK update loop")
    end

    @begin_s_r_z_region()
    if rk_coefs_implicit === nothing
        @loop_s_r_z is this_ir iz begin
            output[iz,this_ir,is] = sum(rk_coefs[i] * var_arrays[i][iz,this_ir,is] for i ∈ 1:N)
        end
    else
        @loop_s_r_z is this_ir iz begin
            output[iz,this_ir,is] = sum(rk_coefs[i] * var_arrays[i][iz,this_ir,is] for i ∈ 1:N) +
                                    sum(rk_coefs_implicit[i] * var_arrays_implicit[i][iz,this_ir,is] for i ∈ 1:N-1)
        end
    end

    return nothing
end

# PI controller integrals
function rk_update_loop_low_storage_controller_integrals!(
        rk_coefs, rk_coefs_implicit, new::AbstractArray{mk_float,3},
        old::AbstractArray{mk_float,3}, first::AbstractArray{mk_float,3}, new_implicit,
        old_implicit, first_implicit; output=new, ir=nothing)
    @boundscheck length(rk_coefs) == 3

    if ir !== nothing
        error("`ir` argument not supported in storage controller integral RK update loop")
    end

    @begin_serial_region()
    @serial_region begin
        if rk_coefs_implicit === nothing
            @. output = rk_coefs[1]*first + rk_coefs[2]*old + rk_coefs[3]*new
        else
            @. output = rk_coefs[1]*first + rk_coefs[2]*old + rk_coefs[3]*new +
                        rk_coefs_implicit[1]*first_implicit + rk_coefs_implicit[2]*old_implicit
        end
    end

    return nothing
end
function rk_update_loop_controller_integrals!(
        rk_coefs, rk_coefs_implicit, var_arrays::NTuple{N,AbstractArray{mk_float,3}},
        var_arrays_implicit; output=var_arrays[N], ir=nothing) where N
    @boundscheck length(rk_coefs) ≥ N

    if ir !== nothing
        error("`ir` argument not supported in storage controller integral RK update loop")
    end

    @begin_serial_region()
    @serial_region begin
        if rk_coefs_implicit === nothing
            for i ∈ eachindex(output)
                output[i] = sum(rk_coefs[j] * var_arrays[j][i] for j ∈ 1:N)
            end
        else
            for i ∈ eachindex(output)
                output[i] = sum(rk_coefs[j] * var_arrays[j][i] for j ∈ 1:N) +
                            sum(rk_coefs_implicit[j] * var_arrays_implicit[j][i] for j ∈ 1:N-1)
            end
        end
    end

    return nothing
end

# Electron distribution function
function rk_update_loop_low_storage!(rk_coefs, rk_coefs_implicit,
                                     new::AbstractArray{mk_float,4},
                                     old::AbstractArray{mk_float,4},
                                     first::AbstractArray{mk_float,4}, new_implicit,
                                     old_implicit, first_implicit; output=new, ir)
    @boundscheck length(rk_coefs) == 3

    if ir === nothing
        @begin_r_z_vperp_vpa_region()
        if rk_coefs_implicit === nothing
            @loop_r_z_vperp_vpa this_ir iz ivperp ivpa begin
                output[ivpa,ivperp,iz,this_ir] = rk_coefs[1]*first[ivpa,ivperp,iz,this_ir] +
                                                 rk_coefs[2]*old[ivpa,ivperp,iz,this_ir] +
                                                 rk_coefs[3]*new[ivpa,ivperp,iz,this_ir]
            end
        else
            @loop_r_z_vperp_vpa this_ir iz ivperp ivpa begin
                output[ivpa,ivperp,iz,this_ir] = rk_coefs[1]*first[ivpa,ivperp,iz,this_ir] +
                                                 rk_coefs[2]*old[ivpa,ivperp,iz,this_ir] +
                                                 rk_coefs[3]*new[ivpa,ivperp,iz,this_ir] +
                                                 rk_coefs_implicit[1]*first_implicit[ivpa,ivperp,iz,this_ir] +
                                                 rk_coefs_implicit[2]*old_implicit[ivpa,ivperp,iz,this_ir]
            end
        end
    else
        @begin_anyzv_z_vperp_vpa_region()
        if rk_coefs_implicit === nothing
            @loop_z_vperp_vpa iz ivperp ivpa begin
                output[ivpa,ivperp,iz,ir] = rk_coefs[1]*first[ivpa,ivperp,iz,ir] +
                                            rk_coefs[2]*old[ivpa,ivperp,iz,ir] +
                                            rk_coefs[3]*new[ivpa,ivperp,iz,ir]
            end
        else
            @loop_z_vperp_vpa iz ivperp ivpa begin
                output[ivpa,ivperp,iz,ir] = rk_coefs[1]*first[ivpa,ivperp,iz,ir] +
                                            rk_coefs[2]*old[ivpa,ivperp,iz,ir] +
                                            rk_coefs[3]*new[ivpa,ivperp,iz,ir] +
                                            rk_coefs_implicit[1]*first_implicit[ivpa,ivperp,iz,ir] +
                                            rk_coefs_implicit[2]*old_implicit[ivpa,ivperp,iz,ir]
            end
        end
    end

    return nothing
end
function rk_update_loop!(rk_coefs, rk_coefs_implicit,
                         var_arrays::NTuple{N,AbstractArray{mk_float,4}},
                         var_arrays_implicit; output=var_arrays[N], ir) where N
    @boundscheck length(rk_coefs) ≥ N

    if ir === nothing
        @begin_r_z_vperp_vpa_region()
        if rk_coefs_implicit === nothing
            @loop_r_z_vperp_vpa this_ir iz ivperp ivpa begin
                output[ivpa,ivperp,iz,this_ir] =
                    sum(rk_coefs[i] * var_arrays[i][ivpa,ivperp,iz,this_ir] for i ∈ 1:N)
            end
        else
            @loop_r_z_vperp_vpa this_ir iz ivperp ivpa begin
                output[ivpa,ivperp,iz,this_ir] =
                    sum(rk_coefs[i] * var_arrays[i][ivpa,ivperp,iz,this_ir] for i ∈ 1:N) +
                    sum(rk_coefs_implicit[i] * var_arrays_implicit[i][ivpa,ivperp,iz,this_ir]
                        for i ∈ 1:N-1)
            end
        end
    else
        @begin_anyzv_z_vperp_vpa_region()
        if rk_coefs_implicit === nothing
            @loop_z_vperp_vpa iz ivperp ivpa begin
                output[ivpa,ivperp,iz,ir] =
                    sum(rk_coefs[i] * var_arrays[i][ivpa,ivperp,iz,ir] for i ∈ 1:N)
            end
        else
            @loop_z_vperp_vpa iz ivperp ivpa begin
                output[ivpa,ivperp,iz,ir] =
                    sum(rk_coefs[i] * var_arrays[i][ivpa,ivperp,iz,ir] for i ∈ 1:N) +
                    sum(rk_coefs_implicit[i] * var_arrays_implicit[i][ivpa,ivperp,iz,ir]
                        for i ∈ 1:N-1)
            end
        end
    end

    return nothing
end

# Electron moments
function rk_update_loop_low_storage!(rk_coefs, rk_coefs_implicit,
                                     new::AbstractArray{mk_float,2},
                                     old::AbstractArray{mk_float,2},
                                     first::AbstractArray{mk_float,2}, new_implicit,
                                     old_implicit, first_implicit; output=new, ir)
    @boundscheck length(rk_coefs) == 3

    if ir === nothing
        @begin_r_z_region()
        if rk_coefs_implicit === nothing
            @loop_r_z this_ir iz begin
                output[iz,this_ir] = rk_coefs[1]*first[iz,this_ir] +
                                     rk_coefs[2]*old[iz,this_ir] +
                                     rk_coefs[3]*new[iz,this_ir]
            end
        else
            @loop_r_z this_ir iz begin
                output[iz,this_ir] = rk_coefs[1]*first[iz,this_ir] +
                                     rk_coefs[2]*old[iz,this_ir] +
                                     rk_coefs[3]*new[iz,this_ir] +
                                     rk_coefs_implicit[1]*first_implicit[iz,this_ir] +
                                     rk_coefs_implicit[2]*old_implicit[iz,this_ir]
            end
        end
    else
        @begin_anyzv_z_region()
        if rk_coefs_implicit === nothing
            @loop_z iz begin
                output[iz,ir] = rk_coefs[1]*first[iz,ir] +
                                rk_coefs[2]*old[iz,ir] +
                                rk_coefs[3]*new[iz,ir]
            end
        else
            @loop_z iz begin
                output[iz,ir] = rk_coefs[1]*first[iz,ir] +
                                rk_coefs[2]*old[iz,ir] +
                                rk_coefs[3]*new[iz,ir] +
                                rk_coefs_implicit[1]*first_implicit[iz,ir] +
                                rk_coefs_implicit[2]*old_implicit[iz,ir]
            end
        end
    end

    return nothing
end
function rk_update_loop!(rk_coefs, rk_coefs_implicit,
                         var_arrays::NTuple{N,AbstractArray{mk_float,2}},
                         var_arrays_implicit;
                         output=var_arrays[N], ir) where N
    @boundscheck length(rk_coefs) ≥ N

    if ir === nothing
        @begin_r_z_region()
        if rk_coefs_implicit === nothing
            @loop_r_z this_ir iz begin
                output[iz,this_ir] = sum(rk_coefs[i] * var_arrays[i][iz,this_ir] for i ∈ 1:N)
            end
        else
            @loop_r_z this_ir iz begin
                output[iz,this_ir] = sum(rk_coefs[i] * var_arrays[i][iz,this_ir] for i ∈ 1:N) +
                                sum(rk_coefs_implicit[i] * var_arrays_implicit[i][iz,this_ir]
                                    for i ∈ 1:N-1)
            end
        end
    else
        @begin_anyzv_z_region()
        if rk_coefs_implicit === nothing
            @loop_z iz begin
                output[iz,ir] = sum(rk_coefs[i] * var_arrays[i][iz,ir] for i ∈ 1:N)
            end
        else
            @loop_z iz begin
                output[iz,ir] = sum(rk_coefs[i] * var_arrays[i][iz,ir] for i ∈ 1:N) +
                                sum(rk_coefs_implicit[i] * var_arrays_implicit[i][iz,ir]
                                    for i ∈ 1:N-1)
            end
        end
    end

    return nothing
end

# Neutral distribution function
function rk_update_loop_neutrals_low_storage!(rk_coefs, rk_coefs_implicit,
                                              new::AbstractArray{mk_float,6},
                                              old::AbstractArray{mk_float,6},
                                              first::AbstractArray{mk_float,6},
                                              new_implicit, old_implicit, first_implicit;
                                              output=new, ir)
    @boundscheck length(rk_coefs) == 3

    if ir !== nothing
        error("`ir` argument not supported in neutral RK update loop")
    end

    @begin_sn_r_z_vzeta_vr_vz_region()
    if rk_coefs_implicit === nothing
        @loop_sn_r_z_vzeta_vr_vz isn this_ir iz ivzeta ivr ivz begin
            output[ivz,ivr,ivzeta,iz,this_ir,isn] = rk_coefs[1]*first[ivz,ivr,ivzeta,iz,this_ir,isn] +
                                                    rk_coefs[2]*old[ivz,ivr,ivzeta,iz,this_ir,isn] +
                                                    rk_coefs[3]*new[ivz,ivr,ivzeta,iz,this_ir,isn]
        end
    else
        @loop_sn_r_z_vzeta_vr_vz isn this_ir iz ivzeta ivr ivz begin
            output[ivz,ivr,ivzeta,iz,this_ir,isn] = rk_coefs[1]*first[ivz,ivr,ivzeta,iz,this_ir,isn] +
                                                    rk_coefs[2]*old[ivz,ivr,ivzeta,iz,this_ir,isn] +
                                                    rk_coefs[3]*new[ivz,ivr,ivzeta,iz,this_ir,isn] +
                                                    rk_coefs_implicit[1]*first_implicit[ivz,ivr,ivzeta,iz,this_ir,isn] +
                                                    rk_coefs_implicit[2]*old_implicit[ivz,ivr,ivzeta,iz,this_ir,isn]
        end
    end

    return nothing
end
function rk_update_loop_neutrals!(rk_coefs, rk_coefs_implicit,
                                  var_arrays::NTuple{N,AbstractArray{mk_float,6}},
                                  var_arrays_implicit; output=var_arrays[N], ir) where N
    @boundscheck length(rk_coefs) ≥ N

    if ir !== nothing
        error("`ir` argument not supported in neutral RK update loop")
    end

    @begin_sn_r_z_vzeta_vr_vz_region()
    if rk_coefs_implicit === nothing
        @loop_sn_r_z_vzeta_vr_vz isn this_ir iz ivzeta ivr ivz begin
            output[ivz,ivr,ivzeta,iz,this_ir,isn] =
                sum(rk_coefs[i] * var_arrays[i][ivz,ivr,ivzeta,iz,this_ir,isn] for i ∈ 1:N)
        end
    else
        @loop_sn_r_z_vzeta_vr_vz isn this_ir iz ivzeta ivr ivz begin
            output[ivz,ivr,ivzeta,iz,this_ir,isn] =
                sum(rk_coefs[i] * var_arrays[i][ivz,ivr,ivzeta,iz,this_ir,isn] for i ∈ 1:N) +
                sum(rk_coefs_implicit[i] * var_arrays_implicit[i][ivz,ivr,ivzeta,iz,this_ir,isn]
                    for i ∈ 1:N-1)
        end
    end

    return nothing
end

# Neutral moments
function rk_update_loop_neutrals_low_storage!(rk_coefs, rk_coefs_implicit,
                                              new::AbstractArray{mk_float,3},
                                              old::AbstractArray{mk_float,3},
                                              first::AbstractArray{mk_float,3},
                                              new_implicit, old_implicit, first_implicit;
                                              output=new, ir)
    @boundscheck length(rk_coefs) == 3

    if ir !== nothing
        error("`ir` argument not supported in neutral RK update loop")
    end

    @begin_sn_r_z_region()
    if rk_coefs_implicit === nothing
        @loop_sn_r_z isn this_ir iz begin
            output[iz,this_ir,isn] = rk_coefs[1]*first[iz,this_ir,isn] +
                                     rk_coefs[2]*old[iz,this_ir,isn] +
                                     rk_coefs[3]*new[iz,this_ir,isn]
        end
    else
        @loop_sn_r_z isn this_ir iz begin
            output[iz,this_ir,isn] = rk_coefs[1]*first[iz,this_ir,isn] +
                                     rk_coefs[2]*old[iz,this_ir,isn] +
                                     rk_coefs[3]*new[iz,this_ir,isn] +
                                     rk_coefs_implicit[1]*first_implicit[iz,this_ir,isn] +
                                     rk_coefs_implicit[2]*old_implicit[iz,this_ir,isn]
        end
    end

    return nothing
end
function rk_update_loop_neutrals!(rk_coefs, rk_coefs_implicit,
                                  var_arrays::NTuple{N,AbstractArray{mk_float,3}},
                                  var_arrays_implicit; output=var_arrays[N], ir) where N
    @boundscheck length(rk_coefs) ≥ N

    if ir !== nothing
        error("`ir` argument not supported in neutral RK update loop")
    end

    @begin_sn_r_z_region()
    if rk_coefs_implicit === nothing
        @loop_sn_r_z isn this_ir iz begin
            output[iz,this_ir,isn] = sum(rk_coefs[i] * var_arrays[i][iz,this_ir,isn] for i ∈ 1:N)
        end
    else
        @loop_sn_r_z isn this_ir iz begin
            output[iz,this_ir,isn] = sum(rk_coefs[i] * var_arrays[i][iz,this_ir,isn] for i ∈ 1:N) +
                                     sum(rk_coefs_implicit[i] * var_arrays_implicit[i][iz,this_ir,isn]
                                         for i ∈ 1:N-1)
        end
    end

    return nothing
end

"""
    local_error_norm(error, f, rtol, atol; ir=nothing)
    local_error_norm(error, f, rtol, atol, neutral=false; method="Linf",
                     skip_r_inner=false, skip_z_lower=false, error_sum_zero=0.0,
                     ir=nothing)

Maximum error norm in the range owned by this MPI process, given by
```math
\\max(\\frac{|\\mathtt{error}|}{\\mathtt{rtol}*|\\mathtt{f}| + \\mathtt{atol})
```

3 dimensional arrays (which represent moments) are treated as ion moments unless
`neutral=true` is passed.

`method` can be "Linf" (to take the maximum error) or "L2" to take the root-mean-square
(RMS) error.

`skip_r_inner` and `skip_z_lower` can be set to true to skip the contribution from the
inner/lower boundaries, to avoid double-counting those points when using
distributed-memory MPI.

`error_sum_zero` should always have value 0.0, but is included so that different types can
be used for L2sum. For testing, if we want consistency of results when using different
numbers of processes (when the number of processes changes the order of operations in the
sum is changed, which changes the rounding errors) then we have to use higher precision
(i.e. use the Float128 type from the Quadmath package). The type of a 0.0 value can be set
according to the `high_precision_error_sum` option in the `[timestepping]` section, and
stored in a template-typed value in the `t_params` object - when that value is passed in
as the argument to `error_sum_zero`, that type will be used for L2sum, and the type will
be known at compile time, allowing this function to be efficient.

`ir` can be passed to calculate the error norm at a single r-index.
"""
function local_error_norm end

function local_error_norm(f_loworder::MPISharedArray{mk_float,2},
                          f::MPISharedArray{mk_float,2}, rtol, atol; method="Linf",
                          skip_r_inner=false, skip_z_lower=false, error_sum_zero=0.0,
                          ir=nothing)
    if method == "Linf"
        f_max = -Inf
        if ir === nothing
            @loop_r_z this_ir iz begin
                error_norm = abs(f_loworder[iz,this_ir] - f[iz,this_ir]) / (rtol*abs(f[iz,this_ir]) + atol)
                f_max = max(f_max, error_norm)
            end
        else
            @loop_z iz begin
                error_norm = abs(f_loworder[iz,ir] - f[iz,ir]) / (rtol*abs(f[iz,ir]) + atol)
                f_max = max(f_max, error_norm)
            end
        end
        return f_max
    elseif method == "L2"
        L2sum = error_sum_zero
        if ir === nothing
            @loop_r_z this_ir iz begin
                if (skip_r_inner && this_ir == 1) || (skip_z_lower && iz == 1)
                    continue
                end
                error_norm = ((f_loworder[iz,this_ir] - f[iz,this_ir]) / (rtol*abs(f[iz,this_ir]) + atol))^2
                L2sum += error_norm
            end
        else
            @loop_z iz begin
                if (skip_r_inner && ir == 1) || (skip_z_lower && iz == 1)
                    continue
                end
                error_norm = ((f_loworder[iz,ir] - f[iz,ir]) / (rtol*abs(f[iz,ir]) + atol))^2
                L2sum += error_norm
            end
        end
        # Will sum results from different processes in shared memory block after returning
        # from this function.
        nz, nr = size(f_loworder)
        if skip_r_inner
            nr -= 1
        end
        if skip_z_lower
            nz -= 1
        end
        return L2sum
    else
        error("Unrecognized method '$method'")
    end
end
function local_error_norm(f_loworder::MPISharedArray{mk_float,3},
                          f::MPISharedArray{mk_float,3}, rtol, atol, neutral=false;
                          method="Linf", skip_r_inner=false, skip_z_lower=false,
                          error_sum_zero=0.0, ir=nothing)
    if ir !== nothing
        error("`ir` argument not supported in ion/neutral local error norm")
    end

    if method == "Linf"
        f_max = -Inf
        if neutral
            @loop_sn_r_z isn ir iz begin
                error_norm = abs(f_loworder[iz,ir,isn] - f[iz,ir,isn]) / (rtol*abs(f[iz,ir,isn]) + atol)
                f_max = max(f_max, error_norm)
            end
        else
            @loop_s_r_z is ir iz begin
                error_norm = abs(f_loworder[iz,ir,is] - f[iz,ir,is]) / (rtol*abs(f[iz,ir,is]) + atol)
                f_max = max(f_max, error_norm)
            end
        end
        return f_max
    elseif method == "L2"
        L2sum = error_sum_zero
        if neutral
            @loop_sn_r_z isn ir iz begin
                if (skip_r_inner && ir == 1) || (skip_z_lower && iz == 1)
                    continue
                end
                error_norm = ((f_loworder[iz,ir,isn] - f[iz,ir,isn]) / (rtol*abs(f[iz,ir,isn]) + atol))^2
                L2sum += error_norm
            end
        else
            @loop_s_r_z is ir iz begin
                if (skip_r_inner && ir == 1) || (skip_z_lower && iz == 1)
                    continue
                end
                error_norm = ((f_loworder[iz,ir,is] - f[iz,ir,is]) / (rtol*abs(f[iz,ir,is]) + atol))^2
                L2sum += error_norm
            end
        end
        # Will sum results from different processes in shared memory block after returning
        # from this function.
        nz, nr, nspecies = size(f_loworder)
        if skip_r_inner
            nr -= 1
        end
        if skip_z_lower
            nz -= 1
        end
        return L2sum
    else
        error("Unrecognized method '$method'")
    end
end
function local_error_norm(f_loworder::MPISharedArray{mk_float,4},
                          f::MPISharedArray{mk_float,4}, rtol, atol; method="Linf",
                          skip_r_inner=false, skip_z_lower=false, error_sum_zero=0.0,
                          ir=nothing)
    if method == "Linf"
        f_max = -Inf
        if ir === nothing
            @loop_r_z_vperp_vpa this_ir iz ivperp ivpa begin
                error_norm = abs(f_loworder[ivpa,ivperp,iz,this_ir] - f[ivpa,ivperp,iz,this_ir]) /
                             (rtol*abs(f[ivpa,ivperp,iz,this_ir]) + atol)
                f_max = max(f_max, error_norm)
            end
        else
            @loop_z_vperp_vpa iz ivperp ivpa begin
                error_norm = abs(f_loworder[ivpa,ivperp,iz,ir] - f[ivpa,ivperp,iz,ir]) /
                             (rtol*abs(f[ivpa,ivperp,iz,ir]) + atol)
                f_max = max(f_max, error_norm)
            end
        end
        return f_max
    elseif method == "L2"
        L2sum = error_sum_zero
        if ir === nothing
            @loop_r_z_vperp_vpa this_ir iz ivperp ivpa begin
                if (skip_r_inner && this_ir == 1) || (skip_z_lower && iz == 1)
                    continue
                end
                error_norm = ((f_loworder[ivpa,ivperp,iz,this_ir] - f[ivpa,ivperp,iz,this_ir]) /
                              (rtol*abs(f[ivpa,ivperp,iz,this_ir]) + atol))^2
                L2sum += error_norm
            end
        else
            @loop_z_vperp_vpa iz ivperp ivpa begin
                if (skip_r_inner && ir == 1) || (skip_z_lower && iz == 1)
                    continue
                end
                error_norm = ((f_loworder[ivpa,ivperp,iz,ir] - f[ivpa,ivperp,iz,ir]) /
                              (rtol*abs(f[ivpa,ivperp,iz,ir]) + atol))^2
                L2sum += error_norm
            end
        end
        # Will sum results from different processes in shared memory block after returning
        # from this function.
        nvpa, nvperp, nz, nr = size(f_loworder)
        if skip_r_inner
            nr -= 1
        end
        if skip_z_lower
            nz -= 1
        end
        return L2sum
    else
        error("Unrecognized method '$method'")
    end
end
function local_error_norm(f_loworder::MPISharedArray{mk_float,5},
                          f::MPISharedArray{mk_float,5}, rtol, atol; method="Linf",
                          skip_r_inner=false, skip_z_lower=false, error_sum_zero=0.0,
                          ir=nothing)
    if ir !== nothing
        error("`ir` argument not supported in ion local error norm")
    end

    if method == "Linf"
        f_max = -Inf
        @loop_s_r_z_vperp_vpa is ir iz ivperp ivpa begin
            error_norm = abs(f_loworder[ivpa,ivperp,iz,ir,is] - f[ivpa,ivperp,iz,ir,is]) /
                         (rtol*abs(f[ivpa,ivperp,iz,ir,is]) + atol)
            f_max = max(f_max, error_norm)
        end
        return f_max
    elseif method == "L2"
        L2sum = error_sum_zero
        @loop_s_r_z_vperp_vpa is ir iz ivperp ivpa begin
            if (skip_r_inner && ir == 1) || (skip_z_lower && iz == 1)
                continue
            end
            error_norm = ((f_loworder[ivpa,ivperp,iz,ir,is] - f[ivpa,ivperp,iz,ir,is]) /
                          (rtol*abs(f[ivpa,ivperp,iz,ir,is]) + atol))^2
            L2sum += error_norm
        end
        # Will sum results from different processes in shared memory block after returning
        # from this function.
        nvpa, nvperp, nz, nr, nspecies = size(f_loworder)
        if skip_r_inner
            nr -= 1
        end
        if skip_z_lower
            nz -= 1
        end
        return L2sum
    else
        error("Unrecognized method '$method'")
    end
end
function local_error_norm(f_loworder::MPISharedArray{mk_float,6},
                          f::MPISharedArray{mk_float,6}, rtol, atol; method="Linf",
                          skip_r_inner=false, skip_z_lower=false, error_sum_zero=0.0,
                          ir=nothing)
    if ir !== nothing
        error("`ir` argument not supported in neutral local error norm")
    end

    if method == "Linf"
        f_max = -Inf
        @loop_sn_r_z_vzeta_vr_vz isn ir iz ivzeta ivr ivz begin
            error_norm = abs(f_loworder[ivz,ivr,ivzeta,iz,ir,isn] - f[ivz,ivr,ivzeta,iz,ir,isn]) /
                         (rtol*abs(f[ivz,ivr,ivzeta,iz,ir,isn]) + atol)
            f_max = max(f_max, error_norm)
        end
        return f_max
    elseif method == "L2"
        L2sum = error_sum_zero
        @loop_sn_r_z_vzeta_vr_vz isn ir iz ivzeta ivr ivz begin
            if (skip_r_inner && ir == 1) || (skip_z_lower && iz == 1)
                continue
            end
            error_norm = ((f_loworder[ivz,ivr,ivzeta,iz,ir,isn] - f_loworder[ivz,ivr,ivzeta,iz,ir,isn]) /
                          (rtol*abs(f[ivz,ivr,ivzeta,iz,ir,isn]) + atol))^2
            L2sum += error_norm
        end
        # Will sum results from different processes in shared memory block after returning
        # from this function.
        return L2sum
    else
        error("Unrecognized method '$method'")
    end
end

"""
    adaptive_timestep_update_t_params!(t_params, CFL_limits, error_norms,
                                       total_points, error_norm_method, success,
                                       nl_max_its_fraction, nl_total_its_soft_limit,
                                       nl_total_its_soft_limit_reduce_dt,
                                       composition, z; electron=false,
                                       local_max_dt::mk_float=Inf, ir=nothing)

Use the calculated `CFL_limits` and `error_norms` to update the timestep in `t_params`.
"""
function adaptive_timestep_update_t_params!(t_params, CFL_limits, error_norms,
                                            total_points, error_norm_method, success,
                                            nl_max_its_fraction, nl_total_its_soft_limit,
                                            nl_total_its_soft_limit_reduce_dt,
                                            composition, z; electron=false,
                                            local_max_dt::mk_float=Inf, ir=nothing)
    if ir === nothing
        is_global_root = (global_rank[] == 0)
        is_block_root = (block_rank[] == 0)
    else
        is_global_root = (z.irank == 0 && anyzv_subblock_rank[] == 0)
        is_block_root = (anyzv_subblock_rank[] == 0)
    end

    if ir === nothing
        # Get global minimum of CFL limits
        CFL_limit = Ref(0.0)
        this_limit_caused_by = nothing
        @serial_region begin
            # Get maximum error over all blocks
            CFL_limits_vec = [l for l ∈ values(CFL_limits)]
            MPI.Allreduce!(CFL_limits_vec, min, comm_inter_block[])
            CFL_limit_caused_by = argmin(CFL_limits_vec)
            CFL_limit[] = CFL_limits_vec[CFL_limit_caused_by]
            this_limit_caused_by = CFL_limits.keys[CFL_limit_caused_by]
        end
        MPI.Bcast!(CFL_limit, comm_block[])

        if error_norm_method == "Linf"
            # Get overall maximum error on the shared-memory block
            error_norms_vec = [l for l ∈ values(error_norms)]
            MPI.Reduce!(error_norms_vec, max, comm_block[]; root=0)

            error_norm = Ref{mk_float}(0.0)
            max_error_variable_index = -1
            @serial_region begin
                # Get maximum error over all blocks
                MPI.Allreduce!(error_norms_vec, max, comm_inter_block[])
                max_error_variable_index = argmax(error_norms)
                error_norm[] = error_norms_vec[max_error_variable_index]
                max_error_variable = error_norms.keys[max_error_variable_index]
            end
            MPI.Bcast!(error_norm, 0, comm_block[])
        elseif error_norm_method == "L2"
            # Get overall maximum error on the shared-memory block
            error_norms_vec = [l for l ∈ values(error_norms)]
            MPI.Reduce!(error_norms_vec, +, comm_block[]; root=0)

            error_norm = Ref{mk_float}(0.0)
            max_error_variable_index = -1
            @serial_region begin
                # Get maximum error over all blocks
                MPI.Allreduce!(error_norms_vec, +, comm_inter_block[])

                # So far `error_norms_vec` is the sum of squares of the errors. Now that summation
                # is finished, need to divide by total number of points and take square-root.
                error_norms_vec .= sqrt.(error_norms_vec ./ total_points)

                # Weight the error from each variable equally by taking the mean, so the
                # larger number of points in the distribution functions does not mean that
                # error on the moments is ignored.
                error_norm[] = mean(error_norms_vec)

                # Record which variable had the maximum error
                max_error_variable_index = argmax(error_norms_vec)
                max_error_variable = error_norms.keys[max_error_variable_index]
            end

            MPI.Bcast!(error_norm, 0, comm_block[])
        else
            error("Unrecognized error_norm_method '$method'")
        end

        failure_counter = t_params.failure_counter
        t = t_params.t
        dt = t_params.dt
        previous_dt = t_params.previous_dt
        dt_before_last_fail = t_params.dt_before_last_fail
        dt_before_output = t_params.dt_before_output
        failure_caused_by = t_params.failure_caused_by
        limit_caused_by = t_params.limit_caused_by
        step_counter = t_params.step_counter
        failure_counter = t_params.failure_counter
    else
        # Get global minimum of CFL limits
        CFL_limit = Ref(0.0)
        this_limit_caused_by = nothing
        @anyzv_serial_region begin
            # Get maximum error over all blocks
            CFL_limits_vec = [l for l ∈ values(CFL_limits)]
            MPI.Allreduce!(CFL_limits_vec, min, z.comm)
            CFL_limit_caused_by = argmin(CFL_limits_vec)
            CFL_limit[] = CFL_limits_vec[CFL_limit_caused_by]
            this_limit_caused_by = CFL_limits.keys[CFL_limit_caused_by]
        end
        MPI.Bcast!(CFL_limit, comm_anyzv_subblock[])

        if error_norm_method == "Linf"
            # Get overall maximum error on the shared-memory block
            error_norms_vec = [l for l ∈ values(error_norms)]
            MPI.Reduce!(error_norms_vec, max, comm_anyzv_subblock[]; root=0)

            error_norm = Ref{mk_float}(0.0)
            max_error_variable_index = -1
            @anyzv_serial_region begin
                # Get maximum error over all blocks
                MPI.Allreduce!(error_norms_vec, max, z.comm)
                max_error_variable_index = argmax(error_norms)
                error_norm[] = error_norms_vec[max_error_variable_index]
                max_error_variable = error_norms.keys[max_error_variable_index]
            end
            MPI.Bcast!(error_norm, 0, comm_anyzv_subblock[])
        elseif error_norm_method == "L2"
            # Get overall maximum error on the shared-memory block
            error_norms_vec = [l for l ∈ values(error_norms)]
            MPI.Reduce!(error_norms_vec, +, comm_anyzv_subblock[]; root=0)

            error_norm = Ref{mk_float}(0.0)
            max_error_variable_index = -1
            @anyzv_serial_region begin
                # Get maximum error over all blocks
                MPI.Allreduce!(error_norms_vec, +, z.comm)

                # So far `error_norms_vec` is the sum of squares of the errors. Now that summation
                # is finished, need to divide by total number of points and take square-root.
                error_norms_vec .= sqrt.(error_norms_vec ./ total_points)

                # Weight the error from each variable equally by taking the mean, so the
                # larger number of points in the distribution functions does not mean that
                # error on the moments is ignored.
                error_norm[] = mean(error_norms_vec)

                # Record which variable had the maximum error
                max_error_variable_index = argmax(error_norms_vec)
                max_error_variable = error_norms.keys[max_error_variable_index]
            end

            MPI.Bcast!(error_norm, 0, comm_anyzv_subblock[])
        else
            error("Unrecognized error_norm_method '$method'")
        end

        failure_counter = @view t_params.failure_counter[ir:ir]
        t = @view t_params.t[ir:ir]
        dt = @view t_params.dt[ir:ir]
        previous_dt = @view t_params.previous_dt[ir:ir]
        dt_before_last_fail = @view t_params.dt_before_last_fail[ir:ir]
        dt_before_output = @view t_params.dt_before_output[ir:ir]
        failure_caused_by = t_params.failure_caused_by[ir]
        limit_caused_by = t_params.limit_caused_by[ir]
        step_counter = @view t_params.step_counter[ir:ir]
        failure_counter = @view t_params.failure_counter[ir:ir]
    end
    if success != ""
        # Iteration failed in implicit part of timestep try decreasing timestep

        failure_counter[] += 1

        if previous_dt[] > 0.0
            # If previous_dt=0, the previous step was also a failure so only update
            # dt_before_last_fail when previous_dt>0
            dt_before_last_fail[] = previous_dt[]
        end

        # Decrease timestep by 1/2 - this factor should probably be settable!
        # Note when nonlinear solve iteration fails, we do not enforce
        # minimum_dt, as the timesolver must error if we do not decrease dt.
        if dt[] > t_params.minimum_dt
            # ...but try decreasing just to minimum_dt first, if the dt is still
            # bigger than this.
            dt[] = max(dt[] / 2.0, t_params.minimum_dt)
        else
            dt[] = dt[] / 2.0
        end

        # Don't update the simulation time, as this step failed
        previous_dt[] = 0.0

        # Call the 'cause' of the timestep failure the variable that has the biggest
        # error norm here.
        # Could do with a better way to sort the different possible types of
        # convergence failure...
        if t_params.rk_coefs_implicit !== nothing &&
                composition.electron_physics ∈ (kinetic_electrons,
                                                kinetic_electrons_with_temperature_equation)
            if success == "nonlinear-solver"
                failure_caused_by["nonlinear_solver_convergence"] += 1
            elseif success == "kinetic-electrons"
                failure_caused_by["kinetic_electron_convergence"] += 1
            else
                error("Unrecognised cause of convergence failure: \"$success\"")
            end
        else
            failure_caused_by["nonlinear_solver_convergence"] += 1
        end

        if t_params.exact_output_times
            # If we were trying to take a step to the output timestep, dt will be smaller on
            # the re-try, so will not reach the output time.
            t_params.step_to_moments_output[] = false
            t_params.step_to_dfns_output[] = false
        else
            # If with the reduced dt the step will not pass the next output time,
            # deactivate step_to_*_output[].
            if (t_params.step_to_moments_output[]
                && t[] + previous_dt[] + dt[] <
                   t_params.moments_output_times[t_params.moments_output_counter[]])
                t_params.step_to_moments_output[] = false
            end
            if (t_params.step_to_dfns_output[]
                && t[] + previous_dt[] + dt[] <
                   t_params.dfns_output_times[t_params.dfns_output_counter[]])
                t_params.step_to_dfns_output[] = false
            end
        end
    elseif (error_norm[] > 1.0 || isnan(error_norm[])) && dt[] > t_params.minimum_dt * (1.0 + 1.0e-13)
        # (1.0 + 1.0e-13) fudge factor accounts for possible rounding errors when
        # t+dt=next_output_time.
        #
        # Timestep failed, reduce timestep and re-try

        failure_counter[] += 1

        if previous_dt[] > 0.0
            # If previous_dt=0, the previous step was also a failure so only update
            # dt_before_last_fail when previous_dt>0
            dt_before_last_fail[] = previous_dt[]
        end

        # Get new timestep estimate using same formula as for a successful step, but
        # limit decrease to factor 1/2 - this factor should probably be settable!
        dt[] = max(dt[] / 2.0,
                   dt[] * t_params.step_update_prefactor * error_norm[]^(-1.0/t_params.rk_order))
        dt[] = max(dt[], t_params.minimum_dt)

        # Don't update the simulation time, as this step failed
        previous_dt[] = 0.0

        # Call the 'cause' of the timestep failure the variable that has the biggest
        # error norm here
        if is_block_root
            failure_caused_by[max_error_variable] += 1
        end

        if t_params.exact_output_times
            # If we were trying to take a step to the output timestep, dt will be smaller on
            # the re-try, so will not reach the output time.
            t_params.step_to_moments_output[] = false
            t_params.step_to_dfns_output[] = false
        else
            # If with the reduced dt the step will not pass the next output time,
            # deactivate step_to_*_output[].
            if (t_params.step_to_moments_output[]
                && t[] + previous_dt[] + dt[] <
                   t_params.moments_output_times[t_params.moments_output_counter[]])
                t_params.step_to_moments_output[] = false
            end
            if (t_params.step_to_dfns_output[]
                && t[] + previous_dt[] + dt[] <
                   t_params.dfns_output_times[t_params.dfns_output_counter[]])
                t_params.step_to_dfns_output[] = false
            end
        end

        #println("t=$t, timestep failed, error_norm=$(error_norm[]), error_norms=$error_norms, decreasing timestep to ", dt[])
    else
        # Save the timestep used to complete this step, this is used to update the
        # simulation time.
        previous_dt[] = dt[]

        if t_params.step_to_moments_output[] || t_params.step_to_dfns_output[]
            if !t_params.exact_output_times
                # Completed an output step, reset dt to what it was before it was reduced to reach
                # the output time
                dt[] = dt_before_output[]
            end

            if t_params.step_to_moments_output[]
                t_params.step_to_moments_output[] = false
                t_params.write_moments_output[] = true
            end
            if t_params.step_to_dfns_output[]
                t_params.step_to_dfns_output[] = false
                t_params.write_dfns_output[] = true
            end

            if dt[] > CFL_limit[]
                dt[] = CFL_limit[]
            end
        end
        if !t_params.exact_output_times || !(t_params.write_moments_output[] || t_params.write_dfns_output[])
            # Adjust timestep according to Fehlberg's suggestion
            # (https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method).
            # `step_update_prefactor` is a constant numerical factor to make the estimate
            # of a good value for the next timestep slightly conservative. It defaults to
            # 0.9.
            dt[] *= t_params.step_update_prefactor * error_norm[]^(-1.0/t_params.rk_order)

            if dt[] > CFL_limit[]
                dt[] = CFL_limit[]
            else
                # Reserve first four entries of t_params.limit_caused_by for
                # max_increase_factor, max_increase_factor_near_fail, minimum_dt and
                # maximum_dt limits, high_nl_iterations.
                if is_block_root
                    this_limit_caused_by = max_error_variable
                end
            end

            # Limit so timestep cannot increase by a large factor, which might lead to
            # numerical instability in some cases.
            max_cap_limit_caused_by = "max_increase_factor"
            if isinf(t_params.max_increase_factor_near_last_fail)
                # Not using special timestep limiting near last failed dt value
                max_cap = t_params.max_increase_factor * previous_dt[]
            else
                max_cap = t_params.max_increase_factor * previous_dt[]
                slow_increase_threshold = dt_before_last_fail[] / t_params.last_fail_proximity_factor
                if previous_dt[] > dt_before_last_fail[] * t_params.last_fail_proximity_factor
                    # dt has successfully exceeded the last failed value, so allow it
                    # to increase more quickly again
                    dt_before_last_fail[] = Inf
                elseif max_cap > slow_increase_threshold
                    # dt is getting close to last failed value, so increase more
                    # slowly
                    max_cap = max(slow_increase_threshold,
                                  t_params.max_increase_factor_near_last_fail *
                                  previous_dt[])
                    max_cap_limit_caused_by = "max_increase_factor_near_last_fail"
                end
            end
            if dt[] > max_cap
                dt[] = max_cap
                if is_block_root
                    this_limit_caused_by = max_cap_limit_caused_by
                end
            end

            # Prevent timestep from going below minimum_dt
            if dt[] < t_params.minimum_dt
                dt[] = t_params.minimum_dt
                if is_block_root
                    this_limit_caused_by = "minimum_dt"
                end
            end

            # Prevent timestep from going above maximum_dt
            max_dt = min(t_params.maximum_dt, local_max_dt)
            if dt[] > max_dt
                dt[] = max_dt
                if is_block_root
                    this_limit_caused_by = "maximum_dt"
                end
            end

            if nl_total_its_soft_limit_reduce_dt && previous_dt[] > 0.0
                # The last step took very many nonlinear iterations, so reduce the
                # timestep slightly.
                # If t_params.previous_dt[]==0.0, then the previous step failed so
                # timestep will not be increasing, so do not need this check.
                iteration_limited_dt = previous_dt[] / t_params.max_increase_factor
                if dt[] > iteration_limited_dt
                    dt[] = iteration_limited_dt
                    if is_block_root
                        this_limit_caused_by = "high_nl_iterations"
                    end
                end
            elseif (nl_max_its_fraction > 0.5 || nl_total_its_soft_limit) && previous_dt[] > 0.0
                # The last step took many nonlinear iterations, so do not allow the
                # timestep to increase.
                # If previous_dt[]==0.0, then the previous step failed so
                # timestep will not be increasing, so do not need this check.
                if dt[] > previous_dt[]
                    dt[] = previous_dt[]
                    if is_block_root
                        this_limit_caused_by = "high_nl_iterations"
                    end
                end
            end

            if is_block_root
                limit_caused_by[this_limit_caused_by] += 1
            end

            if (step_counter[] % 1000 == 0) && is_global_root
                prefix = electron ? "electron" : "ion"
                println("$prefix step ", step_counter[], ": t=", round(t[], sigdigits=6),
                        ", nfail=", failure_counter[], ", dt=", dt[])
            end
        end
    end

    minimum_dt = 1.e-14
    if dt[] < minimum_dt
        println("Time advance failed: trying to set dt=$(dt[]) less than "
                * "$minimum_dt at t=$(t[]). Ending run.")
        # Set dt negative to signal an error
        dt[] = -1.0
    end

    current_time = t[] + previous_dt[]
    # Store here to ensure dt_before_output is set correctly when both moments and
    # dfns are written at the same time.
    current_dt = dt[]
    if (!t_params.write_after_fixed_step_count
        && !t_params.write_moments_output[]
        && length(t_params.moments_output_times) > 0
        && (t_params.moments_output_counter[] ≤ length(t_params.moments_output_times))
        && (current_time + dt[] >= t_params.moments_output_times[t_params.moments_output_counter[]]))

        dt_before_output[] = current_dt
        if t_params.exact_output_times
            dt[] = t_params.moments_output_times[t_params.moments_output_counter[]] - current_time
        end
        t_params.step_to_moments_output[] = true

        if dt[] < 0.0
            error("When trying to step to next output time, made negative timestep "
                  * "dt=$(dt[])")
        end
    end
    if (!t_params.write_after_fixed_step_count
        && !t_params.write_dfns_output[]
        && length(t_params.dfns_output_times) > 0
        && (t_params.dfns_output_counter[] ≤ length(t_params.dfns_output_times))
        && (current_time + dt[] >= t_params.dfns_output_times[t_params.dfns_output_counter[]]))

        dt_before_output[] = current_dt
        if t_params.exact_output_times
            dt[] = t_params.dfns_output_times[t_params.dfns_output_counter[]] - current_time
        end
        t_params.step_to_dfns_output[] = true

        if dt[] < 0.0
            error("When trying to step to next output time, made negative timestep "
                  * "dt=$(dt[])")
        end
    end

    return nothing
end

end # runge_kutta
